[{"title":"26线程基础","url":"/2019/09/21/26线程基础/","content":"\n# 线程基础\n","tags":["CLR读书笔记"]},{"title":"24运行时序列化","url":"/2019/09/17/24运行时序列化/","content":"\n# 运行时序列化\n\n**序列化** 是将对象或对象图转换成字节流的过程，反序列化是将字节流转换回对象图的过程。在对象和字节流之间转换是很有用的机制。\n\n1. 应用程序的状态（对象图）可轻松保存到磁盘文件或数据库中，并在应用程序下次运行时恢复。ASP.NET就是利用序列化和反序列来保存和还原会话状态。\n2. 一组对象可轻松复制到系统的剪贴板，再粘贴回同一个或另一个应用程序。事实上，windows窗体和Windows Presentation Foundation（WPF）就利用了这个功能。\n3. 一组对象可克隆并放到一边作为“备份”；与此同时，用户操纵一组“主”对象。\n4. 一组对象可轻松地通过网络发送给另一台机器上运行的进程。Microsoft .Net Framework的**Remoting（远程处理）** 架构会对按值封送（marshaled by value）的对象进行序列化和反序列化。这个技术还可跨AppDomain边界发送对象。\n\n除了上述应用，一旦将对象序列化成内存中的字节流，就可方便地以一些更有用的方式处理数据，比如进行加密和压缩。\n\n由于序列化如此有用，所以许多程序员耗费了大量时间写代码执行这些操作。历史上，这种代码很难编写，相等繁琐，还容易出错。开发人员需要克服的难题包括通信协议、客户端/服务器数据类型不匹配（比如低位优先/高位优先问题）、错误处理、一个对象引用了其他对象、in和out参数以及由结构构成的数组。\n\n让人高兴的是，.Net Framework内建了出色的序列化和反序列化支持。上述所有难题都迎刃而解，而且.Net Framework是在后台悄悄帮你解决的。开发者现在只需负责序列化之前和反序列化之后的对象处理，中间过程由.Net Framework负责。\n\n本章解释了.Net Framework如何公开它的序列化和序列化服务。对于几乎所有数据类型，这些服务的默认行为已经足够。也就是说，几乎不需要做任何工作就可以使自己的类型“可序列化”。但对于少量类型，序列化服务的默认行为是不够的。幸好，序列化服务的扩展性极佳，本章将解释如何利用这些扩展性机制，在序列化或反序列化对象时采取一些相当强大的操作。\n\n注意：本章重点在于CLR的运行时序列化技术。这种技术对CLR数据类型有很深刻的理解，能将对象的所有公共、受保护、内部甚至私有字段序列化到压缩的二进制流中，从而获得很好的性能。 **要把CLR数据类型序列化成XML流**, 参见`System.Runtime.Serialization.NetDataContractSerializer`类. .Net Framework还提供了其他序列化技术, 它们主要是为了**CLR数据类型和非CLR数据类型**之间的互操作而设计的. 这些技术用的是`System.Xml.Serialization.XmlSerializer`类和`System.Runtime.Serialization.DataContractSerializer`类.\n\n# 序列化/反序列化快速入门\n\n```csharp\nstatic void Main(string[] args)\n{\n    //创建对象图以便把它们序列化到流中\n    var objectGraph = new List<string> {\"Jeff\", \"Kristin\", \"Aidan\"};\n    Stream stream = SerializeToMemory(objectGraph);\n    //为了演示，将一切都重置\n    stream.Position = 0;\n    objectGraph = null;\n\n    //反序列化对象，证明它能工作\n    objectGraph = (List<string>) DeserializeFromMemory(stream);\n    foreach (var s in objectGraph)\n    {\n        Console.WriteLine(s);\n    }\n}\nprivate static MemoryStream SerializeToMemory(object objectGraph)\n{\n    //构造流来容纳序列化对象\n    MemoryStream stream = new MemoryStream();\n    //构造序列化格式化器来执行所有真正的工作\n    BinaryFormatter formatter = new BinaryFormatter();\n    //告诉格式化器将对象序列化到流中\n    formatter.Serialize(stream,objectGraph);\n    //将序列化好的对象流返回给调用者\n    return stream;\n}\nprivate static object DeserializeFromMemory(Stream stream)\n{\n    //构造序列化格式器来做所有真正的工作\n    BinaryFormatter formatter = new BinaryFormatter();\n    //告诉格式化器从流中反序列化对象\n    return formatter.Deserialize(stream);\n}\n```\n\n一切视乎都很简单`！SerializeToMemory`方法构造一个`System.Io.MemoryStream`对象。这个对象表明要将序列化好的字节块放在哪儿。然后，方法构造一个`BinaryFormatter`对象（在`System.Runtime.Serialization.Formatters.Binary`命名空间中定义）。格式化器是实现了`System.Runtime.Serialization.IFormatter`接口的类型，它知道如何序列化和反序列化对象图。\n\n序列化对象图只需调用格式化器的`Serialize方法`，并向它传递两样东西：**对流对象的引用**，以及对想要序列化的**对象图的引用**。流对象表示了序列化好的字节应该放到哪里，它可以是从System.IO.Stream抽象基类派生的任何类型的对象。 也就是说对象图可序列化成一个`MemoryStream`,`FileStream`或者`NetworkStream`等.\n\n格式化器参考**对每个对象的类型进行描述的元数据**，从而了解如何序列化完整的对象图。序列化时，`Serialize方法`利用反射来查看每个对象的类型中都有哪些实例字段。在这些字段中，任何一个引用了其他对象，格式化器的`Serialize方法`就知道哪些对象也要进行序列化。\n\n格式化器的算法非常智能。他们知道如何确保对象图中的每个对象都只序列化一次。**换言之，如果对象图中的两个对象互相引用，格式化器会检测到这一点，每个对象都只序列化一次，避免发生死循环**。\n\n在内部，格式化器的`Deserialize方法`检查流的内容，构造流中所有对象的实例，并**初始化所有这些对象中的字段**，使它们具有与当初序列化时相同的值。通常要将`Deserialize方法`返回的对象引用**转型为应用程序期待的类型**。\n\n**利用序列化创建对象的深拷贝**:\n\n```csharp\nprivate static object DeepClone(object original)\n{\n    //构造临时内存流\n    using (MemoryStream stream = new MemoryStream())\n    {\n        //构造序列化格式器来做所有真正的工作\n        BinaryFormatter formatter = new BinaryFormatter();\n        // 之后讲解 \"流上下文\"\n        formatter.Context = new StreamingContext(StreamingContextStates.Clone);\n        //将对象图序列化到内存流中\n        formatter.Serialize(stream, original);\n        //反序列化前，定位到内存流的起始位置\n        stream.Position = 0;\n        //将对象图反序列化成一组新对象，向调用者返回对象图（深拷贝）的根\n        return formatter.Deserialize(stream);\n    }\n}\n```\n\n有几点需要注意。首先，是由你来保证代码为序列化和反序列化使用相同的格式化器。其次，可以将多个对象图序列化到一个流中，这是很有用的一个操作。例如，假定有以下两个类定义：\n\n```csharp\n[Serializable]\ninternal sealed class Customer{}\n[Serializable]\ninternal sealed class Oreder{}\n```\n\n然后，在应用程序的主要类中定义了以下静态字段：\n\n```csharp\nprivate static List<Customer> s_customers    = new List<Customer>();\nprivate static List<Oreder> s_pendingOrders  = new List<Oreder>();\nprivate static List<Oreder> s_processedOrders= new List<Oreder>();\n```\n\n现在，可利用如下所示方法将应用程序的状态序列化到单个流中：\n\n```csharp\nprivate static void SaveApplicationState(Stream stream)\n{\n    //构造序列化格式器来做所有真正的工作\n    BinaryFormatter formatter = new BinaryFormatter();\n    //序列化我们的应用程序的完整状态\n    formatter.Serialize(stream,s_customers);\n    formatter.Serialize(stream,s_pendingOrders);\n    formatter.Serialize(stream,s_processedOrders);\n}\n```\n\n最后一个注意事项与**程序集**有关。序列化对象时，**类型的全名和类型定义程序集的全名会被写入流**。`BinaryFormatter`默认输出程序集的完整表示，其中包括程序集的文件名（无扩展名）、版本号、语言文化以及公钥信息。反序列化对象是，格式化器首先获取程序集标识信息，并通过调用`System.Reflection.Assembly`的`Load方法`确保程序集已加载到正在执行的Appdomain中。\n\n\n程序集加载好之后，格式化器在程序集中查找与要反序列化的对象匹配的类型\n- **找不到匹配类型就抛出异常**，不再对更多的对象进行反序列化。\n  - 找到匹配的类型，就创建类型的实例，并用流中包含的值对其字段字段进行初始化。\n- 如果类型中的字段与流中读取的**字段名不完全匹配**，就抛出`SerializationException异常`，不再对更多的对象进行反序列化。\n\n## 关于Assembly.LoadFrom加载程序集的相关问题\n\n![](24运行时序列化/QQ截图20190918114813.png)\n\n反序列化会调用`Assembly.Load`而非`LoadFrom`, 一般情况下无法定位程序集, 造成`SerializationException异常`.\n\n如果这样做了, 建议在**调用格式化器的Deserialize方法之前**, 实现一个方法, 它的**签名匹配`System.ResolueEventHandler`委托**. 并向`AppDomain`的`AssemblyResolve事件`注册这个方法.  `Deserialize方法`结束后,马上向事件注销这个方法. 现在每个格式化器加载一个程序集失败,CLR都会自动调用你的`ResolueEventHandler`方法, 加载失败的程序集的标识会传给这个方法, 方法可以从程序集的标识知道去哪里寻找文件. 然后方法可调用`Assembly.LoadFrom`加载程序集, 最后返回对结果程序集的引用.\n\n# 使类型可序列化\n\n设计类型时，设计人员必须郑重地决定是否允许类型的实例序列化。**类型默认是不可序列化的**。开发者必须向类型应用`定制特性System.SerializableAttribute`。**任何对象不可序列化，格式化器的`Serialize方法`都会抛出异常**。\n\n\n注意: 序列化对象图时, 也许有的对象的类型能序列化,有的不能. 考虑到性能, 在序列化之前, 格式化器**不会验证**对象图中的所有对象都能序列化. 所以序列化对象图时, 在抛出`SerializationException`异常之前, 完全有可能已经有一部分对象序列化到流中, 如果发生这种情况, 流中就会包含已损坏的数据.\n\n序列化对象图时, 如果你认为有一些对象不可序列化, 那么写的代码就应该能得体地从这种情况中恢复. **一个方案是,先将对象序列化到`MemoryStream`中, 然后如果所有对象都成功序列化, 才将`MemoryStream`中的字节复制到`你正在希望的目标流(文件或网络流)`中.**\n\n\n**`SerializableAttribute`定制特性只能应用于引用类型(class), 值类型(struct),枚举类型(enum)和委托类型(delegate).**  注意, 枚举和委托类型总是可序列化的.所以不必显式应用此特性. 除此之外,**此特性不会被派生类型继承**.\n\n如果基类型没有应用`SerializableAttribute`定制特性, 那么很难想象如何从它的派生出可序列化的类型. 这样设计的原因是如果基类型不允许它的实例序列化, 它的字段就不能序列化. 因为基对象实际就是派生对象的一部分. 这也是基对象`Object`已经应用了`SerializableAttribute`特性的原因.\n\n\n一般建议将你定义的大多数类型都设置成可序列化. 毕竟, 这样能为类型的用户提供很大的灵活性. 但必须注意的是, 序列化会读取对象的**所有字段**. 不管这些字段声明为public, protected,internal,private. **如果类型的实例要包含敏感或安全数据(比如密码), 或者数据在转移之后便没有含义或者没有值, 就不应该使类型变得可序列化.**\n\n# 控制序列化和反序列化\n\n用`SerializableAttribute`定制特性应用于类型, 但类型可能定义了一些不应序列化的实例字段. 一般有两个原因造成我们不想序列化部分实例字段:\n- 字段含有反序列化后变得无效的信息.\n  - 例如, 对象包含Windows内核对象（如文件、进程、线程、互斥体、事件、信号量等）的句柄，那么在反序列化到另一个进程或另一台机器之后，就会失去意义。因为Windows内核对象是跟进程相关的值。\n- 字段含有很容易计算的信息.\n  - 这时要选出哪些无须序列化的字段, 减少需要传输的数据, 增强应用程序的性能.\n\n以下代码使用`System.NonSerializedAttribute`定制特性指出类型中不应序列化的字段.**注意，该特性只能应用于类型中的字段，而且会被派生类型继承。**\n\n```csharp\n[Serializable]\npublic class Circle\n{\n    private Double m_radius;\n\n    [NonSerialized]\n    private Double m_area;\n\n    public Circle(Double radius)\n    {\n        m_radius = radius;\n        m_area = Math.PI * m_radius * m_radius;\n    }\n}\n```\n\n上述代码中, Circle对象可以序列化, 但格式化器只会序列化对象的`m_radius字段`的值. `m_area`的值不会被序列化, 因为字段应用了`[NonSerialized]`特性. 并且会被派生类型继承.\n\n假如构造一个Circle对象: `Circle c = new Circle(10);`, 在内部, `m_area`值会设置成一个月为314.159的值.  这个对象序列化时, 只有`m_radius`字段的值(10)才会写入流. 但当流反序列化`Circle对象`时, 就会遇到一个问题, `Circle对象`的`m_radius`值会被设为10, 但它的`m_area`字段会被初始化成0, 而不是314.159 !\n\n以下代码演示如何修正上述问题:\n\n```csharp\n[Serializable]\npublic class Circle\n{\n    private Double m_radius;\n\n    [NonSerialized]\n    private Double m_area;\n\n    public Circle(Double radius)\n    {\n        m_radius = radius;\n        m_area = Math.PI * m_radius * m_radius;\n    }\n\n    [OnDeserialized]\n    private void OnDeserialized(StreamContext context)\n    {\n       m_area = Math.PI * m_radius * m_radius;\n    }\n}\n```\n\n> 要在对象反序列化时调用一个方法, System.Runtime.Serialization.OnDeserialized 定制特性时首选方案, 而不是上类型实现 System.Runtime.Serialization.IDeserializationCallback接口的OnDeserialized方法\n\n应用了此特性`[OnDeserialized]`的方法, 每次反序列化类型的实例, `格式化器`都会检查类型中是否定义了应用该特性的方法, 如果是,就调用该方法, 从而确保对象的完全反序列化.\n\n\n- `OnSerializingAttribute`\n- `OnSerializedAttribute`\n- `OnDeserializingAttribute`\n- `OnDeserializedAttribute`\n\n可以将它们应用于类型汇总定义的方法, 对序列化和反序列化过程进行更多的控制.\n\n```csharp\n[Serializable]\npublic class MyType\n{\n    private int x, y;\n    [NonSerialized] private int sum;\n    public MyType(int x,int y)\n    {\n        this.x = x;\n        this.y = y;\n        sum = x + y;\n    }\n    [OnDeserializing]\n    private void OnDeserializing(StreamingContext context)\n    {\n        // 在类型的新版本中,(反序列化开始时)为字段设置默认值\n    }\n    [OnDeserialized]\n    private void OnDeserialized(StreamingContext context)\n    {\n        // 反序列化结束后, 根据字段值初始化瞬时状态比如sum值\n        sum = x + y;\n    }\n    [OnSerializing]\n    private void OnSerializing(StreamingContext context)\n    {\n        // 在序列化前, 修改任何需要修改的状态\n    }\n    [OnSerialized]\n    private void OnSerialized(StreamingContext context)\n    {\n        // 在序列化后, 恢复任何需要恢复的状态\n    }\n}\n```\n\n使用这4个属性中的任何一个时, 你定义的方法必须获取一个`StreamingContext`参数\"流上下文\", 并返回void. 方法名可以是任意名称, 且方法声明为private,以免被普通的代码调用; **格式化器运行时有充足的安全权限. 所以能调用私有方法**.  \n\n序列化一组对象时,\n1. 格式化器首先调用对象的标记了`[OnSerializing]`的所有方法.\n2. 接着序列化对象的所有字段\n3. 最后完调用对象的标记了`[OnSerialized]`的所有方法\n\n反序列化一组对象时,\n1. 首先, 格式化器调用对象的标记了`[OnDeserializing]`的所有方法.\n2. 然后, 它反序列化对象的所有字段.\n3. 最后, 调用对象的标记了`[OnDeserialized]`的所有方法.\n\n反序列化期间, 格式化器处理带有`[OnDeserialized]`特性的方法时, 会将这个对象的引用添加到一个内部**列表**中. 所有对象都反序列化之后, **格式化器反向遍历列表**.  之所以要以相反的顺序调用这些方法, 因为这样才能**使内层对象先于外层对象完成反序列化**.\n\n例如, `Hashtable`或`Dictonary`内部用了一个哈希表维护它的数据项列表. 这个集合中的对象类型有标记了`[OnDeserialized]`特性的方法(用于反序列化之后的操作). 即使集合对象先反序列化(先于它包含的数据项). 它的`[OnDeserialized]`方法也会最后调用(在调用完它的数据项的所有`[OnDeserialized]`方法之后). 这样一来, 所有数据项在反序列化后它们的所有字段都能得到正确的初始化, 以便计算出一个好的哈希码值. 利用哈希码将数据放到内部哈希桶中.\n\n**如果序列化类型的实例, 在类型中添加新字段, 然后视图反序列化不包含新字段的对象, 格式化器就会抛出`SerializationException异常`, 并显示一条消息告诉你流中要反序列化的数据包含错误的成员数目. 这时可以利用`System.Runtime.Serialization.OptionalFieldAttribute`特性. 类型中新增的每个字段都要应用`[OptionalField]`特性(可选字段), 这样格式化器就不会因为流中的数据不包含这个字段而抛出`SerializationException异常`.**\n\n# 格式化器如何序列化类型实例\n\n本节将深入讨论格式化器**如何序列化对象的字段**。为了简化格式化器的操作，FCL在`System.Runtime.Serialization`命名空间提供了一个`FormatterServices类型`。该类型只包含静态方法，而且该类型不能实例化。\n\n## 以下步骤描述了格式化器如何**自动序列化类型**应用`Serializable`特性的对象。\n\n1. 格式化器调用`FormatterService`的`GetSerializableMembers方法`.\n\n `public static MemberInfo[] GetSerializableMembers(Type type, StreamingContext context);`\n\n 这个方法利用反射获取类型的`public`和`private`实例字段(标记了`NonSerializedAttribute特性`的字段除外). 方法返回由`MemberInfo`对象构成的数组, 其中每个元素都对应一个可序列化的实例字段.\n\n2. 对象被序列化, `System.Reflection.MemberInfo`对象数组传给`FormatterServices`的静态方法`GetObjectData`\n\n`public static object[] GetObjectData(object obj, MemberInfo[] members);`  \n\n这个方法返回一个Object数组, 每个元素都表示了被序列化的那个对象中的一个字段的值. 这个`Object数组`和`MemberInfo数组`是**并行**的. **换言之, Object数组中的元素0是MemberInfo数组中的元素0所标识的那个成员的值**.\n\n3. 格式化器将程序集标识和类型的完整名称写入流中。\n4. 格式化器然后**遍历两个数组**中的元素，将每个成员的名称和值写入流中。\n\n\n## 以下步骤描述了格式化器如何**自动反序列化类型**应用`Serializable`特性的对象。\n\n1. 格式化器从流中读取程序集标识和完整类型名称. 如果程序集当前没有加载到AppDomain中, 就加载它,如果加载失败就抛出`SerializationException异常`,程序集已加载,格式化器将程序集标识信息和类型全名传给`FormatterServices`的`静态方法GetTypeFromAssembly`;\n\n`public static Type GetTypeFromAssembly(Assembly assem, String name);`\n\n这个方法返回一个System.Type对象, 它代表要反序列化的那个对象的类型.\n\n2. 格式化器调用`FormatterServices`的`静态方法GetUninitializedObject`:\n\n`public static Object GetUninitializedObject(Type type);`\n\n这个方法为一个新对象分配内存, **但不为对象调用构造器**. 然而, **对象的所有字节都被初始化成null或0**.\n\n3. 格式化器现在构造并初始化一个`MemberInfo数组`, 具体做法和前面一样, 都是调用`FormatterServices`的`GetSerializableMembers`方法, 这个方法返回序列化好,现在需要反序列化的一组字段.\n\n4. 格式化器根据流中包含的数据创建并初始化一个Object数组.\n5. 将新分配对象, MemberInfo数组(包含字段类型)以及并行Object数组(包含字段值)的引用传给`FormatterServices`的`静态方法PopulateObjectMembers`:\n\n```csharp\npublic static Object PopulateObjectMembers(Object obj, MemberInfo[] members, Object[] data);\n```\n\n这个方法遍历数组, 将每个字段初始化成对应的值. 到此为止, 对象就算是被彻底反序列化了.\n\n# 控制序列化/反序列化的数据\n\n本章前面讨论过，控制序列化和反序列过程的最佳方式就是使用`OnSerializing`等**特性**。然后，一些极少的情况下，这些特性不能提供你想要的全部控制。此外，格式化器(`Formatter`)内部使用的是**反射**，而反射的速度是比较慢的，这会增大序列化和反序列化对象所花的时间。\n\n为了对序列化、反序列化的数据进行完全控制，并避免使用反射，你的类型可实现`System.Runtime.Serialization. ISerializable`接口，定义如下:\n\n```csharp\npublic interface ISerializable\n{\n    void GetObjectData(SerializationInfo info, StreamingContext context);\n}\n```\n\n这个接口只有一个方法，即`GetObjectData`。但实现这个接口的大多数类型还实现了一个`特殊的构造器`。\n\n重要提示：`ISerializable`接口最大的问题在于，**一旦类型实现了它，所有派生类型也必须实现它**，**而且派生类型必须保证调用基类的GetObjectData方法和特殊构造器**。此外，一旦类型实现了该接口，便永远不能删除它，否则会时区与派生类型的兼容性。所以，密封类实现ISerializable接口是最让人放心的。\n\n`ISerializable`接口和`特殊构造器`旨在由格式化器使用, 但其他代码可能调用`GetObjectData`来返回敏感数据. 另外其他代码可能构造对象, 并传入损坏的数据. 因此, 建议向`GetObjectData`方法和特殊构造器应用以下特性:\n\n```csharp\n// .net framework 4.8 中 此 API 现已过时。\n[SecurityPermissionAttribute(SecurityAction.Demand, SerializionFormatter = true)]\n```\n\n**格式化器** 序列化对象图时会检查每个对象。如果发现一个对象的类型实现了`ISerializable接口`，就会**忽略所有定制特性**，改为构造新的`System.Runtime.Serialization.SerializationInfo`对象。该对象包含了要为对象序列化的值的集合。\n\n构造`SerializationInfo对象`时，格式化器要传递两个参数：`Type`和`System.Runtime.Serialization.IFormatterConverter`。Type参数标识要序列化的对象。\n- 类型的全名`SerializationInfo.FullTypeName`\n- 程序集的标识`SerializationInfo.AssemblyName`\n- 构造器获取类型的定义程序集: 内部查询`Type`的`Module`属性, 再查询`Module`的`Assembly`属性, 再查询`Assembly`的`FullName`属性.\n\n![](24运行时序列化/QQ截图20190919143558.png)\n\n构造好并初始化好`SerializationInfo`对象后，格式化器调用类型的`GetObjectData方法`，向它传递对`SerializationInfo对象`的引用。`GetObjectData`调用`SerializationInfo`类型提供的`AddValue`方法的众多重载版本之一来指定要序列化的信息。针对要添加的每个数据，都要调用一次`AddValue`。\n\n以下代码展示了`Dictionary<TKey,TValue>类型`如何实现`ISerializable`和`IDeserializationCallback接口`来控制其对象的序列化和反序列化。\n\n```csharp\n[Serializable]\npublic class Dictionary<TKey, TValue> : ISerializable, IDeserializationCallback\n{\n    // 其他一些私有字段未列出\n\n    private SerializationInfo m_siInfo;//只用于反序列化\n\n    //用于控制反序列化的特殊构造器（这是ISerializable需要的）\n    [SecurityPermission(SecurityAction.Demand, SerializationFormatter = true)]\n    protected Dictionary(SerializationInfo info, StreamingContext context)\n    {\n        //反序列化期间，为OnDeserialization保存SerializationInfo\n        m_siInfo = info;\n    }\n\n    //用于控制序列化的方法\n    [SecurityCritical]\n    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        info.AddValue(\"Version\",m_version);\n        //......\n    }\n    //所有key/value对象都反序列化好之后调用的方法\n    public virtual void IDeserializationCallback.OnDeserialization(object sender)\n    {\n        if (m_siInfo==null)\n        {\n            return;//从不设置，直接返回\n        }\n        // ....\n    }\n}\n```\n\n每个Addvalue方法都获取一个String名称和一些数据。数据一般是简单的值类型。然后，还可以在调用AddValue时向它传递对一个object的引用。`GetObjectData`添加好所有必要的序列化信息之后，会返回至格式化器。\n\n![](24运行时序列化/QQ截图20190919144728.png)\n\n现在,格式化器获取已添加到`SerializationInfo`对象的所有值, 并把它们都序列化到流中.  我们还向`GetObjectData`方法传递了另一个参数 `StreamingContext`对象的引用, 大多数类型的`GetObjectData`都会完全忽略这个参数.\n\n知道了如何设置序列化所需的全部信息之后，再来看**反序列化**。格式化器从流中提取一个对象时，会为新对象分配内存（`FormatterService`的静态方法`GetUninitializedObject`）。最初，**这个对象的所有字段都设为0或者null**。然后，格式化器检查类型是否实现了`ISerializable接口`。如果存在这个接口，格式化器就尝试调用一个**特殊构造器**，他的参数和`GetObjectData`方法完全一致。\n\n> 如果是密封类,强烈建议声明特殊构造器为private防止任何代码不慎调用到它. 而不是密封类, 则声明为protected,确保只有派生类才能调用. 但是无论怎么声明,格式化器都能调用它.\n\n构造器获取了`SerializationInfo`对象引用, 其中包含了序列化时添加的所有值. 特殊构造器可调用`GetInt`,`GetString`等Get方法, 向它传递与序列化一个值所用的名称对应的字符串. 获取的值再去初始化字段.\n\n反序列化对象的字段时，应调用和对象序列化时传给`AddValue方法`的值的类型匹配的get方法。换言之，**如果GetObjectData方法调用AddValue时传递的是一个`int值`，那么在反序列化对象时，应该为同一个值调用`GetInt32`方法**。**如果值在流中的类型和你试图获取get的类型不符，格式化器会尝试用一个IFormatterConverter对象将流中的值类型转型成你指定的类型**。\n\n`FormatterConverter`会调用`System.Convert类`的各种静态方法在不同的核心类型之间对值进行转换. (比如Int64转成一个Int32), 然而,为了在其他任意类型之间转换一个值, `FormatterConverter`要调用`Convert类`的`ChangeType方法`将序列化好的类型转型为一个`IConvertible`接口, 再调用恰当的接口方法.  \n\n**所以要允许一个可序列化类型的对象反序列化成一个不同的类型, 可考虑让自己的类型实现IConvertible接口**. 注意, 只有在反序列化对象时调用一个Get方法,发现它的类型和流中的类型不符时,才会使用`FormatterConverter`对象.\n\n特殊构造器也可以不调用上面列出的各个Get方法, 而是调用`GetEnumerator`. 该方法返回一个`SerializationInfo.Enumerator`对象, 可用该对象遍历`SerializationInfo`对象中包含的所有值. 枚举的每个值都是一个`SerializationEntry`对象.\n\n当然, 完全可以定义自己的类型, 让它从实现了`ISerializable`的`GetObjectData方法`和`特殊构造器`的类型派生. 如果你的类型也实现了`ISerializable`, **那么在你实现的`GetObjectData方法`和`特殊构造器`中,必须调用基类中的同名方法**. **确保对象能正确序列化和反序列化. 这一点很重要**.\n\n![](24运行时序列化/QQ截图20190920113237.png)\n\n## 要实现ISerializable但基类型没有实现怎么办？\n\n前面讲过，`ISerializable接口`的功能非常强大，允许类型完全控制如何对类型的实例进行序列化和反序列化。但这个能力是有代价的：现在，**该类型还要负责它的基类型的所有字段的序列化**。如果基类型也实现了`ISerializable接口`，那么对基类型的字段进行序列化时很容易。调用基类型的`GetObjectData`即可。\n\n但是如果基类型没有实现`ISerializable接口`，在这种情况下，**派生类必须手动序列化基类的字段**。**具体的做法是获取它们的值，并把这些值添加到`SerializationInfo集合`中。然后，在你的特殊构造器中，还必须从集合中取出值，并以某种方式设置基类的字段。如果是public或者protected的,那么一切很容易实现, 如果是private字段,就不可能实现.**\n\n以下代码演示了如何正确实现`ISerializable接口`的`GetObjectData方法`和它的隐含的`构造器`, 使基类的字段能被序列化:\n\n```csharp\n[Serializable]\ninternal class Base\n{\n    protected string m_name = \"Jeff\";\n    public Base(){}\n}\n[Serializable]\ninternal class Derived:Base,ISerializable\n{\n    private DateTime m_date=DateTime.Now;\n    public Derived(){}\n\n    // 如果这个构造器不存在, 便会引发一个SerializationException异常\n    // 如果这个类不是密封类, 这个构造器就应该是protected的\n    [SecurityPermission(SecurityAction.Demand,SerializationFormatter = true)]\n    private Derived(SerializationInfo info, StreamingContext context)\n    {\n       //为我们的类和基类获取可序列化的成员集合\n        Type baseType = this.GetType().BaseType;\n        MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);\n\n        //从info对象反序列化基类的字段\n        for (int i = 0; i < mi.Length; i++)\n        {\n            //获取字段，并把它设为反序列化好的值\n            FieldInfo fi = (FieldInfo) mi[i];\n            fi.SetValue(this,info.GetValue(baseType.FullName+\"+\"+fi.Name,fi.FieldType));\n        }\n        //反序列化为这个类序列化的值\n        m_date = info.GetDateTime(\"Date\");\n    }\n\n    [SecurityPermission(SecurityAction.Demand,SerializationFormatter =true)]\n    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        //为这个类序列化希望的值\n        info.AddValue(\"Date\",m_date);\n        //获取我们的类和基类的可序列化的成员\n        Type baseType = this.GetType().BaseType;\n        MemberInfo[] mi = FormatterServices.GetSerializableMembers(baseType, context);\n        //将基类的字段序列化到info对象中\n        for (int i = 0; i < mi.Length; i++)\n        {\n            //为字段名附加基类型全名作为前缀\n            info.AddValue(baseType.FullName+\"+\"+mi[i].Name, ((FieldInfo)mi[i]).GetValue(this));\n        }\n    }\n    public override string ToString()\n    {\n        return string.Format(\"Name={0},Date={1}\", m_name, m_date);\n    }\n}\n```\n\n上述代码有一个名为`Base`的基类,它只用`SerializableAttribute`定制特性进行标识, 从它派生的`Derived`类,除了应用了此特性还实现了`ISerializable`接口. 两个类都定义了`m_name`的String字段, **调用`SerializationInfo`的`AddValue`不能添加多个同名值**. 解决这个问题的方案是在字段名前附加类名作为前缀. 从而对每个字段进行标识. 例如, 当GetObjectData方法调用`AddValue`来序列化`Base的m_name字段`时, 写入的值名称是\"Base+m_name\".\n\n\n# 流上下文\n\n前面讲过，一组序列化好的对象可以有许多目的地：同一个进程、同一台机器上的不同进程、不同机器上的不同进程等。在一些比较少见的情况下，一个对象可能想知道它要在什么地方反序列化，从而以不同的方式生产它的状态。例如，如果对象中包装了windows信号量对象，如果它知道要反序列化到同一个进程，就可决定对它的内核句柄进行序列化，这是因为内核句柄在一个进程中有效。但如果要反序列化到同一台计算机的不同进程中，就可决定对信号量的字符串名称名称进行序列化。最后，如果要反序列化到不同计算机上的进程，就可决定抛出异常，因为信号量只在一台机器内有效。\n\n本章提到的大量方法都接受一个`StreamingContext（流上下文）`。`StreamingContext`结构是一个非常简单的**值类型**，它只提供了两个公共只读属性，如下:\n\n![](24运行时序列化/QQ截图20190920144424.png)\n\n![](24运行时序列化/QQ截图20190920151102.png)\n\n知道如何获取这些信息后，接着讨论如何设置。`IFormatter接口`定义了`StreamingContext`类型的可读写属性`Context`。构造格式化器时，格式化器会初始化它的Context属性，将`StreamingContextStates`设为All，将对额外状态对象的引用设为null。\n\n格式化器构造好之后，就可以使用任何`StreamingContextStates位标志`来构造一个`StreamingContext结构`，并可选择传递一个`对象(包含你需要的任何额外的上下文信息)引用`。现在，在调用格式化器的`Serialize`或`Deserialize`方法之前，你只需要将格式化器的`context属性`设为这个新的`StreamingContext对象`。\n\n\n# 类型序列化为不同类型以及对象反序列化为不同对象\n\n.Net Framework的序列化架构是相当全面的，本节要讨论如何设计类型**将自己序列化或反序列化成不同的类型或对象**。下面列举了一些有趣的例子。\n\n1. 有的类型（比如`System.DBNull`和`System.Reflection.Missing`）设计为每个Appdomain一个实例。经常将这些类型称为**单实例（Singleton）类型**。**给定一个DBNull对象引用，序列化和反序列化它不应造成在appdomain中新建一个DBNull对象，反序列化后，返回的引用应指向appdomain中现有的DBNull对象。**\n\n2. 对某些类型（比如`System.Type`和`System.Reflection.Assembly`，以及其他反射类型，例如`MemberInfo`），每个类型、程序集或成员等都只能有一个实例。例如，假定一个数组中的每个元素都引用一个`MemberInfo`对象，其中5个元素引用的都是一个`MemberInfo对象`。序列化和反序列化这个数组后，那5个元素引用的应该还是一个`MemberInfo对象`。除此之外，这些元素引用的`MemberInfo`对象还必须实际对应于Appdomain中的一个特定成员。轮询数据库连接对象或者其他任何类型的对象时，这个功能也是很好用的。\n\n3. 对于远程控制的对象，CLR序列化与服务器对象有关的信息。在客户端上反序列化时，会造成CLR创建一个代理对象。这个代理对象的类型有别于服务器对象的类型，但这对于客户端代码来说是透明的（客户端不需要关心这个问题）。客户端直接在代理对象上调用实例方法。然后，代理代码内部会调用远程发送给服务器，由后者实际执行请求操作。\n\n如何正确的序列化和反序列化`单实例类型`:\n\n```csharp\n[Serializable]\npublic sealed class Singleton : ISerializable\n{\n    //这是该类型的一个实例\n    private static readonly Singleton s_theOneObject = new Singleton();\n\n    //这些是实例字段\n    public string Name = \"Jeff\";\n    public DateTime Date=DateTime.Now;\n\n    //私有构造器，允许这个类型构造单实例\n    private Singleton(){}\n\n    //该方法返回对单实例的引用\n    public static Singleton GetSingleton()\n    {\n        return s_theOneObject;\n    }\n\n    // 序列化一个singleton时调用的方法\n    // 我建议在这里使用一个显式接口方法实现（eimi）\n    [SecurityPermission(SecurityAction.Demand,SerializationFormatter = true)]\n    void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n       info.SetType(typeof(SingletonSerializationHelper));\n       // 不需要设置其他值\n    }\n\n    [Serializable]\n    private sealed class SingletonSerializationHelper:IObjectReference\n    {\n        //这个方法在对象（它没有字段）反序列化之后调用\n        public object GetRealObject(StreamingContext context)\n        {\n            return Singleton.GetSingleton();\n        }\n    }\n\n    // 特殊构造器是不必要的,因为它永远不会调用\n}\n```\n\nSingleton类所代表的类型规定每个AppDomain只能存在它的一个实例. 以下是测试序列化和反序列化代码:\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 创建数组，其中多个元素引用一个singleton对象\n    Singleton[] a1 = { Singleton.GetSingleton(), Singleton.GetSingleton() };\n    Console.WriteLine(\"两个元素都指向同一个对象吗?\"+(al[0]==al[1])); // True\n    using (var stream = new MemoryStream())\n    {\n        BinaryFormatter formatter=new BinaryFormatter();\n        //先序列化再反序列化数组元素\n        formatter.Serialize(stream, a1);\n        stream.Position = 0;\n        Singleton[] a2 = (Singleton[]) formatter.Deserialize(stream);\n        //证明它的工作和预期一样\n        // 证明a2数组的两个元素引用的同一个对象\n        Console.WriteLine(\"两个都指向同一个对象吗?\"+(a2[0]==a2[1]));//true\n        // 两个数组中的元素引用是同一个对象\n        Console.WriteLine(\"所有的元素都指向同一个对象吗?\"+(a1[0]==a2[0]));//true\n    }\n}\n```\n\n现在，我们通过分析代码来理解所发生的事情。Singleton类型加载到Appdomain中时，CLR调用它的静态构造器来构造一个Singleton对象，并将对它的引用保存到静态字段`s_theOneObject`中。`Singleton`类没有提供任何公共构造器，**这防止了其他任何代码构造该类的其他实例**。\n\n`formatter.Serialize`时, 格式器检测到`Singleton`类型实现了`ISerializable`接口. 并调用`GetObjectData`方法, 这个方法调用`SetType`,向它传递`SingletonSerializationHelper`对象, 由于没有调用`AddValue`, 所以没有额外的字段信息写入流. 格式化器自动检测出两个数组元素都引用一个对象. 所以格式化器只序列化一个对象.\n\n序列化数组之后，调用格式化器的`Deserialize`方法。对流进行反序列化时，格式化器尝试反序列化一个`SingletonSerializationHelper`对象，这是格式化器之前被“欺骗”所序列化的东西(事实上着正是为什么Singleton类不提供特殊构造器的原因, 实现了`ISerializable`接口的通常都需要提供这个特殊构造器)。构造好`SingletonSerializationHelper`对象后，格式化器发现这个类型实现了`System.Runtime.Serialization.IObjectReference`接口。\n\n```csharp\npublic interface IObjectReference\n{\n   Object GetRealObject(StreamingContext context);\n}\n```\n\n如果类型实现了这个接口，格式化器会调用`GetRealObject`方法。这个方法返回在对象反序列化好之后你真正想引用的对象。在我的例子中，`SingletonSerializationHelper`类型让`GetRealObject`返回对Appdomain中已经存在的`Singleton对象`的一个引用。所以，当格式化器的Deserialize方法返回时，a2数组包含两个元素，两者都引用`Appdomain`的`Singleton`对象。用于帮助进行反序列化的`SingletonSerializationHelper`对象立即变得“不可达”了，将来会被垃圾回收。\n\n\n# 序列化代理\n\n格式化器还允许不是“类型实现的一部分”的代码重写该类型“序列化和反序列化其对象”的方式。应用程序代码之所以要重写（覆盖）类型的行为，主要是出于两方面的考虑。\n\n1. 允许开发人员序列化最初没有设计要序列化的类型。\n2. 允许开发人员提供一种方式将类型的一个版本映射到类型的一个不同的版本。\n\n简单地说，为了使这个机制工作起来，首先要定义一个“**代理类型**”（surrogate type），它接管对现有类型进行序列化和反序列化的行动。然后，向格式化器登记该代理类型的实例，告诉格式化器代理类型要作用于现有的哪个类型。一旦格式化器要对现有类型的实例进行序列化和反序列化，就调用由你的代理对象定义的方法。下面例子演示这一切如何工作:\n\n序列化**代理类型**必须实现`ISerializationSurrogate接口`，如下定义\n\n```csharp\npublic interface ISerializationSurrogate\n{\n   void GetObjectData(Object obj, SerializationInfo info, StreamingContext context);\n\n   object SetObjectData(object obj, SerializationInfo info, StreamingContext context, ISurrogateSelector selector);\n}\n```\n\n假定程序含有一些DateTime对象, 其中包含用户计算机的本地值. 如果想把DateTime对象序列化到流中, 同时希望值用国际标准时间序列化, 如何操作呢?  这样一来就可以将数据通过网络流发送给世界上其他地方的另一台机器, 使DateTime值保持正确. 它能控制DateTime对象的序列化和反序列化方式.\n\n```csharp\npublic class UniversalToLocalTimeSerializationSurrogate:ISerializationSurrogate\n{\n    public void GetObjectData(object obj,SerializationInfo info,StreamingContext context)\n    {\n        //将datetime从本地时间转换成UTC\n        info.AddValue(\"Date\",((DateTime)obj).ToUniversalTime().ToString(\"u\"));\n    }\n    public object SetObjectData(object obj,SerializationInfo info,StreamingContext context,ISurrogateSelector selector)\n    {\n        //将datetime从UTC转换成本地时间\n        return DateTime.ParseExact(info.GetString(\"Date\"), \"u\", null).ToLocalTime();\n    }\n}\n```\n\n`GetObjectData`方法在这里的工作方式与`ISerializable接口的GetObjectData方法`差不多, 唯一区别在于,**要多获取一个额外的参数----对要序列化的\"真实\"对象的引用**. 上述方法中,这个对象是DateTime. 值从本地时间转换为世界时. 并将一个字符串(使用通用完整日期/事件模式来格式化)添加到`SerializationInfo`集合.\n\n`SetObjectData`方法用于反序列化一个DateTime对象, 调用这个方法时要向它传递一个`SerializationInfo`对象的引用,`SetObjectData`从这个集合中获取字符串形式的日期, 把它解析成通用完整日期/事件模式的字符串, 然后将结果DateTime对象从世界时转换成计算机的本地时间.\n\n传给`SetObjectData`第一个参数的object有点奇怪。在调用`SetObjectData`之前，格式化器分配（调用`FormatterService`的静态方法`GetUninitializedObject`）要代理的那个类型的实例。实例的字段全是`0/null`，而且没有在对象上调用构造器。`SetObjectData`内部的代码为了初始化这个实例的字段，可以使用传入的`SerializationInfo`中的值，并让`SetObjectData`返回`null`。另外，`SetObjectData`可以创建一个完全不同的对象，甚至创建不同类型的对象，并返回对新对象的引用。这种情况下，格式化器会忽略对传给`SetObjectData`对象的任何更改。\n\n在例子中, `UniversalToLocalTimeSerializationSurrogate`类扮演了DateTime类型的代理的角色, DateTime是值类型, 所以obj参数引用一个DateTime的已装箱实例. 大多数值类型中的字段都无法更改, 所以我的`SetObjectData`方法会忽略obj参数, 并返回一个新的DateTime对象, 其中已装好了期望的值.\n\n序列化/反序列化一个DateTime对象时，格式化器怎么知道要用这个`ISerializationSurrogate`类型呢？一下代码进行测试：\n\n```csharp\nstatic void Main(string[] args)\n{\n    using (var stream=new MemoryStream())\n    {\n        //1 构造所需的格式化器\n        IFormatter formatter = new BinaryFormatter();\n        //2 构造一个SurrogateSelector代理选择器对象\n        SurrogateSelector ss = new SurrogateSelector();\n        //3 告诉代理选择器为datetime对象使用我们的代理\n        ss.AddSurrogate(typeof(DateTime),formatter.Context,new UniversalToLocalTimeSerializationSurrogate());\n        //4 告诉格式化器使用代理选择器\n        formatter.SurrogateSelector = ss;\n\n        //创建一个datetime来代表机器上的本地时间，并序列化它\n        DateTime localTimeBeforeSerialize = DateTime.Now;\n        formatter.Serialize(stream,localTimeBeforeSerialize);\n\n        //stream将university时间作为一个字符串显示，证明能正常工作\n        stream.Position = 0;\n        Console.WriteLine(new StreamReader(stream).ReadToEnd());\n\n        //反序列化universal时间字符串，并且把它转换成本地datetime\n        stream.Position = 0;\n        DateTime localTimeAfterDeserialize = (DateTime) formatter.Deserialize(stream);\n\n        //证明它能正确工作\n        Console.WriteLine(\"LocalTimeBeforeSerialize ={0}\",localTimeBeforeSerialize);\n        Console.WriteLine(\"LocalTimeAfterDeserialize={0}\",localTimeAfterDeserialize);\n    }\n}\n```\n\n步骤1到步骤4执行完毕后，格式化器就准备好实用已登记的代理类型。调用格式化器的`Serialize方法`时，会在`SurrogateSelector`维护的集合（一个哈希表）中查找（要序列化的）每个对象的类型。如果发现一个匹配，就调用`ISerializationSurrogate`对象的`GetObjectData`方法来获取应该写入流的信息。\n\n格式化器的`Deseialize方法`在调用时，会在格式化器的`SurrogateSelector`中查找要反序列化的对象的类型。如果发现一个匹配，就调用`ISerializationSurrogate对象`的`SetObjectData方法`来设置要反序列化的对象中的字段。\n\nSurrogateSelector对象在内部维护了一个私有哈希表。调用AddSurrogate时，type和StreamingContext构成了哈希表的键（key），对应的值（value）就是ISerializationSurrogate对象。如果已经存在和要添加的Type/StreamingContext相同的一个键，AddSurrogate会抛出一个ArgumentException。通过在键中包含一个StramingContext，可以登记一个代理类型对象，它知道如何将Datetime对象序列化/反序列化到一个文件中；再登记一个不同的代理对象，它知道如何将Datetime对象序列化/反序列化到一个不同的进程中。\n\n![](24运行时序列化/QQ截图20190921155118.png)\n\n## 代理选择器链\n\n多个SurrogateSelector对象可连接到一起。例如，可以让一个SurrogateSelector对象维护一组序列化代理，这些序列化代理（Surrogate）用于将类型序列化成代理（proxy），以便通过网络传送，或者跨越不同的AppDomain传送。还可以让另一个SurrogateSelector对象维护一组序列化代理，这些序列化代理用于将版本1的类型转换成版本2的类型。\n\n> Surrogate 代理: 负责序列化\n> proxy 代理: 负责跨越AppDomain边界访问对象\n\n![](24运行时序列化/QQ截图20190921155443.png)\n\n![](24运行时序列化/QQ截图20190921155501.png)\n\n\n# 反序列化对象时重写程序集/类型\n\n序列化对象时, 格式化器输出类型及其定义程序集的全名. 反序列化对象时, 格式化器根据这个信息确定要为对象构造并初始化什么类型. 前面讨论了如何利用`ISerializationSurrogate`接口来接管特定类型的序列化和反序列化工作, 实现了`ISerializationSurrogate`接口的类型与特定程序集中的特定类型关联.\n\n有的时候`ISerializationSurrogate`机制的灵活性显得有点不足, 下面列举的情形中,有必要将对象反序列化成和序列化时不同的类型.\n\n- 开发人员可能想把一个类型的实现从一个程序集移动到另一个程序集. 例如, 程序集的版本号的变化造成新程序集有别于原始程序集.\n- 服务器对象序列化到发送给客户端的流中. 客户端处理流时, 可以将对象反序列化成完全不同的类型, 该类型的代码知道如何向服务器的对象发出远程方法调用.\n- 开发人员创建了类型的新版本, 想把已序列化的对象反序列化成类型的新版本.\n\n利用`SerializationBinder`类, 可以非常简单地将一个对象反序列化成不同类型. 为此,要先定义自己的类型, 让它从抽象类`SerializationBinder`类派生, 假定你的版本1.0.0.0程序集定义了名为Ver1的类, 并假定程序集的新版本定义`Ver1ToVer2SerializationBinder`类, 还定义了名为Ver2的类:\n\n```csharp\ninternal static class SerializationBinderDemo\n{\n    public static void Go()\n    {\n        using (var stream = new MemoryStream())\n        {\n            IFormatter formatter = new BinaryFormatter();\n            formatter.Binder = new Ver1ToVer2SerializationBinder();\n            formatter.Serialize(stream, new Ver1());\n\n            stream.Position = 0;\n            Ver2 t = (Ver2) formatter.Deserialize(stream);\n            Console.WriteLine(\"反序列化:{0}, ToString={{{1}}}\", t.GetType(), t);\n        }\n    }\n\n    [Serializable]\n    private sealed class Ver1\n    {\n        public Int32 x = 1, y = 2, z = 3;\n    }\n\n    [Serializable]\n    private sealed class Ver2 : ISerializable\n    {\n        Int32 a, b, c;\n\n        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n        public void GetObjectData(SerializationInfo info, StreamingContext context)\n        {\n            /* Never called: do nothing */\n        }\n\n        // 特殊构造器\n        [SecurityPermissionAttribute(SecurityAction.Demand, SerializationFormatter = true)]\n        private Ver2(SerializationInfo info, StreamingContext context)\n        {\n            a = info.GetInt32(\"x\");\n            b = info.GetInt32(\"y\");\n            c = info.GetInt32(\"z\");\n        }\n\n        public override string ToString()\n        {\n            return String.Format(\"a={0}, b={1}, c={2}\", a, b, c);\n        }\n    }\n\n    private sealed class Ver1ToVer2SerializationBinder : SerializationBinder\n    {\n        public override void BindToName(Type serializedType, out string assemblyName, out string typeName)\n        {\n            assemblyName = Assembly.GetExecutingAssembly().FullName;\n            typeName     = typeof(Ver2).FullName;\n        }\n\n        public override Type BindToType(String assemblyName, String typeName)\n        {\n            // 将任何Ver1对象从版本1.0.0.0反序列化成一个Ver2对象\n\n            // 计算定义Ver1类型的程序集名称\n            AssemblyName assemVer1 = Assembly.GetExecutingAssembly().GetName();\n            assemVer1.Version = new Version(1, 0, 0, 0);\n\n            // 如果从V1.0.0.0反序列化Ver1对象, 就把它转变成一个Ver2对象\n            if (assemblyName == assemVer1.ToString() && typeName == \"SerializationBinderDemo+Ver1\")\n                return typeof(Ver2);\n\n            // 否则, 就只返回请求的同一类型\n            return Type.GetType(String.Format(\"{0}, {1}\", typeName, assemblyName));\n        }\n    }\n}\n```\n\n![](24运行时序列化/QQ截图20190921170339.png)\n","tags":["CLR读书笔记"]},{"title":"23程序集加载和反射","url":"/2019/09/16/23程序集加载和反射/","content":"\n# 程序集加载和反射\n\n本章主要讨论在编译时对一个类型一无所知的情况下，如何在**运行时**发现**类型的信息**、**创建类型的实例**以及**访问类型的成员**。可利用本章讲述的内容创建**动态可扩展**应用程序。\n\n动态可扩展应用程序可利用第22章讲述的CLR技术和AppDomain. 宿主可以在一个AppDomain中运行加载项代码, 这个AppDomain有它自己的安全性和配置设置. 宿主还可通过卸载AppDomain来卸载加载项.\n\n> 这里讨论的是.Net Framework 4.5引入的新的反射API.\n\n![](23程序集加载和反射/QQ截图20190916122107.png)\n\n# 程序集加载\n\n我们知道，JIT编译器将方法的IL代码编译成本机代码时，会查看IL代码中引用了哪些类型。在运行时，JIT编译器利用程序集的`TypeRef`和`AssemblyRef元数据表`来确定哪一个程序集定义了所引用的类型。在`AssemblyRef元数据表`的记录项中，包含了构成程序集**强名称**的各个部分。JIT编译器获取所有这些部分—---包括名称、版本、语言文化和公钥信息（public key token）----并把它们连接成一个字符串。然后，JIT编译器尝试将与该标识匹配的程序集加载到`AppDomain`中（如果还没有加载的话）。如果被加载的程序集是**弱命名**的，那么表示中就只包含程序集的名称。\n\n在内部, CLR使用`System.Reflection.Assembly`类的`静态Load方法`尝试加载这个程序集. 这个方法是公开的, 可以显式地将程序集加载到AppDomain中. 该方法是CLR的与Win32` LoadLibrary函数`等价的方法.\n\n```csharp\npublic class Assmbly\n{\n   // 常用的重载的原型\n   public static Assembly Load(AssemblyName assemblyRef);\n   public static Assembly Load(String assemblyString);\n   // 未列出不常用的函数\n}\n```\n\n在内部，Lad导致CLR向程序集应用一个版本绑定重定向策略，**并在GAC（全局程序集缓存）中查找程序集**。如果没找到，就接着去应用程序的基目录、私有路径子目录和codebase位置查找。如果调用Load时传递的是弱命名程序集，Load就不会向程序集应用版本绑定重定向策略，CLR也不会去GAC查找程序集。如果Load找到指定的程序集，会返回对代表已加载的那个程序集的一个Assembly对象的引用。如果没找到，会抛出`System.IO.FileNotFoundException`异常。\n\n![](23程序集加载和反射/QQ截图20190916123303.png)\n\n`System.AppDomain`提供了`Load方法`. 和`Assembly`的`静态Load方法`不同, **AppDomain的Load是实例方法,它允许将程序集加载到指定的AppDomain中**. 该方法设计由非托管代码调用. 允许宿主将程序集**注入**特定AppDomain中.调用`System.AppDomain`的`Load方法`需要传递一个标识了程序集的字符串.\n\n`AppDomain`的`Load方法`会返回对程序集的引用, 由于`Assembly`类不是从`System.MarshallByRefObject`派生的, 所以程序集对象必须**按值封送回**发出调用的AppDomain. **应该避免使用AppDomain的Load方法**.\n\n![](23程序集加载和反射/QQ截图20190916124703.png)\n\n\n在大多数动态可扩展应用程序中，**`Assembly`的`Load方法`是将程序集加载到AppDomain的首选方式**。但它要求事先**掌握构成程序集标识的各个部分**。开发人员经常需要写一些工具或实用程序来操作程序集，他们都要获取引用了程序集文件路径名（包括文件扩展名）的命令行实参。\n\n调用Assembly的`LoadFrom方法`加载指定了路径名的程序集：\n\n```csharp\npublic class Assembly\n{\n    public static Assembly LoadFrom(string path);\n}\n```\n\n在内部，\n1. `LoadFrom`首先调用`System.Reflection.AssemblyName类`的静态`GetAssemblyName`方法。\n2. 该方法打开指定的文件，找到`AssemblyRef`元数据表的记录项，提取程序集标识信息，\n3. 然后以一个`System.Reflection.AssemblyName`对象的形式返回这些信息。\n4. 随后，`LoadFrom`方法在内部调用`Assembly`的`Load`方法，将AssemblyName对象传给它。\n5. 然后，CLR应用版本绑定重定向策略，并在各个位置查找匹配的程序集。Load找到匹配程序集会加载它，并返回待办已加载程序集的Assembly对象；`LoadFrom`方法将返回到这个值。\n  - 如果Load没有找到匹配的程序集，LoadFrom会加载通过LoadFrom的实参传递的路径中的程序集。\n  - 当然，如果已加载具有相同标识的程序集，LoadFrom方法就会直接返回代表已加载程序集的Assembly对象。\n\n`LoadForm方法`允许传递一个URL作为实参，如下：\n\n`Assembly a=Assembly.LoadFrom(@”http://xxxxxxxxx.xxxxAssembly.dll”);`\n\n如果传递的是一个internet位置，clr会下载文件，把它安装到用户的下载缓存中，再从那儿加载文件。注意，当前必须联网，否则会抛出异常。但如果文件之前已下载过，而且ie被设置为脱机工作，就会使用以前下载的文件, 不会抛出异常, 还可以调用`UnsafeLoadFrom`方法, 能够加载从网上下载的程序集,同时绕过一些安全检查.\n\n![](23程序集加载和反射/QQ截图20190916125533.png)\n\nVS的UI设计人员和其他工具一般用的是`Assembly`的`LoadFile`方法。**这个方法可从任意路径加载程序集**，而且可以将具有相同标识的程序集**多次加载**到一个AppDomain中。**在设计器/工具中对应用程序的UI进行修改，而且用户重新生成了程序集时，便有可能发生这种情况**。通过LoadFile加载程序集时，CLR**不会自动解析任何依赖性问题**；你的代码必须向AppDomain的AssemblyResolve事件登记，并让事件回调方法显式地加载任何依赖的程序集。\n\n如果你构建的一个工具只想通过反射来分析程序集的元数据，并希望**确保程序集中的任何代码都不会执行**，那么加载程序集的最佳方式就是使用`Assembly`的`ReflectionOnlyLoadFrom方法`或者使用`Assembly`的`ReflectionOnlyLoad方法`(比较少见)。\n\n```csharp\npublic class Assembly\n{\n    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);\n    public static Assembly ReflectionOnlyLoad(string assemblyString);\n}\n```\n\n`ReflectionOnlyLoadFrom`方法加载由路径指定的文件；文件的强名称标识不会获取，也不会在GAC和其他位置搜索文件。`ReflectionOnlyLoad`方法会在GAC、应用程序基目录、私有路径和codebase指定的位置搜索指定的程序集。但和Load方法不同的是，`ReflectionOnlyLoad`方法**不会应用版本控制策略**，所以你指定的是哪个版本，获得的就是哪个版本。要自行向程序集标识应用版本控制策略，可将字符串传给AppDomain的`ApplyPolicy`方法。\n\n利用**反射**来分析由这两个方法之一加载的程序集时，代码经常需要向AppDomain的`ReflectionOnlyAssemblyResovle`事件注册一个回调方法，以便手动加载任何引用的程序集；CLR不会自动帮你做这个事情。回调方法被调用时，它必须调用Assembly的ReflectionOnlyLoadFrom或ReflectionOnlyLoad方法来显式加载引用程序集，并返回对程序集的引用。\n\n**CLR不提供卸载单独程序集的能力. 如果CLR允许这样做, 那么一旦线程从某个方法返回至已卸载的一个程序集中的代码, 应用程序就会崩溃, 健壮性和安全性是CLR最优先考虑的目标.** 如果允许应用程序以这样的一种方式崩溃，就和它的设计初衷背道而驰了。卸载程序集必须卸载包含它的整个AppDomain。\n\n许多应用程序都是由一个要**依赖于众多dll文件**的exe文件构成。部署应用程序时，所有文件都必须部署。但有一个技术允许**只部署一个exe文件**。首先标识出exe文件要依赖的、不是作为.NET Framework一部分发布的所有dll文件。然后将这些dll添加到vs项目中。对于添加的每个dll，都显示它的属性，将它的“生成操作”更改为“**嵌入的资源**”。**这会导致C#编译器将dll文件嵌入exe文件中，以后就只需要部署这个exe。**\n\n在运行时，CLR会找不到依赖的dll程序集。为了解决这个问题，当应用程序初始化时，向AppDomain的`ResolveAssembly`事件登记一个回调方法，代码大致如下：\n\n```csharp\nprivate static Assembly ResolveEventHandler(object sender,ResolveEventArgs args)\n{\n    string dllName=new AssemblyName(args.Name).Name+\".dll\";\n    var assem = Assembly.GetExecutingAssembly();\n    string resourceName = assem.GetManifestResourceNames().FirstOrDefault(c => c.EndsWith(dllName));\n    if (resourceName==null)\n    {\n        return null;//not found,maybe another handler will find it\n    }\n\n    using (var stream=assem.GetManifestResourceStream(resourceName))\n    {\n        byte[] assemblyData=new byte[stream.Length];\n        stream.Read(assemblyData, 0, assemblyData.Length);\n        return Assembly.Load(assemblyData);\n    }\n}\n\n```\n\n现在，线程首次调用一个方法时，如果发现该方法引用了依赖DLL文件中的类型，就会引发一个`AssemblyResolve事件`，而上述回调代码会找到所需的签入DLL资源，并调用Assembly的Load方法获取一个`byte[]实参`的重载版本来加载所需的资源。虽然我喜欢将依赖DLL嵌入程序集的技术，但要注意这会增大应用程序在运行时的内存消耗。\n\n# 使用反射构建动态可扩展应用程序\n\n总所周知，元数据时用一系列的表存储的。生成程序集或模块时，编译器会创建一个类型定义表、一个字段定义表、一个方法定义表以及其他表。利用System.Reflection命名空间中包含的类型，可以写代码来反射这些元数据表。实际上，这个命名空间中的类型为程序集或模块中包含的元数据提供了一个对象模型。\n\n利用对象模型中的类型，可以轻松枚举类型定义元数据表中的所有类型，而针对每个类型都可获取它的基类型、它实现的接口以及与类型关联的标志。利用System.Reflection命名空间中的其他类型，还可解析对应的元数据表来查询类型的字段、方法、属性和事件。还可发现应用于任何元数据实体的定制特性。甚至有些类允许判断引用的程序集；还有一些方法能返回一个方法的IL字节流。利用所有这些信息，很容易构建出与Microsoft的IlDasm.exe相似的工具。\n\n> 有些反射类型是专门由CLR编辑器开发人员使用的, 应用程序的开发人员一般用不着.\n\n在运行时，当应用程序需要从特定程序集中加载特定类型以执行特定任务时，也要使用反射。例如，应用程序可要求用户提供程序集和类型名。然后应用程序可显式加载程序集，构造类型的实例，再调用类型中定义的方法。以这种方式绑定到类型并调用方法称为**晚期绑定**。（对应的，早期绑定是指在编译时就确定应用程序要使用的类型和方法.）\n\n# 反射的性能\n\n反射是相当强大的机制，允许在`运行时`发现并使用编译时还不了解的类型及成员。但是，他也有下面两个缺点。\n\n1. 反射造成编译时无法保证类型安全性。**由于反射严重依赖字符串，所以会丧失编译时的类型安全性**。例如，执行`Type.GetType(“int”);`要求通过反射在程序集中查找名为`int`的类型，代码会通过编译，但在运行时会返回`null`，因为CLR只知道`System.Int32`，不知道`int`。\n\n2. 反射速度慢。使用反射时，类型及其成员的名称在编译时未知；你要用字符串名称标识每个类型及成员，然后再运行时发现它们。也就是说，使用`System.Reflection`命名空间中的类型扫描程序集的元数据时，反射机制会不停执行字符串搜索。通常，**字符串搜索执行的是不区分大小写的比较**，这会进一步影响速度。\n\n使用反射调用成员也会影响性能。用反射调用方法时，首先必须将实参`打包`成数组；在内部，反射必须将这些实参`解包`到线程栈上。此外，在调用方法前，CLR必须检查实参具有正确的数据类型。最后，CLR必须确保调用者有正确的安全权限来访问被调用成员。\n\n基于上述所有原因，最好避免利用反射来访问字段或调用`方法/属性`。\n\n**应该利用以下两种技术之一开发应用程序来动态发现和构造类型实例。**\n\n1. 让类型从编译时已知的基类型派生。在运行时构造派生类型的实例，将对它的引用放到基类型的变量中，再调用基类型定义的虚方法。\n2. 让类型实现编译时已知的接口。在运行时构造类型的实例，将对它的引用放到接口类型的变量中，再调用接口定义的方法。\n\n在这两种技术中，我个人更喜欢使用`接口技术`而非`基类技术`，因为基类技术不允许开发人员选择特定情况下工作得最好的基类。不过，需要版本控制的时候基类技术更合适，因为可随时向基类添加成员，派生类会直接继承该成员。相反，要向接口添加成员，实现该接口的所有类型都得修改它们的代码并重新编译。\n\n\n## 发现程序集中定义的类型\n\n反射经常用于判断程序集定义了哪些类型。FCL提供了许多api来获取这方面的信息。目前常用的是Assembly的`ExportedTypes属性`。 显示其中定义的所有公开导出的类型(也就是public类型).\n\n```csharp\nstatic void Main(string[] args)\n{\n    string dataAssembly = \"System.Data,version=4.0.0.0,\" + \"culture=neutral,PublicKeyToken=b77a5c561934e089\";\n    LoadAssemAndShowPublicTypes(dataAssembly);\n}\nprivate static void LoadAssemAndShowPublicTypes(string assemblyName)\n{\n    //显式地将程序集加载到这个appDomain中\n    Assembly a = Assembly.Load(assemblyName);\n    //在一个循环中显示已加载程序集中每个公开导出type全名\n    foreach (Type t in a.ExportedTypes)\n    {\n        Console.WriteLine(t.FullName);\n    }\n}\n```\n\n## 类型对象的准确含义\n\n注意，上述代码遍历`System.Type`对象构成的数组。**System.Type类型是执行类型和对象操作的起点**。**System.Type对象代表一个类型引用（而不是类型定义）**。\n\n总所周知，`System.Object`定义了公共`非虚实例方法GetType`。调用这个方法时，CLR会判定指定对象的类型，并返回对该类型的Type对象的引用。由于在一个AppDomain中，每个类型只有一个Type对象，所以可以使用相等和不相等操作符来判断两个对象是不是相同的类型。\n\n`o1.GetType() == o2.GetType();`\n\n除了调用Object的GetType方法，FCL还提供了获得Type对象的其他几种方式。\n1. `System.Type`类型提供了静态`GetType`方法的几个重载版本。**所有版本都接受一个String参数。字符串必须指定类型的全名,而不是编辑器支持的基元类型**(int,string,bool等), 这些名称对CLR没有任何意义。\n2. `System.Type`类型提供了静态的`ReflectionOnlyGetType`方法. 与上一条行为上相似, 只是类型会以\"仅反射\"的方式加载, 不能执行.\n3. `System.TypeInfo`类型提供了实例成员`DeclaredNestedTypes`和`GetDeclaredNestedType`。\n\n4. `System.Reflection.Assembly`类型提供了实例成员`GetType`，`DefinedTypes`和`ExportedTypes`。\n\n![](23程序集加载和反射/QQ截图20190916162528.png)\n\n> 参考文档: [指定完全限定的类型名称](https://docs.microsoft.com/zh-cn/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names)\n\n许多编程语言都允许使用一个操作符(`typeof`)并根据编译时已知的类型名来获得Type对象。**尽量用这个操作符获取Type引用，而不要使用上述列表中的任何方法，因为操作符生成的代码通畅更快**。C#的这个操作符称为`typeof`，通常用它将晚期绑定的类型信息与早期绑定（编译时已知）的类型信息进行比较。\n\n```csharp\nprivate static void SomeMethod(object o)\n{\n    //getType在运行时返回对象的类型（晚期绑定）\n    //typeof返回指定类的类型（早期绑定）\n    if (o.GetType()==typeof(FileInfo))\n    {\n        //.....\n    }\n    if (o.GetType()==typeof(DirectoryInfo))\n    {\n        //.....\n    }\n}\n```\n\n上述代码中, 使用`typeof`是精确匹配, 而不是兼容匹配.\n- 精确匹配: 不检查是否从FileInfo类型**派生的对象**, 只检查是否引用了FileInfo类型对象.\n- 兼容匹配: 使用`转型或者C#is/as`操作符时, 测试的就是兼容匹配.\n\n如前所述，**Type对象是轻量级的对象引用。要更多地了解类型本身，必须获取一个TypeInfo对象，后者才代表类型定义**。可调用`System.Reflection.IntrospectionExtensions`的`GetTypeInfo`扩展方法将`Type`对象转换成`TypeInfo`对象。\n\n```csharp\nType typeReference = o.GetType();//例如o.gettype()或者typeof(Object)\n// 将Type对象转换成TypeInfo对象\nTypeInfo typeDefinition = typeReference.GetTypeInfo();\n\n// 将TypeInfo对象转换为Type对象\nType typeReference2 = typeDefinition.AsType();\n```\n\n另外，虽然作用不大，但还可调用`TypeInfo`的`AsType方法`将`TypeInfo对象`转换为`Type对象`。\n\n获取TypeInfo对象会强迫CLR确保已加载类型的定义程序集，从而对类型进行解析。这个操作可能代价高昂。如果只需要类型引用（Type对象），就应该避免这个操作。但一旦获得了TypeInfo对象，就可查询类型的许多属性进一步了解它。大多数属性，比如`IsPublic`，`isSealed`，`isAbstract`，`isClass`和`isValueType`等，都指明了与类型关联的标志。另一些属性，比如Assembly，AssemblyQualifiedName，FullName和Module等，则返回定义该类型程序集或模块的名称以及类型全名。还可查询BaseType属性来获取对类型的基类型的引用。除此之外，还有许多方法能提供关于类型的更多信息。\n\n## 构建Exception 派生类型的层次结构\n\n以下代码使用本章讨论的许多概念将一组程序集加载到Appdomain中，并显示最终从System.Exception派生的所有类。\n\n```csharp\nprivate static void Go()\n{\n    //显示加载想要反射的程序集\n    LoadAssemblies();\n    //对所有类型进行筛选和排序\n    var allTypes = (from a in AppDomain.CurrentDomain.GetAssemblies()\n            from t in a.ExportedTypes\n            where typeof(Exception).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())\n            orderby t.Name\n            select t).ToArray();\n    //生成并显示继承层次结构\n    Console.WriteLine(WalkInheritanceHierarchy(new StringBuilder(),0,typeof(Exception),allTypes ));\n}\nprivate static StringBuilder WalkInheritanceHierarchy(StringBuilder sb ,int indent,Type baseType,IEnumerable<Type> allTypes)\n{\n    string spaces = new String(' ', indent * 3);\n    sb.AppendLine(spaces + baseType.FullName);\n    foreach (var t in allTypes)\n    {\n        if (t.GetTypeInfo().BaseType!=baseType)\n        {\n            continue;\n        }\n        WalkInheritanceHierarchy(sb, indent + 1, t, allTypes);\n    }\n    return sb;\n}\nprivate static void LoadAssemblies()\n{\n    string[] assemblies = {\"System,PublicKeyToken={0}\", \"System.Core,PublicKeyToken={0}\",\"System.Data,PublicKeyToken={0}\",\"System.Design,PublicKeyToken={1}\"};\n\n    string ecmaPublicKeyToken = \"b77a5c561934e089\";\n    string msPublicKeyToken = \"b03f5f7f11d50a3a\";\n    //获取包含system.object的程序集的版本，假定其他所有程序集都是相同的版本\n    Version version = typeof(System.Object).Assembly.GetName().Version;\n    //显示加载想要反射的程序集\n    foreach (var a in assemblies)\n    {\n        string assemblyIdentity = string.Format(a, ecmaPublicKeyToken, msPublicKeyToken) +\n                                  \",Culture=neutral,Version=\" + version;\n        Assembly.Load(assemblyIdentity);\n    }\n}\n```\n\n![](23程序集加载和反射/QQ截图20190916173727.png)\n\n\n## 构造类型的实例\n\n获取对`Type派生对象`的引用之后，就可以构造该类型的实例了。FCL提供了一下几个机制。\n\n1. `System.Activator`的`CreateInstance`方法\n\n`Activator类`提供了**静态**`CreateInstance`方法的几个重载版本.  可以传递`Type对象`引用, 也可以传递标识了类型的`String`, 直接获取类型对象的几个版本较为简单。你要为类型的构造器传递一组实参，方法返回新对象的引用。\n\n用字符串来制定类型的几个版本稍微复杂一些。首先必须指定另一个字符串来表示定义了类型的程序集。其次，如果正确配置了远程访问(remoting)选项，这些方法还允许构造远程对象, 这些版本返回的不是新对象的引用, 而是一个`System.Runtime.Remoting.ObjectHandle`对象(从`MarshalByRefObject`派生).  `ObjectHandle`允许将一个AppDomain中创建的对象传至其他AppDomain.  期间不强迫对象**具体化(materialize)** , 准备好具体化这个对象时, 它将定义了要具体化的类型的程序集加载到这个AppDomain中. 如果对象按引用封送, 会创建代理类型和对象. 如果按值封送, 对象的副本会被序列化.\n\n2. `System.Activator`的`CreateInstanceForm`方法\n\nActivator类还提供了一组**静态**CreateInstanceForm方法，他们与CreateInstance的行为相似，只是必须通过**字符串参数来指定**类型及其程序集。程序集用Assembly的LoadForm（而非load）方法加载到调用AppDomain中。由于都不接受Type参数，所以返回的都是一个`ObjectHandle`对象引用，必须调用`ObjectHandle`的`Unwrap`方法进行具体化.\n\n3. `System.Appdomain`的方法\n\nAppdomain类型提供了4个用于构造类型实例的**实例方法**，包括`CreateInstance`，`CreateInstanceFrom`和`CreateInstanceFromAndUnwrap`。这些方法和行为和Activator类的方法相似。区别在于他们都是实例方法，允许指定在哪个Appdomain中构造对象。另外，带Unwrap后缀的方法还能简化操作，不必执行额外的方法调用。\n\n4. `System.Reflection.ConstructorInfo`的`Invoke`实例方法\n\n使用一个Type对象引用，可以绑定到一个特定的构造器，并获取对构造器的`ConstructorInfo`对象的引用。然后，可利用`ConstructorInfo`对象引用来调用它的`Invoke方法`。类型总是在调用Appdomain中创建，返回的是对新对象的引用。\n\n注意： CLR不要求`值类型`定义任何构造器。`Activator`的`CreateInstance方法`**允许在不调用构造器的情况下创建值类型的实例**。必须调用`CreateInstance`方法获取单个Type参数的重载版本或者获取Type和Boolean参数的重载版本。\n\n利用前面列出的机制，可为除**数组(System.Array派生类型)** 和**委托(System.MulticastDelegate派生类型)** 之外的所有类型**创建对象**。\n\n**创建数组** 需要调用`Array`的静态`CreateInstance方法`。所有版本的CreateInstance方法获取的第一个参数都是对数组元素`Type的引用`。`CreateInstance`的其他参数允许指定数组位数**维数**和**上下限**的各种组合。\n\n**创建委托** 则要调用`MethodInfo`的静态`CreateDelegate方法`。所有版本的CreateDelegate方法获取的第一个参数都是对委托Type的引用。CreateDelegate方法的其他参数允许指定在调用实例方法时应将哪个对象作为this参数传递。\n\n\n构造泛型类型的实例首先要获取对开放类型的引用，然后调用`Type`的`MakeGenericType方法`并向其传递一个数组（其中包含要作为类型实参使用的类型）。然后，获取返回的Type对象并把它传给上面列出的某个方法。\n\n```csharp\ninternal sealed class Dictionary<TKey,TValue>{}\n\npublic static class Program\n{\n    static void Main(string[] args)\n    {\n        // 获取对泛型类型的类型对象的引用 , 没限定泛型的类型就是开放类型\n        Type openType = typeof(Dictionary<,>);\n\n        // 使用Tkey=string、Tvalue=int封闭泛型类型\n        // 限定了泛型类型, 就是封闭类型\n        Type closedType = openType.MakeGenericType(typeof(string), typeof(int));\n\n        // 构造封闭类型的实例\n        Object o = Activator.CreateInstance(closedType);\n        // 证实能正常工作\n        Console.WriteLine(o.GetType());\n        // 输出:ConsoleApp2.Dictionary`2[System.String,System.Int32]\n    }\n}\n```\n\n# 设计支持加载项的应用程序\n\n构建可扩展应用程序时, 接口是中心. 可用基类代替接口, 但接口通常是首选的. 因为它允许加载项开发人员选择他们自己的基类.  例如要写一个应用程序来无缝加载和使用别人的类型. 下面描述了如何设计:\n\n- 创建`宿主SDK`程序集, 它定义一个接口. `接口的方法`作为**宿主应用程序**与**加载项**之间的通信机制使用.  接口方法定义参数和返回类型时, 请尝试使用`MSCorLib.dll`中定义的其他接口或类型. 要传递并返回自己的数据类型, 也在`宿主SDK`程序集中定义.  一定搞定接口定义, 就可为这个程序集赋予**强名称**. 然后打包并部署到用户那里. 发布以后要避免对该程序集中的类型做出任何重大的改变. 例如: 不要以任何方式更改接口. 如果定义了任何数据类型, 在类型中添加新成员时完全允许的.\n\n> 之所以能用`MSCorLib.dll`中定义的类型, 是因为CLR总是加载与CLR本身的版本匹配的`MSCorLib.dll`. 此外, 一个CLR实例只会加载一个版本的`MSCorLib.dll`.\n\n- 加载项开发人员会在加载项程序集中定义自己的类型. 这些程序集引用你的`宿主`程序集中的类型. 加载项开发人员可按自己的步调推出程序集的新版本, **而宿主应用程序能正常使用加载项中的类型.**\n\n- 创建单独的\"**宿主应用程序**\" 程序集, 在其中包含你的应用程序的类型, 这个程序集显然要引用`宿主SDK`, 并使用其中定义的类型. 可自由修改`宿主应用程序`程序集的代码, 由于加载项开发人员不会引用这个`宿主应用程序`程序集, 所以随时都能退出`宿主应用程序`程序集的新版本. 不会对加载项开发人员产生任何影响.\n\n跨程序集使用类型时, 需要关注程序集的版本控制问题. 如果要修改,一定要修改程序集的版本号.\n\n下面演示一个例子:\n\n```csharp\nusing System;\n// HostSDK.dll程序集的代码\nnamespace Wintellect.HostSDK\n{\n    public interface IAddIn\n    {\n        String DoSomething(Int32 x);\n    }\n}\n```\n\n```csharp\nusing System;\nusing Wintellect.HostSDK;\n\n// AddInTypes.dll程序集的代码 其中定义了两个公共类型\n// 实现了HostSDK.dll的接口\npublic class AddIn_A : IAddIn\n{\n    public AddIn_A()\n    {\n    }\n\n    public String DoSomething(Int32 x)\n    {\n        return \"AddIn_A: \" + x.ToString();\n    }\n}\n\npublic class AddIn_B : IAddIn\n{\n    public AddIn_B()\n    {\n    }\n\n    public String DoSomething(Int32 x)\n    {\n        return \"AddIn_B: \" + (x * 2).ToString();\n    }\n}\n```\n\n然后试一个简单的Host.exe程序集(控制台应用程序的代码). 生成该程序集必须引用HostSDK.dll.\n\n```csharp\nusing System;\nusing System.Linq;\nusing System.IO;\nusing System.Reflection;\nusing System.Collections.Generic;\nusing Wintellect.HostSDK;\n\npublic sealed class Program\n{\n    public static void Main()\n    {\n        // 查找Host.exe所在的目录\n        // F:\\迅雷下载\\新建文件夹\\bin\\Debug\n        String AddInDir = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);\n\n        // 假定加载项程序集和Host.exe文件在同一目录\n        // 返回满足指定条件的文件名的可枚举集合。\n        // F:\\迅雷下载\\新建文件夹\\bin\\Debug\\Ch23-2-AddIn_SDKAssembly.dll\n        var AddInAssemblies = Directory.EnumerateFiles(AddInDir, \"*.dll\");\n\n        // Ch23-2-AddIn_SDKAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\n        var test = Assembly.LoadFrom(@\"F:\\迅雷下载\\新建文件夹\\bin\\Debug\\Ch23-2-AddIn_SDKAssembly.dll\");\n        // Console.WriteLine(test.GetName());\n\n        var test1 = Assembly.Load(\"Ch23-2-AddIn_SDKAssembly, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\");\n        // Console.WriteLine(test1.GetName());\n\n\n        // 创建可由宿主使用的所有加载Type的一个集合\n        var AddInTypes =\n            from file in AddInAssemblies\n            let assembly = Assembly.LoadFrom(file) // 这里源代码错了, 书中代码写的是Assembly.Load, 通过给定程序集的长格式名称加载程序集。\n            from t in assembly.ExportedTypes // 公开导出的类型\n            // 如果类型实现了IAddIn接口, 该类型就可由宿主使用\n            where t.IsClass && typeof(IAddIn).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())\n            select t;\n        // 初始化完成: 宿主已发现所有可用的加载项\n\n        // 下面示范宿主如何构造加载项对象并使用\n        foreach (Type t in AddInTypes)\n        {\n            IAddIn ai = (IAddIn) Activator.CreateInstance(t);\n            Console.WriteLine(ai.DoSomething(5));\n        }\n    }\n}\n// AddIn_A: 5\n// AddIn_B: 10\n```\n\n# 使用反射发现类型的成员\n\n本章剩余部分将从其他角度探讨反射，目的是发现并调用类型的成员。\n\n\n## 发现类型的成员\n\n字段、构造器、方法、属性、事件和嵌套类型都可以定义成类型的成员。FCL包含抽象基类`System.Reflection.MemberInfo`，封装了所有类型成员都通用的一组属性。`MemberInfo`有许多派生类, 每个都封装了与特定类型成员相关的更多属性.\n\n![](23程序集加载和反射/QQ截图20190917142359.png)\n\n演示如何查询类型的成员并显示成员的信息. **代码处理的是由调用AppDomain加载的所有程序集定义的所有公共类型.** 对每个类型都调用`DeclaredMembers`属性以返回由`MemberInfo`派生对象构成的集合; 每个对象都引用类型中定义的一个成员. 然后显示每个成员的种类(字段,构造器,方法和属性等)及其字符串值(调用ToString来获取).\n\n```csharp\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        //遍历这个appDomain中加载的所有程序集\n        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();\n        foreach (var a in assemblies)\n        {\n            // 缩进0*3个空格, a代表单个程序集\n            // Assembly:mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n            Show(0, \"Assembly:{0}\", a);\n            //查找程序集中的类型\n            // a.ExportedTypes 是所有类型的集合\n            foreach (var t in a.ExportedTypes)\n            {\n                //    Assembly:Microsoft.Win32.Registry\n                // 缩进1*3个空格 t代表单个导出类型\n                Show(1, \"Assembly:{0}\", t);\n                //发现类型的成员\n                // t.GetTypeInfo().DeclaredMembers 类型的所有成员\n                foreach (var mi in t.GetTypeInfo().DeclaredMembers)\n                {\n                    string typeName                     = string.Empty;\n                    if (mi is Type) typeName            = \"(Nested) Type\";\n                    if (mi is FieldInfo) typeName       = \"FieldInfo\";\n                    if (mi is MethodInfo) typeName      = \"MethodInfo\";\n                    if (mi is ConstructorInfo) typeName = \"ConstructorInfo\";\n                    if (mi is PropertyInfo) typeName    = \"PropertyInfo\";\n                    if (mi is EventInfo) typeName       = \"EventInfo\";\n\n                    Show(2, \"{0}:{1}\", typeName, mi);\n                }\n            }\n        }\n    }\n\n    private static void Show(int indent, string format, params object[] args)\n    {\n        Console.WriteLine(new string(' ', 3 * indent) + format, args);\n    }\n}\n```\n\n![](23程序集加载和反射/QQ截图20190917143948.png)\n\n在查询`DeclaredMembers属性`所返回的集合中，每个元素都是对层次结构中的一个**具体类型的引用**。虽然`TypeInfo`的`DeclaredMembers属性`能返回类型的所有成员，但还可利用`TypeInfo`提供的一些方法返回具有指定字符串名称的成员类型。例如，利用`TypeInfo`的`GetDeclaredNestedType`、`GetDeclaredField`等. 而利用`GetDeclaredMethods`方法能返回由`MethodInfo`对象构成的集合.\n\n![](23程序集加载和反射/QQ截图20190917150817.png)\n\n总结了用于遍历反射对象模型的各种类型:\n- 基于`AppDoamin`,可发现其中加载的所有程序集, 可发现它的所有模块.\n- 基于`程序集或模块`, 可发现它定义的所有类型.\n- 基于`类型`,可以发现它的嵌套类型,字段,构造器,方法,属性和事件.\n\n命名空间不是这个层次结构的一部分.因为它们只是从语法角度将相关类型聚集到一起。CLR不知道什么是命名空间。要列出程序集中定义的所有命名空间，需枚举程序集中的所有类型，并查看其`Namespace属性`。\n\n![](23程序集加载和反射/QQ截图20190917151127.png)\n\n- 基于一个类型，还可发现它实现的接口。\n- 基于构造器、方法、属性访问器方法或者事件的添加、删除方法，可调用`GetParameters方法`来获取由`ParameterInfo`对象构成的数组，从而了解成员的参数的类型。\n- 还可查询只读属性`ReturnParameter`获得一个`ParameterInfo`对象，他详细描述了成员的返回类型。\n- 对于泛型类型或方法，可调用`GetgenericArguments方法`来获得类型参数的集合。\n\n最后，针对上述任何一项，都可查询`CustomAttributes属性`来获得应用于它们的自定义定制特性的集合。\n\n## 调用类型的成员\n\n发现类型定义的成员后可调用它们. \"调用\"(invoke)的确切含义取决于要调用的成员的种类.\n\n![](23程序集加载和反射/QQ截图20190917151843.png)\n\n\n`PropertyInfo`类代表与属性有关的元数据信息；也就是说，PropertyInfo提供了`CanRead`、`CanWrite`和`PropertyType只读属性`，他们指出属性是否可读和可写，以及属性的数据类型是什么。PropertyInfo还提供了`只读GetMethod`和`SetMethod属性`，他们返回待办属性get和set访问器方法的`MethodInfo对象`。`PropertyInfo`的GetValue和SetValue方法只是为了提供方便：在内部，，他们会自己调用合适的MethodInfo对象。为了支持有参属性（c#的索引器），GetValue和SetValue方法提供了一个object[]类型的index参数。\n\n`EventInfo`类型代表与事件有关的元数据信息。`EventInfo`类型提供了`只读EventHandlerType属性`，返回事件的基础`委托的Type`。EventInfo类型还提供了`只读AddMethod`和`RemoveMethod属性`，返回为事件增删委托的方法的MethodInfo对象。增删委托可调用这些MethodInfo对象，也可调用EventInfo类型提供的更好用的`AddEventHandler`和`RemoveEventHandler`方法。\n\n### 以下实例应用程序演示了用反射来访问类型成员的各种方式。\n\nSomeType类包含多种成员：一个私有字段（`m_someField`）；一个公共构造器（`SomeType`），它获取一个传引用的`Int32`实参；一个公共方法（`ToString`）；一个公共属性（`SomeProp`）；以及一个公共事件（`SomeEvent`）。定义好SomeType类型后，我提供了三个不同的方法，他们利用反射来访问SomeType的成员。三个方法用不同的方式做相同的事情。\n\n1. `BindToMemberThenInvokeTheMember方法`,演示了如何绑定到成员并调用它。\n2. `BindToMemberCreateDelegateToMemberThenInvokeTheMember方法`演示了如何绑定到一个对象或成员，然后创建一个委托来引用该对象或成员。通过委托来调用的速度很快。如果需要在相同的对象上多次调用相同的成员，**这个技术的性能比上一个好**。\n3. `UseDynamicToBindAndInvokeTheMember方法`演示了如何利用C#的`dynamic`基元类型简化成员访问语法。此外，在相同类型的不同对象上调用相同成员时，这个技术还能提供不错的性能，因为针对每个类型，绑定都只会发生一次。而且可以缓存起来，以后多次调用的速度会非常快。用这个计数也可以调用不同类型的对象的成员。\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing Microsoft.CSharp.RuntimeBinder;\n\ninternal sealed class SomeType\n{\n    private int m_someField;\n\n    public SomeType(int x)\n    {\n        x *= 2;\n    }\n\n    public override string ToString()\n    {\n        return m_someField.ToString();\n    }\n\n    public int SomeProp\n    {\n        get { return m_someField; }\n        set\n        {\n            if (value < 1)\n            {\n                throw new ArgumentOutOfRangeException(\"value\");\n            }\n\n            m_someField = value;\n        }\n    }\n\n    public event EventHandler SomeEvent;\n\n    private void NoCompilerWarnings()\n    {\n        SomeEvent.ToString();\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Type t = typeof(SomeType);\n        BindToMemberThenInvokeTheMember(t);\n        Console.WriteLine();\n\n        BindToMemberCreateDelegateToMemberThenInvokeTheMember(t);\n        Console.WriteLine();\n\n        UseDynamicToBindAndInvokeTheMember(t);\n        Console.WriteLine();\n    }\n\n    private static void BindToMemberThenInvokeTheMember(Type t)\n    {\n        Console.WriteLine(\"BindToMemberThenInvokeTheMember\");\n        //构造实例\n        Type ctorArgument = Type.GetType(\"System.Int32\");\n        //或者typeof(Int32).MakeByRefType();\n\n        // 获取当前类型t定义的构造函数集合\n        IEnumerable<ConstructorInfo> ctors = t.GetTypeInfo().DeclaredConstructors;\n\n        // 找出参数是Int32类型的构造函数\n        ConstructorInfo ctor  = ctors.First(c => c.GetParameters()[0].ParameterType == ctorArgument);\n        //ConstructorInfo ctor = t.GetTypeInfo().DeclaredConstructors\n        //    .First(c => c.GetParameters()[0].ParameterType == ctorArgument);\n\n        //构造器的实参\n        object[] args = new object[] {12};\n\n        Console.WriteLine(\"x before constructor called:\" + args[0]);\n        // 用绑定好的ConstructorInfo去调用Invoke并传入参数args\n        object obj = ctor.Invoke(args);\n        Console.WriteLine(\"Type\" + obj.GetType());\n        Console.WriteLine(\"x after constructor returns\" + args[0]);\n\n        //读写字段\n        FieldInfo fi = obj.GetType().GetTypeInfo().GetDeclaredField(\"m_someField\");\n        fi.SetValue(obj, 33);\n        Console.WriteLine(\"someField:\" + fi.GetValue(obj));\n\n        //调用方法\n        MethodInfo mi = obj.GetType().GetTypeInfo().GetDeclaredMethod(\"ToString\");\n        string     s  = (string) mi.Invoke(obj, null);\n        Console.WriteLine(\"ToString:\" + s);\n\n        //读写属性\n        PropertyInfo pi = obj.GetType().GetTypeInfo().GetDeclaredProperty(\"SomeProp\");\n        try\n        {\n            pi.SetValue(obj, 0, null);\n        }\n        catch (TargetInvocationException e)\n        {\n            if (e.InnerException.GetType() != typeof(ArgumentOutOfRangeException))\n            {\n                throw;\n            }\n\n            Console.WriteLine(\"Property set catch \");\n        }\n\n        pi.SetValue(obj, 2, null);\n        Console.WriteLine(\"SomeProp:\" + pi.GetValue(obj, null));\n\n        //为事件添加和删除委托\n        EventInfo    ei = obj.GetType().GetTypeInfo().GetDeclaredEvent(\"SomeEvent\");\n        EventHandler eh = new EventHandler(EventCallback);\n        ei.AddEventHandler(obj, eh);\n        ei.RemoveEventHandler(obj, eh);\n    }\n\n    //添加到事件的回调方法\n    private static void EventCallback(object sender, EventArgs e)\n    {\n    }\n\n    private static void BindToMemberCreateDelegateToMemberThenInvokeTheMember(Type t)\n    {\n        Console.WriteLine(\"BindToMemberCreateDelegateToMemberThenInvokeTheMember\");\n\n        //构造实例（）不能创建对构造器的委托\n        Object[] args = new object[] {12};\n\n        Console.WriteLine(\"x before constructor called:\" + args[0]);\n        object obj = Activator.CreateInstance(t, args);\n        Console.WriteLine(\"Type\" + obj.GetType());\n        Console.WriteLine(\"x after constructor returns\" + args[0]);\n\n        //注意：不能创建对字段的委托\n\n        //调用方法\n        MethodInfo mi = obj.GetType().GetTypeInfo().GetDeclaredMethod(\"ToString\");\n        var toString = mi.CreateDelegate<Func<string>>(obj);\n        string s  = toString();\n        Console.WriteLine(\"ToString:\" + s);\n\n        //读写属性\n        PropertyInfo pi          = obj.GetType().GetTypeInfo().GetDeclaredProperty(\"SomeProp\");\n        var          setSomeProp = pi.SetMethod.CreateDelegate<Action<int>>(obj);\n        try\n        {\n            setSomeProp(0);\n        }\n        catch (ArgumentOutOfRangeException)\n        {\n            Console.WriteLine(\"Property set catch \");\n        }\n\n        setSomeProp(2);\n        var getSomeProp = pi.GetMethod.CreateDelegate<Func<int>>(obj);\n        Console.WriteLine(\"SomeProp:\" + getSomeProp());\n\n        //为事件添加和删除委托\n        EventInfo ei           = obj.GetType().GetTypeInfo().GetDeclaredEvent(\"SomeEvent\");\n        var       addSomeEvent = ei.AddMethod.CreateDelegate<Action<EventHandler>>(obj);\n        addSomeEvent(EventCallback);\n        var removeSomeEvent = ei.RemoveMethod.CreateDelegate<Action<EventHandler>>(obj);\n        removeSomeEvent(EventCallback);\n    }\n\n    private static void UseDynamicToBindAndInvokeTheMember(Type t)\n    {\n        //构造实例（）不能创建对构造器的委托\n        Object[] args = new object[] {12};\n\n        Console.WriteLine(\"x before constructor called:\" + args[0]);\n        dynamic obj = Activator.CreateInstance(t, args);\n        Console.WriteLine(\"Type\" + obj.GetType());\n        Console.WriteLine(\"x after constructor returns\" + args[0]);\n\n        //读写字段\n\n        try\n        {\n            obj.m_someField = 5;\n            int v = (int) obj.m_someField;\n            Console.WriteLine(\"someField:\" + v);\n        }\n        catch (RuntimeBinderException e)\n        {\n            Console.WriteLine(\"failed to access field: \" + e.Message);\n        }\n\n        //调用方法\n\n        string s = (string) obj.ToString();\n        Console.WriteLine(\"ToString:\" + s);\n\n        //读写属性\n        try\n        {\n            obj.SomeProp = 0;\n        }\n        catch (ArgumentOutOfRangeException e)\n        {\n            Console.WriteLine(\"Property set catch \");\n        }\n\n        obj.SomeProp = 2;\n        int val = (int) obj.SomeProp;\n        Console.WriteLine(\"SomeProp:\" + val);\n\n        //为事件添加和删除委托\n        obj.SomeEvent += new EventHandler(EventCallback);\n        obj.SomeEvent -= new EventHandler(EventCallback);\n    }\n}\n\ninternal static class ReflectionExtensions\n{\n    public static TDelegate CreateDelegate<TDelegate>(this MethodInfo mi, object target = null)\n    {\n        return (TDelegate) (Object) mi.CreateDelegate(typeof(TDelegate), target);\n    }\n}\n\n// BindToMemberThenInvokeTheMember\n// x before constructor called:12\n// TypeConsoleApp2.SomeType\n// x after constructor returns12\n// someField:33\n// ToString:33\n// Property set catch\n// SomeProp:2\n//\n// BindToMemberCreateDelegateToMemberThenInvokeTheMember\n// x before constructor called:12\n// TypeConsoleApp2.SomeType\n// x after constructor returns12\n// ToString:0\n// Property set catch\n// SomeProp:2\n//\n// x before constructor called:12\n// TypeConsoleApp2.SomeType\n// x after constructor returns12\n// failed to access field: “ConsoleApp2.SomeType.m_someField”不可访问，因为它具有一定的保护级别\n// ToString:0\n// Property set catch\n// SomeProp:2\n```\n\n\n第三种方式简化了成员访问语法. 需要熟悉.\n\n## 使用绑定句柄(Handle)减少进程的内存消耗\n\n许多应用程序都绑定了一组类型（Type对象）或类型成员（MemberInfo派生对象），并将这些对象保存在某种形式的集合中。以后，应用程序搜索这个集合，查找特定对象，然后调用(invoke)这个对象。这个机制很好，只是有个小问题：**`Type`和`MemberInfo派生对象`需要大量内存**。所以，如果应用程序容纳了太多这样的对象，但只是偶尔调用，应用程序消耗的内存就会急剧增加，对应用程序的性能产生负面影响。\n\nCLR内部用更精简的方式表示这种信息。CLR之所以为应用程序创建这些对象，只是为了方便开发人员。CLR不需要这些大对象就能运行。如果需要保存/缓存大量`Type和MemberInfo派生对象`，开发人员可以使用`句柄（Runtime Handle）`代替对象以减小工作集内存。FCL定义了三个运行时`句柄类型`（全部都在System命名空间），包括`RuntimeTypeHandle`，`RuntimeFieldHandle`和`RuntimeMethodHandle`。**三个类型都是值类型，都只包含一个字段，也就是一个IntPtr；这使类型的实例显得相当精简**。`IntPtr字段`是一个**句柄**，**引用AppDomain的Loader堆中的一个类型、字段或方法**。因此，现在需要以一种简单、高效的方式将重量级的`Type或MemberInfo对象`转换为轻量级的运行时`句柄实例`，反之亦然。幸好，使用以下转换方法和属性可轻松达到目的。\n\n- `Type对象`转为`RuntimeTypeHandle`, 调用Type的`静态GetTypeHandle方法`并传递那个Type对象引用.\n  - 反向转换, 调用Type的静态方法`GetTypeFromHandle`并传递那个`RuntimeTypeHandle`对象引用.\n- 要将`FieldInfo对象`转为`RuntimeTypeHandle`, 查询`FieldInfo`的实例`只读属性FieldHandle`.\n  - 反向转换, 调用`FieldInfo`的`静态方法GetFieldFromHandle`.\n- 要将`MethodInfo对象`转换为一个`RuntimeMethodHandle`, 查询`MethodInfo`的实例`只读属性MethodHandle`.\n  - 反向转换, 调用`MethodInfo`的`静态方法GetMethodFromHandle`.\n\n以下实例程序获取许多`MethodInfo对象`，把它们转换为`RuntimeMethodHandle实例`，并演示了转换前后的工作集的差异。\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Reflection;\n\npublic class Program\n{\n    private const BindingFlags c_bf = BindingFlags.FlattenHierarchy | BindingFlags.Instance | BindingFlags.Static |\n                                      BindingFlags.Public | BindingFlags.NonPublic;\n\n    static void Main(string[] args)\n    {\n        //显示在任何反射操作之前堆的大小\n        Show(\"做任何事之前\"); // 刚开始占用的22384字节数\n\n        //为MSCorlib.dll中所有方法构建MethodInfo对象缓存\n        List<MethodBase> methodInfos = new List<MethodBase>();\n        foreach (Type t in typeof(object).Assembly.GetExportedTypes())\n        {\n            //跳过任何泛型类型\n            if (t.IsGenericTypeDefinition)\n            {\n                continue;\n            }\n\n            // 获取位标志BindingFlags 的方法\n            MethodBase[] mb = t.GetMethods(c_bf);\n            // Add：添加单个元素\n            // AddRange：添加实现了接口IEnumerable<T>的一个泛型集合的所有元素到指定泛型集合末尾\n            // 可以直接添加somelist.ToArray()\n            methodInfos.AddRange(mb);\n        }\n\n        //显示当绑定所有方法之后，方法的个数和堆的大小\n        Console.WriteLine(\"# 方法个数:={0:N0}\", methodInfos.Count); // 有54333个方法\n        Show(\"在创建了MethodInfo对象的缓存之后\");// 完成缓存后占用了3956516字节数\n\n        //为所有methodINFO对象构建RuntimeMethodHandle缓存\n        List<RuntimeMethodHandle> methodHandles = methodInfos.ConvertAll<RuntimeMethodHandle>(c => c.MethodHandle);\n\n        Show(\"保存MethodInfo和RuntimeMethodHandle缓存\");\n        GC.KeepAlive(methodInfos);//阻止缓存被过早垃圾回收\n\n        methodInfos = null;//现在允许缓存垃圾回收\n        Show(\"在释放methodinfo对象之后\");\n\n\n        methodInfos = methodHandles.ConvertAll<MethodBase>(c => MethodBase.GetMethodFromHandle(c));\n        Show(\"重新创建methodInfo对象后堆的大小\");\n\n\n        GC.KeepAlive(methodHandles); //组织缓存被过早垃圾回收\n        GC.KeepAlive(methodInfos);//组织缓存被过早垃圾回收\n\n        methodHandles = null; //现在允许缓存垃圾回收\n        methodInfos = null;//现在允许缓存垃圾回收\n\n        Show(\"释放methodInfos和runtimemethodhandle之后\");\n\n    }\n\n    private static void Show(string s)\n    {\n        Console.WriteLine(\"Heap size={0,2:N0}-{1}\", GC.GetTotalMemory(true), s);\n    }\n}\n\n// Heap size=22,092-做任何事之前\n// # 方法个数:=54,333\n// Heap size=4,095,280-在创建了MethodInfo对象的缓存之后\n// Heap size=4,312,680-保存MethodInfo和RuntimeMethodHandle缓存\n// Heap size=3,956,288-在释放methodinfo对象之后\n// Heap size=4,173,700-重新创建methodInfo对象后堆的大小\n// Heap size=82,596-释放methodInfos和runtimemethodhandle之后\n\n```\n\n`RuntimeTypeHandle`，`RuntimeFieldHandle`和`RuntimeMethodHandle`。**三个类型都是值类型，都只包含一个字段，也就是一个IntPtr；这使类型的实例显得相当精简**。\n","tags":["CLR读书笔记"]},{"title":"22CLR寄宿和AppDomain","url":"/2019/09/11/22CLR寄宿和AppDomain/","content":"\n# CLR寄宿和AppDomain\n\n`寄宿(Hosting)` 使任何应用程序都能利用CLR的功能.\n\n`AppDomain`允许第三方的,不受信任的代码在现有的进程中运行,而CLR保证数据结构,代码和安全上下文不被滥用和破坏.\n\n# CLR寄宿\n\n`.Net Framework`在Windows平台的顶部运行, 这意味着.net必须用Windows能理解的技术来构建。首先，所有托管模块和程序集文件都必须使用`windows PE文件格式`，而且要么是windows `EXE文件`，要么是`Dll文件`。\n\n开发CLR时, Microsoft实际是把它写成一个包含一个DLL中的COM服务器. 安装`.Net Framework`时, 代表CLR的COM服务器一样在注册表中注册. 任何Windows应用程序都能寄宿(容纳)CLR。\n\n![](22CLR寄宿和AppDomain/QQ截图20190913103810.png)\n\n> CLRCreateInstance函数在MSCorEE.dll文件中实现，该文件一般在system32目录中。这个dll被人们亲切地称为垫片（shim），它的工作是决定创建哪个版本的CLR：垫片DLL本身不包含CLR com服务器。\n\n`CLRCreateInstance`函数可返回一个`ICLRMetaHost接口`。宿主应用程序可调用这个接口的`GetRuntime函数`，指定数组要创建的`CLR`的版本。然后，垫片将所需版本的CLR加载到宿主的进程中。\n\n# AppDomain\n\nCLR COM服务器服务器初始化时会创建一个AppDomain。AppDomain是一组程序集的逻辑容器. CLR初始化时创建的第一个AppDomain称为`默认AppDomain`，这个默认的AppDomain只有在windows进程终止时才会被注销。\n\n除了默认AppDomain，正在使用非托管com接口方法或托管类型方法的宿主还可要求CLR创建额外的AppDomain。AppDomain是为了提供隔离而设计的。下面总结了AppDomain的具体功能。\n\n1. 一个AppDomain的代码不能直接访问另一个AppDomain的代码创建的对象\n\n一个AppDomain中的代码创建了一个对象后，该对象便被该AppDomain拥有。换言之，它的生存期不能超过创建它的代码所在的AppDomain。**一个AppDomain中的代码要访问另一个AppDomain中的对象，只能使用按`引用封送(marshal-by-reference)`或者`按值封送(marshal-by-value)`的语义**。这就强制建立了清晰的分隔和边界，因为一个AppDomain中的代码**不能**直接引用另一个AppDomain中的代码创建的对象。这种隔离使得AppDomain能很容易地从进程中卸载，不会影响其他AppDomain正在运行的代码。\n\n2. AppDomain可以卸载\n\n**CLR不支持从AppDomain中卸载特定的程序集。但可以告诉clr卸载一个AppDomain，从而卸载该AppDomain当前包含的所有程序集。**\n\n3. AppDomain可以单独保护\n\nAppDomain创建后会应用一个权限集，它决定了向这个AppDomain中运行的程序集授予的最大权限。正式由于存在这些权限，所以当宿主加载一些代码后，可以保证这些代码不会破坏（或读取）宿主本身使用的一些重要数据结构。\n\n4. AppDomain可以单独配置\n\nAppDomain创建后会管理一组配置设置，这些设置主要影响clr在AppDomain中加载程序集的方式。涉及搜索路径、版本绑定重定向、劵影复制以及加载器优化。\n\n> 在windows中创建进程的开销很大。win32 createProcess函数的速度很慢，而且windows需要大量内存来虚拟化进程的地址空间。但是，如果应用程序完全由托管代码构成，同时这些代码没有调用非托管代码，那么在一个windows进程中运行多个托管应用程序是没有问题的。\n\n图22-1演示了一个**windows进程**，其中运行着一个**CLR COM服务器**。该CLR当前管理着两个AppDomain（虽然在一个windows进程中可以运行的AppDomain数量没有硬性限制）。每个AppDomain都有自己的`Loader堆`，每个`Loader堆`都记录了自AppDomain创建以来访问过哪些类型。`Loader堆`中的每个类型对象都有一个方法表，方法表中的每个记录项都指向JIT编译的本机代码（前提是方法至少执行过一次）。\n\n![](22CLR寄宿和AppDomain/QQ截图20190913110455.png)\n\n除此之外，每个AppDomain都加载了一些程序集。AppDomain #1（默认AppDomain）有三个程序集：myApp.exe，TypeLib.dll和System.dll。AppDomain#2有两个程序集Wintellect.dll和System.dll。\n\n两个AppDomain都加载了System.dll程序集。**如果这两个AppDomain都使用来自System.dll的一个类型，那么两个AppDomain的Loader堆会为相同的类型分别分配一个类型对象：类型对象的内存不会由两个AppDomain共享**。另外，一个AppDomain中的代码调用一个类型定义的方法时，方法IL代码会进行JIT编译，生成的本机代码单独与每个AppDomain关联，而**不是由调用它的所有AppDomain共享**。\n\n\n不共享类型对象的内存或本机代码显得有些浪费。但AppDomain的设计宗旨就是提供**隔离**：**CLR要求在卸载某个AppDomain并释放其所有资源时不会影响到其他任何AppDomain**。复制CLR的数据结构才能保证这一点。另外，还保证多个AppDomain使用的类型在每个AppDomain中都有一组静态字段。\n\n有的程序集本来就要有多个AppDomain使用。最典型的例子就是`MSCorLib.dll`。该程序集包含了`System.object`,`System.int32`以及其他所有.net密不可分的类型。CLR初始化时，该程序集会自动加载，而且所有AppDomain都**共享该程序集中的类型**。为了减少资源消耗，**MSCorLib程序集以一种AppDomain中立的方式加载**。也就是说，针对以**AppDomain中立方式加载的程序集**，CLR会为他们维护一个**特殊**的`Loader堆`。**该Loader堆中的所有类型对象，以及为这些类型定义的方法JIT编译生成的所有本机代码，都会由进程中所有AppDomain共享**。遗憾的是，共享这些资源所获得的收益并不是没有代价，这个代价就是，以AppDomain中立方式加载的所有程序集**永远不能卸载**。要回收他们占用的资源，唯一的办法就是**终止Windows进程**，让Windows去回收资源。\n\n## 跨越AppDomain边界访问对象\n\n一个AppDomain中的代码可以和另一个AppDomain中的类型和对象通信. 但只能通过良好定义的机制进行, 以下例子演示三种类型构造时的不同行为,以及卸载时的不同行为:\n- `引用封送(marshal-by-reference)`\n- `按值封送(marshal-by-value)`\n- 完全不能封送的类型\n\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.Remoting;\nusing System.Runtime.Serialization;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\n\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Marshalling();\n    }\n\n    private static void Marshalling()\n    {\n        //获取AppDomain引用（“调用线程”当前正在该AppDomain中执行）\n        AppDomain adCallingThreadDomain = Thread.GetDomain();\n\n        //每个AppDomain都分配了友好字符串名称（以便调试）\n        //获取这个AppDomain的友好名称并显示它\n        String CallingDomainName = adCallingThreadDomain.FriendlyName; // ClassLibrary1.exe\\r\\n无上下文策略\\r\\n\n        Console.WriteLine(\"默认AppDomain友好的名称={0}\", adCallingThreadDomain);\n\n        //获取并显示我们的AppDomain中包含了“Main”方法的程序集\n        String exeAssembly = Assembly.GetEntryAssembly().FullName;\n        Console.WriteLine(\"包含“Main”方法的程序集={0}\",\n            exeAssembly); // ClassLibrary1, Version=1.0.0.0, Culture=neutral, PublicKeyToken = null\n\n\n        //定义局部变量来引用一个AppDomain\n        AppDomain ad2 = null;\n\n        //***********************************************\n        //DEMO 1：使用“按引用封送”进行跨AppDomain通信 ***\n        //***********************************************\n\n        //Environment.NewLine 获取为该环境定义的换行字符串。\n        Console.WriteLine(\"{0} Demo1 按引用封送\", Environment.NewLine);\n\n        //新建一个AppDomain（从当前AppDomain继承安全性和配置）\n        ad2 = AppDomain.CreateDomain(\"AD #2\", null, null);\n\n        MarshalByRefType mbrt = null;\n        //将我们的程序集加载到新AppDomain,构造一个对象，把它封送回我们的AppDomain（实际得到对一个代理的引用）\n        mbrt = (MarshalByRefType) ad2.CreateInstanceAndUnwrap(exeAssembly, \"MarshalByRefType\");\n\n        // CLR在类型上撒谎了\n        Console.WriteLine(\"Type={0}\", mbrt.GetType()); //Type=MarshalByRefType\n\n        //证明得到的是对一个代理对象的引用\n        Console.WriteLine(\"Is proxy={0}\", RemotingServices.IsTransparentProxy(mbrt)); // Is proxy=True\n\n        //看起来像是在MarshalByRefType上调用了一个方法，实则不然。\n        //我们是在代理类型上调用了一个方法，代理是线程切换到拥有对象的那个\n        //AppDomain,并在真实的对象上调用这个方法\n        mbrt.SomeMethod();\n\n        //卸载新的AppDomain\n        AppDomain.Unload(ad2);\n\n        //此时，mbrt引用了一个有效的代理对象；代理对象引用一个无效的AppDomain\n        // 会抛出异常,AppDomain被卸载了\n        try\n        {\n            mbrt.SomeMethod();\n            Console.WriteLine(\"调用成功\");\n        }\n        catch (AppDomainUnloadedException)\n        {\n            Console.WriteLine(\"调用失败，AppDomain被卸载了\");\n        }\n\n        //**********************************************\n        // DEMO 2：使用“按值封送”进行跨AppDomain通信 ***\n        //**********************************************\n\n        Console.WriteLine(\"{0} Demo2 按值封送\", Environment.NewLine);\n\n\n        ad2  = AppDomain.CreateDomain(\"AD #2\", null, null);\n        mbrt = (MarshalByRefType) ad2.CreateInstanceAndUnwrap(exeAssembly, \"MarshalByRefType\");\n\n        //对象的方法返回所返回对象的副本\n        //对象按值（而非按引用）封送\n        MarshalByValType mbvt = mbrt.MethodWithReturn();\n\n        //证明得到的是对一个代理对象的引用\n        Console.WriteLine(\"Is proxy={0}\", RemotingServices.IsTransparentProxy(mbvt)); // Is proxy=False\n\n        //看起来在MarshalByValType上调用一个方法，实际也是如此\n        Console.WriteLine(\"Return object created \" + mbvt.ToString()); // Return object created 2019年9月13日\n\n        //卸载新的AppDomain\n        AppDomain.Unload(ad2);\n        // 此时，mbrt引用了一个有效的x代理对象；代理对象引用一个无效的AppDomain\n        // 不会抛出异常\n        try\n        {\n            //卸载AppDomain之后调用mbvt方法不会抛出异常\n            Console.WriteLine(\"Return object created \" + mbvt.ToString()); // Return object created 2019年9月13日\n            Console.WriteLine(\"调用成功\");\n        }\n        catch (AppDomainUnloadedException)\n        {\n            Console.WriteLine(\"调用失败，AppDomain被卸载了\");\n        }\n\n        //**********************************************\n        //DEMO 3：使用不可封送的类型进行跨AppDomain通信*\n        //**********************************************\n        ad2  = AppDomain.CreateDomain(\"AD #2\", null, null);\n        mbrt = (MarshalByRefType) ad2.CreateInstanceAndUnwrap(exeAssembly, \"MarshalByRefType\");\n\n        try\n        {\n            // 对象的方法返回一个不可封送的对象,抛出异常\n            NonMarshalableType nmt = mbrt.MethodArgAndReturn(CallingDomainName); //抛出异常:未标记为可序列化\n        }\n        catch (SerializationException)\n        {\n            Console.WriteLine(\"抛出异常:未标记为可序列化\");\n        }\n\n        Console.ReadKey();\n    }\n}\n\n//该类型的实例可跨越AppDomain的边界“按引用封送”\npublic sealed class MarshalByRefType : MarshalByRefObject\n{\n    public MarshalByRefType()\n    {\n        Console.WriteLine(\"{0} 构造器运行在 {1} 中\", GetType(), Thread.GetDomain().FriendlyName);\n    }\n\n    public void SomeMethod()\n    {\n        Console.WriteLine(\"Executing in \" + Thread.GetDomain().FriendlyName);\n    }\n\n    public MarshalByValType MethodWithReturn()\n    {\n        Console.WriteLine(\"Execute in \" + Thread.GetDomain().FriendlyName);\n        MarshalByValType t = new MarshalByValType();\n        return t;\n    }\n\n    public NonMarshalableType MethodArgAndReturn(string callingDomainName)\n    {\n        //注意：callingDomainName是可序列化的\n        Console.WriteLine(\"Calling from '{0}' to '{1}'.\", callingDomainName, Thread.GetDomain().FriendlyName);\n        NonMarshalableType t = new NonMarshalableType();\n        return t;\n    }\n}\n\n//该类的实例可跨越AppDomain的边界“按值封送”\n[Serializable]\npublic sealed class MarshalByValType : Object\n{\n    private DateTime m_creationTime = DateTime.Now; //注意：DateTime是可序列化的\n\n    public MarshalByValType()\n    {\n        Console.WriteLine(\"{0} ctor running in {1}, Created no {2:D}\", GetType(), Thread.GetDomain().FriendlyName,\n            m_creationTime);\n    }\n\n    public override string ToString()\n    {\n        return m_creationTime.ToLongDateString();\n    }\n}\n\n//该类的实例不能跨AppDomain边界进行封送\n//[Serializable]\npublic sealed class NonMarshalableType : Object\n{\n    public NonMarshalableType()\n    {\n        Console.WriteLine(\"Execute in \" + Thread.GetDomain().FriendlyName);\n    }\n}\n```\n\n1. Marshalling方法首先获得一个AppDomain对象引用, 当前\"调用线程\"当前正在该AppDomain中执行.\n\n在Windows中, **线程** 总是在一个**进程的上下文中**创建, 而且线程的整个生存期都在该进程的生存期内. 但**线程和AppDomain没有一对一关系. AppDomain是一项CLR功能.** Windows对AppDomain无所知.\n\n由于一个Windows进程可包含多个AppDomain,所以线程能执行一个AppDomain中的代码,再执行另一个AppDomain. **从CLR的角度看, 线程一次只能执行一个AppDomain中的代码.**\n\n2. 线程可以调用`System.Threading.Thread`的静态方法`GetDomain`向CLR询问它正在哪个AppDomain中执行. 线程还可以查询AppDomain的`静态只读属性CurrentDomain`获得相同的信息.\n\n3. AppDomain创建后可以赋予一个`友好名称`, 是用于标识AppDomain的一个`String`. 作用是用来方便的调试. **CLR在任何代码执行前创建默认的AppDomain, 所以使用可执行文件的文件名作为默认的AppDomain名称**. `Marshalling`方法使用AppDomain的只读`FriendlyName`属性来查询默认AppDomain的友好名称.\n\n4. `Marshalling`方法查询默认AppDomain中加载的程序集的强命名标识, 这个程序集定义了入口方法Main(其中调用了Marshalling方法),类型`MarshalByRefType`,`MarshalByValType`,`NonMarshalableType`.\n\n\n### 演示Demo 1 : 使用\"按引用封送\"进行跨AppDomain通信\n\n`AppDomain.CreateDomain`三个参数:\n- 友好名称`AD #2`\n- 用于计算AppDomain`权限集`的证据, 传null代表新的AppDomain从创建它的AppDomain继承权限集.\n- 代表AppDomain使用的配置参数,  传null代表新的AppDomain从创建它的AppDomain继承配置设置.\n\n`CreateDomain`方法内部会在进程中新建一个AppDomain, 有自己的Loader堆,这个堆目前是空的.\n\n现在要在新的AppDomain中创建类型的实例. 首先要将程序集加载到新的AppDomain中,然后构造定义类型的实例. 这就是`CreateInstanceAndUnwrap`方法所做的事情: 传递了两个参数\n- `String` : 标识了想在新AppDomain中加载的程序集\n- `String` : 要构建实例的类型名称`MarshalByRefType`\n\n`CreateInstanceAndUnwrap`方法会在内部从当前AppDomain切换到新AppDomain, 线程将指定程序集加载到新AppDomain中, 扫描程序集的类型定义元数据表, 找到类型后,线程调用`MarshalByRefType`的无参构造器, 现在线程又切换回默认的AppDomain. 使`CreateInstanceAndUnwrap`能返回对新`MarshalByRefType`对象的引用.\n\n> CreateInstanceAndUnwrap 有重载方法可以传递实参\n\n**但是, CLR不允许一个AppDomain中的`变量`引用另一个AppDomain中创建的对象.** 如果`CreateInstanceAndUnwrap`方法照顾会返回对象引用, 隔离性就会被打破, 隔离是AppDomain的全部目的! 因此`CreateInstanceAndUnwrap`方法在返回对象引用前要执行一些额外的逻辑.\n\n`MarshalByRefType`类型从一个很特别的基类`MarshalByRefObject`派生, 当`CreateInstanceAndUnwrap`发现它封送的对象的类型继承自`MarshalByRefObject`时, CLR就会跨AppDomain边界`按引用封送对象`.\n\n将一个引用对象从`源AppDomain`封送到`目标AppDomain`的具体含义:\n- CLR会在目标AppDomain的Loader堆中定义一个`代理类型`, 是用原始类型的元数据定义的\n  - **有完全的一样的实例成员(属性,事件,方法)**\n  - **但是唯独没有实例字段**, 因为代理类型会定义自己的实例字段, 和原始字段不一致.\n  - 这些字段只是指出哪个AppDomain拥有真实的对象, 以及如何找到真实的对象\n  - 在内部,`代理对象`用一个GCHandle实例引用真实的对象\n\n在目标AppDomain中定义好这个类型之后,`CreateInstanceAndUnwrap`方法就会创建代理类型的实例,初始化它的字段来标识源AppDomain和真实的对象, 然后将这个代理对象的引用返回给`源AppDomain`.\n\n`MarshalByRefType mbrt变量`被设为引用这个代理. 注意! 实际上返回的对象不是`MarshalByRefType`类型的实例,当前情况下CLR之所以允许转型, 是因为新类型具有和原始类型一样的实例成员. 代理对象调用`GetType()`,它会向你撒谎说自己是一个`MarshalByRefType`对象.\n\n`RemotingServices.IsTransparentProxy(mbrt)` 用这个证明mbrt是代理, 也就是`CreateInstanceAndUnwrap`方法返回的是代理.\n\n`mbrt.SomeMethod();` 通过代理, 调用由**代理实现的SomeMethod方法**, 代理的实现利用代理对象中的信息字段,**将调用线程从默认AppDomain切换至对应AppDomain**. 线程接着使用代理对象的`GCHandle`字段查找`新AppDomain`中的**真实对象**,  并用真实对象调用**真实的SomeMethod方法**.\n\n两个办法可以证明调用线程已经从默认的AppDomain切换至新AppDomain.\n\n1. `Thread.GetDomain().FriendlyName` 将返回`AD #2`\n2. 通过逐语句调试代码,并打开调用堆栈窗口, [外部代码]行会标注一个线程什么位置跨域AppDomain边界.(VS中)\n\n在Rider中是:\n\n![](22CLR寄宿和AppDomain/QQ截图20190914113026.png)\n\n```csharp\nMarshalByRefType.SomeMethod() in , ClassLibrary1.exe\n[Application Domain Transition]\nProgram.Marshalling() in , ClassLibrary1.exe\nProgram.Main() in , ClassLibrary1.exe\n```\n\n`真实的SomeMethod方法`返回后, 会返回至`代理的SomeMethod方法`, 后者会将线程切换至默认AppDomain,线程继续执行默认AppDomain中的代码.\n\n`AppDomain.Unload(ad2);`这会指定卸载指定的AppDomain包括加载到其中的所有程序集. 并强行执行一次垃圾回收, 来释放由卸载的AppDomain中的代码创建的所有对象. mbrt变量引用的仍然的是有效的代理对象, 但是代理对象已不再引用一个有效的AppDomain(已经卸载了).\n\n当默认AppDomain试图使用代理对象调用SomeMethod方法时, 调用的是该方法在代理中的实现, 代理发现包含真实对象的AppDomain已经卸载, 就抛出`AppDomainUnloadedException`异常,告诉操作者无法完成.\n\n> 一个AppDomain的方法执行完毕,才能执行另一个AppDomain的方法,不能多个AppDomain的代码并发执行.\n\n**使用\"按引用封送\"的语义进行跨AppDomain边界的对象访问,会产生一些性能上的开销. 一般尽量少用这个功能.**\n\n从`MarshalByRefObject`派生的类型可以定义实例字段, 但是这些字段不会成为代理类型的一部分,也不会包含在代理对象中.  这实例字段的读写会用到反射,性能很差, 访问默认AppDomain中的性能也好不到那里去.\n\n![](22CLR寄宿和AppDomain/QQ截图20190914140533.png)\n\n派生自`MarshalByRefObject`的类型应该避免定义任何静态成员, 因为静态成员总是在调用AppDomain的上下文中访问. 静态成员的一个AppDomain中执行, 实例成员却在另一个AppDomain中执行. 这样的编程模型太丑了.\n\n#### 租约管理器\n\n![](22CLR寄宿和AppDomain/QQ截图20190914141009.png)\n\n### 演示Demo 2 : 使用\"按值封送\"进行跨AppDomain通信\n\n前面一样, 不一样的是, 代理还需要调用 `MarshalByValType mbvt = mbrt.MethodWithReturn();`, 将在**新的AppDomain**中执行以创建`MarshalByValType`类型的实例, 并将一个对象引用返回给**默认的AppDomain**.\n\n`MarshalByValType`不从`MarshalByRefObject`派生, 所以CLR不能定义一个代理类型并创建代理类型的实例. 对象不能按引用跨AppDomain边界进行封送.\n\n由于`MarshalByValType`标记了自定义特性[Serializable], 所以`MethodWithReturn`方法能按值封送对象. 下面描述将一个对象按值从源AppDomain封送到目标AppDomain的含义.\n\n源AppDomain想向目标AppDomain发送或返回一个对象引用时, CLR将对象的实例字段序列化成一个字节数组. 字节数组从源AppDomain复制到目标AppDomain. 然后CLR在目标AppDomain中反序列化字节数组, 这里会强制CLR将定义了此类型的程序集加载到目标AppDomain中. CLR创建类型时,并利用字节数组中的值初始化对象的字段,使之与源对象中的值相同.  **也就是说 CLR在目标AppDomain中精确复制了源对象.** 然后`MethodWithReturn`返回对这个副本的引用.\n\n`RemotingServices.IsTransparentProxy(mbvt)`返回是false, 说明对象是一个真实的对象,不是代理. 由于mbvt引用真实的对象, 在卸载新AppDomain之后, `mbvt.ToString()`会调用这个方法的真实实现, 线程不会在AppDomain之间切换.\n\n### 演示Demo 3 : 使用不可封送的进行跨AppDomain通信\n\n与之前大致相似, 不同的是 `NonMarshalableType nmt = mbrt.MethodArgAndReturn(CallingDomainName);`, 由于`NonMarshalableType`不是`MarshalByRefObject`派生的, 也没有用`[Serializable]`定制特性进行标记, 所以不允许`MethodArgAndReturn`按引用或按值封送对象. 此对象完全不能跨越AppDomain边界进行封送.\n\n此例子中传递的参数String不是从`MarshalByRefObject`派生,但是String被标记为`[Serializable]`,所以CLR能按值封送它.\n\n对于String对象,CLR会采取特殊的优化措施. 跨越AppDomain边界封送一个String对象时, **CLR只是跨越边界传递对String对的引用, 不会真的生成String对象的副本,** 之所以提供这个优化,是因为String对象是不可变的.\n\n\n# 卸载AppDomain\n\nAppDomain很强大的一个地方就是可以卸载它. 卸载AppDomain会导致CLR卸载AppDomain中的所有程序集. 还会释放AppDomain的Loader堆. **卸载AppDomain的办法是调用AppDomain的静态Unload方法**.\n\n1. CLR挂起进程中执行过托管代码的所有线程\n2. CLR检查所有线程栈, 查看哪些线程正在执行要卸载的AppDomain中的代码,或者哪些线程会在某个时候返回至要卸载的AppDomain. 任何栈上有要卸载的AppDomain, CLR都会强迫对应线程抛出一个 `ThreadAbortException`(同时恢复线程的执行), 这导致线程展开(unwind), 并执行遇到的所有finally块以清理资源. 如果没有代码捕捉`ThreadAbortException`,会成为未处理异常, 特殊的是CLR会吞噬这个异常, 线程终止,但进程可以继续. 对于其他所有未经处理的异常CLR都会终止进程.\n\n![](22CLR寄宿和AppDomain/QQ截图20190915102254.png)\n\n临界执行区  : 指线程终止或未处理异常的影响可能不限于当前任务的区域.\n非临界执行区: 终止或失败只对出错的任务有影响.\n\n3. 当第二步发现的而所有线程都离开AppDomain后, CLR遍历堆, 为引用了**由已卸载的AppDomain创建的对象**的**每个代理对象都设置一个标志(flag)** .这些对象现在知道它们引用的真实对象已经不在了, 现在, 任何代码在无效的代理对象上调用方法都会抛出一个AppDomainUnloadedException异常.\n4. CLR强制垃圾回收,回收由已卸载的AppDomain创建的任何对象的内存. 这些对象Finalize方法被调用, 使对象有机会正确清理它们占用的资源.\n5. CLR恢复剩余所有线程的执行, 调用AppDomain.Unload方法的线程将继续运行; 对AppDomain.Unload的调用是同步进行的.\n\n**当一个线程 调用AppDomain.Unload方法时, 针对要卸载的AppDomain中的`线程`,CLR会给它们10秒钟的时间离开. 10秒钟后, 如果调用AppDomain.Unload方法的线程还没有返回,CLR将抛出`CannotUnloadAppDomianException`异常, AppDomain将来可能会,也可能不会卸载.**\n\n# 监视AppDomain\n\nAppDomain的静态`MonitoringEnabled属性`设置为true, 显式打开监控。打开监控后便不能关闭，再设为false会抛ArgumentException, 代码可查询AppDomain类提供的以下4个只读属性\n\n1. `MonitoringSurvivedProcessMemorySize`:这个Int64静态属性返回由当前CLR实例控制的所有AppDomain使用的字节数。这个数字值保证在上一次垃圾回收时时准确的\n\n2. `MonitoringTotalAllocatedMemorySize`:这个Int64实例属性返回特定AppDomain已分配的字节数。这个数字只保证在上一次垃圾回收时是准确的\n\n3. `MonitoringSuvivedMemorySize`:这个Int64实例属性返回特定AppDomain当前正在使用的字节数。这个数字只保证在上一次垃圾回收时是准确的\n\n4. `MonitoringTotalProcessorTime`:这个TimeSpan实例返回特定AppDomain的CPU占用率\n\n# AppDomain FirstCance异常通知\n\n**每个AppDomain都可关联一组回调方法. 回调方法不能处理异常,也不能吞噬异常, 它们只是接收关于异常发生的通知. 要接收通知, 为AppDomain的实例事件FirstChanceException添加一个委托就就可以了.**\n\n- 异常首次抛出时，CLR调用向抛出异常的AppDomain登记的所有FirstChanceException回调方法。\n- 然后。CLR查找栈上同一个AppDomain中的任何catch块，有一个catch块能处理异常，则异常处理完成，将继续执行\n- 如果AppDomain中没有一个catch块能处理异常，则CLR沿着栈向上来到调用AppDomain，再次抛出同一异常对象（序列化和反序列化之后）\n- 这时感觉就像是抛出一个全新新的异常，CLR调用当前AppDomain登记的所有FirstChanceException回调方法.\n- 这个过程会一直执行，直到抵达线程栈顶部。如果异常还未处理，则进程终止.\n\n# 宿主如何使用AppDomain\n\n不同应用程序类型如何寄宿(容纳)CLR, 以及如何管理AppDomain.\n\n## 可执行应用程序\n\n控制台UI应用程序、NT Service应用程序、Windows窗体应用程序和Windows Presentation Foundation（WPF）应用程序都是自寄宿（self-hosted，即自己容纳CLR）的应用程序，它们都有托管exe文件。Windows用托管exe文件初始化进程时，会加载垫片。垫片检查应用程序的程序集（exe文件）中的CLR头信息。头信息指明了生成和测试应用程序时使用的CLR版本。垫片根据这些信息决定将哪个版本的CLR加载到进程中，**CLR加载并初始化好之后，会再次检查程序集CLR头，判断哪个方法是应用程序的入口方法（main）**。CLR调用该方法，此时应用程序才真正启动并运行起来。\n\n代码运行时会访问其他类型。引用另一个程序集中的类型时，CLR会定位所需的程序集，并将其加载到同一个AppDomain中。应用程序的main方法返回后，Windows进程终止（销毁默认AppDomain和其他所有AppDomain）\n\n> 注意：要关闭Windows进程（包括它所有AppDomain），可调用System.Environment的静态方法Exit。**Exit是终止进程最得体的方式**，因为它首先调用托管堆上的所有对象的Finalize方法，再释放CLR容纳的所有非托管com对象。最后，exit调用win32 `ExitProcess函数`。\n\n\n# 高级宿主控制\n\n## 使用托管代码管理CLR\n\n`System.AppDomainManager类`允许宿主使用托管代码（而不是非托管代码）覆盖CLR的默认行为。你唯一要做的就是定义自己的类，让它从`System.AppDomainManager派生`，重写想要接手控制的任何虚方法。然后，在专用的程序集中生成类，并将程序集安装到GAC中。(GAC中的所有程序集都总是被授予完全信任权限).\n\n## 写健壮的宿主应用程序\n\n托管代码出现错误时，宿主可告诉CLR采取什么行动。\n1. 如果线程执行时间过长，CLR可终止线程并返回一个响应。\n2. CLR可卸载AppDomain。这会终止线程并返回一个响应。\n3. CLR可被禁用。这会阻止更多的托管代码在程序中运行，但仍允许非托管代码运行。\n4. CLR 可退出Windows进程。首先会终止所有线程，并卸载所有AppDomain，使资源清理操作得以执行，然后才会终止进程。\n\nCLR可以得体地或者粗鲁地终止线程或者AppDomain.\n- 得体地: 会执行资源清理代码, finally块会运行, 对象的Finalize方法也将被执行.\n  - 如果正在一个catch块或者finally块中的线程, 则无法终止.\n- 粗鲁地: 清理代码不会执行, finally和Finalize可能不会执行.\n  - 能终止在一个catch块或者finally块中的线程\n  - 非托管代码或约束执行区中的线程完全无法终止.\n\n## 宿主如何拿回它的线程\n\n![](22CLR寄宿和AppDomain/QQ截图20190916113812.png)\n\n1. 客户端向服务器发送请求\n\n2. 服务器线程获得请求，把它派发给一个线程池线程来执行实际工作。\n\n3. 线程池线程获得客户端的请求，执行由构建并测试宿主应用程序的那个公司写的可信代码\n\n4. 可信代码进入一个try块。从这个try块中，**跨越一个AppDomain的边界进行调用（通过派生自MarshalByRefObject的一个类型）**。AppDomain中包含的是不可信代码（可能是存储过程），这些代码不是由制作宿主应用程序的那个公司生成和测试的可信代码。在这个时候，服务器相当于把它的线程的控制权交给了一些不可信的代码，服务器感到有点紧张了。\n\n5. 宿主会记录接收到客户端请求的时间。不可信代码在管理员设定的时间内没有对客户端做出响应，宿主就会调用Thread的`Abort方法`要求CLR终止线程池线程，强制它抛出一个`ThreadAbortException`。\n\n6. 这时，线程池线程开始展开(unwind)，调用finally块，使清理代码得以执行。最后，线程池线程穿越`AppDomain`边界返回。由于宿主的存根代码是从一个`try块`中调用不可信代码，所以宿主的存根代码有一个`catch块`捕捉`ThreadAbortException`。\n\n7. 为了响应捕捉到的`ThreadAbortException异常`，宿主调用Thread的`ResetAbort`方法。\n\n8. 现在，宿主代码已捕捉到`ThreadAbortException异常`。因此，宿主可向客户端返回某种形式的错误，允许线程池线程返回线程池，供未来的客户端请求使用。\n\n澄清一下上述架构中容易被忽视的地方。首先，**thread的Abort方法是异步的**。调用Abort方法时，会在设置目标线程的`AbortRequested标志`后立即返回。“运行时”检测到一个线程要中止时，**会尝试将线程弄到一个安全地点（safe place）**。如果“运行时”认为能安全地停止线程正在做的事情，不会造成灾难性后果，就说线程在安全地点。如果线程正在执行一个托管的阻塞,他就在一个安全地点。如果线程正在执行类型的类构造器、catch块或者finally块中的代码、cer中的代码或者非托管代码，线程就不在安全地点.\n\n线程到达安全地点后，“运行时”检测到线程已设置了`AbortRequested标志`。这导致线程抛出一个`ThreadAbortException`，如果该异常未被捕捉，异常就会成为未处理的异常，所有挂起的finally块将执行，线程得体地终止。**和其他所有异常不同，未处理的ThreadAbortException不会导致应用程序终止**。“运行时”会悄悄地吞噬这个异常（假装它没有发生），线程将死亡。当应用程序及其剩余的所有线程都将继续运行。\n\n在本例中，宿主捕捉`ThreadAbortException`，允许宿主重新获取该线程的控制权，并把它归还到线程池中。但还有一个问题：宿主用什么办法阻止不可信代码自己捕获`ThreadAbortException`，从而保持宿主对线程的控制呢？**答案是CLR以一种非常特殊的方法对待ThreadAbortException。即使代码捕捉了ThreadAbortException，CLR也不允许代码悄悄地吞噬该异常。换言之，在catch块的尾部，CLR会自动重新抛出ThreadAbortException。**\n\nCLR的这个功能又引起另一个问题：如果CLR在catch块的尾部重新抛出了ThreadAbortException异常，宿主如何捕捉它并重新获取线程的控制权呢？**宿主的catch块中有一个对Thread的`ResetAbort方法`的调用。调用该方法会告诉CLR在catch块的尾部不要重新抛出ThreadAbortException异常。**\n\n这又引起了另一个问题：宿主怎么阻止不可信代码自己捕捉`ThreadAbortException`并调用Thread的`ResetAbort方法`，从而保持宿主对线程的控制呢？**答案是Thread的ResetAbort方法要求调用者被授权了`SecurityPermission`权限**，而且其`ControlThread标志`已被设置为true。宿主为不可信代码创建AppDomain时，不会向其授予这个权限，所以不可信代码不能保持对宿主的线程的控制权。\n\n需要指出的是，这里仍然存在一个潜在的漏洞：当线程从它的`ThreadAbortException`展开时，不可信代码可执行catch块和finally块。在这些块中，不可信代码可能进入死循环，阻止宿主重新获取线程的控制权。宿主应用程序通过设置一个升级策略来修正这个问题。要终止的线程在合理的时间内没有完成，CLR可将线程的终止方式升级成“粗鲁”的线程终止、“粗鲁”的AppDomain卸载、禁用CLR甚至杀死整个进程。还要注意，不可信代码可捕捉`ThreadAbortException`，并在catch块中抛出其他种类的一个异常。如果这个其他的异常被捕捉到，CLR会在catch块的尾部自动重新抛出ThreadAbortException异常。\n\n需要指出的是，大多数不可信的代码实际并非故意写成恶意代码：只是根据宿主的标准，它们的执行时间太长了一点。通常，catch块和finally块只包含及少量代码，这些代码可以很快地执行，不会造成死循环，也不会执行耗时很长的任务。所以，宿主为了重新获取线程的控制权限，一般情况都不会动用升级策略（开始各种各样的“粗鲁”行为）。\n\n顺便说一句，thread类实际提供了两个`Abort方法`：一个`无参`；另一个获取一个`object参数`，允许传递任何东西进来。代码捕捉到`ThreadAbortException`时，可查询它的只读`Exception属性`。该属性返回的就是传给`Abort`的对象。这就允许调用Abort的线程指定了一些额外的信息，供捕捉ThreadAbortException异常的代码检查。宿主可利用这个功能让自己的处理代码知道它为什么要中止线程。\n","tags":["CLR读书笔记"]},{"title":"21托管堆和垃圾回收2","url":"/2019/09/11/21托管堆和垃圾回收2/","content":"\n# 使用需要特殊清理的类型\n\n.\n\n## StreamWriter和FileStream的一个问题讨论\n\n`System.IO.FileStream`类型允许用户打开文件进行读写。为提高性能，该类型的实现利用了一个**内存缓冲区**。**只有缓冲区满时，类型才将缓冲区中的数据刷入文件**。FileStream类型只支持字节的写入。写入字符和字符串可以使用一个`System.IO.StreamWriter`，如下所示\n\n```csharp\nFileStream fs=new FileStream(\"temp.dat\",FileMode.Create);\nStreamWriter sw=new StreamWriter(fs);\nsw.Write(“Hi There”);\n// 不要忘记写下面这个Dispose调用\n// 由于StreamWriter对象实现了IDisposable接口, 所以可以使用C#的using语句\n// 调用Dispose,StreamWriter对象将数据flush到Stream对象并关闭该对象\nsw.Dispose();\n// 调用StreamWriter 的Dispose会关闭FileStream\n// FileStream无需显示关闭\n// 不需要再FileStream上显式调用Dispose,因为StreamWriter会帮你调用, 非要显式调用Dispose\n// FileStream会发现对象已经清理过了, 所以方法什么都不做而直接返回.\n```\n\n不需要再`FileStream`上显式调用`Dispose`,因为`StreamWriter`会帮你调用, 非要显式调用`Dispose`,`FileStream`会发现对象已经清理过了, 所以方法什么都不做而直接返回.\n\n没有代码显式调用Dispose会发生什么? 在某个时刻,垃圾回收器会正确检测到对象是垃圾,并对其进行终结, 但垃圾回收器不保证对象的终结顺序.  所以, 如果`FileStream`对象先终结, 就会先关闭文件,然后`StreamWriter`对象终结时,会试图向已关闭的文件flush(冲入,写入)数据, 造成抛出异常. 如果`StreamWriter`对象先终结,数据就会安全写入文件.\n\nMicrosoft解决这个问题是让`StreamWriter`对象类型**不支持终结器**, **如果不调用`Dispose`方法,就永远不会将缓冲区的数据flush到`FileStream`对象.** 数据肯定丢失.\n\n## GC为本机资源提供的其他功能\n\n包装本机资源的`托管对象`只占用**很少**的内存,但是本机资源有时会消耗大量内存.例如位图, 如果大量分配数百个位图(CLR觉得这些对象占用的内存很少不需要去GC),但进程的内存将以一个恐怖的速度增长.\n\n为了修正这个问题,GC类提供了以下2个静态方法:\n\n```csharp\npublic static void AddMemoryPressure(Int64 bytesAllocated);\npublic static void RemoveMemoryPressure(Int64 bytesAllocated);\n```\n\n如果一个类要包装可能很大的本机资源,就应该使用这些方法提示垃圾回收器实际需要消耗多少内存. 垃圾回收器会监视内存压力, 压力变大时,就强制执行垃圾回收.\n\n详细例子可以去看原文.\n\n# 终结的内部工作原理\n\n终结器表面上很简单: 创建对象, 当它被回收时, 它的Finalize方法得以调用.  深究下去, 就会发现终结的门道很多.\n\n1. `new`操作符会从堆中分配内存\n2. 如果对象的类型**重写**了`System.Object`继承的`Finalize`方法(就认为此类和派生类是可终结对象).\n  1. 不重写,就会被CLR认为忽略掉.认为是不可终结对象.\n3. 类型构造器被调用之前,会将该对象指针放入 `终结列表(finalization list)`中\n  1. 这个`终结列表`是由垃圾回收器孔子的一个内部数据结构.\n4. 回收对象的内存前,应调用该对象的`Finalize`方法.\n\n![](21托管堆和垃圾回收2/QQ截图20190911141358.png)\n\n系统检测到CEFIJ对象定义了Finalize方法, 所以将指向这些对象的指针添加到终结列表中.\n\n![](21托管堆和垃圾回收2/QQ截图20190911141737.png)\n\n垃圾回收开始时,对象BEGHIJ被判定为垃圾, 垃圾回收器扫描`终结队列`查找这些对象的引用, 找到后从终结列表移除, 移除并附加到`freachable队列`(也是垃圾回收器的一个内部数据结构)\n\n> freachable 名字的由来: f 代表终结 finalization . freachable队列中的每个记录项都是对托管堆中应调用其Finalize方法的一个对象的引用.   reachable 代表对象是可达的.\n> 换言之: 可将freachable队列看成是像静态字段那样的一个根(引用对象). 所以freachable队列中的引用使它指向的对象保持可达,不是垃圾.\n\n![](21托管堆和垃圾回收2/QQ截图20190911145528.png)\n\nBGH占用的内存已经被回收, EIJ占用的内存暂时不能回收, 因为它们的Finalize方法还没有调用.\n\n一个特殊的高优先级CLR线程专门调用`Finalize`方法. `freachable队列`为空时,线程睡眠,一但进来记录项,就会唤醒线程去执行, 然后调用`Finalize`方法后移除. 注意不应该在`Finalize`中访问线程的本地存储.\n\n当一个对象不可达时, 垃圾回收器就视它为垃圾. **但是当垃圾回收器将对象引用从`终结列表`移至`freachable队列`时, 就不再被认为是垃圾, 不能回收它的内存.  对象复活了...**\n\n标记`freachable`对象时, `垃圾回收器`将递归**标记**对象中的引用类型的字段所引用的`对象`; 所以这些对象也必须复活以便在回收过程中存活. 之后, 垃圾回收器才结束对垃圾的标识. 在这个过程中, 一些原本被认为是垃圾的对象复活了,然后垃圾回收器压缩(移动)可回收的内存, 将复活的对象提升到较老的一`代`(这不理想), 现在,特殊的`终结线程`清空`freachable队列`,执行每个对象的`Finalize`方法.\n\n在下一次对老一`代`进行回收时,会发现已终结的对象称为真正的垃圾, 因为没有`根`指向他们. `freachable队列`也不再指向它们.  **所以在整个过程中, 可终结对象需要执行两次垃圾回收才能释放它们占用的内存. 在实际应用中可能不止两次, 可能被提升至另一`代`了.**\n\n![](21托管堆和垃圾回收2/QQ截图20190911153218.png)\n\n# 手动监视和控制对象的生存期\n\nCLR为每个AppDomain都提供了`GC句柄表(GC Handle table)`, 允许应用程序监视或手动控制对象的生存期.  这个表创建之初是空白的, 其中的记录项包含2中信息:\n- 对托管堆中的一个对象的`引用`\n- 如何监视或控制对象的`标志flag`\n\n![](21托管堆和垃圾回收2/QQ截图20190911155057.png)\n\n![](21托管堆和垃圾回收2/QQ截图20190911155106.png)\n\n简单地说,为了控制或监视对象的生存期, 可调用`GCHandle`的`静态Alloc方法`,并传递想控制/监视的对象的`引用`.  还可传递一个`GCHandleType`枚举标志,定义如下:\n\n```csharp\npublic enum GCHandleType\n{\n   Weak = 0,                  // 用于监视对象的存在\n   WeakTrackResurrection = 1, // 用于监视对象的存在\n   Normal = 2,                // 用于控制对象的生存期\n   Pinned = 3                 // 用于控制对象的生存期\n}\n```\n\n- `Weak` : 监视对象的生存期, 具体地说,可以检测垃圾回收器在什么时候判断该对象在应用程序代码中不可达. 注意, 此时对象的Finalize方法可能执行,也可能没执行, 对象可能还在内存中.\n- `WeakTrackResurrection` : 与上面相同, 不同的是此时对象的`Finalize方法`已经执行,对象的内存已经回收.\n- `Normal` : 该标志允许控制对象的生存期. 是告诉垃圾回收器: 即使应用程序中没有变量(根)引用该对象. 该变量也必须留在内存中. 垃圾回收发生时, 该对象的内存可以压缩(移动). **不向Alloc方法传递任何GCHandleType标志.就默认用`Normal`.**\n- `Pinned` : 与上面那条不同的是, 垃圾回收发生时, 该对象的内存**不能**压缩(移动). 这个功能用于需要将内存地址交给本机代码时,本机代码知道GC不会移动对象,所以能放心地向托管堆的这个内存写入.\n\n\n`GCHandle`的`静态Alloc方法`会在调用时扫描AppDomain的`GC句柄表`,调用`GCHandle`的`Free方法`, 将IntPtr字段设为0, 使实例变得无效.\n\n垃圾回收器如何使用GC句柄表, 当垃圾回收发生时, 垃圾回收器的行为如下:\n\n![](21托管堆和垃圾回收2/QQ截图20190911173608.png)\n\n在什么情况下使用, 具体看书.\n\nfix语句的使用\n\n![](21托管堆和垃圾回收2/QQ截图20190911174650.png)\n\n\n# 关于强弱引用\n\n开发人员刚开始学习`弱引用`时, 会马上想到它们在缓存情形中的用处. 例如: 构造包含大量数据的一组对象, 并创建这些对象的`弱引用`. 需要数据时就去检查这些弱引用, 看看包含这些数据的对象是否依然\"健在\", 对象还在就直接使用对象; 这与程序就会有较好的性能, **但是如果发生垃圾回收, 包含数据的对象就会被销毁**. 一旦需要重新创建数据,性能就会收到影响.\n\n**垃圾回收不是内存满或接近满时才发生的, 只要第0代满了,垃圾回收就会发生.**\n\n`弱引用`在缓存情形中确实能得到高效应用,但构建良好的缓存算法来找到内存消耗和速度之间的平衡点十分复杂. 简单的说: 你希望缓存保持对自己的所有对象的`强引用`, 内存吃紧就开始将`强引用`转换为`弱引用`. 通过调用WIN32的`GlobalMemoryyStatusEx`函数并检查返回`MEMORYSTATUSEX`结构的`dwMemoryLoad`成员做到这一点. 当大于80,内存空间处于吃紧状态.\n","tags":["CLR读书笔记"]},{"title":"21托管堆和垃圾回收","url":"/2019/09/10/21托管堆和垃圾回收/","content":"\n# 托管堆和垃圾回收\n\n托管应用程序如何构造新对象,如何控制这些对象的生存期, 以及如何回收这些对象的内存.\n\n# 托管堆基础\n\n每个程序都要使用这样或那样的资源，包括文件、内存缓冲区、屏幕空间、网络连接、数据库资源等。事实上，在面向对象的环境中，每个类型都代表可提供程序使用的一种资源。要使用这些资源，必须为代表资源的类型分配内存。以下是访问一个资源所需的步骤\n\n1. 调用`IL指令newobj`，为代表资源的类型分配内存（一般使用c# `new`操作符来完成）\n2. 初始化内存，设置资源的初始状态并使资源可用。类型的实参构造器负责设置初始状态。\n3. 访问类型成员来使用资源。\n4. 摧毁资源的状态以进行清理\n5. 释放内存。垃圾回收器独自负责这一步。\n\n现在，只要写的是可验证的、类型安全的代码(不要用`unsafe`关键字)，应用程序就不可能会出现内存被破坏的情况。内存仍有可能泄漏，但不像以前那样是默认行为。\n\n现在**内存泄漏**一般是因为在集合中存储了对象，但不需要对象的时候一直不去删除。\n\n为了简化编程,开发人员经常使用的**大多数类型**都不需要`步骤4摧毁资源的状态以进行清理`, 靠垃圾回收器自动释放内存.\n\n使用需要**特殊清理的类型**时，编程模型还是像刚才描述的那样。只是有时需要尽快清理资源，而不是非要等`GC`介入。可在这些类中调用一个额外的方法（`Dispose`），按照自己的节奏清理资源。另一方面，实现这样的类需要考虑到较多问题。**一般只有包装了本机资源（文件、套接字和数据库连接等）的类型才需要特殊清理。**\n\n## 从托管堆分配资源\n\n**CLR要求所有对象都从托管堆分配**。进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还要维护一个指针，我把它称作`NextObjPtr`。该指针指向下一个对象在堆中的分配位置。刚开始的时候，`NextObjPtr`设为地址空间区域的基地址。\n\n一个区域被非垃圾对象填满后，CLR会分配更多的区域。这个过程一直重复，直至整个进程地址空间都被填满。所以，你的应用程序的内存受进程的虚拟地址空间的限制。32位进程最多能分配1.5Gb，64位进程最多能分配8Tb。\n\nC#的`new`操作符导致CLR执行以下步骤。\n1. 计算类型的字段（以及从基类型继承的字段）所需的字节数。\n2. 加上对象的开销所需的字节数。每个对象都有两个开销字段：`类型对象指针`和`同步块索引`。对于32位应用程序，这两个字段各自需要32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各自需要64位，所以每个对象要增加16字节。\n3. CLR检查区域中是否有分配对象所需的字节数。如果托管堆有足够的可用空间，就在`NextObjPtr指针`指向的地址处放入对象，为对象分配的字节会被清零。接着调用类型的构造器（为this参数传递NextObjPtr），new操作符返回对象引用。就在返回这个引用之前，`NextObjPtr指针`的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。\n\n![](21托管堆和垃圾回收/QQ截图20190910114941.png)\n\n对于托管堆，分配对象只需要在指针上加一个值—---速度相当快。**由于托管堆在内存中连续分配这些对象**，所以会因为引用的“局部化”（locality）而获得性能上的提示。具体地说，这意味着进程的工作集会非常小，应用程序只需要使用很少的内存，从而提高了速度。还意味着代码使用的对象可以全部驻留在cpu的缓存中。结果是应用程序能以惊人的速度访问这些对象，因为cpu在执行大多数操作时，不会因为`缓存未命中`而被迫访问较慢的RAM。\n\n> 随机存取存储器（英语：Random Access Memory，缩写：RAM）也叫主存，是与CPU直接交换数据的内部存储器。\n\n根据前面的描述，似乎托管堆的性能天下无敌。但先别激动，刚才说的有一个大前提—---**内存无限**，CLR总是能分配新对象。但内存不可能无限，所以CLR通过称为`垃圾回收`的技术删除堆中你的应用程序不再需要的对象。\n\n## 垃圾回收算法\n\n应用程序调用new操作符创建对象时，可能没有足够地址空间来分配该对象。发现空间不够，CLR就执行垃圾回收。\n\n![](21托管堆和垃圾回收/QQ截图20190910115624.png)\n\n至于对象生存期管理，有的系统采用的是某种`引用计数算法`, Microsoft自己的组件对象模型（component Object Model，COM）用的就是`引用计数`.\n\n这种系统中，堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一部分到达代码中某个不再需要对象的地方，就递减对象的计数字段。计数字段变成0，对象就可以从内存中删除了。\n\n**许多引用计数系统最大的问题是处理不好循环引用**。例如在GUI应用程序中，窗口将容纳对子ui元素的引用，而子ui元素将容纳对父窗口的引用。这种引用会**阻止**两个对象的计数器达到0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口了。\n\n鉴于`引用计数`垃圾回收期算法存在的问题，CLR改为使用一种`引用跟踪算法`。**引用跟踪算法只关心引用类型的变量**，因为只有这种变量才能引用托管堆上的对象；值类型变量直接包含值类型实例。引用类型变量可在许多场合使用，包括类的静态和实例字段，或者方法的参数和局部变量。**我们将所有引用类型的变量都称为`根`。**\n\nCLR开始GC时，首先暂停进程中的所有线程。这样可以防止线程在CLR检查期间访问对象并更改其状态。然后，CLR进行gc的`标记`阶段。在这个阶段，CLR遍历堆中所有对象，将`同步块索引字段`中的一位设为0。这表明所有对象都应删除。然后，CLR检查所有活动`根`，查看他们引用了哪些对象。这正是CLR的gc称为引用跟踪gc的原因。如果一个跟包含null，CLRr忽略这个根并继续检查下个`根`。\n\n任何`根`如果引用了堆上的对象，CLR都会标记那个对象，也就是将该对象的`同步块索引`中的位设为1.一个对象被标记后，CLR会检查那个对象中的`根`，标记它们引用的对象。**如果发现对象已经标记，就不重新检查对象的字段。这就避免了因为循环引用而产生的死循环**。\n\n![](21托管堆和垃圾回收/QQ截图20190910120558.png)\n\n上图展示了一个堆, 其中包含几个对象, 应用程序的根(变量)直接引用了对象`A`,`C`,`D`,`F`. 这4个对象都以及被`标记`,`标记``D`时, 垃圾回收期发现这个对象含有一个引用`H`的字段,造成`H`也被`标记`. `标记过程`会持续到所有`根(变量)`检查完毕.\n\n检查完毕后，堆中的对象要么**已标记**，要么**未标记**。已标记的对象不能被垃圾回收，因为至少有一个跟在引用它。我们说这种对象是可达的，因为应用程序代码可通过仍在引用它的变量抵达它。**未标记的对象是不可达的**，因为应用程序中不存在使对象能被再次访问的根。\n\nCLR知道哪些对象可以幸存，哪些可以删除后，就进入GC的`压缩阶段(碎片整理,变的更紧凑)`。在这个阶段，CLR对堆中已标记的对象进行“乾坤大挪移”，压缩所有幸存下来的对象，**使他们占用连续的内存空间**。这样做有许多好处。首先，所有幸存对象在内存中紧挨在一起，**恢复了引用的“局部化”**，减小了应用程序的工作集，从而提升了将来访问这些对象时的性能。其实，可用空间也全部是连续的，所以这个地址空间区段得到了解放，允许其他东西进驻。最后，**\"压缩\"意味着托管堆解决了本机(原生)堆的空间`碎片化`问题**。\n\n> 大对象堆不会压缩, 大对象堆还是可能发生地址空间碎片化的.\n\n在内存中移动了对象之后有一个问题亟待解决。引用幸存对象的`根`现在**引用的还是对象最初在内存中的位置，而非移动后的位置**，被暂停的线程恢复执行时，将访问旧的内存位置，会造成内存损害。这显然不能容忍的，所以作为压缩阶段的一部分，CLR还要从每个`根`减去所引用的对象在内存中偏移的字节数。这样就能保证每个根还是引用和之前一样的对象：只是对象在内存中变换了位置。\n\n压缩好内存后，托管堆的`NextObjPtr指针`指向最后一个幸存对象之后的位置。下一个分配的对象将放到这个位置。\n\n![](21托管堆和垃圾回收/QQ截图20190910124714.png)\n\n压缩阶段完成后, CLR恢复应用程序的所有线程, 这些线程继续访问对象.\n\n如果CLR在一次gc之后回收不了内存，而且进程中没有空间来分配新的gc区域，就说明该进程的内存已耗尽。此时，视图分配更多内存的`new`操作符会抛出`OutOfMemoryException`。应用程序可捕捉该异常并从中恢复。但大多数应用程序都不会这么做：相反，异常会成为未处理异常,Windows将终止进程并回收进程使用的全部内存.\n\n**`静态字段`引用的对象一直存在，直到用于加载类型的AppDomain卸载为止。内存泄漏的一个常见原因就是让静态字段引用某个集合对象，然后不停地向集合添加数据项。静态字段使集合一直存活,而集合对象使所有数据项一直存活.**\n\n## 垃圾回收和调试\n\n```csharp\npublic static void Main()\n{\n    // 创建每2000毫秒就调用一次TimerCallback方法的Timer对象\n    var t = new System.Threading.Timer(TimerCallback, null, 0, 2000);\n    // 等待用户按Enter键\n    Console.ReadLine();\n}\n\nprivate static void TimerCallback(Object o)\n{\n    // 当调用该方法时,显示日期和时间\n    Console.WriteLine(\"In TimerCallback: \" + DateTime.Now);\n    // 出于演示目的, 强制执行一次垃圾回收\n    GC.Collect();\n}\n\n// 在debug下运行,   可以一直输出\n// 在release下运行, 只会输出一次\n```\n\n观察代码可能以为`TimerCallback`方法每隔2000毫秒调用一次, 毕竟代码创建了一个Timer对象, 而且有一个`变量t`引用该对象, 计时器对象存在,计时器就应该一直能触发. 但实际上不是这样的.\n\n运行代码，会发现`TimerCallback`方法只被调用一次，因为方法调用了`GC.Collect()`强制执行了一次垃圾回收。\n\n回收开始时, 垃圾回收器首先假定堆中的所有对象都是不可达的(垃圾); 这自然也包括Timer对象,然后垃圾回收器检查应用程序的`根(引用变量)`,发现初始化`t`之后,Main方法再也没有用过`变量t`, **应用程序没有任何变量引用Timer对象, 所以被回收了.**\n\n大多数开发人员没有料到这个结果,认为不合常理,所以Microsoft提出了一个解决方案:\n\n使用C#编译器/debug开关编译程序集时, 编译器会应用`System.Diagnostics.DebuggableAttribute`特性, 并未结果程序集设置`DebuggingModes`的`DisableOptimizations`标志. **运行时编译方法时, JIT编译器看到这个标志,会将所有`根(引用变量)`的生存期延长至方法结束.** 在例子中, JIT编译器认为Main的t变量必须存活至方法结束. 所以垃圾回收时GC认为t仍然是一个`根`, t引用的Timer对象仍然可达, TimerCallback方法会被反复调用,直至Main退出.\n\n\n从这个例子看来Debug生成中正常工作的应用程序,但它在Release生成中是不正常的. 没人喜欢只有调试时才正常的程序,所以讨论以下修改:\n\n```csharp\n// 不正确修改方式\npublic static void Main()\n{\n    // 创建每2000毫秒就调用一次TimerCallback方法的Timer对象\n    var t = new System.Threading.Timer(TimerCallback, null, 0, 2000);\n    // 等待用户按Enter键\n    Console.ReadLine();\n    // 在ReadLine之后引用t , 但是会被JIT优化掉\n    // 将局部变量或参数设为null等价于根本不引用该变量\n    // JIT编译器会将这行代码删除(优化掉)\n    t = null;\n}\n\n// 正确修改方式\npublic static void Main()\n{\n    // 创建每2000毫秒就调用一次TimerCallback方法的Timer对象\n    var t = new System.Threading.Timer(TimerCallback, null, 0, 2000);\n    // 等待用户按Enter键\n    Console.ReadLine();\n    // 在ReadLine之后引用t ,\n    // 在Dispose方法返回前,t会在GC中存活.\n    t.Dispose();\n}\n```\n\n`t.Dispose();` 要求t对象必须存活才能去调用`Dispose`实例方法(**t中的值要作为this实参传给Dispose**). 显式释放计时器才能活到被释放那一刻.\n\n**注意：不用担心对象被过早回收这个问题. 这里讨论的是特殊情况. 所有非timer对象都会根据应用程序的的需要而自动存货。timer是一个比较特殊行为。**\n\n![](21托管堆和垃圾回收/QQ截图20190910153416.png)\n\n# 代:提升性能\n\nCLR的gc是基于`代`的垃圾回收器，他对你的代码做出做出了以下几点假设\n\n1. 对象越新，生存期越短。\n2. 对象越老，生存期越长。\n3. 回收堆的一部分，速度快于回收整个堆。\n\n大量研究证明，这些假设对于现今大多数应用程序都是成立的，它们影响了垃圾回收器的实现方式。\n\n托管堆在初始化时不包含对象。添加到堆的对象称为第0代对象。简单地说，第0代对象就是那些**新构造的对象**，垃圾回收期从未检查过它们。\n\n![](21托管堆和垃圾回收/QQ截图20190910153726.png)\n\n一个新启动的应用程序,分配了5个对象,ABCDE, 一会之后,CE变不可达.\n\n![](21托管堆和垃圾回收/QQ截图20190910153821.png)\n\nCLR初始化时为`第0代对象`选择一个预算容量（以kb为单位）。如果分配一个新对象造成`第0代`超过预算，就必须启动一次垃圾回收。假设对象A到E刚好用完`第0代`的空间,那么分配F对象就会启动一次垃圾回收.\n\n垃圾回收判断CE是垃圾,就会压缩D对象,使之与B相邻. 垃圾回收之后，未被引用的对象将会被回收，**ABD对象称为`第1代对象`**。一次垃圾回收之后，`第0代`就不包含任何对象了。然后会重复上面的逻辑。\n\n> 经历过几次垃圾回收器的检查就可以称为第几代.\n\n假如继续运行, 新对象会被分配到`第0代`中,分配了FGHIJK对象,之后BHJ变得不可达.\n\n![](21托管堆和垃圾回收/QQ截图20190910160753.png)\n\n现在,再分配新对象L的时候,会造成`第0代`超出预算, 必须启动垃圾回收. 开始垃圾回收时必须决定检查哪些`代`.  垃圾回收器开始回收时, 会检查`第1代`占了多少内存, 由于第一代占的内存远少于预算, 所以垃圾回收器值检查`第0代`中的对象.  **对象越新，生存期越短。** 因此`第0代`包含垃圾的可能性越大,能回收更多的内存.\n\n显然，忽略第一代对象能提升垃圾回收器的性能。对性能有更大提振作用的是现在不必遍历托管堆中的每个对象。如果`根`或`对象引用`了`老一代`的某个对象，垃圾回收期可以忽略老对象内部的所有引用，能在更短的时间内构造好可达对象图。当然，老对象的字段也有可能引用新对象。为了确保对老对象的已更新字段进行检查，垃圾回收期利用了JIT编译器内部的一个机制。这个机制在对象的**引用字段发生变化时**，会设置一个对应的`位标志`。这样，**只有字段发生变化的老对象才需检查是否引用了`第0代`新对象。**\n\n![](21托管堆和垃圾回收/QQ截图20190910162140.png)\n\n注意：Microsoft的性能测试表明，对第0代执行一次垃圾回收，所花的时间不超过1毫秒。\n\n`对象越老，生存期越长。` 基于`代`的垃圾回收器还假设老的对象活得越长, 第1代对象在应用程序中有可能是继续可达的,很有可能找不到多少垃圾. 因此对`第1代`进行垃圾回收很可能是浪费时间,如果真的有,它将留在那里.\n\n![](21托管堆和垃圾回收/QQ截图20190910162408.png)\n\n经过这轮垃圾回收之后幸存下来的`第0代`对象都成了`第1代`的一部分. 由于垃圾回收没有检查`第1代`所以B对象没有被回收.\n\n经过几次垃圾回收,`第1代`会慢慢增长, 假定`第1代`的增长超出了预算,这时继续运行,因为垃圾回收刚刚完成, 等到`第0代`超出预算时, 垃圾回收器将检查`第0代`和`第1代`(之前因为之前第1代占据的内存小于预算), 两代都被垃圾回收之后,如图所示:\n\n![](21托管堆和垃圾回收/QQ截图20190910163219.png)\n\n![](21托管堆和垃圾回收/QQ截图20190910163142.png)\n\n**托管堆只支持三代: 第0代,第1代,第2代.** 没有第3代.(System.GC.MaxGeneration方法返回2). CLR初始化时, 会为每一代选择预算. 然而, CLR的垃圾回收器时自调节的.\n\n**最终结果就是, 垃圾回收器会根据应用程序要求的内存负载来自动优化.**\n\n## 垃圾回收触发条件\n\n0. CLR在检测`第0代`超过预算时触发一次GC。这是GC最常见的触发条件\n1. 代码显式调用`System.GC`的静态`Collect`方法\n  - 代码可显式请求CLR执行回收,虽然Microsoft强烈反对这种请求，但有时情势比人强。\n2. windows报告低内存情况\n  - CLR内部使用WIN32函数监视总体内存使用情况,在低内存情况下,强制垃圾回收以释放死对象.\n3. CLR正在卸载AppDomain\n  - 一个AppDomain卸载时，CLR认为其中一切都不是根，所以执行涵盖`所有代`的垃圾回收。\n4. CLR正在关闭\n  - CLR在进程正常终止时关闭(相反的是外部终止,例如任务管理器). 关闭期间,CLR认为进程中的一切都不是`根`, CLR不会试图压缩或释放内存, window将回收进程的全部内存.\n\n\n## 大对象\n\n还有另一个性能提升值得注意。CLR将对象分为`大对象`和`小对象`。本章到目前为止说的都是`小对象`。目前认为**85000字节以上**的对象是`大对象`。CLR以不同方式对待`大小对象`。\n\n1. **`大对象`不是在`小对象`的地址空间分配，而是在进程地址空间的其他地方分配。**\n2. 目前版本的GC不压缩大对象，因为在内存中移动他们代价过高。\n3. **大对象总是第二代，绝不可能是0代或1代**。所以只能为需要长时间存活的资源创建大对象。分配短时间存货的大对象会导致第二代被更频繁的回收，会损害性能。大对象一般是大字符串（比如XML或Json）或用于`I\\O`操作的字节数组。\n\n在很大程度上视大对象若无物, 可以忽略它们的存在. 仅在出现解释不了的情况时(比如地址空间碎片化)才对它进行特殊处理.\n\n\n## 垃圾回收模式\n\nCLR启动时会选择一个GC模式，进程终止前该模式不会改变。有两个基本GC模式\n\n1. 工作站\n\n该模式针对客户端应用程序优化gc。gc造成的延时很低，应用程序线程挂起时间很短，避免使用户感到焦虑。该模式中，gc假定机器上运行的其他应用程序都不会消耗太多的cpu资源。\n\n2. 服务器\n\n该模式针对服务器端应用程序优化gc。**被优化的主要是吞吐量和资源里利用。GC假定机器上没有运行其他应用程序，并假定机器的所有cpu都可用来辅助完成gc**。该模式造成托管堆被拆分成几个区域（section），每个cpu一个。开始垃圾回收时，垃圾回收期在每个cpu上都运行一个特殊线程；每个线程和其他线程并发回收它自己的区域。对于工作者线程行为一致的服务器应用程序，并发回收能很好地进行。\n\n\n**应用程序默认以工作站GC模式运行**。寄宿了CLR的服务器应用程序可请求CLR加载服务器GC。但如果服务器应用程序在单处理器计算机上运行，CLR将总是使用工作站gc模式。\n\n```\n<configuration>\n  <runtime>\n    <gcServer enabled=\"true\"/>\n  </runtime>\n</configuration>\n```\n\n独立应用程序可创建一个配置文件告诉CLR使用服务器回收器。应用程序运行时，可查询`GCSettings类`的只读`bool`属性`IsServerGc`来询问CLR它是否正在服务器GC模式中运行。\n\n\n除了这两种主要模式，GC还支持两种子模式：`并发（默认）`或`非并发`。在并发方式中，垃圾回收器有一个额外的后台线程，它能在应用程序运行时并发标记对象.\n\n```\n<configuration>\n  <runtime>\n    <gcConcurrent enabled=\"false\"/>\n  </runtime>\n</configuration>\n```\n\nGC模式是针对进程配置的, 进程运行期间不能更改. 但是可以使用`GCSetting`类的`GCLatencyMode`属性对垃圾回收进行某种程度的控制.\n\n![](21托管堆和垃圾回收/QQ截图20190910175234.png)\n\n`LatencyMode`,一般用它执行一次短期的,时间敏感的操作,再将模式设回普通的`Batch`或`Interactive`, 在模式设为LowLatency期间,垃圾回收器会全力避免任何第2代回收, 因为那样花费的时间较多. 当然调用GC.Collect()仍会回收第2代. 如果Windows告诉CLR内存低,也会回收第2代.\n\n![](21托管堆和垃圾回收/QQ截图20190910175945.png)\n\n## 强制垃圾回收\n\n`System.GC`类型允许应用程序对垃圾回收器进行一些直接控制.\n\n还可调用`GC类`的`Collect方法`强制垃圾回收, 可以像方法传递一个代表最多回收几代的整数.\n\n`public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);`\n\n![](21托管堆和垃圾回收/QQ截图20190910180446.png)\n\n**大多时候都要避免调用任何collect方法：最好让垃圾回收期自行斟酌执行，让他根据应用程序行为跳转各个代的预算。**（调用Collect会导致代的预算发生调整）但如果写一个CUI(控制台应用程序)或GUI(图图形用户界面)应用程序，应用程序代码将拥有进程和那个进程中的CLR。对于这种应用程序，你可能希望建议垃圾回收的时间；为此，请将`GCCollectionMode`设为`Optimized`并调用`Collect()`。`Default`和`Forced模式`一般用于调试、测试和查找内存泄漏。\n\n例如，加入刚才发生了某个非重复性的事件，并导致大量旧对象死亡，就可考虑手动调用一次collect方法。由于是非重复性的，垃圾回收期基于历史的预测可能变得不准吃，所以这时调用Collect时合适的。由于调用Collect会导致代的预算发生调整，所以调用它不是为了改善应用程序的响应时间，而是为了减小进程工作集。\n\n### 处理大量对象的服务器应用程序\n\n![](21托管堆和垃圾回收/QQ截图20190910181115.png)\n\n## 监视应用程序的内存使用\n\n可在进程中调用几个方法来监视垃圾回收期。具体地说，gc类提供了一下静态方法，可调用它们查看某一代发生了多少次垃圾回收，或者托管堆中的对象当前使用了多少内存。\n\n```csharp\n int32 CollectionCount(int generation);\n int64 GetTotalMemory(Boolean ForceFullCollection);\n```\n\n为了评估特定代码块的性能，我经常在代码块前后写代码调用这些方法，并计算差异。这使我能很好地把握代码块对进程工作集的影响，并了解执行代码块时发生了多少次垃圾回收。数字太大，就知道应该花更多的时间调整代码块中的算法。\n\n还可了解大度的AppDomain使用了多少内存。安装.NET时会自动安装一组性能计数器，为clr的操作提供大量实时统计数据。这些统计数据可通过windows自带的perfmon.exe工具或者系统监视器activeX控件来查看。\n\n\n# 使用需要特殊清理的类型\n\n大多数类型有内存就能正常工作，但有的类型除了内存还需要本机资源。\n\n例如，`System.IO.FileStream`类型需要打开一个文件（本机资源）并保存文件的句柄。然后，类型的`Read`和`Write`方法用句柄操作文件。\n\n**包含本机资源的类型被GC时，GC会回收对象在托管堆中使用的内存。但这样会造成本机资源的泄漏(因为GC对此一无所知)**，这当然是不允许的。所以，CLR提供了称为`终结（finalization）`的机制，允许对象在被判定为垃圾之后，但在对象回收之前执行一些代码。任何包装了本机资源（文件、网络连接、套接字）的类型都支持`终结`。CLR判定一个对象不可达时，**对象将终结它自己，释放它包装的本机资源。之后，gc会从托管堆回收对象。**\n\n终极基类`System.Object`定义了`受保护的虚方法Finalize`。垃圾回收期判定判定对象是垃圾后，会调用对象的`Finalize`方法（如果重写）。C#团队认为`Finalize`在编程语言中需要特殊语法。因此，c#要求在类名前添加`~符号`来定义`Finalize方法`.\n\n> C++有析构器. C#早期称此为析构器, 但是后来Finalize方法的工作方式与C++析构器完全不同, 会产生混淆. 所以称为终结方法.\n\n```csharp\ninternal sealed class SomeType\n{\n   // 这是一个Finalize方法\n   ~SomeType()\n   {\n      // 这里代码会进入Finalize\n   }\n}\n```\n\n用ILDasm.exe查看得到的程序集,c#编译器实际是在模块的元数据中生成了名为`Finalize`的`protected override方法`。查看Finalize的IL，会发现方法主体的代码被放到一个`try块`中，在`finally块`中则放入了一个`base.Finalize`调用.\n\n![](21托管堆和垃圾回收/QQ截图20190910182557.png)\n\n**被视为垃圾的对象在垃圾回收完毕后才调用`Finalize方法`.** 所以这些对象的内存不是马上被回收的, 因为Finalize方法可能要执行访问字段的代码. **可终结对象在回收时必须存活,** 造成它被提升到另一代. 使对象活得比正常时间长. 这增大了内存耗用, 应尽可能避免终结. 更糟的是,可终结对象被提升时, 其字段引用的所有对象也会被提升, 因为它们必须继续存活. 所有, 要尽量避免为引用类型的字段定义可终结对象.\n\n注意: `Finalize方法`的执行时间是控制不了的. 应用程序请求更多内存时才可能发生GC, **而GC完之后才运行`Finalize`**. CLR不保证`Finalize方法`的调用顺序, 在`Finalize方法`中不要访问定义了`Finalize方法`的其他类型的对象, 那些对象可能已经终结. 但可以访问安全地访问值类型的实例, 或者访问没有定义`Finalize方法`的引用类型的对象.\n\nCLR用一个特殊的、高优先级的专用线程调用`Finalize方法`来避免死锁。如果Finalize方法阻塞，该特殊线程就调用不了任何更多的Finalize方法。 这是非常坏的情况,永远回收不了可终结对象占用的内存,就会一直泄露内存. 抛出未处理异常则进程终止,没办法捕捉该异常.\n\n综上所述，`Finalize方法`问题较多，使用需谨慎。记住他们是为了**释放本机资源**而设计的。强烈建议不要重写`Object`的`Finalize方法`。相反，使用Microsoft在FCL中提供的辅助类。这些辅助类重写了Finalize方法并添加了一些特殊的CLR“魔法”(之后提到)。你从这些辅助类派生自己的类，从而继承CLR的“魔法”。\n\n创建封装了`本机资源`的托管类型时，应该先从System.runtime.interopServices.SafeHandle这个特殊基类派生出一个类。\n\n![](21托管堆和垃圾回收/QQ截图20190910232426.png)\n\n![](21托管堆和垃圾回收/QQ截图20190910232450.png)\n\nCLR以特殊方式对待这个类及其派生类，具体地说，CLR赋予这个类一下三个很酷的功能\n\n1. 首次构造任何`CriticalFinalizerObject`派生类型的对象时，CLR立即对继承层次结构中所有的`Finalize方法`进行JIT编译。这样确保对象被确定为垃圾之后，资源肯定会得到释放。不提前编译的话,无法保证释放（内存紧张时，CLR可能找不到足够的内存来编译`Finalize方法`，这会阻止Finalize方法执行，造成本机资源泄漏）。\n\n2. CLR是在调用了`非CriticalFinalizerObject`派生类型的`Finalize方法`之后，才调用`CriticalFinalizerObject`派生类型的`Finalize`。这样，托管资源类就可以在他们`Finalize方法`中成功地访问`CriticalFinalizerObject`派生类型的对象，例如fileStream类的`Finalize方法`可以放心地将数据从内存缓冲区flush(`冲洗`到别处)到磁盘，它知道此时磁盘文件还没有关闭。\n\n3. 如果appdomain被一个宿主应用程序强行中断，CLR将调用`CriticalFinalizerObject`派生类型的`Finalize`方法。宿主应用程序不再信任它内部运行的托管代码时，也利用也利用好这个功能确保本机资源得到释放。\n\n具体看书.... 云里雾里...\n\n## 使用了包装本机资源的类型\n\n你现在知道了如何定义包装了本机资源的`SafeHandle派生类`，接着说说如何使用它。\n\n以常用的`System.IO.FileStream`类为例，可利用它打开一个文件，从文件中读取字节，向文件写入字节，然后关闭文件。\n\n`FileStream对象`在构造时会调用Win32 `CreateFile`函数，函数返回的句柄保存到`SafeFileHandle`对象中，然后通过`FileStream`对象的一个私有字段来维护对该对象的引用。`FileStream`还提供几个额外属性（例如length，position，canread）和方法（read，write，flush）。\n\n 假定要写代码来创建一个临时文件，向其中写入一些字节，然后删除文件。\n\n```csharp\n// 大多数时候都不能正常工作,以下代码\nstatic void Main(string[] args)\n{\n     //创建要写入临时文件的字节\n     Byte[] bytesToWrite=new byte[]{1,2,3,4,5};\n     //创建临时文件\n     FileStream fs=new FileStream(\"temp.dat\",FileMode.Create);\n     //将字节写入临时文件\n     fs.Write(bytesToWrite,0,bytesToWrite.Length);\n     // 此方法要求windows删除一个仍然打开的文件,所以会抛出IO异常\n     File.Delete(\"temp.dat\");//抛出Io异常\n }\n```\n\n但某些情况下, 文件可能误打误撞地被删除! 如果另一线程不知怎么造成了一次垃圾回收, 而且这次垃圾回收刚好在调用Write之后, 调用Delete之前发生, 那么`FileStream对象`的`SafeFileHandle字段`的`Finalize方法`就会被调用. 这会关闭文件, 随后Delete操作也可以正常运行,但这种情况发生概率很小, 无法运行的可能性99%.\n\n**类如果想允许使用者控制类包装的本机资源的生存期,就必须实现如下所示的IDispose接口.**\n\n![](21托管堆和垃圾回收/QQ截图20190910233916.png)\n\n幸好，FileStrram类实现了`IDisposable接口`。在实现中,会在FileStream对象的私有`SafeFileHandle`字段上调用`Dispose`, 现在就能修改代码来显式关闭文件,而不是等着未来某个GC的发生.\n\n```csharp\n// 一般的写法\nstatic void Main(string[] args)\n{\n    //创建要写入临时文件的字节\n    Byte[] bytesToWrite=new byte[]{1,2,3,4,5};\n    //创建临时文件\n    FileStream fs=new FileStream(\"temp.dat\",FileMode.Create);\n    //将字节写入临时文件\n    fs.Write(bytesToWrite,0,bytesToWrite.Length);\n    //写入结束后显示关闭文件\n    fs.Dispose();\n    // 以下代码能正常工作\n    File.Delete(\"temp.dat\");\n}\n```\n\n并非一定要调用Dispose才能保证本机资源得以清理. **本机资源的清理最终总会发生,调用Dispose只是控制这个清理动作的发生时间.** 另外,调用`Dispose`不会将托管对象从托管堆删除，**只有在垃圾回收后，托管堆中的内存才会得以回收**。 这意味你即使`Dispose`了托管对象过去用过的任何本机资源,也能在托管对象上调用方法, 只是不会成功而已,会抛出异常. 不会对造成对内存的破坏.\n\n但是当你显式调用`Dispose`后，**再调用它的方法并不会执行成功**，**比如再操作对象写入更多数据，会提示无法访问已关闭文件。** 会抛出`ObjectDisposeedException`.\n\n![](21托管堆和垃圾回收/QQ截图20190910235005.png)\n\n如果决定显示调用Dispose，强烈建议将调用放到一个finally块中。这样可以保证清理代码得以执行。也可以使用using语句，简化编码。\n\n```csharp\n// 更好的写法\nstatic void Main(string[] args)\n{\n    //创建要写入临时文件的字节\n    Byte[] bytesToWrite=new byte[]{1,2,3,4,5};\n    //创建临时文件\n    FileStream fs=new FileStream(\"temp.dat\",FileMode.Create);\n\n    try\n    {\n      //将字节写入临时文件\n      fs.Write(bytesToWrite,0,bytesToWrite.Length);\n    }\n    finally\n    {\n      if (fs!=null)\n        fs.Dispose();\n    }\n    // 写入结束后显示关闭文件\n    // 总以下代码能正常工作\n    File.Delete(\"temp.dat\");\n}\n```\n\n> 垃圾回收系统有许多好处: **无内存泄露**, **无内存损坏**, **无地址空间碎片化**以及**缩小的工作集**. 还有**同步**,GC确实能作为线程同步机制使用,因为GC会终结对象.\n\nC#语言提供一个`using`语句,允许用简化的语法来获得和上述代码相同的结果.\n\n```csharp\n// 使用using的写法,最简洁的写法\nstatic void Main(string[] args)\n{\n    //创建要写入临时文件的字节\n    Byte[] bytesToWrite=new byte[]{1,2,3,4,5};\n    //创建临时文件\n    using(FileStream fs=new FileStream(\"temp.dat\",FileMode.Create))\n    {\n       //将字节写入临时文件\n       fs.Write(bytesToWrite,0,bytesToWrite.Length);\n    }\n\n    // 写入结束后显示关闭文件\n    // 总以下代码能正常工作\n    File.Delete(\"temp.dat\");\n}\n```\n\n`using语句`初始化一个对象, 并将它的引用保存到一个变量中,然后在`using语句`的大括号内访问该变量.  编译这段代码时, 编译器自动生成`try块`和`finally块`. 在`finally块`中, 编译器生成代码将变量转型为一个`IDisposable`并调用`Dispose方法`,  显而易见, **`using语句`只能用于那些实现了IDisposable接口的类型.**\n\n![](21托管堆和垃圾回收/QQ截图20190911000011.png)\n","tags":["CLR读书笔记"]},{"title":"20异常和状态管理2","url":"/2019/09/09/20异常和状态管理2/","content":"\n# 设计规范和最佳实践\n\n![](20异常和状态管理2/QQ截图20190909123857.png)\n\n## 善用finally块\n\n`finally块`非常厉害, 无论线程抛出什么类型的异常,`finally块`中的代码都会执行. 经常利用`finally块`显式释放对象以避免资源泄露.\n\n\n**确保清理代码的执行时很重要的, 以至于许多语言提供了一些构造来简化这种代码**. 例如:\n- `lock`\n  - **锁在`finally块`中释放**\n- `using`\n  - **在`finally块`中调用对象的`Dispose`方法**\n- `foreach`\n  - **在`finally块`中调用IEnumerator对象的Dispose方法.**\n- 定义析构器方法(`Finalize方法`)时\n  - **在`finally块`中调用基类的`Finalize方法`**\n\n**C#编译器会自动生成try/finally块.** 重写类的析构器`Finalize方法`时, 也会生成try/finally块.使用这些构造时,编译器将你写的代码放到`try块`内部, 并将清理代码放到`finally块`中.\n\n## 不要什么都捕捉\n\n绝对不要写大小通吃的类型,悄悄地**吞噬**异常, 而是应该允许异常在调用栈中向上移动,让应用程序代码针对性地处理它.\n\n> 吞噬 swallow, 也有作者喜欢说bury, 有人也翻译为隐藏, 简单的说就是自己搞定异常,然后装作异常没有发生.\n\n![](20异常和状态管理2/QQ截图20190909160010.png)\n\n确实可以在catch块中捕捉System.Exception并执行一些代码, 只要在这个catch块的末尾重新抛出异常. 千万不要捕捉System.Exception异常并悄悄吞噬它而不重新抛出, 否则应用程序不知道已经出错,还是会继续运行.\n\n可以在一个线程中捕捉异常, 在另一个线程中重新抛出异常. 为此提供支持的是异步编程模型.\n\n例如,假定在一个线程池线程执行的代码抛出了异常,CLR捕捉并吞噬这个异常, 并允许线程池返回线程池,稍后会有某个线程调用EndXXX方法来判断异步操作的结果, EndXXX方法将抛出与负责实际工作的那个线程池抛出的一样的异常.  所以, 异常虽然被第一个方法吞噬,但又被调用EndXXX的线程重新抛出,这样,该异常在应用程序面前就不是隐藏的了.\n\n## 得体地从异常中恢复\n\n```csharp\ntry\n{\n   // 计算电子表格单元格中的值\n}\ncatch (DivideByZeroException)\n{\n   \"不能显示值, 除数为0\";\n}\ncatch (OverflowException)\n{\n   \"不能显示值, 溢出\"\n}\n```\n\n捕捉具体异常时, 应充分掌握在什么时候会抛出异常, 并知道从捕捉的异常类型派生出了哪些类型, 不要捕捉System.Exception(除非你会重新抛出).\n\n## 发生不可恢复的异常时回滚部分完成的操作----维持状态\n\n```csharp\npublic void SerializeObjectGraph(FileStream fs, IFormatter formatter, Object rootObj)\n{\n   // 保存文件的当前位置\n   Int64 beforeSerialization = fs.Position;\n\n   try\n   {\n      // 尝试将对象图序列化到文件中\n      formatter.Serialize(fs, rootObj);\n   }\n   catch // 捕捉所有异常\n   {\n      // 任何事情出错,就将文件恢复到一个有效状态\n      fs.Position = beforeSerialization;\n\n      // 截断文件\n      fs.SetLength(fs.Position);\n\n      // 注意: 上述代码没有放到finally块中, 因为只有在序列化失败时才对流进行重置\n\n      // 重新抛出相同的异常,让调用者知道发生了什么\n      thorw;\n   }\n}\n\n```\n\n为了正确回滚已部分完成的操作, 代码应捕捉所有异常. 是的,这里要捕捉所有异常, 因为你不关心发生了什么错误, 只关心如何将数据结构恢复为一致状态. **捕捉并处理好异常后.不要把它吞噬(假装没发生), 想法,要让调用者知道发生了什么异常, 只需要单独使用C#的`关键字throw`, 不在`关键字throw`后指定任何东西.**\n\n## 隐藏实现细节来维系协定\n\n有时需要捕捉一个异常并重新抛出不同的异常. 这样做唯一的原因是维系方法的**协定**(contract). 另外,抛出的新异常类型应该是一个具体异常(不是其他异常的基类).\n\n例子(伪代码):\n\n![](20异常和状态管理2/QQ截图20190909163814.png)\n\n文件由于任何原因未找到或者不能读取, 调用者将看到一个FileNotFoundException或者IOException异常, 因为这两个异常都不是调用者预期的, 因为**文件存在与否**以及**能否读取**不是方法的隐式协定的一部分, **调用者根本猜不到(猜不到PhoneBook类的方法要从文件中读取数据)**. 所以`GetPhoneNumber方法`会捕捉这两种异常,抛出一个新的`NameNotFoundException`异常.\n\n`NameNotFoundException`异常为调用者提供了理解其中原因的一个抽象视图,**将内部异常设为FileNotFoundException或者IOException异常** 是非常重要的一环,这样才能保证不丢失造成异常的真正原因.\n\n![](20异常和状态管理2/QQ截图20190909170409.png)\n\n这个技术会使调试变得困难,务必慎用. **有时开发人员之所以捕捉一个异常并抛出一个新异常,目的是在异常中添加额外的数据或上下文.** 如果只是这个目的,那么只需捕捉希望的异常类型,在异常对象的Data属性(一个键值对)中添加数据, 然后重新抛出相同的异常对象:\n\n`catch(IOException e) { e.Data.Add(\"Filename\",filename); throw; }`\n\n将文件名添加到IOException对象中,这样重新抛出同一个异常对象,只是它现在包含额外的数据.\n\n![](20异常和状态管理2/QQ截图20190909180415.png)\n\n\n# 未处理的异常\n\n异常抛出时, CLR在调用栈中向上查找与抛出的异常对象的类型匹配的catch块. 没有任何catch块匹配抛出的异常类型. 就会发生一个**未处理的异常**. CLR检测到任何线程中的未处理异常都会终止进程.\n\n当应用程序的开发人员才需关心未处理的异常. 应用程序发生未处理的异常时, windows会向事件日志写一条记录. 查看该记录: 事件查看器-> windows日志->应用程序节点\n\n系统托盘中的小旗->打开操作中心->展开维护->单击查看可靠性历史记录\n\n会在底部的窗格看到应用程序由于未处理的异常而终止.\n\n![](20异常和状态管理2/QQ截图20190909181311.png)\n\n![](20异常和状态管理2/QQ截图20190909181352.png)\n\n![](20异常和状态管理2/QQ截图20190909182058.png)\n\n\n# 对异常进行调试\n\n针对VS. 具体看书.\n\n# 异常处理的性能问题\n\n个别时候会遇到频繁调用但频频失败的方法, 这时抛出异常所造成的性能损失可能令人无法接受. 例如: 在调用`Int32`的`Parse`方法时, 最终用户经常输入无法解析的数据, 由于频繁调用`Parse`方法, 抛出和捕捉异常对总体性能造成了很大影响. **为了解决这个问题,Microsoft为Int32类型添加了新的TryParse方法**.\n\n```csharp\npublic static Boolean TryParse(String s, out Int32 result);\npublic static Boolean TryParse(String s, NumberStyle style, IFrmatProvider provider, out Int32 result);\n```\n\n这些方法都返回一个`Boolean`,指明传给方法的`String`是否包含了能解析成`Int32`的字符. 它们同时返回一个名为`result`的输出参数.\n- 如果方法返回`true`,`result`将包含字符串解析成32位整数的结果\n- 返回`false`,`result`将包含0, 这时自然不应再执行任何代码去检查result.\n  - **如果TryXX方法的Boolean返回值为false,那么代表的只是一种错误. 方法仍要为其他错误抛出异常.**\n  - 例如: 为`style参数`传递的实参无效,`Int32`的`TryParse`方法会抛出一个`ArgumentException`异常,另外调用`TryParse`方法时仍有可能抛出一个`OutMemoryException`异常\n\n定义类型成员时,应确保在一般使用情形中不会失败. 只有用户以后因为抛出异常而堆性能不满意时, 才应考虑添加以下`TryXxx`方法.\n\n# 约束执行区域(CER)\n\n许多应用程序都不需要健壮到能从任何错误恢复的地步.\n\nCLR中, 我们有包含了状态的AppDomain. 卸载时,它的所有状态都会卸载. 所以,如果AppDomain中的一个线程遭遇未处理的异常,可以在不终止整个进程的情况下卸载AppDDomain(销毁它的所有状态).\n\n> 线程的整个生命周期都在一个AppDomain的内部. 这个说法是成立的.\n\n根据定义, CER是必须对错误有所适应的代码块. 一般用CER处理多个AppDomain或进程共享的状态, 称这些异常为异步异常. CER就非常有用.\n\n例如, 调用方法时,CLR必须加载程序集,在`AppDomain`的`Loader堆`中创建`类型对象`, 调用类型的`静态构造器`,并将`IL`代码JIT编译成本机代码. 这些操作都可能失败,CLR通过抛出异常来报告失败.\n\n如果任何这些操作再一个catch或finally块中失败, 你的错误恢复或资源清理代码就不会完整的执行.\n\n```csharp\nprivate static void Demo1()\n{\n    Console.WriteLine(\"In Demo1\");\n    try\n    {\n        Console.WriteLine(\"In try\");\n    }\n    finally\n    {\n        // 隐式调用Type1的静态构造器\n        Type1.M();\n    }\n}\n\nprivate sealed class Type1\n{\n    static Type1()\n    {\n        // 如果这里抛出异常,M就得不到调用\n        Console.WriteLine(\"Type1's static ctor called\");\n    }\n    public static void M()\n    {}\n}\n```\n上述代码存在一个问题,如果在静态构造器中发生异常,M就得不到调用, M就得不到调用.\n\n想要达到的目的是,除非 **保证(大致保证)** 关联的`catch`和`finally`块中的代码得到执行, 否则上述`try块`的代码根本不要开始执行.为了这个目的,修改成下面这样:\n\n> 保证和大致保证分别对应后文所说的`WillNotCorrupState`和`MayCorrupInstance`两个枚举成员\n\n```csharp\nprivate static void Demo2()\n{\n    Console.WriteLine(\"In Demo2\");\n    // JIT编译器如果发现一个`try块`之前调用了这个方法,就会提前编译与`try块`关联的`catch`和`finally块`中的代码.\n    // 强迫finally块中的代码提前准备好\n    RuntimeHelpers.PrepareConstrainedRegions(); //在 System.Runtime.CompilerServices命名空间\n    try\n    {\n        Console.WriteLine(\"In try\");\n    }\n    finally\n    {\n        // 隐式调用Type2的静态构造器\n        Type2.M();\n    }\n}\n\npublic class Type2\n{\n    static Type2()\n    {\n        Console.WriteLine(\"Type2's static ctor called\");\n    }\n\n    [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]\n    public static void M()\n    {}\n}\n```\n\n`PrepareConstrainedRegions`是一个很特别的方法, **JIT编译器如果发现一个`try块`之前调用了这个方法,就会提前编译与`try块`关联的`catch`和`finally块`中的代码.** JIT编译器会加载任何程序集, 创建任何类型对象,调用任何静态构造器,并对任何方法进行编译. 如果其中任何操作造成了异常, 这个异常会在线程进入`try块`**之前** 发生.\n\nJIT编译器提前准备方法时, 还会遍历整个调用图, 提前准备被调用的方法, 前提是这些方法应用了`[ReliabilityContract]`特性. 向这个特性实例的构造器传递的是`WillNotCorrupState`或者`MayCorrupInstance`枚举成员.\n\n这是由于加入方法会损坏AppDomain或进程的状态,CLR便无法对一致性做出任何保证. 在通过一个`PrepareConstrainedRegions`调用来保护的一个`catch或finally块`中, 请确保只条用根据刚才的描述设置了`[ReliabilityContract]`的方法.\n\n此特性允许开发者向方法的潜在调用者申明方法的可靠性协定.\n\n## 如何使用这个特性\n\n![](20异常和状态管理2/QQ截图20190909193218.png)\n\n## RuntimeHelpers的另一个方法\n\n![](20异常和状态管理2/QQ截图20190909193444.png)\n\n![](20异常和状态管理2/QQ截图20190909193450.png)\n\n# 代码协定\n\n **协定默认只作为文档使用**, 为了发掘协定的附加价值,必须下载额外的工具和一个VS属性窗格.\n\n以下选看:\n\n**代码协定** 提供了直接在代码中声明代码设计决策的一种方式. 这些协定采取以下的形式:\n\n- **前条件**\n  - 一般用于对实参进行验证\n- **后条件**\n  - 方法因为一次普通的返回或者抛出异常而终止时,对状态进行验证\n- **对象不变性**\n  - 在对象的整个生命期内,确保对象的字段的良好状态\n\n可将上述想象成方法签名的一部分.\n\n代码协定的核心是静态类 `System.Diagnostics.Contracts.Contract`\n\n```csharp\n// 源码\npublic static class Contract\n{\n   // 前条件方法: [Conditional(\"CONTRACTS_FULL\")]\n   public static void Requires(Boolean condition);\n   public static void EndContractBlock();\n\n   // 前条件: Always\n   public static void Requires<TException>(Boolean condition)\n       where TException : Exception;\n\n\n   // 后条件方法: [Conditional(\"CONTRACTS_FULL\")]\n   public static void Ensures(Boolean condition);\n   public static void EnsureOnThrow<TException>(Boolean condition)\n        where TException : Exception;\n\n   // 特殊后条件方法 Always\n   public static T Result<T>();\n   public static T OldValue<T>(T value);\n   public static T ValueAtReturn<T>(out T value);\n\n   // 对象不变性方法 [Conditional(\"CONTRACTS_FULL\")]\n   public static void Invariant(Boolean condition);\n\n   .....//限定符方法,辅助方法,基础结构事件 请查看源码\n\n\n}\n```\n\n`[Conditional(\"CONTRACTS_FULL\")]`或`[Conditional(\"DEBUG\")]`除非定义了恰当的符号,否则编译器会忽略调用这些方法的任何代码. **协定默认只作为文档使用**, 因为生成项目没有定义`CONTRACTS_FULL`符号\n\n标记`Always`的任何方法意味着编译器总是生成调用方法的代码.\n\n`Requires`,`Requires<TException>`,`Ensures`,`EnsureOnThrow<TException>`,`Invariant`,`Assert`,`Assume`方法有一个额外的重载版本这里没有列出, 它获取一个`String实参`,用于显式指定违反协定时显示的字符串消息.\n\n```csharp\ninternal static class CodeContracts\n{\n    public static void Go()\n    {\n        var shoppingCart = new ShoppingCart();\n        shoppingCart.AddItem(new Item());\n    }\n\n    public sealed class Item\n    {\n        /* ... */\n    }\n\n    public sealed class ShoppingCart\n    {\n        private List<Item> m_cart      = new List<Item>();\n        private Decimal    m_totalCost = 0;\n\n        public ShoppingCart()\n        {\n        }\n\n        public void AddItem(Item item)\n        {\n            AddItemHelper(m_cart, item, ref m_totalCost);\n        }\n\n        private static void AddItemHelper(List<Item> m_cart, Item newItem, ref Decimal totalCost)\n        {\n            // 前条件\n            // 1. 前条件指出newItem不能为null\n            // 2. 而且要添加的商铺不在购物车中\n            Contract.Requires(newItem != null);\n            Contract.Requires(Contract.ForAll(m_cart, s => s != newItem));\n\n            // 后条件\n            // 1. 新商品必须在购物车中\n            // 2. 而且总价格至少要与将商铺添加到购物车之前一样多\n            // 3. 因为某个原因抛异常,那么totalCost不发生变化\n            Contract.Ensures(Contract.Exists(m_cart, s => s == newItem));\n            Contract.Ensures(totalCost >= Contract.OldValue(totalCost));\n            Contract.EnsuresOnThrow<IOException>(totalCost == Contract.OldValue(totalCost));\n\n            // 做一些事情,可能抛出IOException\n            m_cart.Add(newItem);\n            totalCost += 1.00M;\n            //throw new IOException(); // 证明违反协定\n        }\n\n        // 对象不变性\n        [ContractInvariantMethod]\n        private void ObjectInvariant()\n        {\n            // 确保对象的m_totalCost永远不包含负值\n            Contract.Invariant(m_totalCost >= 0);\n        }\n    }\n```\n\n后续不知道在讲啥玩意... 工作原理..\n","tags":["CLR读书笔记"]},{"title":"20异常和状态管理","url":"/2019/09/06/20异常和状态管理/","content":"\n# 异常和状态管理\n\n定义错误,如何从错误中恢复. 错误在不恰当的时候发生,代码可能在状态改变的中途发生错误,这时需要将一些状态还原为改变之前的样子. 还要通知调用者有错误发生.\n\n\n# 定义\"异常\"\n\n设计类型时要想好各种使用情况. 当一个类型的成员（如方法，属性）不能完成任务时，就应抛出异常。\n\n> 异常是指成员没有完成它的名称时所宣称的行动.\n\n```csharp\ninternal class Account\n{\n   // 两个账户,转账金额\n   // 此方法的作用是从一个函数扣钱,添加到另一个账户中\n   public static void Transfer(Account from, Account to, Decimal amount)\n   {\n      from -= amount;\n      to +=amount;\n   }\n}\n```\n\n以上转账方法可能有多种原因导致失败:\n- from,to实参可能是0\n- from账户没有足够的资金\n- to账户可能资金过多,以至于增加资金时导致账户溢出\n- amount参数为0,负数或者小数超过2位\n\n`Boolean f = \"Jeff\".Substring(1,1).ToUpper().EndsWith(\"E\"); // true`\n\n利用`C#扩展方法`将多个操作链接到一起, 但是有一个重要的前提,这行代码没有操作失败和中途出错. 为了让不返回错误代码的方法报告错误, .NetFramework通过`异常处理`来解决这个问题.\n\n\n# 异常处理机制\n\n本文旨在提供何时以及如何使用异常处理的设计规范.\n\n.NetFramework异常机制使用Windows提供的`结构化异常处理(Structured Exception Handling,SEH)`机制构建的. (Windows核心编程(第5版)一书,其中有3章专门谈论SEH).\n\n异常处理机制的标准用法:\n\n```csharp\npublic static void SomeMethod()\n{\n    try\n    {\n        // 需要进行恢复 和/或 清理的代码放在这里\n    }\n    catch (InvalidOperationException)\n    {\n        // 从 InvalidOperationException 恢复的代码放这\n    }\n    catch (IOException)\n    {\n        // 从 IOException 恢复的代码放这\n    }\n    catch\n    {\n        // 从除了上述异常之外的其他所有异常恢复的代码放在这里\n        throw; // 如果什么异常都捕捉,通常需要重新抛出异常\n    }\n    finally\n    {\n        // 这里的代码对始于try块的任何操作进行清理\n        // 这里的代码总是执行,不管是不是抛出了异常\n    }\n\n    // 如果try块没有抛出异常, 或者某个catch块捕捉到异常,但没有抛出或重新抛出就执行下面的代码\n    ...\n}\n```\n\n大多数情况只有一个try块和一个匹配finally块, 或者一个try块和一个匹配的catch块\n\n## try块\n\n如果代码需要执行一般性的资源清理操作,需要从异常中恢复,或者两者都需要,就可以放到`try`块. 负责清理的代码应放到一个`finally`块.  `try`块还可包含也许会抛出异常的代码, 负责异常恢复的代码应放到一个或多个`catch`块中. 针对应用程序能从安全恢复的每一种异常,都应该创建一个`catch`块中. 单独的`try`块没有意义C#也不允许.\n\n**重要提示: 开发人员有时不知道应该在一个try块中放入多少代码, 这具体取决于`状态管理`. 如果在一个try块中执行多个可能抛出`同一个异常类型`的操作, 但不同的操作有不同的异常恢复措施,就应该将每个操作都放到它自己的try块中, 这样才能正确地恢复状态.**\n\n## catch块\n\n`catch`包括的是响应一个异常需要执行的代码.  **如果try块没有抛出异常,CLR永远不会执行它的任何catch块.** 线程将跳过所有的`catch`块,直接执行`finally`(如果有的话). 然后继续执行`finally`之后的语句.\n\ncatch关键字后的圆括号中的表达式称为**捕捉类型**. C#要求捕捉类型必须是`System.Exception`或者是它的派生类型. 最后一个catch块没有指定捕捉类型,能处理除了前面的catch块指定的之外的其他所有异常. **这相当于捕捉System.Exception(只是catch块大括号中的代码访问不了异常信息).**\n\n> 可以在监视窗口中添加特殊变量名称$exception来查看当前抛出的异常对象\n\nCLR自上而下搜索匹配的`catch`块. 较具体的异常类型放在顶部, 最后是`System.Exception`.\n\n在`try`块的代码(或者从`try`块调用的任何代码)中抛出异常, CLR将搜索`捕捉类型`与抛出的异常相同的`catch`块. **如果没有匹配的,CLR回去调用`栈`更高的一层去搜索与异常匹配的捕捉类型, 如果到了栈的顶部还是没有找到匹配的catch块,就会发生未处理的异常.**\n\n**一旦CLR找到匹配的`catch`块,就会执行内层所有`finally`块中的代码.**.\n\n> 所谓`内层finally块`是指从抛出异常的`try`块开始, 到匹配异常的`catch`块之间的所有`finally`块\n\n**注意,匹配异常的那个`catch`块所关联的`finally`块尚未执行,该`finally`块中的代码一直要等到这个`catch`块中的代码执行完毕后才会执行.**\n\n所有`内层finally块`执行完毕之后,匹配异常的那个`catch`块中的代码开始执行. `catch`块中的代码通常执行一些对异常处理的操作, 在`catch`块的末尾,有以下三个选择:\n- 重新抛出相同的异常,向调用栈高一层的代码通知该异常的发生\n- 抛出一个不同的异常,想调用栈高一层的代码提供更丰富的异常信息.\n  - 这两种技术将抛出异常,CLR的行为就和之前说的,回溯调用栈(去更高一层查找捕捉类型和抛出的异常类型匹配的`catch`块).\n- 让线程从`catch`块的底部退出(正常执行下去,并执行匹配的`finally`块).\n  - 最后一种是当线程`catch`块的底部退出后,立即执行包含在`finally`块中的代码. 执行完毕后,线程退出`finally`块.\n\nC#允许在`捕捉类型`后指定一个变量. 该变量引用抛出异常的对象,`catch`块可以通过引用此变量来访问异常的具体信息(例如发生时的堆栈跟踪), 最好把它当成是只读的,不建议修改.\n\n> 你的代码可以向AppDomain的`FirstChanceException事件`登记, 这样只要AppDomain中发生异常,就会收到通知. 这个通知是在CLR开始搜索任何`catch块`**之前** 发生的.\n\n## finally块\n\n`finally`块包含的是保证会执行的代码. 一般在`finally`块中执行`try`块的行动所要求的资源清理操作.\n\n![](20异常和状态管理/QQ截图20190908152538.png)\n\n例如,在`try`块中打开了文件,就应该将关闭文件的代码放到`finally`块中.\n\n```csharp\ntry\n{\n   // 不管此句代码是否会发生异常, 文件保证会在finally块中被关闭.\n   fs = FileStream(pathname, FileMode.Open);\n}\ncatch(IOException)\n{\n   // 在此添加从IOException恢复的代码\n}\nfinally\n{\n   // 确保文件被关闭\n   if(fs != null) fs.Close();\n}\n\n// 这句话不能发在外部, 因为如果没有捕捉到异常, finally块中后面的语句就不会执行\n// 以至于文件不会被关闭, 造成文件一直保持打开状态(直到下一次垃圾回收)\n// if(fs != null) fs.Close();\n```\n\n一个`try`块最多只能关联一个`finally`块,而且必须出现在所有的`catch`块之后.\n\n记住`finally`块中的代码是清理代码. 这些代码只需对`try`块中发起的操作进行清理.\n\n**如果在`catch`块和`finally`块内部抛出了异常,CLR的异常机制仍会正常运转.** 就好像异常是在`finally`块之后抛出的一样. 出现这种情况,CLR不会记录对应的`try`块中抛出的第一个异常,关于第一个异常的所有堆栈跟踪信息都将丢失, 并且程序也会被CLR终止.\n\n## CLS和非CLS异常\n\nC#编译器值允许代码抛出从`Exception`派生的对象,而用其他一些语言写的代码不仅允许抛出`Exception派生对象`,还允许抛出`非Exception派生对象`.\n\nCLR2.0的版本中引入了新的`RuntimeWrappedException类`,派生自`Exception`. `WrappedException`含有一个Object类型的私有字段, 在非CLS相容的一个异常被抛出时, CLR会自动构造这个类的实例, 初始化这个字段,使之引用实际抛出的对象. 这样就能捕捉非CLS相容的异常, 任何捕捉Exception类型的代码都能捕捉非CLS相容的异常.消除了安全隐患.\n\n![](20异常和状态管理/QQ截图20190908161027.png)\n\n\n# Exception类\n\nException是一个很简单的类型,一般不写任何代码以任何方式查询或访问这些属性. 在应用程序因为未处理的异常而终止时, 可以在调试器中查看这些属性,或者在Windows应用程序事件日志或崩溃转储(crash dump)中查看.\n\n![](20异常和状态管理/QQ截图20190908162101.png)\n\n- 只读`StackTrace`属性:\n  - `catch`块可读取该属性来获取一个堆栈跟踪(stack trace). **它描述了异常发生前调用了哪些方法.**\n  - 访问该属性实际会调用CLR中的代码\n  - 该属性并不是简单地返回一个字符串\n    - 构造`Exception`派生类型的新对象时,`StackTrace`属性被初始化为`null`\n\n一个异常抛出时, CLR在内部记录throw指令的位置(抛出位置). 一个`catch`块捕捉到该异常时, CLR会记录捕捉位置. 在`catch`块内访问被抛出的异常对象的`StackTrace`属性, 负责实现该属性的代码会调用CLR内部的代码, 后者创建一个字符串来指出从异常抛出位置到异常捕捉位置的所有方法.\n\n抛出异常时, CLR会重置异常起点,也就是说,CLR只记录最新的异常对象的抛出位置.\n\n```csharp\nprivate void SomeMethod()\n{\n   try { ... }\n   catch (Exception e)\n   {\n      ...\n      // 抛出\n      throw e; // CLR认为这是异常的起点, Fxcop报错\n   }\n}\n\nprivate void SomeMethod2()\n{\n   try { ... }\n   catch (Exception e)\n   {\n      ...\n      // 重新抛出异常\n      throw; // 不影响CLR对异常起点的认知,Fxcop不再报错\n   }\n}\n```\n\n两个方法的区别是: CLR对于异常起始抛出位置的认知. `window`都会重置栈的起点. 如果有一个异常成为未处理的异常, 那么向`Window Error Reporting`报告的栈位置就是最后一次抛出或重新抛出的位置(即使CLR知道异常的原始抛出位置).\n\n`StackTrace属性`返回的字符串不包含调用**栈**中比接受异常对象的那个`catch`高的任何方法. 要获得从线程起始处到异常处理程序(`catch`块)之间的完整堆栈跟踪, 需要使用`System.Diagnostics.StackTrace`类型, 该方法定义了一些属性和方法,允许开发人员程序化地处理堆栈以及构成堆栈跟踪的**栈帧**.\n\n> 栈帧: 代表当前线程调用栈中的一个方法调用. 执行线程的过程中进行的每个方法调用都会在调用栈中创建并压入一个StackFrame.\n\n**如果CLR能找到你的程序集的调试符号(存储在.pdb文件中), 那么在`System.Exception`的`StackTrace属性`或者`System.Diagnostics.StackTrace`的ToString方法返回的字符串中,将包括源代码文件路径和代码行号. 这些信息对于调试很有用.**\n\n获得堆栈跟踪后,可能发现一些方法没有出现在堆栈跟踪字符串中. 有两方面的原因:\n- 调用栈记录的是线程的返回位置(而非来源位置)\n- JIT编译器可能进行了优化\n  - 将一些方法内联,以避免调用单独的方法并从中返回的开销.\n  - /debug命令行开关,使用这个开关可以在生成的程序集中嵌入信息,告诉编译器不要内联程序集中的任何方法. 确保调试人员获得完整的更有意义的堆栈跟踪.\n\n## 用特性禁止方法内联\n\n设置/debug命令行开关就是设置了`DebuggableAtrriable`定制特性,如果指定了`DisableOptimizations`标志,JIT编译器就不会对程序集的方法进行任何内联.\n\n单独方法则应用`MethodImpIAttribute`特性.\n\n![](20异常和状态管理/QQ截图20190908173529.png)\n\n# FCL定义的异常类\n\nException派生类的结构层次:\n\n```csharp\n//#define TEST\n//#define VERIFY\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text;\n\n\npublic static class Program\n{\n    public static void Main()\n    {\n        // 显式加载想要反射的程序集\n        LoadAssemblies();\n\n        // 对所有类型进行筛选和排序\n        var allTypes =\n            (from a in new[] {typeof(Object).Assembly} // AppDomain.CurrentDomain.GetAssemblies()\n                from t in a.ExportedTypes\n                where typeof(Exception).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo())\n                orderby t.Name\n                select t).ToArray();\n\n        // 生成并显示继承层次结构\n        Console.WriteLine(WalkInheritanceHierarchy(new StringBuilder(), 0, typeof(Exception), allTypes));\n    }\n\n    private static StringBuilder WalkInheritanceHierarchy(StringBuilder sb, Int32 indent, Type baseType,\n        IEnumerable<Type> allTypes)\n    {\n        String spaces = new String(' ', indent * 3);\n        sb.AppendLine(spaces + baseType.FullName);\n        foreach (var t in allTypes)\n        {\n            if (t.GetTypeInfo().BaseType != baseType) continue;\n            WalkInheritanceHierarchy(sb, indent + 1, t, allTypes);\n        }\n\n        return sb;\n    }\n\n    private static void LoadAssemblies()\n    {\n        String[] assemblies =\n        {\n            \"System,                        PublicKeyToken={0}\",\n            \"System.Core,                   PublicKeyToken={0}\",\n            \"System.Data,                   PublicKeyToken={0}\",\n//            \"System.Design,                 PublicKeyToken={1}\",\n//            \"System.DirectoryServices,      PublicKeyToken={1}\",\n//            \"System.Drawing,                PublicKeyToken={1}\",\n//            \"System.Drawing.Design,         PublicKeyToken={1}\",\n//            \"System.Management,             PublicKeyToken={1}\",\n//            \"System.Messaging,              PublicKeyToken={1}\",\n//            \"System.Runtime.Remoting,       PublicKeyToken={0}\",\n//            \"System.Runtime.Serialization,  PublicKeyToken={0}\",\n//            \"System.Security,               PublicKeyToken={1}\",\n//            \"System.ServiceModel,           PublicKeyToken={0}\",\n//            \"System.ServiceProcess,         PublicKeyToken={1}\",\n//            \"System.Web,                    PublicKeyToken={1}\",\n//            \"System.Web.RegularExpressions, PublicKeyToken={1}\",\n//            \"System.Web.Services,           PublicKeyToken={1}\",\n//            \"System.Xml,                    PublicKeyToken={0}\",\n//            \"System.Xml.Linq,               PublicKeyToken={0}\",\n            \"Microsoft.CSharp,              PublicKeyToken={1}\",\n        };\n\n        const String EcmaPublicKeyToken = \"b77a5c561934e089\";\n        const String MSPublicKeyToken   = \"b03f5f7f11d50a3a\";\n\n        // 获取包含 System.Object的程序集的版本\n        // We'll assume the same version for all the other assemblies\n        Version version = typeof(System.Object).Assembly.GetName().Version;\n\n        // 显式加载想要反射的程序集\n        foreach (String a in assemblies)\n        {\n            String AssemblyIdentity =\n                String.Format(a, EcmaPublicKeyToken, MSPublicKeyToken) +\n                \", Culture=neutral, Version=\" + version;\n            Assembly.Load(AssemblyIdentity);\n        }\n    }\n}\n\n\nSystem.Exception\n   System.AggregateException\n   System.ApplicationException\n      System.Reflection.InvalidFilterCriteriaException\n      System.Reflection.TargetException\n      System.Reflection.TargetInvocationException\n      System.Reflection.TargetParameterCountException\n      System.Threading.WaitHandleCannotBeOpenedException\n   System.Diagnostics.Contracts.ContractException\n   System.Diagnostics.Tracing.EventSourceException\n   System.InvalidTimeZoneException\n   System.Threading.LockRecursionException\n   System.Runtime.CompilerServices.RuntimeWrappedException\n   System.SystemException\n      System.Threading.AbandonedMutexException\n      System.AccessViolationException\n      System.Reflection.AmbiguousMatchException\n      System.ArgumentException\n         System.ArgumentNullException\n         System.ArgumentOutOfRangeException\n         System.Globalization.CultureNotFoundException\n         System.Text.DecoderFallbackException\n         System.DuplicateWaitObjectException\n         System.Text.EncoderFallbackException\n      System.ArithmeticException\n         System.DivideByZeroException\n         System.NotFiniteNumberException\n         System.OverflowException\n      System.ArrayTypeMismatchException\n      System.BadImageFormatException\n      System.Security.Cryptography.CryptographicException\n      System.DataMisalignedException\n      System.ExecutionEngineException\n      System.Runtime.InteropServices.ExternalException\n         System.Runtime.InteropServices.COMException\n         System.Runtime.InteropServices.SEHException\n      System.FormatException\n         System.Reflection.CustomAttributeFormatException\n      System.IndexOutOfRangeException\n      System.InsufficientExecutionStackException\n      System.InvalidCastException\n      System.Runtime.InteropServices.InvalidComObjectException\n      System.Runtime.InteropServices.InvalidOleVariantTypeException\n      System.InvalidOperationException\n         System.ObjectDisposedException\n      System.InvalidProgramException\n      System.IO.IOException\n         System.IO.DirectoryNotFoundException\n         System.IO.EndOfStreamException\n         System.IO.FileLoadException\n         System.IO.FileNotFoundException\n         System.IO.PathTooLongException\n      System.Collections.Generic.KeyNotFoundException\n      System.Runtime.InteropServices.MarshalDirectiveException\n      System.MemberAccessException\n         System.FieldAccessException\n         System.MethodAccessException\n         System.MissingMemberException\n            System.MissingFieldException\n            System.MissingMethodException\n      System.Resources.MissingManifestResourceException\n      System.Resources.MissingSatelliteAssemblyException\n      System.MulticastNotSupportedException\n      System.NotImplementedException\n      System.NotSupportedException\n         System.PlatformNotSupportedException\n      System.NullReferenceException\n      System.OperationCanceledException\n         System.Threading.Tasks.TaskCanceledException\n      System.OutOfMemoryException\n         System.InsufficientMemoryException\n      System.RankException\n      System.Reflection.ReflectionTypeLoadException\n      System.Runtime.InteropServices.SafeArrayRankMismatchException\n      System.Runtime.InteropServices.SafeArrayTypeMismatchException\n      System.Security.SecurityException\n      System.Threading.SemaphoreFullException\n      System.Runtime.Serialization.SerializationException\n      System.StackOverflowException\n      System.Threading.SynchronizationLockException\n      System.Threading.ThreadAbortException\n      System.Threading.ThreadInterruptedException\n      System.Threading.ThreadStartException\n      System.Threading.ThreadStateException\n      System.TimeoutException\n      System.TypeInitializationException\n      System.TypeLoadException\n         System.DllNotFoundException\n         System.EntryPointNotFoundException\n         System.TypeAccessException\n      System.TypeUnloadedException\n      System.UnauthorizedAccessException\n      System.Security.VerificationException\n   System.Threading.Tasks.TaskSchedulerException\n   System.TimeZoneNotFoundException\n```\n\nMicrosoft本来是打算将`System.Exception`类型作为所有异常的基类型, 而另外两个类型`System.SystemException`和`System.ApplicationException`是唯一直接从Exception派生的类型.另外CLR抛出的所有异常都从`SystemException`派生,应用程序抛出的异常都从`ApplicationException`派生, 这样就可以写一个`catch块`来捕捉CLR抛出的所有异常或者应用程序抛出的所有异常.\n\n从上段代码中看出, 规则没有得到严格遵守. 有的异常直接从`System.Exception`派生, 有的CLR异常从`ApplicationException`中派生, 这根本就是一团糟, 所以上述2个类型现在没有特殊含义, 也不方便去改正,这会破坏现有的代码对这两个类型的引用.\n\n\n# 抛出异常\n\n实现自己的方法时, 如果方法无法完成方法名所指明的任务, 就应抛出一个异常. 要考虑两个问题:\n\n1. 是抛出什么`Exception`派生类型. 应选择一个有意义的类型.\n  1. 强烈建议定义**浅而宽**的异常类型层次结构, 以创建尽量少的基类.\n  2. 原因是基类的主要作用就是将大量错误当做一个错误,而这通常是危险的.\n  3. 基于这样的考虑永远不要抛出一个`Exception`对象,抛出其他任何基类异常类型时也要特别谨慎.\n\n![](20异常和状态管理/QQ截图20190908185958.png)\n\n> 事实上,System.Exception 类标记为 abstract 在编译时旧禁止代码试图抛出它.\n\n\n2. 向异常类型的构造器传递什么字符串消息\n  1. 抛出异常时应包含一条字符串消息,详细说明方法为什么无法完成任务. 在未处理的情况下通常会被写入日志.\n\n\n# 定义自己的异常类\n\n设计自己的异常不仅繁琐,还容易出错. 主要原因是从Exception派生的所有类型都应该是可序列化的(serializable), 使它们能穿越AppDomain边界或写入日志/数据库. 序列化设计很多问题.\n\n以下写了一个自己的泛型`Exception<TExceptionArgs>`类:\n\n```csharp\npublic static class Program\n{\n    public static void Main()\n    {\n        try\n        {\n            throw new Exception<DiskFullExceptionArgs>( new DiskFullExceptionArgs(@\"C:\\\"), \"The disk is full.\");\n        }\n        catch (Exception<DiskFullExceptionArgs> e)\n        {\n            Console.WriteLine(e.Message);\n        }\n    }\n}\n\n/// <summary>表示在应用程序执行期间发生的错误</summary>\n/// <typeparam name=\"TExceptionArgs\">异常的类型和与之关联的任何附加参数</typeparam>\n[Serializable]\npublic sealed class Exception<TExceptionArgs> : Exception, ISerializable where TExceptionArgs : ExceptionArgs\n{\n    private const    String         c_args = \"Args\"; // 用于序列化和反序列化\n    private readonly TExceptionArgs m_args;\n\n    /// <summary>返回对此异常的附加参数的引用</summary>\n    public TExceptionArgs Args\n    {\n        get { return m_args; }\n    }\n\n    /// <summary>\n    /// 使用指定的错误消息和对导致此异常的内部异常的引用初始化异常类的新实例。\n    /// </summary>\n    /// <param name=\"message\">解释异常原因的错误消息.</param>\n    /// <param name=\"innerException\">导致当前异常的异常,如果没有指定内部异常，则为空引用\n    public Exception(String message = null, Exception innerException = null)\n        : this(null, message, innerException)\n    {\n    }\n\n    // 第四个公共构造函数，因为有一个字段\n    public Exception(TExceptionArgs args, String message = null, Exception innerException = null)\n        : base(message, innerException)\n    {\n        m_args = args;\n    }\n\n    // 这个构造器用于反序列化: 由于类是密封的,所以构造器是私有的\n    // 如果这个类不是密封的,这个构造器就应该受保护的\n    [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]\n    private Exception(SerializationInfo info, StreamingContext context)\n        : base(info, context)\n    {\n        // 让基类反序列化它的字段\n        m_args = (TExceptionArgs) info.GetValue(c_args, typeof(TExceptionArgs));\n    }\n\n    // 这个方法用于序列化,由于ISerializable接口,所以它是公共的\n    [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]\n    public override void GetObjectData(SerializationInfo info, StreamingContext context)\n    {\n        info.AddValue(c_args, m_args);\n        base.GetObjectData(info, context);\n    }\n\n    public override String Message\n    {\n        get\n        {\n            String baseMsg = base.Message;\n            return (m_args == null) ? baseMsg : baseMsg + \" (\" + m_args.Message + \")\";\n        }\n    }\n\n    public override Boolean Equals(Object obj)\n    {\n        Exception<TExceptionArgs> other = obj as Exception<TExceptionArgs>;\n        if (other == null) return false;\n        return Object.Equals(m_args, other.m_args) && base.Equals(obj);\n    }\n\n    public override int GetHashCode()\n    {\n        return base.GetHashCode();\n    }\n}\n\n/// <summary>\n/// 自定义异常派生的基类，以便添加自己的异常参数。\n/// </summary>\n[Serializable]\npublic abstract class ExceptionArgs\n{\n    /// <summary>The string message associated with this exception.</summary>\n    public virtual String Message\n    {\n        get { return String.Empty; }\n    }\n}\n\n[Serializable]\npublic sealed class DiskFullExceptionArgs : ExceptionArgs\n{\n    private readonly String m_diskpath; // 构造时设置私有字段\n\n    public DiskFullExceptionArgs(String diskpath)\n    {\n        m_diskpath = diskpath;\n    }\n\n    // 返回字段的公共只读属性\n    public String DiskPath\n    {\n        get { return m_diskpath; }\n    }\n\n    // 重写Message属性来包含我们的字段\n    public override String Message\n    {\n        get { return (m_diskpath == null) ? base.Message : \"DiskPath=\" + m_diskpath; }\n    }\n}\n```\n\n\n# 用可靠性换取开发效率\n\n编译器隐式地做下面这些事情:\n\n- 调用方法时插入可选参数\n- 对值类型的实例进行装箱\n- 构造/初始化参数数组\n- 绑定到dynamic变量/表达式的成员\n- 绑定到扩展方法\n- 绑定/调用重载的操作符(方法)\n- 构造委托对象\n- 在调用泛型,声明局部变量和使用lambda表达式时推断类型\n- 为lambda表达式和迭代器定义/构造`闭包类`\n  - 闭包(closure)是由编译器生成的数据结构(一个C#类), 其中包含一个表达式以及对表达式进行求值所需的变量(C#的公共字段). 变量运行在不改变表达式签名的前提下,将数据从表达式的一次调用传递到下一次调用.\n- 定义/构造/初始化匿名类型及其实例\n- 重写代码来支持LINQ查询表达式和表达式树\n\nCLR隐式做了下面这些事情:\n\n- 调用虚方法和接口方法\n- 加载程序集并对方法进行JIT编译,可能会抛出以下异常\n  - FileLoadException\n  - BadImageFormatException\n  - InvalidProgramException\n  - FieldAccessException\n  - MethodAccessException\n  - MissingFieldException\n  - VerificationException\n- 访问`MarshalByRefObject`派生类型的对象时穿越AppDomain边界\n  - 可能抛出AppDimainUnloadedException\n- 穿越AppDomain边界时序列换和反序列化对象\n- 调用`Thread.Abort`或`AppDomain.Unload`时造成线程抛出ThreadAbortException\n- 垃圾回收之后,在回收对象的内存之前调用Finalize方法\n- 使用泛型类型时,在`Loader堆`中创建类型对象.\n  - 每个`AppDomain`都有一个自己的`托管堆`,这个`托管堆`内部又按照功能进行了不同的划分,其中最重要的就是`GC堆`和`Loader堆`,`Loader堆`负责存储类型的元数据,也就是所谓的**类型对象**, 在每个**类型对象**的末尾,都含有一个方法表.\n- 调用类型的`静态构造器(类型构造器)`\n  - 可能抛出TypeInitalizationException\n- 抛出各种异常\n\n\n**异常的好处在于,未处理的异常会造成应用程序终止,再是但测试和部署之后不希望发生应用程序终止,就会插入System.Exception,也就是所有溢出的基类, 捕捉到异常并使程序能够继续运行.**\n\n例如前面的转账代码: 如果在扣钱后,添加给to钱之前发生异常,如果捕捉异常继续运行,就会发生安全性bug, 如果捕捉Exception,并将钱还给from账户,如果转账这个方法简单,这个方案确实可行. 但是Transfer方法还要生成关于取钱的审计记录,或者其他线程同时操作同一个账户,那么撤销undo操作本身就可能失败,造成抛出其他异常.\n\n![](20异常和状态管理/QQ截图20190909102735.png)\n\n为了缓解对状态的破坏, 可以做下面几件事情.\n\n- 执行catch或Finally块中的代码时, CLR不允许线程终止. 所以可以像下面这样使Transfer方法变得更健壮\n  - 但绝对不建议将所有代码都放到`finally块`中,这个技术只适合修改**极其敏感**的状态.\n\n```csharp\ntry{/* 什么都不做 */}\nfinally\n{\n    from -= amount;\n    // 现在,这里不可能因为 Thread.Abort或AppDomain.Unload而发生线程终止\n    to += amount;\n}\n```\n\n- 可以用`System.Diagnostics.Contracts.Contract`类向方法应用**代码协定**. 通过代码协定,在用实参和其他变量对状态进行修改之前, 可以先对这些实参和变量进行验证. 如果实参/变量遵守协定,状态被破坏的可能性将大幅降低(但不能完全消除). 如果不准守协定,则在修改任何状态前抛出异常.\n- 可以使用`约束执行区域(Constrained Execution Region,CER)`, 它能消除CLR的某些不确定性. 例如, 可让CLR在进入`try块`之前加载与这个`try块`关联的任何`catch`和`finally块`需要的程序集. 此外CLR会编译`catch``和finally块`中的所有代码, 包括从这些块中调用的所有方法. 这样尝试执行`catch块`的错误回复代码或者`finally块`中的清理代码时,可以消除众多潜在的异常(包括`FileLoad`,`MissingMember`等异常).\n- 取决于状态存在于何处, 可以利用`事务(transaction)`来确保状态要么都修改,要么都不修改.\n  - 例如, 如果数据在数据库中,事务能很好地工作. WINDOW现在还支持事务式的注册表和文件操作(仅限NTFS卷), 但是.NetFramework目前没有直接公开这个功能, 必须`P/Invoke`本机代码才行.\n    - `P/Invoke` 平台调用\n    - 参考`TransactionScope`类了解细节.\n- 使自己的方法设计更明确.\n\n```csharp\npublic static class SomeType\n{\n   private static Object s_myLockObject = new Object();\n\n   // 不建议的做法\n   public static void SomeMethod()\n   {\n      // 这个方法已经不建议使用,\n      // 如果抛出异常,是否获取了锁? 如果已经获取了锁,它就得不到释放\n      Monitor.Enter(s_myLockObject);\n\n      try\n      {\n         // 在这里执行线程安全的操作...\n      }\n      finally\n      {\n         Monitor.Exit(s_myLockObject);\n      }\n   }\n\n   // 建议做法\n   public static void SomeMethod()\n   {\n      Boolean lockTaken = false; // 假定没有获取锁\n      try\n      {\n         // 无论是否抛出异常, 以下代码都能正常工作!\n         Monitor.Enter(s_myLockObject, ref lockTaken);\n         // 在这里执行线程安全的操作...\n      }\n      finally\n      {\n         // 如果已获取锁,就释放它\n         if (lockTaken)\n         {\n            Monitor.Exit(s_myLockObject);\n         }\n\n      }\n   }\n}\n```\n\n**虽然上述建议的写法使方法变得更明确,  但在线程同步锁的情况下, 现在的建议是根本不要随同异步处理使用它们.(参考30章混合线程同步构造).**\n\n## 关于状态已损坏之后的处理\n\n如果确定状态已经损坏到无法修复的成都,就应该销毁所有损坏的状态,防止它造成更多的伤害. 然后重启应用程序,将状态初始化到良好状态.\n\n1. 因为托管的状态泄露不到AppDomain外部,所以为了销毁AppDomain中的所有损坏状态, 调用AppDomian.Unload方法来卸载整个AppDomain.\n\n如果觉得状态过于糟糕,以至于整个进程都应该终止,那么应该调用Enviroment的静态FailFast方法:\n\n1. `public static void FailFast(String message);`\n2. `public static void FailFast(String message, Exception exception);`\n\n这个方法终止进程时, 不会允许任何活动的`try/catch块`或者`Finalize方法(注意不是finally块)`. 之所以这样做, 是因为在状态已损坏的前提下执行更多的代码, 很容易使局面变得更坏. 不过`FailFast`为从`CriticalFinalizaerObject`派生的任何对象提供了进行清理的机会, 因为它们一般只是关闭**本机资源**; 而即使CLR或者你的应用程序的状态发生损坏.window状态可能是好的. `FailFast方法`将消息字符串和可选的异常(通常是`catch`捕捉到的异常)写入Windows Application事件日志,生成window错误报告,创建应用程序的`内存转储(dump)`,然后终止当前进程.\n\n![](20异常和状态管理/QQ截图20190909112137.png)\n\n**以上讨论主要是为了让你意识到CLR异常处理机制存在的一些问题. 大多数应用程序都不能容忍状态受损而继续运行. 因为这样会造成不正确的数据,甚至可能造成安全漏洞.**\n","tags":["CLR读书笔记"]},{"title":"19可空值类型","url":"/2019/09/06/19可空值类型/","content":"\n\n# 可空值类型\n\n我们知道值类型的变量永远不会为`null`;它总是包含值类型的值本身.  这正是值类型一词的由来.\n\n有些情况下会成为问题: 例如在设计数据库时,可以将一列数据类型定义为32位整数,并映射到FCL中的Int32数据类型, 但是数据库中的一列可能允许值为空,这样在CLR中就没办法将Int32值表示为null.\n\n![](19可空值类型/QQ截图20190906130043.png)\n\n另一个例子:Java的java.util.Date类是引用类型,所以该类型的变量能设为null. 但是CLR的System.DateTime是值类型,无法设为null.\n\n为了解决这个问题.CLR中引入了 **可空值类型** 的概念. `System.Nullable<T>`\n```csharp\n// 约束T为结构, 因为引用类型本身可以为null\npublic struct Nullable<T> where T : struct\n{\n    // 这两个字段表示状态\n    private bool hasValue = false; // 假定null\n    internal T value = default(T); // 假定所有位都为0\n    ...\n}\n\n// 要在代码中使用一个可空的Int32类型,可以这么写\nNullable<Int32> x = 5;\nNullable<Int32> y = null;\nConsole.WriteLine($\"x: HasValue={x.HasValue}, Value={x.Value}\");\nConsole.WriteLine($\"y: HasValue={y.HasValue}, Value={y.GetValueOrDefault()}\");\n// 以下代码会报异常: Nullable object must have a value.\n// Console.WriteLine($\"{y.Value}\");\n\n\n// x: HasValue=True, Value=5\n// y: HasValue=False, Value=0\n```\n\n# C#对可空值类型的支持\n\nC# 允许使用相当简单的语法初始化上述两个`Nullable<Int32>`变量x和y.\n\n`Int32? x = 5;`\n\n`Int32? y = null;`\n\n在C#中`Int32?`等价于`Nullable<Int32>`,C#在此基础上更进一步,允许开发人员在可空实例上执行**转换**和**转型**.\n\n```csharp\nprivate static void ConversionsAndCasting()\n{\n    // 从非可空的 Int32 转换为 Nullable<Int32>\n    Int32? a = 5;\n    // 从'null'隐式转换为 Nullable<Int32>\n    Int32? b = null;\n    // 从 Nullable<Int32> 显示转换为 Int32\n    Int32 c = (Int32)a;\n    // 在可空基类型之间的转型\n    Double? d = 5; // Int32 转型到 Double? (d是double类型 值为5)\n    Double? e = b; // Int32? 转型到 Double? (e为 null)\n}\n```\n\n还允许向可空实例应用操作符:\n\n```csharp\nprivate static void Operators()\n{\n    Int32? a = 5;\n    Int32? b = null;\n\n    // 一元操作符 (+ ++ - -- ! ~)\n    a++; // a = 6\n    b = -b; // b = null\n\n    // 二元操作符 (+ - * / % & | ^ << >>)\n    a = a + 3; // a = 9\n    b = b * 3; // b = null;\n\n    // 相等性操作符 (== !=)\n    if (a == null) { /* no */  } else { /* yes */ }\n    if (b == null) { /* yes */ } else { /* no */  }\n    if (a != b)    { /* yes */ } else { /* no */  }\n\n    // 比较操作符 (<, >, <=, >=)\n    if (a < b) { /* no */ } else { /* yes */ }\n}\n```\n\n- 一元操作符 (+,++,-,--,!,~)\n  - 操作符是null,结果也是null\n- 二元操作符 (+,-,* , /, %,&,|,^,<<,>>)\n  - **两个操作数任何一个是null, 结果就是null**\n  - **但是有一个例外: 发生在 将`&`和`|`操作符应用于`Boolean?`操作数的时候**\n  - 对于这两个操作符，如果两个操作符都不是null，那么操作符和平常一样工作。如果两个操作符都是null，结果就是null。\n  - 特殊情况就是其中之一为null时发生。下面列出了针对操作符的各种true，false和null组合：\n\n![](19可空值类型/QQ截图20190906134219.png)\n\n- 相等性操作(== , !=)\n  - 两个操作符都是null，两者相等。一个操作符为null，则两个不相等。两个操作数都不是null，就比较值来判断是否相等。\n- 关系操作符(<,>,<=,>=)\n  - **两个操作符任何一个是null，结果就是false**。两个操作数都不是null，就比较值。\n\n\n  应该注意的是，操作符实例时会生成大量代码。例如以下方法：\n```csharp\nprivate static Int32? NullableCodeSize(Int32? a, Int32? b)\n{\n　　return (a + b);\n}  \n```\n\n在编译上述方法时，**会生成相当多的IL代码**，而且会使`对可空类型`的操作符**慢于**`非可空类型`执行的同样的操作。编译器生成的代码等价于以下C#代码：\n\n```csharp\n  private static Nullable<Int32> NullableCodeSize(\n      Nullable<Int32> a, Nullable<Int32> b)\n  {\n      Nullable<Int32> nullable1 = a;\n      Nullable<Int32> nullable2 = b;\n      if (!(nullable1.HasValue & nullable2.HasValue))\n      {\n         return new Nullable<Int32>();\n      }\n      return new Nullable<Int32>(nullable1.GetValueOrDefault() + nullable2.GetValueOrDefault());\n  }  \n```\n\n重载操作符例子:\n```csharp\npublic static void Main()\n{\n    Point? p1 = new Point(1,1);\n    Point? p2 = new Point(2,2);\n\n    Console.WriteLine($\"是否相等?  {(p1 == p2).ToString()}\");\n    Console.WriteLine($\"是否不相等?{(p1 != p2).ToString()}\");\n    //是否相等?  False\n    //是否不相等? True\n\n}\n\ninternal struct Point\n{\n    private Int32 m_x, m_y;\n    public Point(Int32 x, Int32 y)\n    {\n        m_x = x;\n        m_y = y;\n    }\n    public static Boolean operator==(Point p1, Point p2)\n    {\n        return (p1.m_x == p2.m_x) && (p1.m_y == p2.m_y);\n    }\n    public static bool operator !=(Point p1, Point p2)\n    {\n        return !(p1 == p2);\n    }\n}\n```\n\n# C#的空接合操作符\n\nC#提供了一个 `空接合操作符`(null-coalescing operator) 即 `??`操作符, 它要获取两个操作数, **假如左边的操作数不为null,就返回左边这个操作数的值**. 左边操作数为null,就返回右边的操作数的值.\n\n利用`空接合操作符`,可以方便地设置变量的**默认值**.\n\n此操作符的一个好处在于,它既能用于`引用类型`,也能用于`可空值类型`.\n\n```csharp\nprivate static void NullCoalescingOperator()\n{\n    Int32? b = null;\n\n    // 下面这行等价于:\n    // x = (b.HasValue) ? b.Value : 123\n    Int32 x = b ?? 123;\n    Console.WriteLine(x); // \"123\"\n\n    // 下面这行等价于：\n    // String temp = GetFilename();\n    // filename = (temp != null) ? temp : \"Untitled\";\n    String filename = GetFilename() ?? \"Untitled\";\n}\n```\n\n关于`??`与`?:`的说明: 虽然功能相似, 但是`??`提供了重大的语法上的改进.\n\n1. `??`能更好的支持表达式\n\n```csharp\n// 更容易阅读和理解\nFunc<String> f = () => SomeMethod ?? \"Untitled\";\n\n// 要求进行变量的赋值,无法用一个语句完成\nFunc<String> f = () =>\n{\n  var temp = SomeMethod();\n  return temp !=null ? temp : \"Untitled\";\n};\n```\n\n2. `??`能在复合情形下更好用\n\n```csharp\n// 如果SomeMethod()为null,且SomeMethod2为null的前提下,s = \"Untitled\";\n// 从左到右顺序, 最右边是默认值\nString s = SomeMethod() ?? SomeMethod2() ?? \"Untitled\";\n\n\nString s;\nvar    sm1 = SomeMethod();\n// 先判断SomeMethod()是否为null,不为null,则s等于这个值.\nif (sm1 != null)\n    s = sm1;\nelse\n{\n    var sm2 = SomeMethod2();\n    if (sm2 != null)\n        s = sm2;\n    else\n        s = \"Untitled\";\n}\n```\n\n# CLR对可空值类型的特殊支持\n\nCLR内建对可空值类型的支持. 这个特殊的支持是针对\n- 装箱\n- 拆箱\n- 调用GetType\n- 调用方法\n\n使可空值类型能无缝地集成到CLR中.\n\n## 可空值类型的装箱\n\n先假定有一个为`null`的`Nullable<Int32>变量`。如果将该变量传给一个期待获取一个`Object`的方法，那么该变量必须**装箱**，并将对`已装箱的Nullable<Int32>`的`引用`传给方法。但对表面上为`null`的值进行**装箱**不符合直觉,**即使Nullable<Int32>变量本身非null，它只是在逻辑上包含了null**。为了解决这个问题，**clr会在装箱可空变量时执行一些特殊代码**，从表面上维持可空类型一等公民地位。\n\n具体地说, 当CLR对`Nullable<T>`实例进行装箱时,会检查它是否为null.\n  - 如果是: CLR不装箱任何东西,直接返回null\n  - 如果不为null: **CLR从可空实例中取出值并进行装箱.**\n    - **也就是说, 一个值为5的`Nullable<T>`会装箱成值为5的已装箱`Int32`**\n\n```csharp\n// 对Nullable<T>进行装箱，要么返回null，要么返回一个已装箱的T\nInt32? n = null;\nObject o = n; // o 为 null\nConsole.WriteLine(\"o is null={0}\", o == null); // \"True\"\n\nn = 5;\no = n; // o 引用一个已装箱的Int32\nConsole.WriteLine(\"o's type={0}\", o.GetType()); //     \"System.Int32\"\n\n// 其实在第一节中的Nullable<T>源码中已有显示，如：\nstatic object Box(T? o)\n{\n    if (!o.has_value)\n      return null;\n    return o.value;\n}\n```\n\n## 可空值类型的拆箱\n\nCLR运行将已装箱的`值类型T`拆箱为一个`T`或者`Nullable<T>`\n  - 如果对`已装箱值类型`的引用是`null`, 并且要拆箱为一个`Nullable<T>`\n  - 那么CLR会将`Nullable<T>`设为null.\n\n\n```csharp\n// 创建一个已装箱的Int32\nObject o = 5;\n\n// 把它拆箱为一个 Nullable<Int32> 和一个 Int32\nInt32? a = (Int32?)o; // a = 5\nInt32 b = (Int32)o; // b = 5\n\n// 创建初始化为null的一个引用\no = null;\n// 把它\"拆箱\"为一个Nullable<Int32> 和一个 Int32\na = (Int32?)o; // a = null\nb = (Int32) o; // NullReferenceException\n\n// 同样的，在第一节中的Nullable<T>源码中已有显示，如：\nstatic T? Unbox(object o)\n{\n    if (o == null)\n    return null;\n\n    return (T)o;\n}\n```\n\n\n## 通过可空值类型调用GetType\n\n在一个`Nullable<T>`对象上调用`GetType`时，CLR实际上会\"撒谎\"说类型是`T`，而不是`Nullable<T>`。以下代码演示了这一行为:\n\n```csharp\nInt32? x = 5;\n// 下面会显示\"System.Int32\"而不是\"System.Nullable<Int32>\"\nConsole.WriteLine(x.GetType());\n\nInt32? x = null;\n// 空指针异常 NullReferenceException\n// Console.WriteLine(x.GetType());\n```\n\n\n## 通过可空值类型调用接口方法\n\n在下面代码中，将一个`Nullable<Int32>`类型的`变量n`转型为一个接口类型`IComparable<Int32>`。然而，`Nullable<T>`不像`Int32`那样实现了`IComparable<Int32>`接口。C#编译器允许这样的代码通过编译，而且CLR的校验器也会认为这样的代码是可验证的，从而允许我们使用一种更简洁的语法：\n\n```csharp\nInt32? n = 5;\nInt32 result = ((IComparable<Int32>) n).CompareTo(5); // 能顺利通过编译和允许\nConsole.WriteLine(result); // 0\n\n// 假如CLR没有提供这一特殊支持，那么为了在一个可空值类型上调用接口方法，就要写非常繁琐的代码。\n// 首先必须转型对已拆箱的值类型，\n// 然后才能转型为接口以发出调用：\nresult = ((IComparable)(Int32) n).CompareTo(5); // 这太繁琐了\nConsole.WriteLine(result); // 0\n\n```\n","tags":["CLR读书笔记"]},{"title":"18定制特性","url":"/2019/08/31/18定制特性/","content":"\n# 定制特性\n\n.Net Framework最具有创意的功能之一: 定制特性.\n\n可以`宣告式地`为`自己的代码构造`添加`注解`来实现`特殊功能`. 允许为几乎每一个元数据记录项定义和应用信息. 这种可扩展的元数据信息能在运行时查询,从而动态改变代码的执行方式.\n\n\n# 使用定制特性\n\n关于自定义特性, **首先要知道它们只是将一些附加信息与某个目标元素关联起来的方式.** 编译器在托管模块的元数据中生成(嵌入)这些额外的信息.\n\nFCL定义了几百个定制特性,例如:\n- `DllImport`应用于方法, 告诉CLR此方法的实现位于指定DLL的非托管代码中.\n- `Serializable`应用于类型, 告诉`序列格式化器`一个实例的字段可以序列化和反序列化.\n  - 格式化器是实现了`IFormatter接口`的类型,它知道如何序列化和反序列化一个对象组.\n- `AssemblyVersion`应用于程序集, 设置程序集的版本号\n- `Flags`应用于枚举类型, 枚举类型就成了位标志(bit flags)集合\n\n\nCLR允许将特性应用于可在文件的元数据中表示的几乎任何东西, 最常应用特性的还是以下`定义表`中的记录项:`TypeDef(类,结构,枚举,接口和委托),MethodDef(含构造器),ParamDef,FieldDef,Property,EventDef,AssemblyDef,ModuleDef.`\n\nC# 值允许将特性应用于定义以下任何目标元素的源代码: `程序集,模块,类型(类,结构,枚举,接口,委托),字段,方法(含构造器),方法参数,方法返回值,属性,事件和泛型参数`.\n\n```csharp\n// 不能省略前缀,必须向编译器清楚的表明我们的意图\n[assembly: MyAttr(1)] // 应用于程序集\n[module: MyAttr(2)]   // 应用于模块\n\n// 可省略前缀, 编译器可以判断此特性要应用于什么目标元素\n// [MyAttr(3)]\n[type: MyAttr(3)]     // 应用于类型\ninternal sealed class SomeType <[typevar: MyAttr(4)] T> // 应用于泛型类型变量\n{\n\n    [field: MyAttr(5)] // 应用于字段\n    public Int32 SomeField = 0;\n\n    [return: MyAttr(6)] // 应用于返回值   不能省略前缀.\n    [method: MyAttr(7)] // 应用于方法\n    public Int32 SomeMethod(\n        [param: MyAttr(8)] // 应用于方法参数\n        Int32 SomeParam)\n    {\n        return SomeParam;\n    }\n\n    [property: MyAttr(9)] // 应用于属性\n    public String SomeProp\n    {\n        [method: MyAttr(10)] // 应用于get访问器方法\n        get { return null; }\n    }\n\n    [event: MyAttr(11)]  // 应用于事件\n    [field: MyAttr(12)]  // 应用于编译器生成的字段  不能省略前缀\n    [method: MyAttr(13)] // 应用于编译器生成的add&&remove方法  不能省略前缀\n    public event EventHandler SomeEvent;\n}\n\n[AttributeUsage(AttributeTargets.All)]\npublic class MyAttr : Attribute\n{\n    public MyAttr(Int32 x)\n    {\n    }\n}\n```\n\n\n**定制特性其实是一个类型的实例.** 符合CLS的要求,**定制特性必须直接或者间接从公共抽象类型Attribute派生.**\n\n> C# 编译器允许省略Attribute后缀,减少打字量. 例如 : [DllImport(...)] 而不是 [DllImortAttribute(....)]\n\n\n特性是类的实例. 类必须有公共构造器才能创建它的实例. **所以将特性应用于目标元素时,语法类似于调用类的某个实例构造器.** C#语言还支持特殊的语法, 允许设置与特性类关联的公共字段或属性.\n\n`[DllImport(\"kernel32\",CharSet = CharSet.Auto, SetLastError = true)]`\n\n这个特性传递了一些东西, 调用构造器时永远不会出现这样的语法. 在这个例子中，\"Kernel32\"这个String类型的参数已经传给它了。**构造器的参数称为\"定位参数\"，而且是强制性的。也就是说，应用attribute时，必须指定参数。** 那么，另外两个\"参数\"是什么？这种特殊的语法允许在DllImportAttbute对象构造好之后，**设置对象的任何公共字段和属性**。\n\n在这个例子中，当DllImportAttbute对象构造好，而且将`\"Kernel32\"`传给构造器之后，对象的公共实例字段`CharSet`和`SetListError`被分别设置为`CharSet.Auto`和`true`。**用于设置字段或属性的\"参数\"被称为\"命名参数\"。** 这种参数是可选的，因为在应用attribute的一个实例时，不一定要指定命名参数。\n\n\n还 **可以将多个attribute应用于一个目标元素。** 将多个attribute应用一个目标元素时，**attribute的顺序是无关紧要的**。在C#中，可将每个attribute都封闭到一对`方括号`中，也可以在一对方括号中封闭多个以逗号分隔的attribute。\n\n如果特性类的构造器不获取参数,那么圆括号也可以省略.\n\n```csharp\n[Serializable][Flags]\n[Serializable, Flags]\n```\n\n\n# 定义自己的特性类\n\n- 定义一个`FlagsAttribute`类(Attribute后缀可以省略),继承于`Attribute`.\n- 非抽象特性至少要包含一个公共构造器.\n\n应将特性想象成`逻辑状态容器`. 也就是说,虽然特性类型是一个类, 但这个类应该很简单.\n- 只提供一个公共构造器来接受特性的强制性(或定位器)状态信息(例如 构造器的参数),\n- 而且这个类可以提供公共字段和属性, 来接受特性的可选状态信息(例如`CharSet = CharSet.Auto, SetLastError = true`).\n- 特性类不应该提供任何公共方法,事件或其他成员.\n\n> 一般不鼓励使用`公共字段`. 特性也不例外, 使用`属性`要好的多,属性能提供更大的灵活性.\n\n\n`FlagsAttribute`类的实例现在能应用于任何目标元素, 事实上应该只能应用于枚举,应用在其他类型上没有意义, 所以需要给特性类应用`System.AttributeUsageAttribute`类的实例.\n\n```csharp\nnamespace System\n{\n    // 特性类型本质还是类,所以可以应用特性\n    [AttributeUsage(AttributeTargets.Enum, Inherited = false)]\n    public class FlagsAttribute : System.Attribute\n    {\n        public FlagsAttribute()\n        {\n        }\n    }\n}\n```\n\n`AttributeUsage`是一个简单的类,告诉编译器定制的特性的合法应用范围, 所有编译器都内建了对该特性的支持. 源码如下:\n\n> 如果没有向自己的类应用AttributeUsage特性, 编译器会有默认设定: 默认可以应用于所有元素,只能向每个目标应用一次, 可继承.\n\n```csharp\nnamespace System\n{\n  // 可应用于类\n  [AttributeUsage(AttributeTargets.Class, Inherited = true)]\n  public sealed class AttributeUsageAttribute : Attribute\n  {\n    internal static AttributeUsageAttribute Default = new AttributeUsageAttribute(AttributeTargets.All);\n    // 默认是支持全类型\n    private AttributeTargets _attributeTarget = AttributeTargets.All;\n    // 默认是可继承\n    private bool _inherited = true;\n    // 默认只能应用一次\n    private bool _allowMultiple;\n\n    // 公共构造器,需要一个枚举参数(位标志)\n    public AttributeUsageAttribute(AttributeTargets validOn)\n    {\n      this._attributeTarget = validOn;\n    }\n\n    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited)\n    {\n      this._attributeTarget = validOn;\n      this._allowMultiple = allowMultiple;\n      this._inherited = inherited;\n    }\n\n    public AttributeTargets ValidOn\n    {\n      get\n      {\n        return this._attributeTarget;\n      }\n    }\n    // 是否允许多次应用于同一个目标\n    // 大部分特性这样做没有意义\n    public bool AllowMultiple\n    {\n      get\n      {\n        return this._allowMultiple;\n      }\n      set\n      {\n        this._allowMultiple = value;\n      }\n    }\n    // 特性应用于基类时,是否同时应用于派生类和重写的方法\n    public bool Inherited\n    {\n      get\n      {\n        return this._inherited;\n      }\n      set\n      {\n        this._inherited = value;\n      }\n    }\n  }\n}\n```\n\n- `AllowMultiple`\n  - 有少数特性有必要多次应用于同一目标,  FCL特性类`ConditionalAttribute`允许将它的多个实例应用于同一个目标元素,  **不将AllowMultiple明确设为true,特性就只能想选定的目标元素应用一次.**\n- `Inherited`\n  - 特性应用于基类时,是否同时应用于派生类和重写的方法\n\n```csharp\n// 可将此特性应用于类和方法,并且该特性会被子类继承\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method , Inherited = true)]\ninternal class TastyAttribute : Attribute\n{}\n\n[Tasty] [Serializable]\ninternal class BaseType\n{\n   [Tasty] protected virtual void Do(){}\n}\n\n// 无法序列化, 因为Serializable被标记为不可继承\ninternal class DerivedType : BaseType\n{\n   // 此方法会被视为[Tasty]\n   protected override void Do()\n   { }\n}\n```\n\n**注意: .NetFramework只认为 `类`, `方法`, `属性`, `事件`, `字段`, 方法返回值和参数等目标元素可继承. 只有在该特性应用于上述某个目标的前提下, 才将`Inherited`设为true,  可继承特性不会造成在托管模块中为派生类型生成额外的元数据.**\n\n\n# 特性构造器和字段/属性数据类型\n\n定制特性类可定义构造器来获取参数. 使用特性时必须指定这些参数,可以在类中定义`非静态公共字段`和`属性`. 在定义特性类的实例构造器,字段和属性时, 可供选择的数据类型并不多. 具体地说,只允许`Boolean,Char,Byte,SByte,Int16,UInt16,Int32,UInt32,Int64,UInt64,Single,Double,String,Type,Object或枚举类型.` 也可以是使用上述任意类型的一维0基数组, 但应尽量避免使用数组.因为定制特性如果它的构造器要获取数组作为参数,就会失去与CLS的相容性.\n\n**应用特性时必须传递一个编译时常量表达式, 它与特性类定义的类型匹配.**\n\n- 在特性类定义了一个`Type`参数,字段或者属性的任何地方,都必须使用C# `typeof`操作符.\n- 在特性类定义了一个`Object`参数,字段或者属性的任何地方,都可以传递一个`Int32`,`String`或其他`任何常量表达式`(包括`null`)\n  - 如果常量表达式代表`值类型`,那么在运行时构造特性的实例时会对`值类型`进行 **装箱**.\n\n```csharp\npublic enum Color\n{\n    Red\n}\n\n[AttributeUsage(AttributeTargets.All)]\ninternal sealed class SomeAttribute : Attribute\n{\n    // 构造器中的参数 称为定位参数\n    public SomeAttribute(String name, Object o, Type[] types)\n    {\n        // 'name'  引用一个String\n        // 'o'     引用一个合法的类型,如果有必要就进行装箱\n        // 'types' 引用一个一维0基Type数组\n    }\n\n    // 字段,属性称为 命名参数(可选)\n}\n\n// 应用特性时, 传入对应的参数\n// 定位参数必须要填, 命名参数可选\n[Some(\"Jeff\", Color.Red, new Type[] {typeof(Math), typeof(Console)})]\ninternal sealed class SomeType\n{\n}\n```\n\n编译器检测到目标元素应用了定制特性时, 会调用特性类的构造器,向它传递任何指定的参数, 从而构造特性类型的实例. 编辑器采用增强型构造器语法所指定的值,对任何公共字段和属性进行初始化. 构造并初始化好定制特性类的对象之后, 编译器将它的状态序列化到目标元素的元数据表记录项中.\n\n**重要提示:  为方便理解,可以这么想象定制特性, 是类的实例, 被序列化成驻留在元数据中的字节流. 运行时可对元数据中的字节进行反序列化, 从而构造出类的实例.**\n\n实际发生的事: 编译器在元数据中生成创建特性类的实例所需的信息,每个构造器参数都是1字节的类型ID,后跟具体的值.  对构造器参数进行序列化时, 编译器先写入字段/属性名称,在跟上1字节的类型ID,最后是具体的值. 如果是数组, 则会先保存数组元素的个数, 再跟上每个单独的元素.\n\n# 检测定制特性\n\n如果只是定义, 应用自己想要的所有实例,这样除了在程序集中生成额外的数据,没有其他任何意义, 在15章描述了如何将Flags特性应用于枚举类型, 从而改变`System.Enum`的`ToString`和`Format`方法的行为.\n\n方法的行为之所以改变,是因为它们会在 **运行时检查自己操作的枚举类型是否关联了`Flags`特性元数据.** 代码利用`反射`的技术检测特性的存在.\n\n```csharp\npublic override String ToString()\n{\n  // IsDefined 要求系统查看枚举类型的元数据, 是否关联了FlagsAttribute类的实例\n  if (this.GetType().IsDefined(typeof(FlagsAttribute), false))\n  {\n      // 如果是, 就将值视为一个位标志枚举类型\n      ....\n  }else\n  {\n      // 如果不是,就将值视为一个普通枚举类型\n      ...\n  }\n}\n```\n\n所以在定义定制特性时,也必须实现一些代码来检测目标上是否存在该特性类的实例.\n\nFCL提供了多种那个方式来检测特性的存在. `System.Reflection.CustomAttributeExtensions`类定义的扩展方法:\n- `IsDefined`\n- `GetCustomAttributes`\n  - 通常用于将AllowMultiple设为true的特性. 列出所有特性.\n- `GetCustomAttribute`\n  - 如果\n\n以上每个方法都有几个重载版本. **如果只想判断目标是否应用了一个特性,应该使用`IsDefined`,比另外2个方法更高效. 但是不会构造特性对象,不会调用构造器,也不会设置字段和属性.**\n\n要构造特性对象, 必须调用`GetCustomAttributes`或`GetCustomAttribute`方法, 每次调用,都会构造指定特性类的新实例, 并根据源代码中指定的值来设置每个实例的字段和属性. 两个方法都返回对完全构造好的特性类实例的引用.\n\n![](18定制特性/QQ截图20190905095104.png)\n\n**调用上述任何方法,内部都必须扫描托管模块的元数据. 执行字符串比较来定位指定的定制特性类.** 这些操作会耗费一定的时间, 可以考虑缓存这些方法调用的结果,而不是反复调用来请求相同的信息.\n\n`System.Reflection`命名空间定义了几个类允许检查模块的元数据:\n- Assembly\n- Module\n- ParameterInfo\n- MemberInfo\n- Type\n- MethodInfo\n- ConstructorInfo\n- FieldInfo\n- EventInfo\n- PropertyInfo\n- 各自的*Builder类\n\n所有类都提供了`IsDefined`和`GetCustomAttributes`方法.\n\n反射类提供的`GetCustomAttributes`方法返回的是`Object数组`(`Object[]`),而不是由`Attribute实例`构成的数组(`Attribute[]`),不过可以不用关心此不一致性.\n\n只有`Attribute`,`Type`,`MethodInfo`类才实现了支持`Boolean inherit`参数的反射方法. 其他检查特性的所有反射方法都会忽略`inherit`参数, 而且不会检查继承层次结构. **所有要检查事件,属性,字段,构造器或参数是否应用了继承的特性,只能调用Attribute的某个方法.**\n\n**还要注意**: 将一个类传给`IsDefined`,`GetCustomAttributes`,`GetCustomAttribute`方法时, 会检测是否应用了`指定的特性类`或者`指定特性类的派生类`, 如果只是想搜索一个具体的特性类, 应针对返回值执行一次额外的检查, 确保方法返回的正是想搜索的类. 还可以将自己的特性类定义为`sealed`,减少可能存在的混淆,并避免执行这个额外的检查.\n\n演示如何列出一个类型中定义的所有方法,并显示应用于每个方法的特性:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.CompilerServices;\n\npublic static class CustomAttributes\n{\n    public static void Main()\n    {\n        DetectingAttributes.Go();\n    }\n\n    [Serializable]\n    [DefaultMember(\"Main\")]\n    [DebuggerDisplay(\"Richter\", Name = \"Jeff\", Target = typeof(DetectingAttributes))]\n    public sealed class DetectingAttributes\n    {\n        [Conditional(\"Debug\")]\n        [Conditional(\"Release\")]\n        public void DoSomething()\n        {\n        }\n\n        public DetectingAttributes()\n        {\n        }\n\n\n        [MethodImpl(MethodImplOptions.NoInlining)]\n        [STAThread]\n        public static void Go()\n        {\n            Go(ShowAttributes);\n        }\n\n        // 传入一个委托对象(方法的包装)\n        private static void Go(Action<MemberInfo> showAttributes)\n        {\n            // 显示应用于这个类型的特性集\n            showAttributes(typeof(DetectingAttributes));\n\n            // 获取与类型关联的方法集\n            var members =\n                from m in typeof(DetectingAttributes).GetTypeInfo().DeclaredMembers.OfType<MethodBase>()\n                where m.IsPublic\n                select m;\n\n            foreach (MemberInfo member in members)\n            {\n                // 显示应用于这个成员的特性集\n                showAttributes(member);\n            }\n        }\n\n        private static void ShowAttributes(MemberInfo attributeTarget)\n        {\n            var attributes = attributeTarget.GetCustomAttributes<Attribute>();\n\n            Console.WriteLine(\"特性应用于 {0}: {1}\",\n                attributeTarget.Name, (attributes.Count() == 0 ? \"None\" : String.Empty));\n\n            foreach (Attribute attribute in attributes)\n            {\n                // 显示应用的每个特性的类型\n                Console.WriteLine(\"  {0}\", attribute.GetType().ToString());\n\n                if (attribute is DefaultMemberAttribute)\n                    Console.WriteLine(\"    MemberName={0}\",\n                        ((DefaultMemberAttribute) attribute).MemberName);\n\n                if (attribute is ConditionalAttribute)\n                    Console.WriteLine(\"    ConditionString={0}\",\n                        ((ConditionalAttribute) attribute).ConditionString);\n\n                if (attribute is CLSCompliantAttribute)\n                    Console.WriteLine(\"    IsCompliant={0}\",\n                        ((CLSCompliantAttribute) attribute).IsCompliant);\n\n                DebuggerDisplayAttribute dda = attribute as DebuggerDisplayAttribute;\n                if (dda != null)\n                {\n                    Console.WriteLine(\"    Value={0}, Name={1}, Target={2}\",\n                        dda.Value, dda.Name, dda.Target);\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n}\n\n// 特性应用于 DoSomething:\n//   System.Diagnostics.ConditionalAttribute\n//     ConditionString=Debug\n//   System.Diagnostics.ConditionalAttribute\n//     ConditionString=Release\n//\n// 特性应用于 Go:\n//   System.STAThreadAttribute\n//\n// 特性应用于 .ctor: None\n```\n\n\n# 两个特性实例的相互匹配\n\n判断是否向目标应用了一个特性实例,可能还需要检查特性的字段来确定它们的值.\n\n- 一个办法是 写代码检查特性类的字段值. System.Attribute重写了Object的Equals方法,会在内部比较两个对象的类型,`类型一致`的话会`利用反射`来比较两个`特性对象中的字段值`, 每个字段都调用Equals方法, 所有字段匹配才返回true.\n  - 可以在自己的定制特性类中`重写Equals`来移除反射的使用,从而提升性能.\n- Attribute类还公开的`虚方法Match`,可重写它来提供更丰富的语义. Match的默认实现只是调用Equal方法并返回它的结果.\n\n下例演示了如何重写Equals和Match,后者在一个特性代表另一个特性的子集的前提下返回true.\n\n```csharp\nusing System;\nusing System.Reflection;\n\ninternal sealed class MatchingAttributes\n{\n    public static void Main()\n    {\n        // ChildAccount应用了此特性[Accounts(Accounts.Savings)]\n        CanWriteCheck(new ChildAccount());\n        // AdultAccount应用了此特性[Accounts(Accounts.Savings | Accounts.Checking | Accounts.Brokerage)]\n        CanWriteCheck(new AdultAccount());\n\n        // 只是为了演示在一个没有应用AccountsAttribute的类型上,\n        // 方法也能正常工作\n        CanWriteCheck(new MatchingAttributes());\n\n//      MatchingAttributes+ChildAccount 类型不可以开支票.\n//      MatchingAttributes+AdultAccount 类型可以开支票.\n//      MatchingAttributes              类型不可以开支票.\n    }\n\n    private static void CanWriteCheck(Object obj)\n    {\n        // 构造attribute类型的一个实例,并把它初始化成我们要显式查找的内容\n        Attribute checking = new AccountsAttribute(Accounts.Checking);\n\n        // 构造应用于类型的特性实例\n        // 获取传入类型是否有AccountsAttribute实例,并构造特性实例\n        Attribute validAccounts = obj.GetType().GetCustomAttribute<AccountsAttribute>(false);\n\n        // 如果将特性应用于类型 并且特性指定了Accounts.Checking账户\n        // 表示该类型可以开支票\n        // 利用Attribute的.Match方法比较特性实例是否一致\n        if ((validAccounts != null) && checking.Match(validAccounts))\n        {\n            Console.WriteLine(\"{0} 类型可以开支票.\", obj.GetType());\n        }\n        else\n        {\n            Console.WriteLine(\"{0} 类型不可以开支票.\", obj.GetType());\n        }\n    }\n\n    [Flags]\n    private enum Accounts\n    {\n        Savings   = 0x0001,\n        Checking  = 0x0002,\n        Brokerage = 0x0004\n    }\n\n\n    // 重写特性的Equals方法和Match方法\n    [AttributeUsage(AttributeTargets.Class)]\n    private sealed class AccountsAttribute : Attribute\n    {\n        private Accounts m_accounts;\n\n        public AccountsAttribute(Accounts accounts)\n        {\n            m_accounts = accounts;\n        }\n\n        public override Boolean Match(Object obj)\n        {\n            // 如果基类实现了Match,而基类不是Attribute\n            // 就取消下面这两行注释\n            // 调用基类实现的Match, obj和base不相等(说明他们不是从同一个基类派生的),\n            // 表示肯定不相等,返回false\n            // if (!base.Match(obj))\n            //     return false;\n\n            // 由于this不为null,obj为null的话, 对象肯定不相等\n            // 如果基类正确实现了Match, 下面这行可以删除\n            if (obj == null) return false;\n\n            // 如果对象属于不同的类型,肯定不匹配\n            // 如果基类正确实现了Match, 下面这行可以删除\n            if (this.GetType() != obj.GetType()) return false;\n\n            // 将obj转型为我们的类型,以访问字段\n            // 注意:装备不可能失败,因为我们知道两个对象是相同的类型\n            AccountsAttribute other = (AccountsAttribute) obj;\n\n            // 比较字段,判断他们是否有相同的值\n            // 这里判断this账户的Flags是否是other的Flags的子集\n            if ((other.m_accounts & m_accounts) != m_accounts)\n                return false;\n\n            return true; // 对象匹配\n        }\n\n        public override Boolean Equals(Object obj)\n        {\n            // 如果基类实现了Equals,而基类不是Object\n            // 就取消下面这两行注释\n            // 调用基类实现的Equals, obj和base不相等(说明他们不是从同一个基类派生的),\n            // 表示肯定不相等,返回false\n            // if (!base.Equals(obj))\n            //     return false;\n\n            // 由于this不为null,obj为null的话, 对象肯定不相等\n            // 如果基类正确实现了Equals, 下面这行可以删除\n            if (obj == null) return false;\n\n            // 如果对象属于不同的类型,肯定不匹配\n            // 如果基类正确实现了Match, 下面这行可以删除\n            if (this.GetType() != obj.GetType()) return false;\n\n            // 将obj转型为我们的类型,以访问字段\n            // 注意:装备不可能失败,因为我们知道两个对象是相同的类型\n            AccountsAttribute other = (AccountsAttribute) obj;\n\n            // 比较字段,判断他们是否有相同的值\n            if (other.m_accounts != m_accounts)\n                return false;\n\n            return true; // 对象相等\n        }\n\n        // 重写HashCode,因为重写了Equlas\n        // 如果只重写了equals方法而没有重写hashCode方法的话\n        // 则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）\n        public override Int32 GetHashCode()\n        {\n            return (Int32) m_accounts;\n        }\n    }\n\n    [Accounts(Accounts.Savings)]\n    private sealed class ChildAccount\n    {\n    }\n\n    [Accounts(Accounts.Savings | Accounts.Checking | Accounts.Brokerage)]\n    private sealed class AdultAccount\n    {\n    }\n}\n```\n\n# 检测定制特性时不创建从Attribute派生的对象\n\n另一种方法检测应用于元数据记录项的特性. 在某些安全性要求严格的场合,这个技术能保证不执行从Attribute派生类中的代码. 毕竟,**调用`Attribute`的`GetCustomAttribute`和`GetCustomAttributes`方法时,** 会在内部调用特性类的构造器,而且可能会调用属性的`set`访问器方法, 首次访问类型会造成CLR调用类型的类型构造器(如果有的话). 这些方法中可能有一些执行方法,存在安全隐患.\n\n**使用`System.Reflection.CustomAttributeData`类，可以在查找`attribute`时同时禁止执行`attribute类`中的代码**。这个类定义了一个静态方法`GetCustomAttributes`来获取与一个目标关联的`attribute`。该方法有4个重载版本：一个接受一个`Assembly`，一个接受一个`Module`，一个接受一个`ParameterInfo`，还有一个接受一个`Memberinfo`。这个类是在System.Reflection命名空间定义的。通常，是先用Assembly的静态方法`ReflectionOnlyLoad`加载一个程序集，在用`CustomAttributeData`类分析这个程序集的元数据中的`attribute`。简单的说，**`ReflectionOnlyLoad`以一种特方式加载程序集，期间会禁止CLR执行程序集中的任何代码，包括类型构造器。**\n\n`CustomAttributeData`的`GetCustomAttributes`方法相当于一个工厂方法。也就是说，调用它会返回`IList<CustomAttributeData>`类型的对象，其中包括了一个有`CustomAttributeData`构成的一个集合。在集合中，应用于指定目标的每个定制attribute都有一个对象的元素。针对每个`CustomAttribute对象`都可以查询一些只读属性，判断attribute对象是如何构造和初始化的。具体的说，`Customctor属性`指出构造器方法\"要\"如何调用。`ComstructorArguments`属性以一个`IList<CustomAttributeTypedArgument>`实例的形式返回\"将\"传给这个构造器的实参。`NamedArguments`属性以一个`IList<CustomAttributeNamedArgument>`实例的形式，返回\"要\"设置的字段或属性。注意，这里之所以说\"将\"，是因为不会实际地调用构造器和set访问器方法。通过禁止执行attribute类的任何方法，我们获得了增强的安全性。\n\n```csharp\n[Serializable]\n[DefaultMemberAttribute(\"Main\")]\n[DebuggerDisplayAttribute(\"Richter\", Name = \"Jeff\", Target = typeof(DetectingAttributes))]\npublic sealed class DetectingAttributes\n{\n    [Conditional(\"Debug\")]\n    [Conditional(\"Release\")]\n    public void DoSomething()\n    {\n    }\n\n    public DetectingAttributes()\n    {\n    }\n\n    [MethodImpl(MethodImplOptions.NoInlining)]\n    [STAThread]\n    public static void Go()\n    {\n        Go(ShowAttributes);\n        Go(ShowAttributesReflectionOnly);\n    }\n\n    private static void Go(Action<MemberInfo> showAttributes)\n    {\n        // Show the set of attributes applied to this type\n        showAttributes(typeof(DetectingAttributes));\n\n        // Get the set of methods associated with the type\n        var members =\n            from m in typeof(DetectingAttributes).GetTypeInfo().DeclaredMembers.OfType<MethodBase>()\n            where m.IsPublic\n            select m;\n\n        foreach (MemberInfo member in members)\n        {\n            // Show the set of attributes applied to this member\n            showAttributes(member);\n        }\n    }\n\n    private static void ShowAttributes(MemberInfo attributeTarget)\n    {\n        var attributes = attributeTarget.GetCustomAttributes<Attribute>();\n\n        Console.WriteLine(\"Attributes applied to {0}: {1}\",\n            attributeTarget.Name, (attributes.Count() == 0 ? \"None\" : String.Empty));\n\n        foreach (Attribute attribute in attributes)\n        {\n            // Display the type of each applied attribute\n            Console.WriteLine(\"  {0}\", attribute.GetType().ToString());\n\n            if (attribute is DefaultMemberAttribute)\n                Console.WriteLine(\"    MemberName={0}\",\n                    ((DefaultMemberAttribute) attribute).MemberName);\n\n            if (attribute is ConditionalAttribute)\n                Console.WriteLine(\"    ConditionString={0}\",\n                    ((ConditionalAttribute) attribute).ConditionString);\n\n            if (attribute is CLSCompliantAttribute)\n                Console.WriteLine(\"    IsCompliant={0}\",\n                    ((CLSCompliantAttribute) attribute).IsCompliant);\n\n            DebuggerDisplayAttribute dda = attribute as DebuggerDisplayAttribute;\n            if (dda != null)\n            {\n                Console.WriteLine(\"    Value={0}, Name={1}, Target={2}\",\n                    dda.Value, dda.Name, dda.Target);\n            }\n        }\n\n        Console.WriteLine();\n    }\n\n    private static void ShowAttributesReflectionOnly(MemberInfo attributeTarget)\n    {\n        IList<CustomAttributeData> attributes =\n            CustomAttributeData.GetCustomAttributes(attributeTarget);\n\n        Console.WriteLine(\"Attributes applied to {0}: {1}\",\n            attributeTarget.Name, (attributes.Count == 0 ? \"None\" : String.Empty));\n\n        foreach (CustomAttributeData attribute in attributes)\n        {\n            // Display the type of each applied attribute\n            Type t = attribute.Constructor.DeclaringType;\n            Console.WriteLine(\"  {0}\", t.ToString());\n            Console.WriteLine(\"    Constructor called={0}\", attribute.Constructor);\n\n            IList<CustomAttributeTypedArgument> posArgs = attribute.ConstructorArguments;\n            Console.WriteLine(\"    Positional arguments passed to constructor:\" +\n                              ((posArgs.Count == 0) ? \" None\" : String.Empty));\n            foreach (CustomAttributeTypedArgument pa in posArgs)\n            {\n                Console.WriteLine(\"      Type={0}, Value={1}\", pa.ArgumentType, pa.Value);\n            }\n\n\n            IList<CustomAttributeNamedArgument> namedArgs = attribute.NamedArguments;\n            Console.WriteLine(\"    Named arguments set after construction:\" +\n                              ((namedArgs.Count == 0) ? \" None\" : String.Empty));\n            foreach (CustomAttributeNamedArgument na in namedArgs)\n            {\n                Console.WriteLine(\"     Name={0}, Type={1}, Value={2}\",\n                    na.MemberInfo.Name, na.TypedValue.ArgumentType, na.TypedValue.Value);\n            }\n\n            Console.WriteLine();\n        }\n\n        Console.WriteLine();\n    }\n}\n```\n\n# 条件特性类\n\n定义、应用和反射特性能带来许多便利，所以开发人员越来越频繁地使用这些技术。特性简化了对代码的注释，还能实现丰富的功能。近来，开发人员越来越喜欢在设计和调试期间利用特性来辅助开发。\n\n\n```csharp\n//#define TEST\n//#define VERIFY\n\nusing System;\nusing System.Diagnostics;\n\n[Cond]\npublic static class ConditionalAttributeDemo\n{\n    // 只有在定义了VERIFY或TEST的前提下,编译器才会在元数据中生成特性信息\n    // 但是特性类的定义元数据和实现仍然存在于程序集中\n    [Conditional(\"TEST\")]\n    [Conditional(\"VERIFY\")]\n    public sealed class CondAttribute : Attribute\n    {\n    }\n\n    public static void Main()\n    {\n        // 判断当前类ConditionalAttributeDemo, 是否应用了CondAttribute特性\n        Console.WriteLine(\"CondAttribute {0} 应用于程序类型.\",\n            Attribute.IsDefined(typeof(ConditionalAttributeDemo), typeof(CondAttribute)) ?\n                \"\" : \"没有\");\n    }\n}\n\n// CondAttribute 没有 应用于程序类型.\n```\n\n只有在定义了`VERIFY或TEST`的前提下,编译器发现目标元素应用了`CondAttribute`的实例,并且满足这个`CondAttribute`**条件** 才会在元数据中生成特性信息,但是特性类的定义元数据和实现仍然存在于程序集中\n\n> 条件特性类: [Conditional(\"TEST\")]\n","tags":["CLR读书笔记"]},{"title":"Unity编辑器扩展工具OdinInspector","url":"/2019/08/30/Unity编辑器扩展工具OdinInspector/","content":"\n# Odin\n\n[Odin官网](https://odininspector.com/tutorials/getting-started/installing-odin-inspector)\n","tags":["Unity编辑器扩展"]},{"title":"Unity可寻址资产系统示例代码详解","url":"/2019/08/30/Unity可寻址资产系统示例代码详解/","content":"# Project Details\n\n- Unity 2019.1.14f1\n- Addressables 1.1.7\n\n[AddressableAssetsWebinar](https://github.com/Unity-Technologies/AddressableAssetsWebinar)\n\n# 什么是Addressables?\n\n1. 可以取代Asset Bundle的高阶管理系统\n2. 天涯海角都会追踪到的信标(Address)\n3. 自动化仓储管理\n4. 只加载有关联的资源(系统会处理关联性)\n  1. 可以实例化场景,自动关联相关的Asset\n5. 运行阶段优良的内存管理\n6. 除脚本外的资源都可以标记为寻址式资源\n7. Build Script可以让你自己写打包流程(命名规则,打包处理,默认压缩LZ4)\n\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830085842.png)\n\n不需要手动去管理AssetBundle,可以通过Addressables系统自动化.\n\n# Demo\n\n类似皇室战争的demo, 演示Addressable Asset System用法\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830091237.png)\n\n如图所示,弓箭手卡牌(按钮),点击后会在场地实例化一个弓箭手.\n- 按钮点击事件绑定了 当前场景中的`GameManager对象`里的`CharacterManager脚本`中的`SpawnCharacter方法`\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830092202.png)\n\n> SpawnCharacter 大量生产角色\n\n\n## 普通实例化做法\n\n在SpawnCharacter方法中实例化弓箭手, 普通的做法是:\n\n```csharp\n// Inspector面板上放了Archer Red红色弓箭手的prefab\n// 类型是GameObject\npublic GameObject m_archerObject;\n\n// 同步实例化\n// 资源已经在本地端\n// 大量加载容易造成卡顿\nInstantiate(m_archerObject);\n```\n\n## Addressables实例化做法\n\n```csharp\n// AssetReference类型 会指向可寻址资源\npublic AssetReference m_ArcherObject;\n\n// 异步实例化\n// 系统不会等待\n// 大量实例化不会卡住系统\nm_ArcherObject.InstantiateAsync();\n```\n\n同时需要把`Archer Red的prefab`勾选可寻址信标.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830094549.png)\n\n- 勾选`Addressable`后,会在Addressables窗口中出现此资源\n- 也可以直接将prefab拖入Addressables窗口\n\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830094914.png)\n\n在Addressables窗口中右键创建一个`AssetGroups`,这个群组中的所有资源可以视为一个加载包.\n\n> 在项目面板会生成一个同名的包对象. 可以更改Asset Bundle相关设置\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830095303.png)\n\n再去`GameManager对象`的Inspector面板上修改`public AssetReference m_ArcherObject;`的引用, 因为已经将资源加入到Addressable中,所以这里可以下拉框选到对应的可寻址资源.\n\n## Addressables实例化多个对象\n\n1. 将需要实例化的多个对象加入Addressables中\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830104934.png)\n\n2. 在脚本的Inspector面板上选取对应的资源\n  1. 放入 弓箭手,法师,战士资源.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830104956.png)\n\nCharacterManager脚本代码如下:\n```csharp\npublic class CharacterManager : MonoBehaviour\n{\n    // 一次加载多个资源时,用List存放这些资源的AssetReference地址\n    public List<AssetReference> m_Characters;\n    // 资源是否已经加载完毕\n    bool m_AssetsReady = false;\n    // 资源总数\n    int m_ToLoadCount;\n    int m_CharacterIndex = 0;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        // 计数,需要多少个资源\n        m_ToLoadCount = m_Characters.Count;\n\n        foreach (var character in m_Characters)\n        {\n            // 因为不知道这个资源是不是在本地, 所以要确定已经加载完成\n            // 因为是异步加载,注册一个完成后的回调函数\n            character.LoadAssetAsync<GameObject>().Completed += OnCharacterAssetLoaded;  \n        }\n    }\n\n    public void SpawnCharacter(int characterType)\n    {\n        // 当Asset全部加载完毕后,才允许实例化\n        if (m_AssetsReady)\n        {\n            // 返回半径为5的球体内的一个随机点。\n            Vector3 position = Random.insideUnitSphere * 5;\n            // 设置xz轴, y轴为0\n            position.Set(position.x, 0, position.z);\n            // 异步实例化\n            m_Characters[characterType].InstantiateAsync(position, Quaternion.identity);\n        }\n    }\n\n    // 回调函数\n    void OnCharacterAssetLoaded(AsyncOperationHandle<GameObject> obj)\n    {\n        // 加载成功一个, 总数减一\n        m_ToLoadCount--;\n        // 直到加载全部完成 设置flag 为true\n        if (m_ToLoadCount <= 0)\n            m_AssetsReady = true;\n    }\n\n    // 卸载资产Addressables.Release();资产可能会立即卸载，也可能不会立即卸载，具体取决于现有的依赖项\n    private void OnDestroy() //TODO: Should we teach instantiate with game objects and then manually release?\n    {\n        foreach (var character in m_Characters)\n        {\n            // 释放操作及其相关资源。\n            character.ReleaseAsset();\n        }\n    }\n}\n\n```\n\n\n需要注意:\n- 在可寻址资源系统中,因为不知道这个资源是不是在本地, 所以要确定是否已经加载完成,因为是异步加载,注册一个完成后的回调函数\n- 以前需要思考这个包是否下载,去服务器请求,下载之后解包,然后加载. 用了AAS之后,这些步骤由AAS替你完成.\n\n举个例子: 请求加载一个`法师`模型资源, 但是这个资源 **不在本地**,需要从远程地址(服务器)去下载,只有下载完成之后加载好才去做`实例化`的工作.\n\n\n# Addressables窗口\n\n用来放所有被放入Addressables的资产.\n\n1. 默认以`路径`作为资产的`地址(信标)`.这是可以更改的.\n  1. 呼叫此地址的时候,会找到对应的Asset\n2. 可以设置`Labels`. 用来分类,区分一些同名资产.\n\n## profile 配置文件\n\n默认是Default,可以根据不同的需求增加不同的方案,比如正式发布配置方案,测试配置方案等.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830120239.png)\n\n- `Send Profiler Events`  勾选后,可以在编辑器下运行时查看所有Asset的加载与卸载情况.\n  - 默认不勾选,因为正式发布时不需要,影响性能.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830120601.png)\n\n- `蓝绿色背景` 代表 **已加载的资产**.\n- `绿色条状`   代表 **当前引用计数.**\n\n\n# 用Label功能\n\nLabel功能可以复数勾选.\n\n1. 先将需要的资源插入信标(拖入AAS)\n\n![](Unity可寻址资产系统示例代码详解/QQ图片20190830123612.png)\n\n2. 在AddressableAssetSetting中加入Label标签.\n\n3. 给对应的可寻址资源下拉框选择对应的标签.\n\n4. 在对应脚本上的`AssetLabelReference`属性下拉框选择标签\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830123918.png)\n\n这样这个脚本就会在Start的时候,把所有有Tower标签的资源加载进来.(demo中塔顺序不是对应的,只为演示).\n\n\n```csharp\npublic class TowerManager : MonoBehaviour\n{\n    // 塔prefabs\n    public IList<GameObject> m_Towers;\n    // AssetLabelReference Label标签引用对象\n    public AssetLabelReference m_TowerLabel;\n    // 界面上的塔卡片 按钮\n    public Button[] m_TowerCards;\n\n    // Start is called before the first frame update\n    void Start()\n    {\n        // 将所有包(AssetGroups)中的带有这个标签的Asset全部拿出来\n        // 每拿取完成一个之后会调用OnResourcesRetrieved\n        Addressables.LoadAssetsAsync<GameObject>(m_TowerLabel, null).Completed += OnResourcesRetrieved;\n    }\n    private void OnResourcesRetrieved(AsyncOperationHandle<IList<GameObject>> obj)\n    {\n        // 拿取的结果存储在IList<GameObject>中\n        // demo中塔顺序不是对应的,只为演示\n        m_Towers = obj.Result;\n\n        //Activate the tower cards since their assets are now loaded\n        foreach(var towerCard in m_TowerCards)\n        {\n            // 将卡牌按钮显示可按\n            towerCard.interactable = true;\n        }\n    }\n    public void InstantiateTower(int index)\n    {\n        if(m_Towers != null)\n        {\n            // 随机放在一些位置\n            Vector3 position = Random.insideUnitSphere * 5;\n            position.Set(position.x, 0, position.z);\n            Instantiate(m_Towers[index], position, Quaternion.identity, null);\n        }\n    }\n}\n```\n\n## 查询机制\n\n如果我需要一把剑, 但是标有剑的Label有100把,那么这个时候就需要查询功能,不需要全部去加载100把剑.\n\n> 或者可以用更多的Label来区分, 比如青铜系列, 剑, 单手等等.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830125010.png)\n\n因为异步加载的关系, 用Label标签加载的资源可能不是预期的顺序.\n\nAAS提供了一个查询机制(**不加载,也不实例化**,只是查询对应的可寻址资源清单表).\n\n`LoadResourceLocationsAsync(label)`\n\n取出来的清单会放入`IResourceLocation`中,然后根据清单加载哪把剑. 自己使用`LoadAssetAsync`加载.\n\n\n# 本地路径和远端路径\n\n以前的流程是:\n- 本地打包,拿去服务端测,有问题再回本地修复,再去测.\n\n为了简化这种流程,AAS提供了一些模式:\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830131635.png)\n\n- 快速模式\n  - 第一阶段(研发阶段)本地端资源.\n  - 快速模式直接通过资产数据库加载资产，以便快速迭代，无需创建分析或资产包(AB包)。\n- 虚拟模式\n  - 也是本地端资源,会虚拟一个服务器端功能\n  - 分析布局和依赖关系的内容，而无需创建资产包(AB包)。\n- 打包模式\n  - 不会用本地资源,会需要包资源.\n  - 使用已构建的资产包(AB包)。\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830132241.png)\n\n**每个群组包都可以设置放在本地路径还是远端路径.**\n\n> 用处说明: 游戏打包之后, 嵌在包里的资源(本地),以及服务器端的资源(远端).\n> 游戏运行时会请求服务器资源下载.\n\n\n4个路径的说明:\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830132715.png)\n\n如果`群组包`是`本地包(跟随游戏包体一起发布的包)`,则会放入`Local Build Path`路径下.\n\n如果是`远端包(游戏开始时去请求服务器下载的包)`,会放入`Remote Build Path`路径下.\n\n本地测试的话,本地打包路径和本地加载路径是相同的.\n\n远端打包的话,路径是在一个文件夹下,而加载的路径是 **根据http的一个IP和port去加载**.\n\n# 利用AAS附带的虚拟HTTP服务器模拟\n\n开启虚拟资源服务器\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830133914.png)\n\n根据地址选取一个,记住名称,在后面配置远程路径时需要用到, 再添加一个Hosting Services服务来开启端口.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830134320.png)\n\n点击`Enable Services`按钮开启服务,会得到一个端口号. 名称也会需要用到.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830134445.png)\n\n然后开始配置AddressableAssetSetting里的远程路径设置:\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830134633.png)\n\n- Profiles 配置方案新建一个, 改名为开发时的配置方案名称.\n- 将`[PrivateIpAddress_4]`改为`[PrivateIpAddress]`和之前Hosting Services设置对应.\n\n## 设置对应的包为远程包\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830135127.png)\n\n首先,更改`profile`为新建的`deve`方案,然后选择`AessetGroup`里的`Tower`包更改远程构建路径和加载路径. 可以预览的看到.\n\n## 测试\n\n将`Play Mode Script`改为`Packed Paly Mode`, 点击`Build`->`Build Play Contant`. 这样就完成了打包.\n\n点击播放就可以正常运行,包在对应的目录中.\n`\\HostedData\\StandaloneWindows64\\towers_assets_all_ee248a6bacba1b7989b2b4d9c590083b.bundle`\n\n以上就是远端加载流程. 只要把包放到服务器上,把本地设置改掉就可以真实测试了.\n\n# 安装包和加载包设置(渐进式递增更新)\n\n不用重新下载整个包. 从App Store下载最小的APP包. 第一次启动加载资料包.\n\n## 利用Label设计换皮与各种功能包\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830141340.png)\n\n切换到`QualityLevelsDemo`场景.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830142243.png)\n\n将材质放入Addressables, 并且信标(地址)可以相同,设置不同的Label.\n\n> 名称相同比如: 帽子,可以分类为A角色的帽子,B角色的帽子, 他们的名称可以相同,用不同的Label就可以区分他们.\n\n```csharp\npublic class TextureController : MonoBehaviour\n{\n    // 渲染材质\n    public Renderer m_ReferencedMaterial;\n\n    public void SwitchToHighDef()\n    {    \n        // 加载对应名称和Label的资源\n        LoadTexture(\"ArcherSkin\", \"Skin2\");\n    }\n\n    void LoadTexture(string key, string label)\n    {\n        Addressables.LoadAssetsAsync<Texture2D>(new List<object> { key, label }, null, Addressables.MergeMode.Intersection).Completed\n            += TextureLoaded;\n    }\n\n    void TextureLoaded(AsyncOperationHandle<IList<Texture2D>> obj)\n    {\n        m_ReferencedMaterial.material.mainTexture = obj.Result[0];\n    }\n}\n```\n\n运行之后,点击就会成一个穿红色衣服的角色.\n\n# 修改纹理之后,不想要重新打包的做法\n\n静态的本地包可以增量式打包.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830143024.png)\n\n将材质包组设置为静态内容.\n\n- 打包一个可执行文件. 用Unity的build生成exe.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830143255.png)\n\n- 在一些情况下,你想修改包体,而不像重新打包(一个包很大,重新打包很麻烦)\n- 现在可以通过ASS增量式打包(具体规则参考文档)\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830143548.png)\n\n- 修改了Skin2的材质\n- 打包流程就需要改变\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830143708.png)\n\n- 点击 `Prepare For Content Update`\n- [相关说明文档](https://zxt385189207.github.io/2019/08/27/Unity%E5%8F%AF%E5%AF%BB%E5%9D%80%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9FAddressableAssetSystem/#%E8%B5%84%E4%BA%A7%E6%89%98%E7%AE%A1%E6%9C%8D%E5%8A%A1)\n- 选择原本对应的设置,ASS会提示变动的文件,让你选择是否要分离出一个更新包.\n- 之后分离出一个更新包(非静态的) `Content Update组`\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830144037.png)\n\n- 最后再打成`远端包`,选择`Build For Content Update`,选择原本对应的设置.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830144141.png)\n\n- 玩家手中的exe执行档就会从远端下载这个`Content Update组`里的更新包,完成替换.\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830144435.png)\n\n\n> 远程包如果有修改,不管多大都需要重新打一个完整的. 比如包A(资源1,2,3),修改3的话,资源12也需要重新打进去.\n> 本地包(静态内容,随包发布),如果修改了资源,可以增量式打一个修改的小包,通过远程包的形式替换掉本地包的内容.\n\n\n# 场景的异步加载\n\n将场景放入Addressables可以自动关联所有需要的资源.\n\n可以根据信标(地址)用`Addressables.LoadSceneAsync`方式异步加载场景.\n\n> 区别于资源,场景要用`Addressables.LoadSceneAsync`方法加载\n\n![](Unity可寻址资产系统示例代码详解/QQ截图20190830145320.png)\n\n```csharp\npublic class SceneManager : MonoBehaviour\n{\n    public string m_SceneAddressToLoad;\n\n    public void LoadGameplayScene()\n    {\n        // 加载传入String场景名称,异步加载场景\n        Addressables.LoadSceneAsync(m_SceneAddressToLoad, UnityEngine.SceneManagement.LoadSceneMode.Single).Completed += OnSceneLoaded;\n    }\n\n    void OnSceneLoaded(AsyncOperationHandle<SceneInstance> obj)\n    {\n        //Addressables.UnloadSceneAsync(new SceneInstance());\n        // LOGIC THAT KICKSTARTS THE GAMEPLAY\n    }\n}\n```\n","tags":["Unity资源管理系统"]},{"title":"Unity可寻址资产系统AddressableAssetSystem","url":"/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/","content":"\n[Addressable Asset System 官方文档](https://docs.unity3d.com/Packages/com.unity.addressables@1.1/manual/index.html)\n\nUnity全新的资源管理流程Addressable Asset System(寻址式资源管理)可以让你在Unity编辑或运行时来管理各种资源加载分配。它是一个基于Asset Bundle架构延伸出来的高级管理系统。非常适合非程序人员来使用，意味着未来打包与管理资源的工作也可以让非程式人员来分担，对管理大型项目或结构复杂的资源特别有帮助。\n\n\n# 什么是asset?\n\n资产是您用于创建游戏或应用程序的内容。资产的常见示例包括预制件(Prefabs)，纹理(textures)，材料(materials)，音频剪辑(audio clips)和动画(animations)。\n\n# 什么是Addressable Asset?\n\n使资产“可寻址”允许您使用该资产的唯一地址从任何地方调用它。无论该资产是在 **本地应用程序中** 还是在 **内容交付网络(资源服务器)** 上，可寻址资产系统都会找到并返回该资产。您可以通过其地址加载单个可寻址资产，或使用您定义的 **自定义组标签** 加载许多可寻址资产。\n\n# 为什么要使用可寻址资产?\n\nAddressable 缩短了迭代周期:\n- `迭代时间`: 通过其地址引用类型非常有效.对内容的优化不需要更改代码.\n- `依赖关系管理`: 系统返回所请求内容的所有依赖关系, 方便在内容返回之前加载所有依赖的网格,着色器,动画等.\n- `内存管理`: 系统的卸载资产并加载它们,自动计算引用并提供强大的分析器以帮助您发现潜在的内存问题。\n- `内容打包`: 由于系统映射并理解复杂的依赖关系链, 因此即使在移动或重命名资产时，也可以有效地打包捆绑包。您可以轻松地为本地和远程部署准备资产，以支持可下载内容和减少应用程序大小。\n\n# 概述\n\n可寻址资产系统包括两个包：\n- Addressable Assets package (主要包)\n- Scriptable Build Pipeline package (依赖)\n\n> 安装Addressable Assets包时，Scriptable Build Pipeline包将同时安装。\n\n## 概念\n\n- `Address(地址)`: 资产的位置标识符，便于运行时检索.\n- `AddressableAssetData directory(可寻址资产元数据目录)`: 将您的可寻址资产元数据存储在Project的Assets目录.\n- `Asset group(资产组)`: 一组可用于 **构建时处理的** 可寻址资产.\n- `Asset group schema(资产组架构)`: 定义一组数据，您可以将这些数据分配给组并在构建期间使用。\n- `AssetReference(资产引用)`: 一个对象，其操作类似于直接引用，但具有 **延迟初始化**。该AssetReference对象将GUID存储为可按需加载的Addressable。\n- `Asynchronous loading(异步加载)`: 允许在整个开发过程中更改资产及其依赖项的位置，而无需更改游戏代码。异步加载是可寻址资产系统的基础。\n- `Build script(构建脚本)`: 运行 **资产组处理器** 以打包资产，并提供资源管理器的地址和资源位置之间的映射。\n- `Label(标签)`: 为类似项的运行时加载提供附加的 **可寻址资产标识符** (例如, `Addressables.DownloadDependenciesAsync(\"spaceHazards\");`).\n\n# 入门\n\n**重要提示：可寻址资产系统需要Unity版本2018.3或更高版本**\n\n## 使Asset成为AddressableAssets\n\n两种标记方式:\n1. 在对象的`Inspector`面板中 -> 单击`Address`复选框 -> 输入用于标识资产的名称。\n\n![](Unity可寻址资产系统AddressableAssetSystem/inspectorcheckbox.png)\n\n2. 选择 Window > `Asset Management` > `Addressables` 去打开 `Addressables window`. 然后, 将所需的资产从项目窗口拖进`Addressables window`的资产组。\n\n![](Unity可寻址资产系统AddressableAssetSystem/addressableswindow.png)\n\n## 指定地址\n\n资产的 **默认地址** 是项目中资产的路径（例如，`Assets/images/myImage.png`）。**要从`Addressables window`更改资产的地址，请右键单击该资源，然后选择`Rename`。**\n\n当您第一次开始使用可寻址资产时，系统会在`Assets/AddressableAssetsData`文件中为您的项目保存一些编辑时和运行时数据资产，这些资产应添加到您的版本控制签入中。\n\n## 构建可寻址内容\n\n在构建应用程序之前，**Addressables资产系统需要将您的内容构建为正在运行的游戏可以使用的文件。** 此步骤不是自动的。您可以通过编辑器或API构建此内容：\n\n- 要在Editor中构建内容，请打开`Addressables window`，然后选择`Build` -> `Build Player Content`。\n- 要使用API​​构建内容，请使用`AddressableAssetSettings.BuildPlayerContent()。`\n\n## 使用可寻址资产\n\n### 按地址加载或实例化\n\n您可以在运行时加载或实例化可寻址资产。**加载资产会将所有依赖项加载到内存中（包括资产的捆绑数据，如果适用）**，允许您在需要时使用该资产。**这实际上并没有将所需资产放入场景中。要将资源添加到场景中，您必须实例化。** 使用Addressables实例化接口将加载资源，然后立即将其添加到场景中。\n\n要使用字符串地址从游戏脚本访问资产，请声明UnityEngine.AddressableAssets命名空间，然后调用以下方法：\n```csharp\n// 这会使用指定的地址加载资产。\nAddressables.LoadAssetAsync<GameObject>(\"AssetAddress\");\n// 这会将具有指定地址的资产实例化到场景中。\nAddressables.InstantiateAsync(\"AssetAddress\");\n```\n\n> 注意：`LoadAssetAsync`和`InstantiateAsync`是异步操作。您可以在完成加载时提供回调以使用资产。\n\n\n\n```csharp\nusing UnityEngine.AddressableAssets;\nusing UnityEngine;\n\npublic class AddressablesExample : MonoBehaviour\n{\n\n    GameObject myGameObject;\n\n        // ...\n\n        // 使用指定的地址加载资产,完成时回调OnLoadDone方法\n        Addressables.LoadAssetAsync<GameObject>(\"AssetAddress\").Completed += OnLoadDone;\n    }\n\n    private void    OnLoadDone(UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle<GameObject> obj)\n    {\n        // 在生产环境中，您应该添加异常处理来捕获诸如null结果之类的场景。\n        myGameObject = obj.Result;\n    }\n}\n\n```\n\n### 子资产和组件\n\n`子资产`和`组件`是资产加载的特殊情况。\n\n- `组件`：您 **无法** 直接将GameObject的组件作为资源加载。您必须加载或实例化GameObject，然后从中检索组件引用。\n- `子资产`：系统支持加载子资产，但需要特殊语法。潜在子资产的示例包括`sprite sheet`中的`sprites`或FBX文件中的动画片段。要加载它们，请使用以下示例语法：\n\n```csharp\n// 系统支持加载子资产，但需要特殊语法\n// 例如`sprite sheet`中的`sprites`\n// FBX文件中的动画片段\nAddressables.LoadAssetAsync<IList<Sprite>>(\"MySpriteSheetAddress\");\n```\n\n\n## 使用AssetReference类\n\n本`AssetReference类`提供一种方法来访问寻址的资产，而无需知道他们的地址。要使用`AssetReference类`访问可寻址资产：\n1. 从`Scene hierarchy`结构或`Project window`中选择一个GameObject 。\n2. 在Inspector中，单击`Add Component`按钮，然后选择组件类型。任何可序列化组件都可以支持`AssetReference变量`（例如，`a game script`，`ScriptableObject`或`其他可序列化类`）。\n3. `AssetReference`在组件中添加公共变量（例如，`public AssetReference explosion;`）。\n4. 在Inspector中，选择要链接到对象的可寻址资产，方法是将资源从`Project window`拖动到公开AssetReference字段中，或者从项目中先前定义的可寻址资产的下拉列表中进行选择（如下所示）。\n\n![](Unity可寻址资产系统AddressableAssetSystem/Inspectorreferenceselection2.png)\n\n5. 要加载或实例化AssetReference资产，请调用其相应的方法。\n  1. `AssetRefMember.LoadAssetAsync<GameObject>();`\n  2. 或者 `AssetRefMember.InstantiateAsync(pos, rot);`\n\n## 建立考虑因素\n\n### StreamingAssets中的本地数据\n\n可寻址资产系统在运行时需要 **一些文件来知道要加载什么以及如何加载它**。这些文件是在构建Addressables数据时生成的，**并在StreamingAssets文件夹中生成**，该文件夹是Unity中包含构建中所有文件的特殊文件夹。构建Addressables内容时，系统会在库中对这些文件进行分级。然后，在构建应用程序时，**系统会将所需文件复制到StreamingAssets**，构建并从文件夹中 **删除它们**。这样，您可以为多个平台构建数据，同时只在每个构建中包含相关数据。\n\n除了特定于Addressables的数据之外，构建其本地数据的任何组也将使用特定于库平台的分段位置。\n\n要验证这是否有效，请将构建路径和加载路径设置为分别以\n`[UnityEngine.AddressableAssets.Addressables.BuildPath]`和开头的配置文件变量`{UnityEngine.AddressableAssets.Addressables.RuntimePath}`。您可以在`AddressableAssetSettings`的`Inspector`中指定这些设置（默认情况下，此对象位于Project的`Assets/AddressableAssetsData`目录中）。\n\n### 提前下载\n\n调用该`Addressables.DownloadDependenciesAsync()`方法会加载您传入的地址或标签的依赖关系。通常，这是资产包。\n\n`AsyncOperationHandle`此调用返回的结构包含一个`PercentComplete`可用于监视和显示下载进度的属性。您还可以让应用程序等到内容加载完毕。\n\n如果您希望在下载之前询问用户是否同意，请使用`Addressables.GetDownloadSize()`返回从给定地址或标签下载内容所需的空间。请注意，这会考虑任何以前下载的仍在Unity资产包缓存中的捆绑包。\n\n虽然提前为您的应用程序下载资产可能是有利的，**但有些情况下您可能选择不这样做**。例如：\n- 如果您的应用拥有大量在线内容，并且您通常希望用户只与其中的一部分进行互动。\n- 您有一个必须在线连接才能运行的应用程序。如果您的所有应用内容都是小型捆绑包，您可以选择根据需要下载内容。\n\n您可以使用预加载功能显示下载已开始，然后继续，而不是使用百分比完成值等待内容加载。此实现需要加载或等待屏幕来处理资产在需要时尚未完成加载的实例。\n\n### 构建多个平台\n\n在构建应用程序内容时，可寻址资产系统会生成包含可寻址资产的资产包。**资产包依赖于平台，因此必须为您打算支持的每个独特平台重建。**\n\n默认情况下，在构建Addressables应用程序数据时，给定平台的数据存储在Addressables构建路径的特定于平台的子目录中。运行时路径考虑了这些平台文件夹，并指向适用的应用程序数据。\n\n注意：如果`BuildScriptPackedPlayMode`在编辑器播放模式下使用Addressables 脚本，则Addressables将尝试加载`当前活动构建目标(your current active build target)`的数据。因此，**如果您当前的构建目标数据与当前的编辑器平台不兼容，则可能会出现问题。** 有关更多信息，请参阅有关Play mode scripts.的文档。\n\n\n# 开发周期\n\n## 传统的资产管理\n\n如果在Resources目录中安排内容，它将内置到基本应用程序中，您必须使用该`Resources.Load`方法加载内容，并提供资源的路径。\n\n要访问存储在其他位置的内容，您可以使用直接引用或资产包(AB包)。如果您使用资产包(AB包)，则会再次按路径加载，将您的负载和组织策略捆绑在一起。如果您的资产包是远程的，或者依赖于其他捆绑包，则必须编写代码来管理下载，加载和卸载所有捆绑包。\n\n## 可寻址资产管理\n\n为资产提供`地址`允许您使用该地址加载它，无论您在项目中的位置或您如何构建资产。您可以毫无问题地更改可寻址资产的路径或文件名。您还可以 **将`可寻址资产`从Resources文件夹或本地构建目标移动到其他构建位置（包括远程构建位置）**，而无需更改加载代码。\n\n### 资产组架构\n\n架构定义了一组数据。您可以在`Inspector`中将模式附加到资产组。附加到组的`模式集`定义了构建如何处理其内容。例如，在打包模式下构建时，`BundledAssetGroupSchema`附加了架构的组充当资产包的源。您可以将模式集合组合到用于定义新组的模板中。您可以通过`AddressableAssetsSettings`的`Inspector` 添加架构模板。\n\n## 构建脚本\n\n构建脚本`ScriptableObject`在项目中表示为实现`IDataBuilder接口`的资产。用户可以创建自己的构建脚本，并`AddressableAssetSettings`通过其`Inspector` 将它们添加到对象中。要在“ 可寻址”窗口 `Addressables window (Window > Asset Management > Addressables)`,中应用构建脚本，请选择`构建脚本`，然后选择下拉选项。目前，有三个脚本用于支持完整的应用程序构建，三个Play模式脚本用于在编辑器中进行迭代。\n\n### Play mode scripts\n\n有三个构建脚本，用于创建Play模式数据以帮助您加速应用程序开发。\n\n\n- Fast mode **快速模式**\n快速模式（`BuildScriptFastMode`）允许您在完成游戏流程时快速运行游戏。快速模式直接通过资产数据库加载资产，以便快速迭代，**无需创建分析或资产包(AB包)**。\n\n- Virtual mode **虚拟模式**\n虚拟模式（`BuildScriptVirtualMode`）**分析布局和依赖关系的内容**，而无需创建资产包(AB包)。资产从资产数据库`ResourceManager`加载，就像它们是通过捆绑加载一样。要查看在游戏过程中何时加载或卸载软件包，请在`Addressable Profiler window (Window > Asset Management > Addressable Profiler).`中查看资产使用情况。\n\n虚拟模式可帮助您模拟加载策略并调整内容组，以便为​​生产版本找到正确的平衡点。\n\n- Packed Play mode **打包模式**\n\n打包播放模式（`BuildScriptPackedPlayMode`）使用已构建的资产包(AB包)。此模式与已部署的应用程序构建最匹配，但它要求您将数据构建为单独的步骤。如果您不修改资源，此模式是最快的，因为它在进入播放模式时不会处理任何数据。您必须通过选择`Build > Build Player Content`，在Addressables窗口（Window > Asset Management > Addressables）中为此模式 **构建内容** 或 **使用游戏脚本中的方法** `AddressableAssetSettings.BuildPlayerContent()`。\n\n\n- Choosing the right script 选择正确的脚本\n\n要应用播放模式脚本，请从`Addressables window menu (Window > Asset Management > Addressables)`, 选择`Play Mode Script`, 下拉选项中进行选择.每种模式在开发和部署期间都有自己的时间和地点。下表说明了开发周期的各个阶段，其中特定模式很有用\n\n![](Unity可寻址资产系统AddressableAssetSystem/choosingtherightscript.png)\n\n## 分析和调试\n\n默认情况下，可寻址资产 **仅记录警告和错误**。您可以通过打开` Player settings window`，然后将`ADDRESSABLES_LOG_ALL` 添加到`Scripting Define Symbols`字段来启用详细日志记录。\n\n\n您还可以通过在`AddressableAssetSettings`取消选中对象Inspector中的`Log Runtime Exceptions`选项来禁用异常。可以使用自己的异常处理程序实现该属性`ResourceManager.ExceptionHandler`，但这应该在Addressables完成运行时初始化之后完成（见下文）。\n\n## 初始化对象\n\n您可以将对象附加到可寻址资源设置，并在运行时将它们传递给初始化过程。该`CacheInitializationSettings对象`在运行时控制Unity的缓存API. 要创建自己的初始化对象，请创建一个`ScriptableObject`并实现`该IObjectInitializationDataProvider接口`。这是系统的Editor组件，负责创建`ObjectInitializationData`使用运行时数据序列化的组件。\n\n\n## 内容更新工作流程\n\nUnity建议将游戏内容分为两类：\n- 您永远不会期望更新的静态内容。\n- 您希望更新的动态内容。\n\n在此结构中，静态内容随应用程序一起提供（或在安装后很快下载），并且驻留在极少数大型捆绑包中。动态内容在线下载，理想情况下是较小的捆绑包，以最大限度地减少每次更新所需的数据量。可寻址资产系统的目标之一是使这个结构易于使用和修改，而无需更改脚本。\n\n但是，当您不想发布全新的应用程序构建时，可寻址资产系统还可以适应需要更改“静态”内容的情况。\n\n### 运作流程\n\nAddressables使用内容目录将地址 **映射到每个资产**，**指定加载它的位置和方式**。为了使您的应用程序能够修改该映射，您的原始应用程序必须知道此目录的在线副本。要进行此设置，请在`AddressableAssetSettings`的`Inspector`上启用 `Build Remote Catalog(构建远程目录)` 设置。这可确保将目录的副本构建到指定路径并从指定路径加载。**应用程序发布后，此加载路径无法更改。** **内容更新过程创建新版本的目录（具有相同的文件名）以 覆盖先前指定的加载路径上的文件**。\n\n构建应用程序会生成 **唯一的应用程序内容版本字符串**，用于 **标识每个应用程序应加载的内容目录**. 给定服务器可以包含应用程序的多个版本的目录而不会发生冲突。我们将所需的数据存储在`addressables_content_state.bin`文件中。这包括`版本字符串`，以及`标记为的组中包含的任何资产的哈希信息StaticContent`。默认情况下，此文件与`AddressableAssetSettings.asset`文件位于同一文件夹中。\n\n该`addressables_content_state.bin`文件包含`每个哈希`和`依赖信息StaticContent`的 **Addressables系统资产组**。**构建到StreamingAssets文件夹的所有组都应标记为`StaticContent`**，但大型远程组也可能受益于此指定。在下一节（准备内容更新，如下所述）期间，此哈希信息确定是否有任何StaticContent组包含已更改的资产，因此需要将这些资产移动到其他位置。\n\n\n### 准备内容更新\n\n如果您已在任何`StaticContent`组中修改了资产，则需要运行`Prepare For Content Update`命令。这将从静态组中取出任何已修改的资产，并将它们移动到新组。要生成新资产组：\n\n\n- 在Unity编辑器中打开Addressables窗口（窗口 > 资产管理 > 可寻址资产）。\n- 在“ 可寻址”窗口中，选择顶部菜单栏上的 `Build`，然后选择` Prepare For Content Update`。\n- 在打开的`Build Data File`对话框中，选择`addressables_content_state.bin`文件（默认情况下，该文件位于`Assets/AddressableAssetsData`项目目录中。\n\n此数据用于确定 **自上次构建应用程序以来已修改的资产或依赖项**。系统将这些资产移动到新组以准备内容更新构建。\n\n**注意：如果所有更改都限制在非静态组中，则此命令将不执行任何操作。**\n\n重要：在运行准备操作之前，Unity建议 **分支您的版本控制** 系统。准备操作以适合更新内容的方式重新排列资产组。分支确保您下次发布新播放器时，可以返回首选内容安排。\n\n### 构建内容更新\n\n要构建内容更新：\n\n- 在Unity编辑器中打开Addressables窗口（窗口 > 资产管理 > 可寻址资产）。\n- 在Addressables窗口中，选择`Build`在顶部菜单上，然后`Build For Content Update`。\n- 在打开的`Build Data File`对话框中，选择现有应用程序构建的构建文件夹。build文件夹必须包含`addressables_content_state.bin`文件。\n\n构建生成`content catalog内容目录`，`hash file哈希文件`和`asset bundles`资产包。\n\n生成的内容目录与所选应用程序构建中的目录具有相同的名称，将 **覆盖** 旧目录和哈希文件。应用程序加载哈希文件以确定新目录是否可用。系统从应用程序附带或已下载的现有捆绑包中加载未修改的资产。\n\n系统使用`addressables_content_state.bin`文件中的`内容版本字符串`和`位置信息`来创建`资产包(AB包)`。不包含更新内容的资产包使用与为更新选择的构建中的文件名相同的文件名编写。如果资产包中包含更新的内容，则会生成一个`包含更新内容的新资产包`，并使用`新文件名`，以便它可以与原始内容共存。只有具有新文件名的资产包必须复制到托管您内容的位置。\n\n系统还为静态内容构建资产包，但您无需将其上载到内容托管位置，因为没有Addressables资产条目引用它们。\n\n\n### 内容更新例子\n\n一个已发布的应用程序知道以下资源组:\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新.png)\n\n\n玩家的设备上有`Local_Static`，并且可能有一个或两个远程包缓存在本地。\n\n如果您修改每个组中的一个资产(AssetA, AssetL, AssetX)，然后运行`Prepare For Content Update`，那么本地可寻址设置的结果如下:\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新1.png)\n\n\n`Prepare For Content Update`操作实际上编辑静态组, 系统构建了上面的布局.\n\n从玩家的角度来看，你最终会得到以下内容:\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新3.png)\n\n`Local_Static包`已经在设备上，您不能更改它。这个旧版本的`AssetA`不再被引用。相反，它作为死数据被卡在设备上.\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新4.png)\n\n`Remote_Static包`没有改变。如果它还没有缓存在播放器的设备上，它将在请求`AssetM`或`AssetN`时下载。像`AssetA`一样，如果请求`AssetL`,这个旧版本的`AssetL`不再被引用。\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新5.png)\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新6.png)\n\n旧的`Remote_NonStatic包`被替换为一个新版本，由它的散列文件来区分。修改后的`AssetX`版本将使用这个新包进行更新。\n\n![](Unity可寻址资产系统AddressableAssetSystem/内容更新7.png)\n\n`content_update_group包`包含修改后的资产组成。\n\n\n1. 任何已更改的本地资产将永久保留在用户设备上.\n2. 如果用户已经缓存了`Remote_NonStatic`,则需要重新下载包，包括未更改的资产（例如，在本例中，AssetY和AssetZ）。理想情况下，用户没有缓存捆绑包，在这种情况下，他们只需要下载`新Remote_NonStatic`捆绑包。\n3. 如果用户已经缓存了`Static_Remote`捆绑包，则他们只需要下载`更新的资产`（在本例中为`AssetL`通过`content_update_group`）。在这种情况下，这是理想的。如果用户没有缓存包，则必须通过`content_update_group`下载新的`AssetL`，并通过未触及的`Remote_Static`包下载现已失效的资产集。无论初始缓存状态如何，在某种程度上，用户的设备上都将拥有已失效的资产集，尽管从未被访问，但该资产集将被无限期缓存。\n\n\n远程内容的最佳设置将取决于您的特定用例。\n\n\n# 资产托管服务\n\n## 概观\n\n托管服务提供了一个集成工具，用于使用`可寻址资产`配置数据从Unity Editor中将打包内容提供给本地或网络连接的应用程序版本。托管服务旨在提高测试打包内容时的迭代速度，还可用于向本地和远程网络上的连接客户端提供内容。\n\n### 打包模式测试和迭代\n\n从编辑器播放模式测试转向平台应用程序构建测试会为开发过程带来复杂性和时间成本。托管服务提供可扩展的编辑器嵌入式内容交付服务，可直接映射到您的Addressables组配置。使用自定义Addressables配置文件，您可以快速配置应用程序以从Unity Editor本身加载所有内容。这包括部署到移动设备或任何其他平台的构建，这些构建可以对您的开发系统进行网络访问。\n\n### 管理key的内容服务器\n\n您可以将资产托管服务部署到服务器环境中，方法是以批处理模式(headless)运行，为内部网和面向internet的Unity应用程序客户机托管内容。\n\n## 建立\n\n本文详细介绍了项目的资产托管服务的初始设置。虽然设置指南侧重于编辑器工作流，但您可以使用API​​通过设置类的`HostingServicesManager属性`来配置托管服务`AddressableAssetSettings。`\n\n### 配置新的主机服务\n\n使用`Hosting window`添加，配置和启用新的主机服务。在编辑器中，`Window > Asset Management > Hosting Services`，或单击`Addressables window`菜单中的`Hosting`按钮以访问`Hosting window`。\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesWindow_1.png)\n\n要添加新的主机服务，请单击“ 添加服务”按钮。\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesAddService_1.png)\n\n在出现的“ 添加服务”对话框中，您可以选择预定义的服务类型或定义自定义服务类型。要使用预定义的服务类型，请从“ 服务类型”下拉选项中进行选择。使用“ 描述性名称”字段输入服务的名称。\n\n新添加的服务显示在“ 主机 ” 窗口的“ 主机服务”部分中，默认为禁用状态。要启动该服务，请单击 **启用服务** 按钮。\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesWindow_2.png)\n\n`HTTP Hosting Service`在启动时`自动分配端口号`。端口号在Unity会话之间保存并重用。要选择其他端口，请在“ 端口”字段中指定特定端口号，或使用“ 重置”按钮随机分配不同的端口。\n\n注意：如果重置端口号，则必须执行完整的应用程序构建以生成并嵌入正确的URL。\n\n现在，HTTP Hosting Service已启用，可以从`BuildPath`每个资产组中指定的目录中提供内容。\n\n## Profile配置文件设定\n\n在开发期间使用托管服务时，Unity建议创建一个配置文件，该配置文件使用专门为此目的创建的一个或多个目录来配置所有资产组以从托管服务加载内容。\n\n在“ 可寻址”窗口菜单（“ 窗口” >“ 资产管理” >“ 可寻址资源”）中，选择“ 配置文件” >“ 检查配置文件设置”。您也可以通过`AddressableAssetSettings`的`Inspector` 访问这些设置。\n\n接下来，创建一个新的配置文件 在以下示例中，新配置文件称为`Editor Hosted`。\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesProfiles_1.png)\n\n修改加载路径字段，改为从托管服务加载。`HttpHostingService`是使用本地IP地址和分配给服务的端口的URL。在“ 主机”窗口中，您可以使用命名的配置文件变量`PrivateIpAddress`并`HostingServicePort`构造URL（例如，`http://[PrivateIpAddress]:[HostingServicePort]`）。\n\n此外，您应该修改所有构建路径变量以指向Project的Assets文件夹之外的公共目录\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesProfiles_2.png)\n\n验证是否正确配置了每个组。确保将路径`BuildPath`和`LoadPath`路径设置为各自的配置文件密钥，这些密钥已修改为与托管服务一起使用。在此示例中，您可以看到如何LoadPath扩展配置文件变量以构建从托管服务加载的正确基本URL。\n\n![](Unity可寻址资产系统AddressableAssetSystem/HostingServicesGroups_1.png)\n\n最后，从`Addressables窗口`中选择`新配置文件(new profile)`，创建构建并部署到目标设备。Unity Editor现在通过`HttpHostingService`服务提供来自应用程序的所有加载请求。您现在可以在不重新部署的情况下对内容进行添加和更改。重建可寻址内容，然后重新启动已部署的应用程序以刷新内容。\n\n## 从批处理模式中开启服务\n\n您还可以使用托管服务从以批处理模式运行的Unity编辑器中提供内容。为此，请使用以下选项从命令行启动Unity：\n\n`-batchMode -executeMethod UnityEditor.AddressableAssets.HostingServicesManager.BatchMode`\n\n这将从默认`AddressableAssetSettings对象`加载`Hosting Services`配置，并启动所有已配置的服务。\n\n要使用备用`AddressableAssetSettings`配置，请创建自己的静态方法入口点，以调用`UnityEditor.AddressableAssets.HostingServicesManager.BatchMode(AddressableAssetSettings settings)`重载。\n\n\n## 实现自定义服务\n\n实现`IHostingService`接口的脚本,您的自定义服务将显示在“ 服务类型”下拉选项中。\n\n# 内存管理\n\n## 镜像加载和卸载\n\n使用可寻址资产时，确保正确内存管理的主要方法是正确镜像加载和卸载调用。如何执行此操作取决于您的资产类型和加载方法。然而，在所有情况下，release方法要么接受加载的资产，要么接受加载返回的操作句柄。\n\n例如: 加载 `a`由`AsyncOperationHandle<SceneInstance>`,您可以通过这个返回的句柄释放它，或者通过`handle.Result`释放它。Result(在本例中是SceneInstance)。\n\n## 资产加载\n\n要加载资产，请使用:\n- `Addressables.LoadAssetAsync`\n- `Addressables.LoadAssetsAsync`。\n\n**这会将资产加载到内存中而不进行实例化**\n\n Every time the load call executes, it adds one to the ref-count for each asset loaded. **每次加载调用执行时，它会为每个加载的资产的ref-count添加一个。**\n\n 如果用相同的地址调用LoadAssetAsync三次，你会得到`AsyncOperationHandle结构体`的三个 **不同实例**，都引用相同的底层操作。对于相应的资产，该操作的`ref-count`为3。如果加载成功，则生成的`AsyncOperationHandle结构`包含`.Result属性`中的资产.您可以使用已加载的资产使用Unity的内置实例化方法进行实例化，该方法不会增加Addressables引用计数。\n\n 要卸载资产，请使用`Addressables.Release`减少`ref-count`的方法。**当给定资产的引用计数为零时，该资产已准备好卸载，并减少任何依赖项的引用计数。**\n\n**注意：资产可能会立即卸载，也可能不会立即卸载，具体取决于现有的依赖项。**\n\n\n## 场景加载\n\n要加载场景，请使用:\n- `Addressables.LoadSceneAsync`\n\n您可以使用此方法加载场景`Single模式`，关闭所有打开的场景或`Additive模式`.\n\n要卸载场景，请使用:\n- `Addressables.UnloadSceneAsync`或在Single模式下打开新场景。\n\n您可以使用Addressables界面或使用`SceneManager.LoadScene`或`SceneManager.LoadSceneAsync`方法打开新场景。打开一个新场景将关闭当前场景，正确地减少`ref-count`.\n\n\n## GameObject实例化\n\n要加载和实例化GameObject资产，请使用:\n- `Addressables.InstantiateAsync`。\n\n这将实例化由指定`location参数`定位的预制件。**Addressables系统将加载Prefab及其依赖项，增加所有相关资产的引用计数。**\n\n`InstantiateAsync`在同一地址上调用三次会导致所有依赖资产的`ref-count`为3。\n不像调用`LoadAssetAsync`三次,每次`InstantiateAsync`调用都会返回一个AsyncOperationHandle指向唯一操作的调用。这是因为每个实例化`InstantiateAsync`的结果都是唯一的实例。`InstantiateAsync`和其他加载调用之间的另一个区别是可选`trackHandle`参数。设置为`false`，必须`AsyncOperationHandle`在释放实例时保持使用。这更有效，但需要更多的开发工作。\n\n要销毁实例化的gameObject，请使用:\n- `Addressables.ReleaseInstance`或关闭包含实例化对象的Scene。\n\n此场景可以在Additive或Single模式下加载（并因此关闭）,也可以使用`Addressables`或`SceneManagement`的API 加载此场景。如果设置trackHandle为false，则只能`Addressables.ReleaseInstance`使用句柄调用，而不能使用实际的GameObject 调用。\n\n**注意：如果您调用`Addressables.ReleaseInstance`的是未使用`Addressables`的API 创建的实例，或者是使用该API创建的trackHandle==false，则系统会检测到该false实例并返回以指示该方法无法释放指定的实例。在这种情况下，实例不会被销毁。**\n\n`Addressables.InstantiateAsync`有一些相关的开销，所以如果你需要每帧数百次实例化相同的对象，考虑通过`Addressables`的API 加载，然后通过其他方法实例化。在这种情况下，您将调用`Addressables.LoadAssetAsync`，然后保存结果并调用`GameObject.Instantiate()`该结果。这允许以 **Instantiate同步方式调用**。缺点是 **Addressables系统不知道您创建了多少个实例**，如果管理不当，可能会导致内存问题。例如，引用纹理的预制件将不再具有要引用的有效加载纹理，从而导致渲染问题（或更糟）。这些问题可能很难追踪，因为您可能无法立即触发内存卸载.\n\n\n## 可寻址的分析器Profiler\n\n使用 **Addressable Profiler窗口** 监视所有Addressables系统操作的`引用计数`。要在编辑器中访问该窗口，请选择 `Window > Asset Management > Addressable Profiler`。\n\n要点：要在分析器中查看数据，**必须在对象的检查器中启用`Send Profiler Events`设置** 在`AddressableAssetSettings`。\n\n分析器中提供了以下信息：\n- 白色垂直线表示发生加载请求的帧。\n- 蓝色背景表示当前正在加载资产。\n- 图表的绿色部分表示资产的当前引用计数。\n\n## 何时清除内存\n\n不再引用的资产（由分析器中蓝色部分的末尾表示）并不一定意味着资产已被卸载。常见的适用方案涉及资产包中的多个资产。\n\n- 在一个资产包(stuff材料)中有三个资产(`树`、`坦克`和`牛`)\n- 当`树`加载时，分析器会显示一个`树`的`ref-count`和一个`stuff`的`ref-count`。\n- 当坦克加载时，分析器将显示`树`和`坦克`的一个`ref-count`，以及`stuff`包的两个`ref-count`。\n- 如果你释放`树`，它的ref-count变为零，蓝色的条就消失了。\n\n在此示例中，此时tree资产实际上未卸载。您可以加载资产包或其部分内容，但 **不能部分卸载资产包。** `stuff`在`bundle`本身完全卸载之前，不会卸载任何资产。**此规则的例外是引擎接口`Resources.UnloadUnusedAssets`.** 在上面的场景中 **执行此方法将导致tree卸载**。由于Addressables系统无法识别这些事件，因此探查器图仅反映了Addressables引用计数（不完全是内存的内容）。请注意，如果您选择使用`Resources.UnloadUnusedAssets`，则操作非常慢，并且只应在不显示任何故障的屏幕上调用（例如加载屏幕）。\n\n\n# 异步操作处理\n\n`Addressables`API中的几个方法返回一个`AsyncOperationHandle结构`。此句柄的主要目的是允许访问操作的状态和结果。在您调用`Addressables.Release`或`Addressables.ReleaseInstance`执行操作之前，操作的结果是有效的.\n\n\n**操作完成后，`AsyncOperationHandle.Status`属性为`AsyncOperationStatus.Succeeded`或`AsyncOperationStatus.Failed`。如果成功，您可以通过该`AsyncOperationHandle.Result`属性访问结果。**\n\n您可以定期检查操作状态，也可以使用该`AsyncOperationHandle.Complete`事件注册完成的回调。当您不再需要返回的`AsyncOperationHandle结构`提供的资产时，您应该使用该方法释放它`Addressables.Release`。\n\n\n## Type vs typeless handles(类型与无类型句柄)\n\n大多数`Addressables`API方法返回一个通用`AsyncOperationHandle<T>结构`，允许`AsyncOperationHandle.Completed`事件和`AsyncOperationHandle.Result`对象的类型安全。还有一个非泛型`AsyncOperationHandle`结构，您可以根据需要在两个句柄之间进行转换。\n\n请注意，如果您尝试将`非泛型句柄`强制转换为`不正确类型的泛型句柄`，则会发生运行时异常\n\n```csharp\nAsyncOperationHandle<Texture2D> textureHandle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\");\n\n// 转换AsyncOperationHandle<Texture2D> 成一个 AsyncOperationHandle:\n// 泛型Handle转换成非泛型Handle\nAsyncOperationHandle nonGenericHandle = textureHandle;\n\n// 转换AsyncOperationHandle成一个 AsyncOperationHandle<Texture2D>:\n// 非泛型Handle转换成泛型Handle\nAsyncOperationHandle<Texture2D> textureHandle2 = nonGenericHandle.Convert<Texture2D>();\n\n// 会抛出异常,必须是Texture2D类型\nAsyncOperationHandle<Texture> textureHandle3 = nonGenericHandle.Convert<Texture>();\n\n```\n\n## AsyncOperationHandle用例示例\n\n使用`AsyncOperationHandle.Completed`回调注册完成事件的侦听器：\n\n```csharp\nvoid Start()\n{\n    // 注册回调, 加载完成后调用TextureHandle_Completed\n    AsyncOperationHandle<Texture2D> textureHandle = Addressables.LoadAsset<Texture2D>(\"mytexture\");\n    textureHandle.Completed += TextureHandle_Completed;\n}\n\nprivate void TextureHandle_Completed(AsyncOperationHandle<Texture2D> handle)\n{\n    if (handle.Status == AsyncOperationStatus.Succeeded)\n    {\n        Texture2D result = handle.Result;\n        // 纹理可以使用了。\n    }\n}\n```\n\n`AsyncOperationHandle`实现`IEnumerator`所以它可以在协同程序中产生：\n\n```csharp\npublic IEnumerator Start()\n{\n    AsyncOperationHandle<Texture2D> handle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\");\n    yield return handle;\n    if (handle.Status == AsyncOperationStatus.Succeeded)\n    {\n        Texture2D texture = handle.Result;\n        // The texture is ready for use.\n        // ...\n        // Release the asset after its use:\n        Addressables.Release(handle);\n    }\n}\n```\n\n`Addressables`还通过`AsyncOperationHandle.Task`属性支持异步`await`。\n\n```csharp\npublic async Start()\n{\n    AsyncOperationHandle<Texture2D> handle = Addressables.LoadAssetAsync<Texture2D>(\"mytexture\");\n    await handle.Task;\n    // 任务完成了。在存储结果之前，请确保检查状态是否成功。\n}\n```\n\n\n注意:使用`SceneManager.LoadSceneAsync`加载场景并将`allowSceneActivation`设置为`false`或使用`Addressables.LoadSceneAsync`并为`activateOnLoad`参数传入`false`会导致随后的异步操作被阻塞，无法完成。\n\n\n\n# 自定义操作\n\n`IResourceProvider`接口 API允许您通过以数据驱动的方式定义位置和依赖项来扩展加载过程。\n在某些情况下，您可能希望创建自定义操作。`IResourceProvider` API内部构建在这些自定义操作之上。\n\n## 创建自定义操作\n\n通过从`AsyncOperationBase`类派生并覆盖所需的虚拟方法来创建自定义操作。您可以将派生操作传递给`ResourceManager.StartOperation`方法以启动操作并接收`AsyncOperationHandle结构`。以这种方式启动的操作注册到ResourceManager并出现在Addressables分析器中。\n\n\n- 执行操作\n\nResourceManager调用`AsyncOperationBase.Execute`方法。以便在可选的依赖项操作完成后进行自定义操作。\n\n- 完成处理\n\n当您的自定义操作完成时，调用`AsyncOperationBase.Complete`。在自定义操作对象上。您可以在`Execute`方法中调用它，也可以将其推迟到调用的外部。调用`AsyncOperationBase.Complete`通知ResourceManager操作已经完成，并将调用关联的AsyncOperationHandle。完成事件。\n\n- 终止操作\n\nResourceManager调用`AsyncOperationBase.Destroy`。释放引用`AsyncOperationHandle`时的自定义操作。这里应该释放与自定义操作关联的任何内存或资源。\n\n# Analyze分析\n\nAnalyze是一个收集有关Projects的Addressables布局信息的工具。在某些情况下，Analyze可能会采取适当的措施来清理项目的状态。在其他情况下，Analyze纯粹是一个信息工具，可让您就Addressables布局做出更明智的决策。\n\n## 使用Analyze\n在编辑器中，打开“ 可寻址”窗口（“ 窗口” >“ 资产管理” >“ 可寻址资源”），然后单击菜单中的`Analyze`按钮以打开 `Analyze window`.。\n\n“分析”窗口显示“分析”规则列表以及以下操作：\n- 分析所选规则\n  - 分析操作是规则的信息收集步骤。\n- 修复所选规则\n  - 这使用在分析步骤期间收集的数据来执行任何必要的修改并解决问题。\n- 清除所选规则\n  - 此操作将删除分析收集的所有数据并相应地更新TreeView。\n\n\n## 提供分析规则\n\n可修复的规则\n- 检查重复的组依赖关系\n\n此规则通过扫描所有组`BundledAssetGroupSchemas`并投影资产组布局来检查可能重复的资产。这基本上需要触发完整的构建，因此这种检查既耗时又耗费性能。\n\n**问题**：重复的资产是由共享依赖关系的不同组中的资产导致的，例如共享存在于不同可寻址组中的材质的两个预制体。该材质(及其任何依赖项)将被拉入包含预制块的两组中。为了防止这种情况的发生，必须将材质标记为可寻址的，或者使用预制体之一，或者在它自己的空间中，从而将材料及其依赖关系放在一个单独的可寻址组中。\n\n**解决方案**：如果此检查发现任何问题，则对此规则运行修复操作会创建一个新的可寻址组，可在其中移动所有相关资产。\n\n**例外**：如果您有一个包含多个对象的资产，则不同的组可能只会拉入部分资产，而不会实际复制。具有许多网格的FBX就是一个例子。如果一个网格在“GroupA”中而另一个在“GroupB”中，则此规则将认为FBX是共享的，如果运行修复操作，则将其提取到自己的组中。在这种边缘情况下，运行修复操作实际上是有害的，因为两个组都没有完整的FBX资产。\n\n另请注意，重复的资产可能并不总是一个问题。如果资产永远不会被同一组用户请求（例如，特定于区域的资产），则可能需要重复的依赖性，或者至少是无关紧要的。每个项目都是唯一的，因此应根据具体情况评估修复重复的资产依赖性。\n\n## 无法修复的规则\n\n- 检查Resources找到可寻址的重复依赖项\n\n此规则检测构建的可寻址数据与驻留在Resources文件夹中的资产之间是否存在任何资产或资产依赖关系。\n\n**问题**：这些重复意味着数据将包含在应用程序构建和Addressables构建中。\n\n**解决方案**：此规则不可修复，因为不存在适当的操作。它纯粹是信息性的，提醒您冗余。您必须决定如何进行以及采取何种措施（如果有的话）。可能的手动修复的一个示例是将有问题的资产移出Resources文件夹，并使它们成为可寻址的。\n\n\n- 检查场景是否有可寻址的重复依赖项\n\n此规则检测“编辑器场景”列表和“可寻址”中场景之间共享的任何资产或资产依赖项。\n\n**问题**：这些重复意味着数据将包含在应用程序构建和Addressables构建中。\n\n**解决方案**：它纯粹是信息性的，提醒您冗余。您必须决定如何进行以及采取何种措施（如果有的话）。可能的手动修复的一个示例是从构建设置中拉出带有重复引用的内置场景，并使其成为可寻址场景。\n\n## 将自定义规则添加到GUI\n自定义规则必须使用GUI类自身注册AnalyzeWindow.RegisterNewRule<RuleType>()，才能显示在“ 分析”窗口中。例如：\n\n```csharp\nclass MyRule : AnalyzeRule {}\n[InitializeOnLoad]\nclass RegisterMyRule\n{\n    static RegisterMyRule()\n    {\n        AnalyzeWindow.RegisterNewRule<MyRule>();\n    }\n}\n```\n\n# 升级到Addressables系统\n\n本文详细介绍了如何修改现有项目以利用可寻址资产。引用资产有三种传统方法：\n\n- **直接引用**：将资源直接添加到应用程序自动加载的组件或场景中。\n- **资源文件夹**：将资源添加到 Resource文件夹并按文件名加载它们。\n- **Asset Bundles**：将资产添加到资产包，然后按文件路径加载它们的依赖项。\n\n\n## 直接引用\n\n1. 替换对具有资产引用的对象的直接引用（例如，`public GameObject directRefMember;`变为`public AssetReference AssetRefMember;`）。\n2. 将资源拖动到相应组件的Inspector上，就像直接引用一样。\n3. 如果希望基于对象而不是字符串名称加载资产，请直接从您在设置中创建的AssetReference对象实例化它（例如，`AssetRefMember.LoadAssetAsync<GameObject>();`或`AssetRefMember.InstantiateAsync(pos, rot);`）。\n\n注意：可寻址资产系统`异步`加载资产。更新对资产引用的直接引用时，还必须更新代码以`异步操作`。\n\n## Resource文件夹\n\n将Resources文件夹中的资产标记为Addressable时，**系统会自动将资源从Resources文件夹移动到名为Resources_moved的Project中的新文件夹**。移动资产的默认地址是旧路径，省略文件夹名称。例如，您的加载代码可能会更改`Resources.LoadAsync<GameObject>(\"desert/tank.prefab\");`为`Addressables.LoadAssetAsync<GameObject>(\"desert/tank.prefab\");`。\n\n## AB包方法\n\n当您打开Addressables窗口时，**Unity提供将所有资产包转换为可寻址资产组**。这是迁移代码的最简单方法。\n\n**如果选择手动转换资产**，请单击 **忽略** 按钮。然后，**使用先前描述的直接引用或资源文件夹方法。**\n\n资产地址的默认路径是其文件路径。如果您使用路径作为资产的地址，则您将以与从捆绑中加载的方式相同的方式加载资产。可寻址资产系统处理捆绑包及其所有依赖项的加载。\n","tags":["Unity资源管理系统"]},{"title":"17委托","url":"/2019/08/27/17委托/","content":"\n# 认识委托\n\n```csharp\ninternal sealed class DelegateIntro\n{\n    // 声明一个实例委托\n    // 该方法获取一个Int32参数,返回void\n    // Feedback 反馈,回复\n    internal delegate void Feedback(Int32 value);\n\n    public static void Go()\n    {\n        // 用委托回调静态方法\n        StaticDelegateDemo();\n        // 用委托回调实例方法\n        InstanceDelegateDemo();\n        ChainDelegateDemo1(new DelegateIntro());\n        ChainDelegateDemo2(new DelegateIntro());\n    }\n\n    /// <summary>\n    /// 用委托回调静态方法\n    /// </summary>\n    private static void StaticDelegateDemo()\n    {\n        Console.WriteLine(\"----- Static Delegate Demo -----\");\n        Counter(1, 3, null);\n        // 委托对象是方法的包装器(wrapper),使方法能通过包装器来间接回调\n        // FeedbackToConsole方法作用就是向控制台输出字符\n        Counter(1, 3, new Feedback(FeedbackToConsole)); // DelegateIntro. 前缀可选\n        Counter(1, 3, new Feedback(FeedbackToMsgBox));\n        Console.WriteLine();\n\n        // 即使Counter在其他类中定义, 但是要求委托对象是具有足够安全性和可访问性代码创建的\n        // 通过委托来调用另一个类型的私有方法FeedbackToConsole也是没问题的\n\n        // 这个例子中的所有操作都是类型安全的,在构造Feedback委托对象时,\n        // 编译器确保FeedbackToConsole和FeedbackToMsgBox方法的签名都兼容于Feedback委托定义的签名\n\n        // 将方法绑定到委托时, CLR和C#都允许引用类型的协变性(out返回子类)和逆变性(in参数基类)\n        // 只有引用类型才支持逆变性和协变性,,值类型或void不支持\n        // --> 之所以不支持是因为值类型的存储结构是变化的,不像引用类型始终是一个指针\n        // delegate Object MyCallback(FileStream fs);\n        // 通过协变性和逆变性可以绑定以下方法\n        // String SomeMethod(Stream s);\n    }\n\n    private static void InstanceDelegateDemo()\n    {\n        Console.WriteLine(\"----- Instance Delegate Demo -----\");\n        // 先要构造对象\n        DelegateIntro di = new DelegateIntro();\n        // 用委托对象包装一个实例方法\n        Counter(1, 3, new Feedback(di.FeedbackToFile));\n\n        Console.WriteLine();\n    }\n\n    private static void ChainDelegateDemo1(DelegateIntro di)\n    {\n        Console.WriteLine(\"----- Chain Delegate Demo 1 -----\");\n        Feedback fb1 = new Feedback(FeedbackToConsole);\n        Feedback fb2 = new Feedback(FeedbackToMsgBox);\n        Feedback fb3 = new Feedback(di.FeedbackToFile);\n\n        Feedback fbChain = null;\n        fbChain = (Feedback) Delegate.Combine(fbChain, fb1);\n        fbChain = (Feedback) Delegate.Combine(fbChain, fb2);\n        fbChain = (Feedback) Delegate.Combine(fbChain, fb3);\n        Counter(1, 2, fbChain);\n\n        Console.WriteLine();\n        fbChain = (Feedback) Delegate.Remove(fbChain, new Feedback(FeedbackToMsgBox));\n        Counter(1, 2, fbChain);\n    }\n\n    private static void ChainDelegateDemo2(DelegateIntro di)\n    {\n        Console.WriteLine(\"----- Chain Delegate Demo 2 -----\");\n        Feedback fb1 = new Feedback(FeedbackToConsole);\n        Feedback fb2 = new Feedback(FeedbackToMsgBox);\n        Feedback fb3 = new Feedback(di.FeedbackToFile);\n\n        Feedback fbChain = null;\n        fbChain += fb1;\n        fbChain += fb2;\n        fbChain += fb3;\n        Counter(1, 2, fbChain);\n\n        Console.WriteLine();\n        fbChain -= new Feedback(FeedbackToMsgBox);\n        Counter(1, 2, fbChain);\n    }\n\n    /// <summary>\n    /// 从from计数到to\n    /// </summary>\n    /// <param name=\"from\"></param>\n    /// <param name=\"to\"></param>\n    /// <param name=\"fb\"> Feedback委托对象的引用 </param>\n    private static void Counter(Int32 from, Int32 to, Feedback fb)\n    {\n        // 遍历所有整数\n        for (Int32 val = from; val <= to; val++)\n        {\n            // 如果指定了任何回调,则调用它们\n            // 并将val值传给回调方法\n            if (fb != null)\n                fb(val);\n        }\n    }\n\n    private static void FeedbackToConsole(Int32 value)\n    {\n        Console.WriteLine(\"Item=\" + value);\n    }\n\n    private static void FeedbackToMsgBox(Int32 value)\n    {\n        MessageBox.Show(\"Item=\" + value);\n    }\n\n    private void FeedbackToFile(Int32 value)\n    {\n        StreamWriter sw = new StreamWriter(\"Status\", true);\n        sw.WriteLine(\"Item=\" + value);\n        sw.Close();\n    }\n}\n```\n\n**委托对象是方法的包装器(wrapper),使方法能通过包装器来间接回调**.\n\n将方法绑定到委托时, CLR和C#都允许引用类型的`协变性(out返回子类)和逆变性(in参数基类)`,只有引用类型才支持逆变性和协变性,值类型或void不支持(之所以不支持是因为值类型的存储结构是变化的,不像引用类型始终是一个指针)\n\n`delegate Object MyCallback(FileStream fs);`\n通过协变性和逆变性可以绑定以下方法\n`String SomeMethod(Stream s);`\n\n# 委托揭秘\n\n使用`delegate`关键字定义, 用`new`操作符构造委托实例,用委托对象的变量替代方法名调用回调函数.\n\n实际上编译器和CLR在幕后做了大量工作来隐藏复杂性.\n\n`internal delegate void Feedback(Int32 value);` 编译器会像下面这样定义一个完整的类:\n\n```csharp\ninternal class Feedback: System.MulticastDelegate\n{\n    // 构造器\n    public Feedback(Object object, IntPtr method);\n    // 这个方法和源代码指定的原型一样\n    public virtual void Invoke(Int32 value);\n\n    // 以下方法实现了对回调方法的异步回调\n    public virtual IAsyncResult BeginInvoke(Int32 value, AsyncCallback callback, Object object);\n    public virtual void EndInvoke(IAsyncResult result);\n}\n```\n\n![](17委托/QQ截图20190831123154.png)\n\n所有委托都派生自`MulticastDelegate`,`MulticastDelegate`派生自`Delegate`.\n\n**由于委托是类, 凡是能定义类的地方都能定义委托.**\n\n以下是`MulticastDelegate`的三个重要的非公共字段:\n\n![](17委托/QQ截图20190831123958.png)\n\n- 所有委托都有一个`构造器`: 需要获取2个参数\n  - 对象引用\n  - 引用了回调方法的整数(`_IntPtr`)\n\n根据前面的源码, 传递的是`p.FeedbackToFile`这样的值, C#编译器知道要构造的是委托, 所以会分析源代码来确定引用的是哪个对象和方法. 对象引用被传递给构造器的`object参数`, 标识了一个`特殊IntPtr值`(从MethodDef或MemberRef元数据token获得)被传给构造器的`method`参数.  对于静态方法,会为`object参数`传递`null值`.\n\n所以每个委托对象都是一个包装器,其中包装了:\n- 一个方法.\n- 调用该方法时要操作的对象.\n\n```csharp\nFeedback fbStatic = new Feedback(Program.FeedbackToConsole);\nFeedback fbInstance = new Feedback(new Program.FeedbackToFile());\n```\n\n![](17委托/QQ截图20190831125652.png)\n\n以上是委托对象如何构造和内部结构,再来看回调方法如何调用.\n\n```csharp\n/// <summary>\n/// 从from计数到to\n/// </summary>\n/// <param name=\"fb\"> Feedback委托对象的引用 </param>\nprivate static void Counter(Int32 from, Int32 to, Feedback fb)\n{\n    // 遍历所有整数\n    for (Int32 val = from; val <= to; val++)\n    {\n        // 如果指定了任何回调,则调用它们\n        // 并将val值传给回调方法\n        if (fb != null)\n            fb(val);// 可以写成显式调用 fb.Invoke(val);\n    }\n}\n```\n\n**fb的null检查必不可少**, `fb(val);`看上去是调用了方法并传递了一个参数,实际上没有名为fb的函数,而是编译器知道fb是引用了委托对象的变量,所以会生成代码调用该委托对象Invoke方法.生成的代码是`fb.Invoke(val);`, 所以也可以显式的调用Invoke方法.\n\n`Invoke方法`被调用时,会使用私有字段`_target`和`_methodPtr`在指定的私有对象上调用包装好的回调方法.\n\n**Invoke方法的签名和委托的签名匹配.**\n\n# 用委托回调多个方法(委托链)\n\n`委托链`是`委托对象`的集合.\n\n```csharp\nprivate static void ChainDelegateDemo1(DelegateIntro di)\n{\n    Console.WriteLine(\"----- Chain Delegate Demo 1 -----\");\n    Feedback fb1 = new Feedback(FeedbackToConsole);\n    Feedback fb2 = new Feedback(FeedbackToMsgBox);\n    Feedback fb3 = new Feedback(di.FeedbackToFile);\n\n    // 此变量委托变量用来引用委托链\n    Feedback fbChain = null;\n    // Delegate.Combine方法将公共静态方法FeedbackToConsole委托添加到委托链中\n    fbChain = (Feedback) Delegate.Combine(fbChain, fb1);\n    fbChain = (Feedback) Delegate.Combine(fbChain, fb2);\n    fbChain = (Feedback) Delegate.Combine(fbChain, fb3);\n    Counter(1, 2, fbChain);\n\n    fbChain = (Feedback) Delegate.Remove(fbChain, new Feedback(FeedbackToMsgBox));\n    Counter(1, 2, fbChain);\n}\n```\n\n![](17委托/QQ截图20190831132222.png)\n\n## Delegate.Combine的过程\n\n![](17委托/QQ截图20190831132540.png)\n\n![](17委托/QQ截图20190831140241.png)\n\n在第一次执行`Delegate.Combine`方法时,发现试图合并`null`和`fb1`,在方法内部直接返回`fb1`中的值,所以当前`fbChain`变量引用`fb1`变量所引用的委托对象.\n\n第二次执行`Delegate.Combine`方法时,在内部,发现`fbChain`已经引用了一个委托对象,所以Combine会构造一个新的委托对象. **新的委托对象对它的私有字段`_target`和`_methodPtr`进行初始化.** `_invocationList`字段被初始化为引用一个委托对象的数组, 数组的第一个索引0是`FeedbackToConsole`方法的委托(也就是`fbChain`当前的引用的委托). 最后`fbChain`被设为引用新建的委托对象.\n\n> 注意之前新建的委托及其`_invocationList`会进行垃圾回收.\n\n伪代码的形式,Feedback的Invoke方法基本上是像下面这样实现的:\n\n```csharp\npublic void Invoke(Int32 value)\n{\n   Delegate[] delegateSet = _invocationList as Delegatep[];\n   if(delegateSet != null)\n   {\n      foreach(Feedback d in delegateSet)\n        d(value); // 调用每个委托\n   }else // 否则就不是委托链\n   {\n      // 该委托标识了要回调的当个方法\n      // 在指定的目标对象上调用这个回调方法\n      _methodPtr.Invoke(_target, value);\n      // 上面这行代码接近实际的代码,实际发生的事情用C#表示不出来的\n   }\n}\n```\n\n## Delegate.Remove的过程\n\nRemove方法被调用时,它扫描`fbChain`所引用的委托对象内部维护的委托数组(从末尾向索引0扫描).\n\n查找的是其`_target`和`_methodPtr`字段与第二个实参中的字段匹配的委托,如果匹配到,并且在删除后数组中剩余一个数据项, 就返回那个数据项. 如果还有多个数据项,就新建一个委托对象, 创建并初始化`_invocationList`引用剩余的数据项, 返回对这个新建委托对象的引用.\n\n## 有返回值的委托\n\n```csharp\npublic delegate Feedback(Int32 value);\n\npublic void Invoke(Int32 value)\n{\n   Int32 result;\n   Delegate[] delegateSet = _invocationList as Delegatep[];\n   if(delegateSet != null)\n   {\n      foreach(Feedback d in delegateSet)\n        result = d(value); // 调用每个委托\n   }else // 否则就不是委托链\n   {\n      // 该委托标识了要回调的当个方法\n      // 在指定的目标对象上调用这个回调方法\n      result = _methodPtr.Invoke(_target, value);\n      // 上面这行代码接近实际的代码,实际发生的事情用C#表示不出来的\n   }\n   return result;\n}\n```\n\n返回值被保存到result变量中, **但是result变量只包含调用最后一个委托的结果**(前面的返回值会被丢弃). result返回给调用Invoke的代码.\n\n\n## C#对委托链的支持(提供了+=和-=操作符)\n\nC#编译器自动为委托类型的实例重载了`+=`和`-=`操作符.\n\n- `+=` 调用了 `Delegate.Combine`\n- `-=` 调用了 `Delegate.Remove`\n\n生成的IL代码是一样的.\n\n## 获取对委托链调用的更多控制\n\n上述Invoke调用算法是依次遍历, 有 **局限性**:\n- 除了最后一个返回值,其他所有回调方法的返回值都会被丢弃\n- 如果被调用的委托中有一个抛出异常或者阻塞,链中后续的所有对象都调用不了.\n\n这种时候Invoke里的算法就不胜其任, 所以`MulticastDelegate类`提供了一个实例方法`GetInvocationList`,用于显式调用链中的每一个委托,并允许你使用需要的任何算法:\n\n```csharp\npublic abstract class MulticastDelegate : Delegate\n{\n    // 创建一个委托数组，其中每个元素都引用链中的一个委托\n    public sealed override Delegate[] GetInvocationList();\n}\n```\n\n`GetInvocationList`方法操作从`MulticastDelegate`派生的对象, 返回包含`Delegate引用`的一个数组. 在内部,`GetInvocationList`构造并初始化一个数组,让它的每一个元素都引用链中的一个委托. 如果`_invocationList`字段为null,返回的数组就只有一个元素,该元素引用链中唯一的委托(委托实例本身).\n\n\n```csharp\ninternal static class GetInvocationList\n{\n    // 定义一个灯组件\n    internal sealed class Light\n    {\n        // 返回灯的状态\n        public String SwitchPosition()\n        {\n            return \"灯光熄灭了\";\n        }\n    }\n\n    // 定义一个风扇组件\n    internal sealed class Fan\n    {\n        // 返回风扇状态\n        public String Speed()\n        {\n            throw new InvalidOperationException(\"风扇过热而坏了\");\n        }\n    }\n\n    // 定义一个扬声器\n    internal sealed class Speaker\n    {\n        // 返回扬声器的状态\n        public String Volume()\n        {\n            return \"音量太大了\";\n        }\n    }\n\n    // 定义一个委托查询组件的状态\n    private delegate String GetStatus();\n\n    public static void Go()\n    {\n        // 声明空的委托链\n        GetStatus getStatus = null;\n\n        // 构造3个组件,将他们的状态方法添加进委托链\n        getStatus += new GetStatus(new Light().SwitchPosition);\n        getStatus += new GetStatus(new Fan().Speed);\n        getStatus += new GetStatus(new Speaker().Volume);\n\n        // 显示整理好的状态报告,反应这三个组件的状态\n        Console.WriteLine(GetComponentStatusReport(getStatus));\n    }\n\n    // 查询组件并返回状态报告\n    private static String GetComponentStatusReport(GetStatus status)\n    {\n        // 如果委托对象为空,不执行任何操作\n        // 必要的null检查\n        if (status == null) return null;\n\n        // 使用StringBuilder来构造字符串,因为要添加删减\n        StringBuilder report = new StringBuilder();\n\n        // 将委托链中的委托放入数组\n        Delegate[] arrayOfDelegates = status.GetInvocationList();\n\n        // 遍历数组中的每一个委托\n        foreach (GetStatus getStatus in arrayOfDelegates)\n        {\n            try\n            {\n                // 获取组件的状态并附加在报告中\n                report.AppendFormat(\"{0}{1}{1}\", getStatus(), Environment.NewLine);\n            }\n            // 如果有组件有错误异常\n            catch (InvalidOperationException e)\n            {\n                // (property) object System.Delegate.Target 获取类实例，当前委托将对其调用实例方法。\n                Object component = getStatus.Target;\n                // component.GetType()  --> Fan\n                // getStatus.GetMethodInfo().Name --> Speed\n                report.AppendFormat(\n                    \"无法从 {1}{2}{0} 获得状态  错误: {3}{0}{0}\",\n                    Environment.NewLine,\n                    ((component == null) ? \"\" : component.GetType() + \".\"),\n                    getStatus.GetMethodInfo().Name, e.Message);\n            }\n        }\n\n        // 把整理好的报告返回给调用者\n        // 灯光熄灭了\n        //\n        // 无法从 Fan.Speed 获得状态\n        //     错误 : 风扇过热而坏了\n        //\n        // 音量太大了\n        return report.ToString();\n    }\n}\n```\n\n# 委托定义不要太多(委托泛型)\n\n定义的委托 如果返回值和参数类型相同,就是一样的. 不需要重复定义不同名称的委托.\n\n> 实例化该委托的多个实例,就可以实现一样的效果\n\n\n现在，.NET Framewoke现在支持泛型，所以实际上只需要几个泛型委托就可以表示获取多达16个参数的方法：\n```csharp\n// 无返回值的委托\npublic delegate void Action(); //这不是泛型\npublic delegate void Action<T>(T obj);\npublic delegate void Action<T1,T2>(T1 obj1,T2 obj2);\npublic delegate void Action<T1,T2,T3>(T1 obj1,T2 obj2,T3 obj3);\n....\n\n// 有返回值的委托\npublic delegate TResult Func<TResult>();\npublic delegate TResult Func<T,TResult>(T1 arg);\npublic delegate TResult Func<T1,T2,TResult>(T1 arg1,T2 arg2);\n....\n```\n\n**建议使用这些自带的委托定义,减少系统中的类型数量,同时简化编码.**\n\n## 需要自定义委托的情况\n\n- 使用`ref`或`out`关键字以传引用的方式传递参数.\n  - `delegate void Bar(ref Int32 z);`\n  - ref标记:调用方法前 必须先初始化被ref标记的参数, 被调用的方法 可以读写这个参数值.\n  - out标记:被传入调用方法的参数 不必要初始化, 被调用的方法不能读取参数值, 在返回前\n必须向这个值写入.\n- 需要委托通过C#的params关键字获取数量可变的参数\n- 要为委托的任何参数指定默认值\n- 对委托的泛型类型参数进行约束\n\n\n**要获取泛型实参并有返回值的委托支持逆变和协变.**\n\n> “协变”->”和谐的变”->”很自然的变化”->string->object :协变。\n> “逆变”->”逆常的变”->”不正常的变化”->object->string :逆变。\n\n# C#为委托提供的简化语法\n\n多开发人员认为和委托打交道很麻烦。因为它的语法很奇怪。例如以下代码：\n```csharp\n// 向按钮空间登记button1_Click的地址,以便在按钮被单击时调用方法\nbutton1.Click += new EventHandle(button1_Click);\n\n// 其中的button1_Click是一个方法，它看起来像下面这样：\nvoid button1_Click(Object sender, EventArgs e)\n{\n    // 按钮单击后要做的事情....\n}\n```\n\n仅仅为了指定button1_Click方法的地址,就要构造一个EventHandle委托对象,有点麻烦. 然而这时CLR要求的, 因为这个对象提供一个包装器,可确保被包装的方法只能以类型安全的方式调用. 这个包装器还支持调用实例方法和委托链. 所以更多程序喜欢像`button1.Click += button1_Click;`这样写. **C#提供的语法糖为程序员提供了一种更简单的方式生成CLR处理委托时所必须的IL代码.**\n\n## 简化语法1: 不需要构造委托对象\n\n由于C#编译器能自己进行推断,所以可以省略构造WaitCallback委托对象的代码,**但是实际上,C#编译器还是会生成IL代码来新建WaitCallback委托对象,** 只是语法上进行了简化 .\n\n```csharp\npublic sealed class AClass\n{\n    private static void CallbackWithoutNewingADelegateObject()\n    {\n        // QueueUserWorkItem 需要一个WaitCallback委托对象引用\n        // 由于C#编译器能自己进行推断,所以可以省略构造WaitCallback委托对象的代码\n        // 但是实际上,C#编译器还是会生成IL代码来新建WaitCallback委托对象\n        // 只是语法上进行了简化                \n        ThreadPool.QueueUserWorkItem(SomeAsyncTask,5);\n    }\n\n    // 要和 public delegate void WaitCallback(object state);定义一致\n    private static void SomeAsyncTask(Object o)\n    {\n        Console.WriteLine(o);\n    }\n}\n```\n\n## 简化语法2: 不需要定义回调方法(lambda表达式)\n\nC#允许以内联(直接嵌入)的方式写回调方法的代码,不必在它自己的方法写.\n\n```csharp\nprivate static void CallbackWithoutNewingADelegateObject()\n{\n    // lambda表达式\n    ThreadPool.QueueUserWorkItem(obj => Console.WriteLine(obj),5);\n}\n```\n\nlambda表达式可以在编译器预计会看到一个委托的地方使用. **编译器在看到这个lambda表达式之后,会在本类中自动定义一个新的私有方法**, 这个新方法称为 **匿名函数**. 因为你不知道这个函数的名称,但可以利用ILDasm.exe看到C#将该方法命名为`<CallbackWithoutNewingADelegateObject>b_0`,它获取一个Object返回void.\n\nCLR能用`<`符号开头命名,C#则不允许标识符包含`<`, 这就不会让匿名函数和你的函数命名重复. 但是可以通过反射来访问方法,但是C#语言规范指出,编译器生成名称的方式是没有任何保证的,每次编译代码可能生成一个不同的名称.\n\nC#编译器向匿名函数应用了`ComplierGeneratedAttribute`特性, `=> `操作符右侧的代码被放入编译器生成的方法中.\n\n> 写lambda表达式时没有办法向编译器生成的方法应用定制特性. 不能向方法应用任何修饰符比如unsafe,这一般不会有什么问题,因为编译器生成的方法总是私有方法,要么是静态的要么是非静态的, 这取决于方法是否访问了任何实例成员. 没必要向方法应用public,property,internal,virtual,sealed,override,abstract之类的修饰符.\n\n以下是C#编译器改写上段代码的结果:\n\n```csharp\ninternal sealed class AClass\n{\n  // 创建该私有字段视是为了缓存委托对象\n  // 优点: CachedAnonymousMethodDelegatel不会每次调用都新建一个对象\n  // 缓存的对象永远不会被垃圾回收\n  [ComplierGenerated]\n  private static WaitCallback <>9_CachedAnonymousMethodDelegatel;\n\n  private static  void CallbackWithoutNewingADelegateObject()\n  {\n      if(<>9_CachedAnonymousMethodDelegatel !=  null)\n      {\n         // 第一次调用时,创建委托对象并缓存它\n         <>9_CachedAnonymousMethodDelegatel = new WaitCallback(<CachedAnonymousMethodDelegatel>b__0);\n      }\n      ThreadPool.QueueUserWorkItem(<>9_CachedAnonymousMethodDelegatel,5);\n  }\n\n  [ComplierGenerated]\n   private static void <CachedAnonymousMethodDelegatel>b__0(Object obj)\n   {\n      Console.WriteLine(obj);\n   }\n}\n```\n\n**lambda表达式必须匹配WaitCallback委托: 获取Object并返回void.**\n\n- 匿名函数被标记为private,禁止非类型内定义的代码访问(反射能揭示出方法确实存在).\n- 匿名函数被标记为static, 因为代码没有访问任何实例成员.\n- 代码可以引用类中定义的任何静态字段或静态方法.\n- 如果CallbackWithoutNewingADelegateObject本身不是静态的,匿名函数则可以包含对实例成员的引用.\n  - 如果没有引用,编译器还是会生成静态匿名函数,因为它的效率高于实例方法. 因为不需要额外的this参数.\n\n\n### lambda表达式的一些规则\n\n`=>`操作符左侧是指定传给lambda表达式的 **参数的名称**.\n\n```csharp\n// 如果委托不获取任何参数, 就是用()\nFunc<String> f = () => \"Jeff\";\n\n// 如果委托获取1个或更多参数,可显式指定类型\nFunc<Int32,String> f2 = (Int32 n) => n.ToString();\nFunc<Int32,Int32,String> f3 = (Int32 n1, Int32 n2)=>(n1 + n2).ToString();\n\n// 如果委托获取1个或更多参数,编译器可推断类型\nFunc<Int32,String> f4 = (n) => n.ToString();\nFunc<Int32,Int32,String> f5 = (n1,n2)=>(n1 + n2).ToString();\n\n// 如果委托获取1个参数, 可以省略()\nFunc<Int32,String> f6 = n => n.ToString();\n\n// 如果委托有ref/out参数, 必须显示指定ref/out和类型\n// Bar定义 delegate void Bar(out Int32 z);\nBar b = (out Int32 n) => n = 5;\n\n// 如果 =>右侧主题由两个或多个语句构成, 必须用大括号将语句封闭.\n// 并且,如果委托期待返回值,还必须在主体中添加return语句\nFunc<Int32,Int32,String> f7 = (n1,n2) => { Int32 sum = n1 + n2; return sum.ToString(); };\n\n```\n\nlambda表达式的主要优势在于, 它从你的源码中移除了一个`间接层`, 可以说是避免了迂回. 正常情况下必须写一个单独的方法, 命名该方法, 再在需要委托的地方传递这个方法名.  **如果要在多个地方引用同一个代码主体, 单独写一个方法并命名确实是理想的方案.但如果只需要引用一次,那么用lambda表达式直接内联代码,不必为它分配名称,从而提高编程效率.**\n\n> C# 2.0 引入的匿名方法功能 和C# 3.0引入的lambda表达式相似.\n> - 匿名方法描述的也是创建匿名函数的语法.\n> - 新规范建议开发人员使用新的lambda表达式语法,而不要使用旧的匿名方法语法.\n> - lambda表达式更简洁,代码更容易写,读和维护.\n\n\n## 简化语法3: 局部变量不需要手动包装到类中即可传给回调方法\n\n前面展示了回调代码如何引用类中定义的其他成员. 但是有时还希望回调代码引用存在于定义方法中的局部参数或变量.\n\n```csharp\ninternal sealed class AClass2\n{\n    internal static void UsingLocalVariablesInTheCallbackCode(Int32 numToDo)\n    {\n        // 两个局部变量\n        Int32[] squares = new Int32[numToDo];\n        AutoResetEvent done = new AutoResetEvent(false);\n\n        // 在其它线程上执行一系列任务\n        for (Int32 n = 0; n < squares.Length; n++)\n        {\n            ThreadPool.QueueUserWorkItem(\n               delegate(Object obj) // 可以写成 obj =>\n               {\n                   Int32 num = (Int32)obj;\n                   // 耗时任务\n                   squares[num] = num * num;\n                   // 如果是最后一个任务，则让主线程继续执行\n                   if (Interlocked.Decrement(ref numToDo) == 0)\n                       done.Set();\n               }, n);\n        }\n        // 等待其他所有线程执行完毕\n        done.WaitOne();\n        // 显示任务\n        for (Int32 n = 0; n < squares.Length; n++)\n            Console.WriteLine(\"Index {0}, Square={1}\", n, squares[n]);\n    }\n}\n```\n\nlambda表达式中的方法是在一个单独的方法中(CLR要求), 方法变量是如何传给这个单独的方法呢?\n\n唯一的办法就是定义一个**新的辅助类**,\n- 这个类要打算传给回调代码的**每个值都定义一个字段**.\n- 此外回调代码还必须定义成辅助类中的实例方法,\n- `UsingLocalVariablesInTheCallbackCode`方法必须构造辅助类的实例,\n- 用方法定义的局部变量的值来初始化该实例中的字段,\n- 然后, 构造绑定到辅助对象/实例方法的委托对象.\n\n> 当lambda表达式造成编译器生成了一个类, 而且参数/局部变量被转移到该类的字段后, 变量引用的对象的生存期被延长了, **正确情况下, 在方法中最后一次使用`参数/局部变量`之后,这个`参数/局部变量`就会离开作用域,结束其生命周期, 但是,将变量变为字段后,只要包含字段的那个对象不死, 字段引用的对象也不会死**,这个问题在大部分情况下不是大问题, 有时候需要注意一下.\n\n上述代码,由C#自动改为完整代码(详细化语法糖):\n\n![](17委托/QQ截图20190831202610.png)\n![](17委托/QQ截图20190831202619.png)\n\nC#的lambda表达式功能很容易被滥用, 使调试和单步执行变得比较有挑战性. 此书作者为自己设定了一个规则:\n- 如果需要回调方法中包含3行以上的代码,就不使用lambda表达式, 建议手写一个方法\n\n```csharp\n// 创建并初始化一个String数组\nString[] names = {\"Jeff\", \"Kristin\", \"Aidan\"};\n\n// 只获取含有小写字母a的名字\nChar charToFind = 'i';\n// 写法1\nnames = Array.FindAll(names, delegate(String name) { return (name.IndexOf(charToFind) >= 0); });\n// 写法2\nnames = Array.FindAll(names, name => name.IndexOf(charToFind) >= 0);\n\n// 将每个字符串的字符转换为大写\n// 写法1\nnames = Array.ConvertAll<String, String>(names, delegate(String name) { return name.ToUpper(); });\n// 写法2\nnames = Array.ConvertAll<String, String>(names,  name => name.ToUpper());\n\n// 排序名字\n// 写法1\nArray.Sort(names, delegate(String name1, String name2) { return String.Compare(name1, name2); });\n// 写法2\nArray.Sort(names, (String name1, String name2) => String.Compare(name1, name2));\n\n// 显示结果\n// 写法1\nArray.ForEach(names, delegate(String name) { Console.WriteLine(name); });\n// 写法2\nArray.ForEach(names, Console.WriteLine);\n\n```\n\n# 委托和反射\n\n目前使用委托要求开发人员事先知道回调方法的原型(要知道回调方法有多少个参数,以及具体类型). 因此`System.Delegate.MethodInfo`提供了`CreateDelegate`方法, 允许在 **编译时不知道委托的所有必要信息** 的前提下创建委托.\n\n\n`MethodInfo`为`CreateDelegate`方法定义的重载:\n\n```csharp\npublic abstract class MethodInfo : MethodBase\n{\n   // 构造包装了一个静态方法的委托\n   public virtual Delegate CreateDelegate(Type delegateType);\n\n   // 构造包装了一个实例方法的委托: target引用this实参\n   public virtual Delegate CreateDelegate(Type delegateType, Object target);\n}\n\n\n// 创建好委托后,用Delegate的DynamicInvoke方法调用它\npublic abstract class Delegate\n{\n    // 调用委托并传递参数\n    public Object DynamicInvoke(param Object[] args);\n}\n\n```\n\n使用反射API,首先\n- 必须获取引用了回调方法的一个`MethodInfo`对象,\n- 然后调用`CreateDelegate`方法来构造一个由`Delegate`派生类型的对象\n  - 如果委托包含的是实例方法, 还要传递一个target参数, 指定作为this参数传给实例方法的对象.\n\n`System.Delegate`的`DynamicInvoke`方法允许调用委托对象的回调方法, 传递一组在 **运行时确定的参数**.调用`DynamicInvoke`时,**它会在内部保证传递的参数与回调方法期望的参数兼容**.\n- 如果兼容就调用回调方法.\n- 否则抛出异常`ArgumentException`\n\n\n```csharp\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        // 第一个参数是委托类型  委托类型的String是 \"Class+DelegateName\" 例如 DelegateReflection+TwoInt32s\n        // 第二个参数是需要回调的方法   此名称方法要和对应委托匹配参数类型和个数\n        // 之后的参数时传递给回调方法的参数\n        DelegateReflection.Go(typeof(DelegateReflection.TwoInt32s).ToString(),\"Add\",\"123\",\"321\");\n    }\n\n\n}\ninternal static class DelegateReflection\n{\n    // 定义2个委托\n    internal delegate Object TwoInt32s(Int32 n1, Int32 n2);\n    internal delegate Object OneString(String s1);\n\n    public static void Go(params String[] args)\n    {\n        if (args.Length < 2)\n        {\n          //    Usage:\n          //    delType                             methodName [Arg1] [Arg2]\n          //    where delType must                  be TwoInt32s or OneString\n          //    if delType is TwoInt32s, methodName must be      Add or      Subtract\n          //    if delType is OneString, methodName must be      NumChars or Reverse\n          //\n          //    Examples:\n          //    TwoInt32s Add 123 321\n          //    TwoInt32s Subtract 123 321\n          //    OneString NumChars \"Hello there\"\n          //    OneString Reverse  \"Hello there\"\n            return;\n        }\n\n        // 将实参转化为委托类型 (委托是一个类)\n        Type delType = Type.GetType(args[0]);\n        if (delType == null)\n        {\n            Console.WriteLine(\"Invalid delType argument: \" + args[0]);\n            return;\n        }\n\n        Delegate d;\n        try\n        {\n            // 将args[1]转换为方法\n            MethodInfo mi = typeof(DelegateReflection).GetTypeInfo().GetDeclaredMethod(args[1]);\n\n            // 创建包装了静态方法的委托对象\n            d = mi.CreateDelegate(delType);\n        }\n        catch (ArgumentException)\n        {\n            Console.WriteLine(\"Invalid methodName argument: \" + args[1]);\n            return;\n        }\n\n        // 创建一个数组,其中包含要通过委托对象传给方法的参数\n        Object[] callbackArgs = new Object[args.Length - 2];\n\n        if (d.GetType() == typeof(TwoInt32s))\n        {\n            try\n            {\n                // 将String类型参数转换为Int32类型的参数\n                for (Int32 a = 2; a < args.Length; a++)\n                    callbackArgs[a - 2] = Int32.Parse(args[a]);\n            }\n            catch (FormatException)\n            {\n                Console.WriteLine(\"Parameters must be integers.\");\n                return;\n            }\n        }\n\n        if (d.GetType() == typeof(OneString))\n        {\n            // 只复制字符串\n            Array.Copy(args, 2, callbackArgs, 0, callbackArgs.Length);\n        }\n\n        try\n        {\n            // 调用委托并显示结果\n            Object result = d.DynamicInvoke(callbackArgs);\n            Console.WriteLine(\"Result = \" + result);\n        }\n        catch (TargetParameterCountException)\n        {\n            Console.WriteLine(\"Incorrect number of parameters specified.\");\n        }\n    }\n\n    // 需要2个Int32参数的静态函数\n    private static Object Add(Int32 n1, Int32 n2)\n    {\n        return n1 + n2;\n    }\n\n    // 需要2个Int32参数的静态函数\n    private static Object Subtract(Int32 n1, Int32 n2)\n    {\n        return n1 - n2;\n    }\n\n    // 需要1个String参数的静态函数\n    private static Object NumChars(String s1)\n    {\n        return s1.Length;\n    }\n\n    // 需要1个String参数的静态函数\n    private static Object Reverse(String s1)\n    {\n        return new String(s1.Reverse().ToArray());\n    }\n}\n```\n\n以上示例有几个注意的地方:\n\n```csharp\n// 1.将实参转化为委托类型 (委托是一个类)\nType delType = Type.GetType(args[0]);\n\n// 2.先获取当前回调方法所在的类,反射获得TypeInfo,再根据参数名称获取对应的方法.\nMethodInfo mi = typeof(DelegateReflection).GetTypeInfo().GetDeclaredMethod(args[1]);\n\n// 3.创建包含回调静态方法的委托对象\nd = mi.CreateDelegate(delType);\n\n// 4.用if-else判断委托类型是哪个,根据对应的委托,解析对应的参数\nif (d.GetType() == typeof(OneString)) ...\ncallbackArgs[..] = Int32.Parse(args[a]);...\nArray.Copy(args, 2, callbackArgs, 0, callbackArgs.Length);....\n\n// 5. 调用委托传入参数\nObject result = d.DynamicInvoke(callbackArgs);\n```\n","tags":["CLR读书笔记"]},{"title":"16数组","url":"/2019/08/16/16数组/","content":"\n# 数组\n\nCLR支持一维,多维和交错数组(数组构成的数组).\n\n**所有数组类型** 隐式地从`System.Array抽象类`派生, `System.Array`又派生自`System.Object`. 数组 **始终是引用类型**, 是在托管堆上分配的.\n\n```csharp\n// 刚开始声明变量, 没有分配数组,所以为null\nInt32[] myInts; // 声明一个数组引用\n// 在托管堆上分配了100个未装箱Int32所需的内存块,返回该内存块的地址\n// 所有Int32都被初始化为0。因为数组是引用类型,\n// 所以内存块中还包含类型对象指针,同步索引块,一些开销字段(额外成员)\nmyInts = new Int32[100]; //创建含有100个Int32的数组\n\n\nControl[] myCon;\n// Control是引用类型,50个引用全部被初始化为null\nmyCon = new Control[50];\n\n// 执行一些代码\nmyCon[1] = new Button();\nmyCon[2] = new TextBox();\nmyCon[3] = myCon[2]; //两个元素引用同一个对象\nmyCon[1] = new DataGrid();\nmyCon[1] = new ComboBox();\nmyCon[1] = new Button();\n```\n\n![](16数组/值类型和引用类型数组在托管堆中.png)\n\n所有数组必须是0基数组(最小索引为0). CLR支持非0基数组,只是不提倡使用,性能会下降.\n\n每个数组都关联了一些额外的开销信息,\n- 数组的秩(数组的维数).\n- 数组的每一维的下限(几乎总是0)和每一维的长度.\n- 数组的元素类型\n\n> 应尽可能的使用一维0基数组,也称为SZ数组或向量. 向量性能是最佳的,因为可以使用一些特殊的IL指令.\n\n```csharp\n// 创建一个二维数组，由Double值构成\nDouble[,] myDoubles = new Double[10,20];\n\n// 创建一个三维数组，由String引用构成\nString[,,] myStrings = new String[5,3,10];\n\n//CLR还支持交错数组，即由数组构成的数组。下面例子演示了如何创建一个多边形数组，其中每一个多边形都由一个Point实例数组构成。\n// 创建一个含有Point数组的一维数组\nPoint[][] myPolygons = new Point[3][];\n\n// myPolygons[0]引用一个含有10个Point实例的数组\nmyPolygons[0] = new Point[10];\n\n// myPolygons[1]引用一个含有20个Point实例的数组\nmyPolygons[1] = new Point[20];\n\n// myPolygons[2]引用一个含有30个Point实例的数组\nmyPolygons[2] = new Point[30];\n\n// 显示第一个多边形中的Point\nfor (Int32 x =0 ; x < myPolygons[0].Length; x++)\n{\n    Console.WriteLine(myPolygons[0][x]);\n}\n```\n\n访问数组范围之外的会导致`System.IndexOutOfRangeException`异常.\n\n> 数组索引范围检查对性能的检查微乎其微,JIT编译器通常只在循环开始之前检查一次数组边界,而不是每次循环迭代都检查, 还可以用C#的unsafe代码来访问数组,规避这个CLR索引检查造成的性能损失.\n\n# 初始化数组元素\n\n大括号中的以逗号分隔的数据项称为`数组初始化器`,每个数据项都可以是一个复杂的表达式.\n\n```csharp\nString[] names = new String[] { \"Aidan\", \"Grant\" };\n```\n\n## C#的隐式类型的局部变量功能 var\n\n隐式类型的局部变量功能, 让编译器推断`=操作符`右侧的表达式类型.\n\n```csharp\n// 用var代替String\nvar names = new String[] { \"Aidan\", \"Grant\" };\n```\n\n## C#的隐式类型的数组功能\n\n隐式类型的数组功能让编译器推断`数组元素的类型`.省略了new和[]之间的类型.\n\n```csharp\n// 省略了new和[]之间的类型\n// 选择所有数组元素最接近的共同基类来作为数组的类型\n// 本例中,2个string和一个null , 因为null可以隐式转型为任意盈余类型,所以编译器创建为String数组\nvar names = new[] { \"Aidan\", \"Grant\", null};\n\n// 错误的, 因为这样编译器只能推断为共同基类Object\n// 这会造成123数值类型进行隐式装箱, 这个操作代价高昂,所以要在编译时报错\n// var names = new[] { \"Aidan\", \"Grant\", 123};\n\n// 额外语法,还可以这么写, 省略new 和[] 和类型.\n// 但是这种写法不允许使用var\nString[] names = { \"Aidan\", \"Grant\" };\n```\n\n## 匿名类型 与 隐式类型的数组 与 隐式类型的局部变量组合使用\n\n```csharp\n// 两个匿名类具有一致的结构, 表示有一个string类型的Name字段的类.\n// 所以编译器知道这两个对象具有相同的类型\nvar kids = new[] { new { Name = \"Aidan\" }, new { Name = \"Grant\" }};\n\nforeach(var kid in kids)\n Console.WriteLine(kid.Name);\n```\n\n# 数组转型\n\n对于元素为引用类型的数组，CLR允许将数组元素从一种类型隐式转型到另一种类型。为了成功转型，两个数组类型必须维数相等，而且从源类型到目标类型，必须存在一个隐式或显示转换。CLR不允许将值类型元素的数组转型为其他任何类型。(不过为了模拟实现这种效果，可利用`Array.Copy方法`创建一个新数组并在其中填充数据)。\n\n`Array.Copy方法`是浅拷贝.\n\n\n```csharp\n// 创建一个二维FileStream数组\nFileStream[,] fs2dim = new FileStream[5, 10];\n\n// 隐式转型为一个二维Object数组\nObject[,] o2dim = fs2dim;\n\n// 不能从二维数组转型为一维数组\n//Stream[] s1dim = (Stream[]) o2dim;\n\n// 显式转型为二维Stream数组\nStream[,] s2dim = (Stream[,]) o2dim;\n\n// 显式转型为二维String数组\n// 能通过编译，但在运行时会抛出异常,InvalidCastException\n// String[,] st2dim = (String[,]) o2dim;\n\n// 创建一个意味Int32数组(元素是值类型)\nInt32[] i1dim = new Int32[5];\n\n// 不能将值类型的数组转型为其他任何类型\n// Object[] o1dim = (Object[]) i1dim;\n\n// 创建一个新数组，使用Array.Copy将元数组中的每一个元素\n// 转型为目标数组中的元素类型，并把它们复制过去\n// 下面的代码创建一个元素为引用类型的数组，\n// 每个元素都是对已装箱的Int32的引用   ←-------------------重点\nObject[] o1dim = new Object[i1dim.Length];\nArray.Copy(i1dim, o1dim, 0);\n```\n\n## 数组协变性,数组间转型\n\nArray.Copy方法的处理:\n- 将值类型的元素 **装箱** 为引用类型的元素\n- 将引用类型的元素 **拆箱** 为值元素, 比如将Object[]复制到Int32[]中.\n- 加宽CLR基元值类型, 比如将Int32[]元素复制到Double[]中\n- **在两个数组之间复制时, 如果仅从数值类型证明不了两者的兼容性, (比如Object[]转型为IFormattable) 就需要对元素进行向下类型转换. 如果Object[]中的每个对象都实现了IFormattable,那么Copy方法就能执行.**\n\n> 向下类型转换:  把父类对象转为子类对象。\n> 向上类型转换: 将子类对象转为父类对象。此处父类对象可以是接口。\n\n\n```csharp\n// 定义实现了一个接口的值类型\ninternal struct MyValueType : IComparable\n{\n    public int CompareTo(object obj)\n    {\n        throw new NotImplementedException();\n    }\n}\n\npublic static void Main(string[] args)\n{\n    // 创建包含值类型的数组\n    var src = new MyValueType[100];\n    // 创建接口引用数组\n    var comparables = new IComparable[src.Length];\n    // 使他们引用src数组元素的已装箱版本\n    Array.Copy(src,comparables,src.Length);\n}\n\n// 性能损失\nString[] sa = new String[100];\nObject[] oa = sa;  // oa引用了一个String数组\n\noa[5] = \"Jeff\"; // 性能损失,CLR检查oa元素类型是不是String类型,检查通过\n// 运行时抛出ArraryTypeMismatchException\n// 因为CLR要保证赋值的合法性\noa[3] = 5;      // 性能损失,CLR检查oa元素类型是不是Int32; 发现有错,会抛出异常\n\n```\n\n将数组从一种类型转换为另一种类型. 这种功能称为 **数组协变性** (协变out). 会带来性能损失.\n\n## 关于复制数组到另一个数组\n\n`Array.Copy`方法\n- 能正确处理内存的重叠区域\n- 能在复制每个数组元素时进行必要的转换\n- 拆箱装箱,向下类型转换\n\n`System.Buffer的BlockCopy`方法.\n- 它比`Array的Copy方法`快.\n- 它只支持基元类型\n- 不提供Copy方法那样的转型能力.\n- 方法的Int32参数时数组中的字节偏移量,而非元素索引.\n- 用于将Unicode字符的一个Byte[] (按字节的正确顺序) 复制到一个Char[]中.\n\n要将一个数组的元素`可靠地`复制到另一个数组,应该使用`System.Array的ConstrainedCopy`.\n- **该方法要么完成复制,要么抛出异常,总之不会破坏目标数组中的数据.**\n- 这就允许ConstrainedCopy在`约束执行区域`中执行,为了这种保证\n  - 要求`源数组的元素类型`和`目标数组的元素类型`相同或者 **派生自** 目标数组的元素类型.\n  - 不执行任何装箱,拆箱或向下类型转换.\n\n# 所有数组都隐式派生自System.Array\n\n`FileStream[] fsArray;`\n\n`System.Array`类型定义的所有实例方法和属性都将由`FileStream[]`继承.\n\n# 所有数组都隐式实现IEnumerable, ICollection, IList\n\n许多方法都能操纵各种各样的集合对象,因为它们声明为获取`IEnumerable`, `ICollection`, `IList`等参数. `System.Array`也实现了这些非泛型接口.\n\n\nCLR没有为`System.Array`实现泛型接口,而是在创建一维0基数数组类型时,CLR自动使数组类型实现`IEnumerable<T>`, `ICollection<T>`, `IList<T>`,同时还为数组类型的所有基类型实现这三个接口,只要它们是引用类型(数组是值类型则不会).\n\n`FileStream[] fsArray;` 会在CLR下产生如下结构:\n\n![](16数组/CLR自动为数组实现泛型接口.png)\n\nfsArray可以传给以下任何一种原型方法:\n\n```csharp\nvoid M1(IList<FileStream> fsList){...}\nvoid M2(ICollection<Stream> sCollection){...}\nvoid M3(IEnumerable<Object> oEnumerable){...}\n```\n\n如果数组包含值类型元素,数组类型不会为元素的基类型实现接口.例如:一个值类型数组`DateTime[] dtArray;` 只会为此数组类型实现3个泛型接口,CLR不会为它的基类包括ValueType,Object实现这些泛型接口. 这是因为值类型的数组在内存中的布局与引用类型的数组不同.\n\n\n# 数组的传递和返回\n\n数组作为实参传递给方法时, 传递的是`数组的引用`,如果不想被修改,则需要生成数组的拷贝给方法. **Array.Copy方法执行是对原始数组的浅拷贝**, 如果数组中的元素类型是引用类型,新数组还是引用现有的对象.\n\n定义返回数组引用的方法,  如果数组中不包含元素, 不要返回null,建议返回对包含零个元素的一个数组的引用. 这这就不需要进行null检测. `if (xxx != null) ...`\n\n# 创建下限非零的数组\n\n可以调用数组的静态方法`CreatInstance`来动态的创建自己的数组. 允许指定数组的类型,维数,每一维的下限和每一维的元素数目.\n\n静态方法`CreatInstance`为数组分配内存,将参数信息保存到数组的内存块的开销(overhead)部分,然后返回对该数组的引用.\n- 如果维数是二维及以上,可以把返回的引用转型为一个`ElementType[]`变量(名称替换为类型名称),来简化对数组元素的访问.\n- 如果是一维,C#要求必须使用该Array的GetValue和SetValue方法访问数组元素.\n\n\n```csharp\n// 创建一个二维数组{2005...2009} {1...4}\nInt32[] lowerBounds = {2005, 1};\nInt32[] lengths     = {5, 4};\n// 传入元素的类型, 5行4列\nDecimal[,] quarterlyRevenue = (Decimal[,])\n    Array.CreateInstance(typeof(Decimal), lengths, lowerBounds);\n\n// Array的Rank 属性：得到Array的秩（维数）  quarterlyRevenue.Rank等于2;\n// GetUpperBound(int dimension) 用于获取 Array 的指定维度的上限。\n// GetLowerBound(int dimension) 用于获取 Array 的指定维度的下限。\n\n// 取得第一维的下限 , 如果传入1, 则表示取得第二维的下限\nInt32 firstYear = quarterlyRevenue.GetLowerBound(0);\nInt32 lastYear  = quarterlyRevenue.GetUpperBound(0);\nConsole.WriteLine(\"{0,4}  {1,9}  {2,9}  {3,9}  {4,9}\", \"Year\", \"Q1\", \"Q2\", \"Q3\", \"Q4\");\n\nRandom r = new Random();\nfor (Int32 year = firstYear; year <= lastYear; year++)\n{\n    Console.Write(year + \"  \");\n\n    // 把二维数组看成表格,从(1,1)开始, 小于第二维的个数,横向遍历\n    for (Int32 quarter = quarterlyRevenue.GetLowerBound(1);\n        quarter <= quarterlyRevenue.GetUpperBound(1);\n        quarter++)\n    {\n        quarterlyRevenue[year, quarter] = r.Next(10000);\n        // C 表示格式化为货币\n        Console.Write(\"{0,9:C}  \", quarterlyRevenue[year, quarter]);\n    }\n    Console.WriteLine();\n}\n\n// Year         Q1         Q2         Q3         Q4\n// 2005  ￥2,102.00  ￥7,295.00    ￥105.00  ￥5,846.00\n// 2006  ￥6,331.00  ￥1,955.00    ￥879.00  ￥8,752.00\n// 2007    ￥912.00  ￥1,105.00  ￥6,960.00  ￥7,205.00\n// 2008  ￥6,479.00  ￥6,034.00  ￥6,182.00  ￥3,565.00\n// 2009    ￥558.00  ￥8,291.00  ￥4,028.00  ￥1,740.00\n```\n\n\n# 数组内部的工作原理\n\nCLR支持两种不同的数组:\n- 下限为0的一维数组或向量\n- 下限未知的一维或多维数组\n\n\n```csharp\nArray a;\n\n// 定义一维的0基数组,不包含任何元素\na = new String[0];\nConsole.WriteLine(a.GetType()); // System.String[]\n\n// 定义一维的0基数组,不包含任何元素\na = Array.CreateInstance(typeof(String), new Int32[] {0}, new Int32[] {0});\nConsole.WriteLine(a.GetType()); // System.String[]\n\n// 定义一维的1基数组,不包含任何元素\n// 1基数组显示的类型是System.String[*], *号表示CLR知道该数组不是0基的.\n// C#不允许声明String[*]类型的变量,因此不能使用C#语法来访问一维非0基数组.\n// 可以用Array的GetValue和SetValue来访问,但是速度较慢,调用方法有开销.\na = Array.CreateInstance(typeof(String), new Int32[] {0}, new Int32[] {1});\nConsole.WriteLine(a.GetType()); // System.String[*]  <-- INTERESTING!\n\n\n// 定义二维的0基数组,不包含任何元素\na = new String[0, 0];\nConsole.WriteLine(a.GetType()); // System.String[,]\n\n// 定义二维的0基数组,不包含任何元素\na = Array.CreateInstance(typeof(String), new Int32[] {0, 0}, new Int32[] {0, 0});\nConsole.WriteLine(a.GetType()); // System.String[,]\n\n// 定义二维的1基数组,不包含任何元素\n// CLR会将多维数组都视为非0基数组,CLR决定对多维数组不使用*号\na = Array.CreateInstance(typeof(String), new Int32[] {0, 0}, new Int32[] {1, 1});\nConsole.WriteLine(a.GetType()); // System.String[,]\n```\n\n- 1基数组显示的类型是`System.String[*]`, `*`号表示CLR知道该数组不是0基的.\n- C#不允许声明`String[*]`类型的变量,因此不能使用C#语法来访问一维非0基数组.\n- 可以用Array的GetValue和SetValue来访问,但是速度较慢,调用方法有开销.\n\n对于多维数组,CLR会将多维数组都视为非0基数组,会让别人觉得类型是这样`System.String[*,*]`,但是CLR决定对于多维数组,不使用`*`号,大量星号容易产生混淆.\n\n访问1维0基数组的元素比访问非0基一维或多维元素稍快.\n- 有特殊的IL指令用于处理0基数组,可以让JIT编译器生成优化代码\n  - JIT编译器生成的代码假定数组是0基的,访问元素时不需要从指定索引中减去一个偏移量\n- JIT编译器能将索引范围检查代码从循环中拿出,导致它只执行一次\n\n\n```csharp\nvar ints = new Int32[5];\n// ints.Length调用属性方法\nfor (int i = 0; i < ints.Length; i++)\n{\n    // 对ints[i]操作\n}\n```\n\nJIT编译器知道`Length`是`Array类的属性`,**所以生成的代码中实际只调用该属性一次,结果保存到临时变量中** , 之后的每次迭代检查的都是这个临时变量,这就加快了JIT编译的代码速度.\n\n因此,最好保持对数组`Length`属性的调用,而 **不要自己用什么局部变量来缓存它的值**. 这种自作聪明的尝试几乎肯定会对性能造成负面影响,还会使代码更难阅读.\n\nJIT编译器知道for循环要访问0到Length-1的数组元素,JIT编译器会生成代码,在运行时测试所有数组元素的访问都在有效范围内.\n- 也就是来检查是否 `(0 >= ints.GetLowerBound(0)) && ((Length -1)) <= ints.GetUpperBound(0)`\n- 这个检查在循环之前发生,如果都在有效范围内,JIT编译器不会在每一次数组访问时再检查验证. 这样一来访问变得非常快.\n\n**对于非0基数组和多维数组,JIT编译器不会将索引检查从循环中拿出来,所以每次访问都要验证指定的索引.导致访问速度比不上一维0基数组.** 还要添加代码从指定索引中减去数组下限,进一步影响了代码执行速度.\n\n**如果很关心性能. 考虑用由数组构成的数组(`交错数组`)代替矩形数组.**\n\nC#和CLR还允许使用unsafe代码访问数组.这种技术实际能在访问数组时关闭索引上下限检查.\n- 适用于以下元素类型的数组:\n  - SByte,Byte,Int16,UInt16,Int32,UInt32,Int64,UInt64,Char,Single,Double,Decimal,Boolean,枚举类型或任何类型的值类型结构.\n\n> 这个功能很强大,但是使用需要谨慎,它允许直接内存访问,访问越界不会抛出异常.但会损坏内存中的数据.破坏类型的安全性.\n\n\n# 访问二维数组的三种方式(安全,交错和不安全):\n\n```csharp\nprivate const Int32 c_numElements = 10000;\n\npublic static void Go()\n{\n    // 声明二维数组\n    Int32[,] a2Dim = new Int32[c_numElements, c_numElements];\n\n    // 将二维数组声明为交错数组\n    Int32[][] aJagged = new Int32[c_numElements][];\n    for (Int32 x = 0; x < c_numElements; x++)\n        aJagged[x] = new Int32[c_numElements];\n\n\n    // 1: 用普通的安全技术访问数组中的所有元素\n    // 二维数组对象 a[x, y];\n    Safe2DimArrayAccess(a2Dim);\n\n    // 2: 用交错数组技术访问数组中的所有元素\n    // 交错数组对象 a[x][y]\n    SafeJaggedArrayAccess(aJagged);\n\n    // 3: 用unsafe技术访问数组中的所有元素\n    Unsafe2DimArrayAccess(a2Dim);\n}\n\nprivate static Int32 Safe2DimArrayAccess(Int32[,] a)\n{\n    Int32 sum = 0;\n    for (Int32 x = 0; x < c_numElements; x++)\n    {\n        for (Int32 y = 0; y < c_numElements; y++)\n        {\n            sum += a[x, y];\n        }\n    }\n    return sum;\n}\n\nprivate static Int32 SafeJaggedArrayAccess(Int32[][] a)\n{\n    Int32 sum = 0;\n    for (Int32 x = 0; x < c_numElements; x++)\n    {\n        for (Int32 y = 0; y < c_numElements; y++)\n        {\n            sum += a[x][y];\n        }\n    }\n    return sum;\n}\n\n// fixed 语句必须要用unsafe方法修饰符\nprivate static unsafe Int32 Unsafe2DimArrayAccess(Int32[,] a)\n{\n    Int32 sum = 0, numElements = c_numElements * c_numElements;\n    fixed (Int32* pi = a)\n    {\n        for (Int32 x = 0; x < numElements; x++)\n        {\n            sum += pi[x];\n        }\n    }\n    return sum;\n}\n\n```\n\n不安全数据访问技术的三处不足之处:\n- 处理数组元素的代码更复杂,不容易读写,因为要使用C#的`fixed`语句,要执行内存地址计算.\n- 计算过程出错,会损坏内存数据,破坏类型安全性,并可能造成安全漏洞.\n- 因为这些潜在问题,CLR禁止在降低了安全级别的环境中运行不安全代码.\n\n\n# 单维数组\n\n```csharp\n// 可以在声明时初始化数组,在这种情况下，无需长度说明符，因为它已由初始化列表中的元素数目提供。\n// 并且可以省略new int[]\nint[] array1 = new int[] { 1, 3, 5, 7, 9 };\nint[] array2 = { 1, 3, 5, 7, 9 };\n\n\n// 可以在不初始化的情况下声明数组变量，但必须使用 new 运算符向此变量分配数组。\nint[] array3;\narray3 = new int[] { 1, 3, 5, 7, 9 };   // OK\n//array3 = {1, 3, 5, 7, 9};   // Error\n```\n\n# 多维数组\n\n二维数组,逗号分隔,几行几列.\n\n```csharp\n// 以下声明创建一个具有四行两列的二维数组。\n// 也可以\nint[,] array = new int[4, 2];\n\n// 三维数组\nint[, ,] array1 = new int[4, 2, 3];\n\n// Two-dimensional array.\nint[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// The same array with dimensions specified.\nint[,] array2Da = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// A similar array with string elements.\nstring[,] array2Db = new string[3, 2] { { \"one\", \"two\" }, { \"three\", \"four\" },\n                                        { \"five\", \"six\" } };\n\n// 可以简化写法\nint[,] array4 = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// 如果选择在不初始化的情况下声明数组变量，则必须使用 new 运算符将数组赋予变量。\nint[,] array5;\narray5 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };   // OK\n//array5 = {{1,2}, {3,4}, {5,6}, {7,8}};   // Error\n\n\n// 以下代码示例将数组元素初始化为默认值（交错数组除外）\nint[,] array6 = new int[10, 10];                                      \n```\n\n\n# 交错数组\n\n交错数组是元素为数组的数组。 交错数组元素的维度和大小可以不同。 交错数组有时称为“数组的数组”\n\n\n```csharp\n// 声明三个元素,每个元素都是一维整数数组\nint[][] jaggedArray = new int[3][];\n\n\n// 必须初始化 jaggedArray 的元素后才可使用它。\njaggedArray[0] = new int[5];\njaggedArray[1] = new int[4];\njaggedArray[2] = new int[2];\n\n// 也可使用初始化表达式通过值来填充数组元素，这种情况下不需要数组大小\njaggedArray[0] = new int[] { 1, 3, 5, 7, 9 };\njaggedArray[1] = new int[] { 0, 2, 4, 6 };\njaggedArray[2] = new int[] { 11, 22 };\n\n// 不能从元素初始化中省略 new 运算符，因为不存在元素的默认初始化：\n// 可以省略 new int[][]\nint[][] jaggedArray3 = // new int[][]\n{\n    new int[] { 1, 3, 5, 7, 9 },\n    new int[] { 0, 2, 4, 6 },\n    new int[] { 11, 22 }\n};\n\n// 混合使用多维数组和交错数组\nint[][,] jaggedArray4 = new int[3][,]\n{\n    new int[,] { {1,3}, {5,7} },\n    new int[,] { {0,2}, {4,6}, {8,10} },\n    new int[,] { {11,22}, {99,88}, {0,9} }\n};\n// 访问个别元素，示例显示第一个数组的元素 [1,0] 的值\nSystem.Console.Write(\"{0}\", jaggedArray4[0][1, 0]);// 5\n// 方法 Length 返回包含在交错数组中的数组的数目\nSystem.Console.WriteLine(jaggedArray4.Length); // 3\n```\n\n## 对数组使用foreach\n\n- 对于单维数组，foreach 语句以递增索引顺序处理元素（从索引 0 开始并以索引 Length - 1 结束）\n- 对于多维数组，遍历元素的方式为：首先增加最右边维度的索引，然后是它左边的一个维度，以此类推，向左遍历元素\n\n```csharp\n// 一维数组的foreach\nint[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };\nforeach (int i in numbers)\n{\n    System.Console.Write(\"{0} \", i);\n}\n// Output: 4 5 6 1 2 3 -2 -1 0\n\n\n// 多维数组的foreach\nint[,] numbers2D = new int[3, 2] { { 9, 99 }, { 3, 33 }, { 5, 55 } };\n//省略 new int[3, 2]写法\n//int[,] numbers2D = { { 9, 99 }, { 3, 33 }, { 5, 55 } };\n\nforeach (int i in numbers2D)\n{\n    System.Console.Write(\"{0} \", i);\n}\n// Output: 9 99 3 33 5 55\n```\n\n# 不安全的数组访问和固定大小的数组\n\n`不安全的数组`访问能力非常强大,因为它允许访问:\n- `堆上`的托管数组对象中的元素\n- `非托管堆上的数组中的元素`.(14章的ScureString演示了调用Marshal类的SerureStringToCoTaskMemUnicode方法来返回一个数组,并对这个数组进行不安全的数组访问)\n- `线程栈上`的数组中的元素\n\n如果考虑性能是首要目标,请避免在堆上分配托管的数组对象.在线程栈上分配数组. 这是通过C#的`stackalloc`语句来完成的. **并且只能创建一维0基,由值类型元素构成的数组.** 值类型中不能包含任何引用类型的字段. 实际上可以看做是分配了一个内存块,这个内存块可以使用不安全的指针来操作. 所以不能将这个内存缓冲区的地址传给大部分FCL方法. 栈上分配的内存会在返回时自动释放.\n\n\n```csharp\nprivate static void StackallocDemo()\n{\n    unsafe\n    {\n        const Int32 width = 20;\n        // 在栈上分配数组\n        Char*       pc    = stackalloc Char[width];\n        // 15 个字符\n        String s = \"Jeffrey Richter\";\n\n        for (Int32 index = 0; index < width; index++)\n        {\n            pc[width - index - 1] =\n                (index < s.Length) ? s[index] : '.';\n        }\n        // 输出 \".....rethciR yerffeJ\"\n        Console.WriteLine(new String(pc, 0, width));\n    }\n}\n\nprivate static void InlineArrayDemo()\n{\n    unsafe\n    {\n        // 在栈上分配数组\n        CharArray ca;\n        Int32     widthInBytes = sizeof(CharArray);\n        Int32     width        = widthInBytes / 2;\n        // 15 个字符\n        String s = \"Jeffrey Richter\";\n\n        for (Int32 index = 0; index < width; index++)\n        {\n            ca.Characters[width - index - 1] =\n                (index < s.Length) ? s[index] : '.';\n        }\n        // 输出 \".....rethciR yerffeJ\"\n        Console.WriteLine(new String(ca.Characters, 0, width));\n    }\n}\n\nprivate unsafe struct CharArray\n{\n    // 这个数组内联嵌入到结构中\n    public fixed Char Characters[20];\n}\n```\n\n由于数组是引用类型,所以结构中定义的数组字段实际只是指向数组的`指针或引用`. **数组本身在结构的内存的外部.** 不过可以像上述代码`public fixed Char Characters[20];` 嵌入到结构中,但是需要满足以下条件:\n- 类型必须是`结构(值类型)`; 不能再类(引用类型)中嵌入数组.\n- 字段或其定义结构必须用`unsafe`关键字标记\n- 数组字段必须用`fixed关键字`标记.\n- 数组必须是一维0基数组.\n- 数组的元素类型必须是以下类型之一:\n  - Char,SByte,Byte,Int16,UInt16,Int32,UInt32,Int64,UInt64,Char,Single,Double,Boolean\n\n要和非托管代码进行互操作,而且非托管数据结构也有一个内联数组,就特别适合使用内联的数组.\n","tags":["CLR读书笔记"]},{"title":"15枚举类型和位标志","url":"/2019/08/15/15枚举类型和位标志/","content":"# 枚举类型和位标志\n\nCLR和FCL结合起来之后, 枚举类型和位标志才真正成为面向对象的类型. 提供了一些强大的功能.大部分开发人员并不熟悉.\n\n# 枚举类型\n\n**枚举类型(enumerated type)** 定义了一组 \"符号名称/值\" 配对. 例如:\n\n```csharp\n// 每个符号标识一种颜色, 也可以用0标识白色\ninternal enum Color\n{\n  White,    // 赋值0\n  Red,      // 赋值1\n  Green,    // 赋值2\n  Blue,     // 赋值3\n  Orange    // 赋值4\n}\n```\n\n不应该将数字硬编码到代码中,而应该使用枚举类型.\n1. 更容易阅读和理解代表的含义. 调试程序能向开发人员显示有意义的符号名称.\n2. 枚举是强类型的. 比如Color.Orange和Fruit.Orange是不同的,虽然都有一个Orange.\n\n在.Net Framework中, 枚举类型不只是编译器所关心的符号, 还是类型系统中的一等公民, 能实现很强大的操作.(在其他环境比如非托管C++中,枚举没有这个特点的).\n\n**每个枚举都直接从`System.Enum`派生** , `System.Enum`从`System.ValueType`派生.`System.ValueType`又从`System.Object`派生.\n\n枚举都是 **值类型** . 可以用未装箱和已装箱的形式来表示,但是区别于其他值类型, 枚举类型不能定义任何方法,属性,事件.  可以用`扩展方法`功能模拟向枚举类型添加方法.(在最后会举例)\n\n编译枚举类型时,C#编译器把每个符号转换成类型的一个 **常量字段**.\n\n```csharp\n// 此代码是伪类型定义,用来了解内部的工作方式\n// 实际上编译器不会编译以下代码,禁止定义从System.Enum派生的类型.\ninternal struct Color : System.Enum\n{\n  // 以下是一些公共常量,它们定义了Color的符号和值\n  public const Color White  = (Color)0;\n  public const Color Red    = (Color)1;\n  ....\n\n  // 以下是一个公共实例字段.包含Color变量的值\n  // 不能写代码来直接引用该字段\n  public Int32 value__;\n}\n```\n\n简单地说,枚举类型只是一个结构,其中定义了:\n- 一组常量字段\n  - 会嵌入程序集的元数据中,并可以通过反射来访问(有静态方法和实例方法可以操作,不是必须要用反射)\n- 一个实例字段\n\n可以在运行时获得与枚举类型关联的所有符号及其值. 可以将字符串符号转换成对应的数值.`System.Eunm`基类型提供了这些操作, 还提供了几个静态和实例方法, 可利用它们操作枚举类型的实例,从而避免了必须使用反射的麻烦.\n\n> 枚举类型定义的符号是常量值, 编译器发现代码引用了枚举类型的符号时,会在编译时用数值替换符号,代码不再引用定义了符号的枚举类型.\n> 也就是说:运行时可能不需要定义了枚举类型的程序集,编译时才需要.\n> 如果代码引用了枚举类型,而不是只引用了枚举类型定义的符号,那么运行时也需要包含定义枚举所在的程序集.\n> 版本问题: 因为枚举类型符号是常量, 而不是只读的值. 常量值直接嵌入IL代码. 如果枚举常量所在的程序集改动了, 引用此程序集的应用程序没有重新编译,使用的就是旧值.而不会重新从那个程序集中获取常量的新值.\n\n## 返回枚举基础类型的方法\n\n例如，System.Enum类型有一个`GetUnderlyingType`的静态方法，而`System.Type`类型有一个 `GetEnumUnderlyingType`的实例方法。\n\n```csharp\npublic static Type GetUnderlyingType (Type enumType); //System.Enum中定义\npublic Type GetEnumUnderlyingType (Type enumType);    //System.Type中定义\n```\n\n这些方法返回用于容纳一个枚举类型的值的`基础类型`. **每个枚举类型都有一个基础类型.** int最常用,也是C#默认选择的.\n\nC#编译器要求只能指定基元类型名称. 使用FCL类型名称会报错. 应输入类型byte,sbyte,short,ushort,int,uint,long,ulong.\n\n```csharp\ninternal enum Color : byte\n{\n  White,\n  Red,\n  Green\n}\n\n// 以下代码都会显示 System.Byte\nConsole.WriteLine(Enum.GetUnderlyingType(typeof(Color)));\nConsole.WriteLine(typeof(Color).GetEnumUnderlyingType());\n```\n\n\nC#编译器将枚举类型视为基元类型. 所以可用操作符(==,!=,<,>....)来操纵枚举类型的实例.可以显式将`枚举类型`转型为`不同的枚举类型`,可以显式将`枚举类型实例`转换为`数值类型`.\n\n```csharp\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        Color c = Color.Green;\n        Console.WriteLine(c);                            // Green\n        Console.WriteLine(c.ToString());                 // Green\n        Console.WriteLine(c.ToString(\"G\"));              // Green 常规格式\n        Console.WriteLine(c.ToString(\"D\"));              // 2     十进制\n        // 使用十六进制是, ToStirng总是输出大写字母\n        // 输出的位数取决于枚举的基础类型\n        // byte/sbyte: 2位, short/ushort: 4位 int/uint:8位 long/ulong: 16位\n        // 如果有必要会添加前导零\n        Console.WriteLine(c.ToString(\"X\"));              // 02    十六进制\n        Console.WriteLine(Color2.Green.ToString(\"X\"));   // 00000002 十六进制\n    }\n}\n\ninternal enum Color : byte\n{\n    White,\n    Red,\n    Green\n}\ninternal enum Color2 : int\n{\n    White,\n    Red,\n    Green\n}\n```\n## 枚举类型格式化输出的方法\n\n除了ToString方法,System.Enum类型还提供了静态Fotmat方法.\n\n- `ToSring方法`: 代码少,容易调用.\n- `Fotmat方法`: 可以传递value值,而不需要获取枚举的实例. 代码多.\n\n```csharp\n// 比ToString方法好的一个地方是,允许为value传递参数的值,这样就不需要获取枚举的实例\npublic static String Format(Type enumType,Object value, String format);\n\n// 输出: Blue\nConsole.WriteLine(Enum.Format(typeof(Color), 3, \"G\"));\n```\n\n## 返回枚举名称(值)的Array数组方法\n\n声明枚举类型时, 所有符号都可以有相同的数值. 使用常规格式将数值转换为符号时,Enum的方法会返回其中的一个符号,如果没有对应的数值定义的符号时,会返回包含该数值的字符串.\n\n```csharp\n// 返回的数组中每个元素都对应枚举类型中的一个符号名称,每个元素都包含符号名称的数值\npublic static Array GetValues(Type enumType); //System.Enum中定义\npublic Array GetEnumValues(Type enumType);    //System.Type中定义\n\n// 返回一个数组\nColor[] colors = (Color[]) Enum.GetValues(typeof(Color));\n\nConsole.WriteLine(\"定义枚举的个数: \" + colors.Length);\nConsole.WriteLine(\"Value\\tSymbol\\n-----\\t------\");\n\nforeach (Color color in colors)\n{\n    // 以十进制和常规格式显示每个符号\n    // 0代表第0个参数, {0,5:D} 5个占位符,color的十进制   {0:G} color的常规格式(符号名称)\n    Console.WriteLine(\"{0,5:D}\\t{0:G}\", color);\n}\n//    输出:\n//    定义枚举的个数: 3\n//    Value Symbol\n//    -----   ------\n//        0   White\n//        1   Red\n//        2   Green\n```\n\n`GetEnumValues和GetValues`方法返回Array,必须转型成恰当的数组类型. 所以定义了一个自定义的方法:\n```csharp\n// 使用下面自定义的泛型方法可以获得更好的编译时类型安全性\npublic static TEnum[] GetEnumValues<TEnum>() where TEnum :struct\n {\n     return (TEnum[]) Enum.GetValues(typeof(TEnum));\n }\n\n // 使用如下\n Color[] colors = GetEnumValues<Color>();\n```\n\n## 返回枚举符号名称的方法\n\n要显示符号名称时,ToString(常规格式)方法是经常使用的,前提是字符串不需要本地化(枚举类型没有提供本地化支持). 除了GetValues,还提供了以下方法来返回枚举类型的符号.\n\n```csharp\n// 返回数值的字符串表示\npublic static String GetName(Type enumType, Object value); // System.Enum中定义\npublic String GetEnumName(Object value); // System.Type中定义\n\n// 返回一个String数组,枚举中每个符号都对应一个String\npublic static String[] GetName(Type enumType);// System.Enum中定义\npublic String[] GetEnumName();  // System.Type中定义\n```\n\n## 返回与符号对应的值的方法\n\n来查找与符号对应的值. 可以利用这个操作转换用户在文本框中输入的一个符号.利用Enum提供的`静态Parse和TryParse方法`.\n\n```csharp\npublic static Object Parse(Type enumType, String value);\npublic static Object Parse(Type enumType, String value, Boolean ignoreCase);\npublic static Boolean TryParse<TEnum>(String value, out TEnum result) where TEnum : struct;\npublic static Boolean TryParse<TEnum>(String value, Boolean ignoreCase, out TEnum result) where TEnum : struct;\n\n\n// 使用方法\n// 因为orange定义为4, 所有c被初始化为4\nColor c = (Color) Enum.Parse(typeof(Color), \"orange\", true);\n\n// 运行时异常, 没有定义此Brown符号\n// Color c1 = (Color) Enum.Parse(typeof(Color), \"Brown\", false);\n\n// 创建值为1的Color枚举类型的实例.\nEnum.TryParse<Color>(\"1\", false, out c);\nConsole.WriteLine(c.ToString(\"D\")  + \":\" + typeof(Color).GetEnumName(c));\n\n// 创建值23的Color枚举类型的实例.\nEnum.TryParse<Color>(\"23\", false, out c);\nConsole.WriteLine(c + \":\" + typeof(Color).GetEnumName(c));\n\n```\n\n## 判断数值对于某枚举类型是否合法\n\nIsDefined方法经常用于参数校验.\n\n```csharp\npublic static Boolean IsDefined(Type enumType, Object value); // System.Enum中定义\npublic Boolean IsEnumDefined(Object value);// System.Type中定义\n\n\n// 用法\n// 输出 true , Red定义为1\nConsole.WriteLine(Enum.IsDefined(typeof(Color),1));\n// 输出 true , white定义为0\nConsole.WriteLine(Enum.IsDefined(typeof(Color),\"White\"));\n\n// 输出 false , 会检查区分大小写,并没有定义小写的white\nConsole.WriteLine(Enum.IsDefined(typeof(Color),\"white\"));\n// 输出 false , 没有和值10对应的符号\nConsole.WriteLine(Enum.IsDefined(typeof(Color),10));\n\n// IsDefined方法经常用于参数校验.\npublic void SetColor(Color c)\n{\n    if (!Enum.IsDefined(typeof(Color),c))\n    {\n        throw (new ArgumentOutOfRangeException(\"c\",c,\"无效颜色值.\"));\n    }\n    //.....\n}\n```\n\n参数校验是很有用的一个功能,防止别人这样调用`SetColor((Color) 100);` 并没有对应100的颜色,抛出异常指出参数无效.\n\n`IsDefined` 需要慎用\n1. 总是执行 **区分大小写** 的查找,没有办法让它执行不区分大小写的查找\n2. **执行速度慢**,因为内部使用了 **反射**.(如果写代码来手动检查每一个可能的值,性能极有可能变得更好)\n3. 只有枚举类型本身在调用IsDefined在同一个 **程序集** 时才可以使用.(枚举类型是常量,内联到IL代码中的,版本控制问题)\n4. **不要对位标志枚举使用IsDefined方法**. 因为如果传递字符串,它不会把字符串拆分为单独的token来进行查找,而是查找整个字符串, 把它看成是一个包含逗号的更大的符号.由 **于不能再枚举中定义包含逗号的符号**,所以永远找不到. 传递数值,它会检查枚举类型是否定义了其数值和传入的数值匹配,位标志不能简单的这样匹配,所以不要用这个方法.\n\n## ToObject方法\n\n将byte,sbyte,Int16,UInt16,Int32,UInt32,Int64,UInt64等类型的实例转换为 **枚举类型** 的实例.\n\n枚举一般来说应该定义在和需要它的类型同级.\n\n# 位标志\n\n位标志(bit flag), System.IO.File类型的GetAttributes方法,会返回一个`FileAttributes`的实例,\n`FileAttributes`是Int32类型的枚举, 每一个位都反映了文件的一个特性.\n\n```csharp\n[Flags]\n// Int32 有4个字节 每个字节8个位\npublic enum FileAttributes\n{\n    //                十进制        二进制\n    ReadOnly          = 1,      // 0001\n    Hidden            = 2,      // 0010\n    System            = 4,      // 0100\n    Directory         = 16,     // 0001 0000\n    Archive           = 32,     // 0010 0000\n    Device            = 64,     // 0100 0000\n    Normal            = 128,    // 1000 0000\n    Temporary         = 256,    // 0001 0000 0000\n    SparseFile        = 512,    // 0010 0000 0000\n    ReparsePoint      = 1024,   // 0100 0000 0000\n    Compressed        = 2048,   // 1000 0000 0000\n    Offline           = 4096,   // 0001 0000 0000 0000\n    NotContentIndexed = 8192,   // 0010 0000 0000 0000\n    Encrypted         = 16384,  // 0100 0000 0000 0000\n    IntegrityStream   = 32768,  // 1000 0000 0000 0000\n    NoScrubData       = 131072, // 0010 0000 0000 0000 0000\n}\n```\n\n\n```csharp\n// 判断文件是否隐藏可以执行以下代码:\nString file = Assembly.GetEntryAssembly().Location;\n// 获取文件的特性的枚举位标志\nFileAttributes attributes = File.GetAttributes(file);\n// 用& 与操作进行判断,如果attributes对应的Hidden位标志是1,那么1&1 就是true.\nConsole.WriteLine(\"Is {0} hidden? {1}\", file, (attributes & FileAttributes.Hidden) != 0);\n// HasFlag方法获取Enum参数,Enum参数是引用类型.\n// Console.WriteLine(\"Is {0} hidden? {1}\", file, attributes.HasFlag(FileAttributes.Hidden) );\n\n// 设置文件只读和隐藏特性\n// 用 |\nFile.SetAttributes(file, FileAttributes.Hidden | FileAttributes.ReadOnly);\n```\n\n**避免使用Enum提供的HasFlag方法**, 理由是,由于它获取Enum类型的参数,所以传给它的任何值都必须装箱,产生一次内存分配.\n\n## 关于为什么传入结构会进行装箱的问题\n\n在本例中，在进入`HasFlags`方法之前，需要两个装箱调用。\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var f = Fruit.Apple;\n        var result = f.HasFlag(Fruit.Apple);\n\n        Console.ReadLine();\n    }\n}\n\n[Flags]\nenum Fruit\n{\n    Apple\n}\n\n.method private hidebysig static\n    void Main (\n        string[] args\n    ) cil managed\n{\n    // Method begins at RVA 0x2050\n    // Code size 28 (0x1c)\n    .maxstack 2\n    .entrypoint\n    .locals init (\n        [0] valuetype ConsoleApplication1.Fruit f,\n        [1] bool result\n    )\n\n    IL_0000: nop\n    IL_0001: ldc.i4.0\n    IL_0002: stloc.0\n    IL_0003: ldloc.0\n    IL_0004: box ConsoleApplication1.Fruit\n    IL_0009: ldc.i4.0\n    IL_000a: box ConsoleApplication1.Fruit\n    IL_000f: call instance bool [mscorlib]System.Enum::HasFlag(class [mscorlib]System.Enum)\n    IL_0014: stloc.1\n    IL_0015: call string [mscorlib]System.Console::ReadLine()\n    IL_001a: pop\n    IL_001b: ret\n} // end of method Program::Main\n```\n\n- 第一次是将值类型上的方法调用解析为`基类型`方法，\n  - 调用基类型的方法会导致装箱\n- 第二次是参数时引用类型`Enum`, 要对枚举值类型进行装箱.\n\n**调用非虚的,继承的方法时(比如GetType或者MemberwiseClone),无论如何都要对值类型进行装箱, 因为这些方法由System.Object定义,要求this实参是指向堆对象的指针.**\n\n“值类型都是`System.ValueType`的后代”，**但System.ValueType的后代不全是值类型**，`System.Enum`就是唯一的特例！在System.ValueType的所有后代中，除了System.Enum之外其它都是值类型。事实上，我们可以在.NET的源代码中找到System.Enum的声明.\n\n`public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible`\n\n### C#枚举类型、System.Enum、System.ValueType、值类型和引用类型之间存在着什么样的关系？\n\n1. 所有`枚举类型（enum type）`都是值类型。\n2. `System.Enum`和`System.ValueType`本身是引用类型。\n3. `枚举类型（enum type）`都是隐式的直接继承自`System.Enum`，并且这种继承关系只能由编译器自动展开。但`System.Enum`本身 **不是枚举类型（enum type）** 。\n4. `System.Enum`是一个特例，它直接继承自`System.ValueType`，但本身却是一个引用类型。\n\n\n```csharp\n// 结果是什么都没输出\nstatic void Main()  \n{  \n    Type t = typeof(System.Enum);  \n\n    if (t.IsEnum)  \n        Console.WriteLine(\"I'm enum type.\");  \n\n    if (t.IsValueType)  \n        Console.WriteLine(\"I'm value type.\");  \n}\n```\n\n对于第一个判断，`我们很清楚System.Enum并不是枚举类型`。但第二个判断呢？System.Enum明明继承自System.ValueType，却不承认是System.ValueType的后代！这是.NET上的一个特例，恰恰体现出System.Enum是特殊性。\n\n\nQ：既然枚举类型是值类型，自然会涉及到装箱和拆箱（boxing and unboxing）的问题，那么枚举类型会被装箱成什么呢？\n\nA：枚举类型可以被装箱成`System.Enum`、`System.ValueType`、`System.Object`或者`System.IConvertible`、`System.IFormattable`、`System.IComparable`。\n\n[关于枚举的种种 C#, IL, BCL(博客地址)](https://blog.csdn.net/superbirds/article/details/4434133)\n\n## Flag特性\n\n位标志可以用来组合. 虽然枚举类型和位标志相似,但它们语义不尽相同.\n- 枚举类型表示单个数值\n- 位标志表示位集合\n  - 一些位处于On状态(代表1),一些处于off状态 (代表0)\n- **强烈建议向枚举类型应用定制特性类型[Flag]**\n\n```csharp\npublic static void Main(string[] args)\n{\n    // 现在数值为0x0005\n    Actions actions = Actions.Read | Actions.Delete;\n    // 输出: Read, Delete\n    Console.WriteLine(actions.ToString());\n}\n\n// 加上特性类型[Flag],ToString方法会试图转换为对应的符号,\n// 但是0x0005没有对应的值,不过方法检测到[Flag]标志,不会把他视为单独的值\n// 会视为一组位标志 0x0005由0x0001和0x0004组合而成,会输出Read, Delete字符串\n[Flags]\ninternal enum Actions\n{\n    None      = 0b0,\n    Read      = 0b1,\n    Write     = 0b10,  // 0x2\n    ReadWrite = Actions.Read | Actions.Write, //0x5\n    Delete    = 0b100, // 0x4\n    Query     = 0b1000,// 0x8\n    Sync      = 0b10000//0x10\n}\n```\n\n加上特性类型[Flag],ToString方法会试图转换为对应的符号,但是0x0005没有对应的值,不过 **方法检测到[Flag]标志,不会把他视为单独的值,会视为一组位标志** 0x0005由0x0001和0x0004组合而成,会输出Read, Delete字符串,去掉[flag]特性,则输出5.\n\n枚举的ToString()允许三种方式格式化输出:\n1. \"G\" 常规\n  1. 首先会检测类型,是否应用了[Flags]这个特性\n  2. 没有应用就查找与该数值匹配的符号,返回 **符号**\n2. \"D\" 十进制\n3. \"X\" 十六进制\n4. \"F\" 获得正确的字符串\n\n如果应用了[Flags]这个特性,ToString的工作流程如下:\n- 获取枚举类型定义的集合,降序排列这些数值\n- 每个数值都和枚举实例中的值进行`按位与`计算\n- 结果等于数值,与该数值关联的字符串就附加到输出字符串上. 对应的位会被关闭(设为0),认为已经考虑过了.\n- 重复上一步,直到检查完所有的值(或者所有位都为0)\n- 检查完数值后,如果枚举实例仍有不为0,表示处于On位的位不对应任何已经定义的符号.这种情况下,ToString返回枚举实例中的 **原始数值作为字符串返回.**\n- 如果实例不为0,就返回符号之间以逗号分隔的字符串.例如:`Read, Delete`\n- 如果实例原始值是0,并且有对应0值的符号. 返回这个符号\n- 到达这一步就返回\"0\".\n\n**永远不要对位`标志枚举`使用IsDefined方法**.\n- 向方法传递`字符串`,它不会把字符串拆分为单独的token来进行查找,而是查找整个字符串, 把它看成是一个包含逗号的更大的符号.由 **于不能再枚举中定义包含逗号的符号**,所以永远找不到.\n- 向方法传递`数值`,它会检查枚举类型是否定义了其数值和传入的数值匹配,位标志不能简单的这样匹配,所以不要用这个方法.\n\n# 向枚举类型添加方法\n\n利用C#的扩展方法 **模拟** 向枚举类型添加方法.\n\n```csharp\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        FileAttributes fa = FileAttributes.System;\n        fa = fa.Set(FileAttributes.ReadOnly);\n        fa = fa.Clear(FileAttributes.System);\n        // 输出: ReadOnly\n        fa.ForEach(f=>Console.WriteLine(f));\n\n    }\n}\n\n// 先定义一个包含了扩展方法的静态类\ninternal static class FileAttributesExtensionMethod\n{\n    public static Boolean IsSet(this FileAttributes flags, FileAttributes flagToTest)\n    {\n        if (flagToTest == 0)\n        {\n            throw new ArgumentOutOfRangeException(\"flagToTest\",\"值不能为0.\");\n        }\n        return (flags & flagToTest) == flagToTest;\n    }\n\n    public static Boolean IsClear(this FileAttributes flags, FileAttributes flagToTest)\n    {\n        if (flagToTest == 0)\n        {\n            throw new ArgumentOutOfRangeException(\"flagToTest\",\"值不能为0.\");\n        }\n        return  ! IsSet(flags,flagToTest);\n    }\n\n    public static Boolean AnyFlagSet(this FileAttributes flags, FileAttributes testFlag)\n    {\n        return ((flags & testFlag) != 0);\n    }\n\n    public static FileAttributes Set(this FileAttributes flags, FileAttributes setFlag)\n    {\n        return flags | setFlag;\n    }\n\n    public static FileAttributes Clear(this FileAttributes flags, FileAttributes clearFlag)\n    {\n        return flags & ~clearFlag;\n    }\n\n    public static void ForEach(this FileAttributes flags, Action<FileAttributes> processFlag)\n    {\n        if (processFlag == null)\n        {\n            throw new ArgumentNullException(\"processFlag\");\n        }\n\n        for (UInt32 bit = 1; bit != 0; bit <<= 1)\n        {\n            UInt32 temp = ((UInt32) flags) & bit;\n            if (temp!=0)\n            {\n                processFlag((FileAttributes) temp);\n            }\n        }\n    }\n}\n```\n","tags":["CLR读书笔记"]},{"title":"14字符字符串和文本处理2","url":"/2019/08/15/14字符字符串和文本处理2/","content":"# 获取对象的字符串表示 ToStirng\n\nSystem.Object定义了一个pulic,virtual,无参的ToString方法.\n\nSystem.Object的ToStirng实现的只是返回对象所属类型的全名,这对于许多不能提供有意义的字符串的类型来说,这是一个合理的默认值.\n\n想要提供合理的方式获取对象当前值的字符串表示,就应重写ToString方法. 定义类时应该总是重写ToString方法,以提供良好的调试支持.\n\n## 指定具体的格式和语言文化\n\n无参的ToString方法有两个问题:\n- 无法控制字符串的格式\n- 不能选择一种特定的语言文化来格式化字符串\n\n为了解决这个,类型应该实现`System.IFormattable`接口:\n```csharp\n// FCL的所有基类型都实现了这个接口, 另一些类型(Guid)也实现了它\npublic interface IFormattable\n{\n  String ToString(String format, IFormatProvider formatprovider);\n}\n```\n\nIFormattable方法获取两个参数,\n- `String format`: 告诉方法如何格式化字符串\n- `formatprovider`: 是一个实现了IFormatProvider接口的实例类型,提供具体的语言文化信息.\n\nFCL中定义的许多类型都能同时识别几种格式, 例如,\n- DateTime\n  - d 表示短日期\n  - D 表示长日期\n  - g 表示常规\n  - M 表示月/日\n  - s 表示可排序\n  - T 表示长时间\n  - u 表示ISO8601格式的协调世界时\n  - U 表示长日期格式的协调世界时\n  - Y 表示年/月\n- 所有枚举\n  - G 表示常规\n  - F 表示标志\n  - D 表示十进制\n  - X 表示十六进制\n- 所有内建数值类型\n  - C 表示货币格式\n  - D 表示十进制格式\n  - E 表示科学计数法\n  - F 表示定点(fix-point)格式\n  - G 表示常规格式\n  - N 表示数字格式\n  - P 表示百分比格式\n  - R 表示往返行程(round-trip)格式\n    - 保证转换为字符串的数值再次被分析为相同的数值\n    - 此格式仅有浮点型(Single,Double)支持\n  - X 表示十六进制\n- 数值类型还支持 picture数值格式字符串###,###可以显示千分位分隔符. (详情参考自定义数字格式字符串)\n\n![](14字符字符串和文本处理2/R说明符.png)\n\n大多数类型,调用ToStirng传递null完全等价于传递格式字符串`G`.\n\n关于语言文化,默认无参ToString方法默认使用与调用线程关联的语言文化信息进行格式化.如果formatprovider传null,IFormattable的ToString也这么做.\n\n\n格式化数组(货币,整数,浮点数,百分比,日期和时间)适合应用对语言文化敏感的信息.\n\n```csharp\n// 一下代码将以越南地区适用的货币格式来获取一个Decimal数值的字符串表示.\nDecimal price = 123.54M;\nString s = price.ToStirng(\"C\",new CultureInfo(\"vi-VN\"));\nMessageBox.Show(s);\n```\n\n![](14字符字符串和文本处理2/越南货币显示.png)\n\n```csharp\n// 这个版本调用ToString(null,null);\n// 采用常规数值格式,采用线程的语言文化信息\npublic override String ToString();\n\n// 是ToString的真正实现\n// 采用由调用者指定的格式和语言文化信息\npublic String ToString(String format, IFormatProvider formatprovider);\n\n// 简单的调用ToString(null,formatprovider);\n// 实现了IConvertible的ToString方法\npublic String ToString(IFormatProvider formatprovider);\n```\n\n## 将多个对象格式化成一个字符串\n\n```csharp\nString s = String.Format(\"On {0:D}, {1} is {2:E} years old.\", new DateTime(2019, 8, 15), \"AA\", 9);\n// 输出: On 2019年8月15日, AA is 9.000000E+000 years old.\nConsole.WriteLine(s);\n```\n\n在Format中,解析字符串时, 发现可替换`参数0`应该调用它的IFormattable接口的ToString方法,并为方法传递\"D\",null参数.\n\n但是如果使用StringBulider而不是String来构造字符串,可以调用StringBulider的AppendFormat方法.AppendFormat原理与String的Format相似.\n\nConsole的Write/WriteLine要格式化符合特定语言文化的字符串必须要调用String的Format方法.\n\n## 提供定制格式化器\n\n可以定义一个方法,在任何对象需要格式化字符串的时候由`StringBuilder`的`AppendFormat`方法调用该方法,按照我们希望的任何方式格式化对象. (也适用于String的Format方法)\n\n也就是说,`AppendFormat`不是为每个对象调用ToString方法,而是调用自定义的方法.\n\n以下代码为了将所有的Int32值在HTML中加粗显示.\n\n```csharp\n/// <summary>\n/// 格式化定制器\n/// 将所有的Int32值在HTML中加粗显示.用<B></B>加粗显示\n/// </summary>\nnamespace FormatController\n{\n    class Program\n    {\n        public static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            // 传入定制类BoldInt32s为参数\n            sb.AppendFormat(new BoldInt32s(), \"{0} {1} {2:M}\", \"AAA\", 23, DateTime.Now);\n            //输出 AAA <b>23</b> 8月15日\n            Console.WriteLine(sb);         \n            Console.ReadKey(true);\n        }\n    }\n    // 需要实现IFormatProvider和ICustomFormatter接口\n    internal sealed class BoldInt32s : IFormatProvider, ICustomFormatter\n    {\n        public object GetFormat(Type formatType)\n        {\n            if(formatType == typeof(ICustomFormatter))\n            {\n                return this;\n            }       \n            return Thread.CurrentThread.CurrentCulture.GetFormat(formatType);\n        }       \n        public string Format(string format, object arg, IFormatProvider formatProvider)\n        {\n            string s;       \n            IFormattable formattable = arg as IFormattable;         \n            if(formattable == null)\n            {\n                s = arg.ToString();\n            }\n            else\n            {\n                s = formattable.ToString(format, formatProvider);\n            }         \n            if(arg.GetType() == typeof(Int32))\n            {\n                return \"<b>\" + s + \"</b>\";\n            }       \n            return s;\n        }     \n    }         \n}\n```\n\nAppendFormat的工作方式:\n1. 需要格式化一个可替换参数时,会调用ICustomFormatter的Format方法\n2. 如果不支持就调用简单的无参的ToString方法\n3. 如果对象支持IFormattable就调用支持富格式化的ToString,向它传递字符串和格式提供器.\n4. 最后核实类型是否是需求的类型,处理自定义操作.\n\n\n# 解析字符串来获取对象 : Parse\n\n从某种意义上来说,Parse扮演了一个工厂的角色. 能解析字符串的任何类型都提供了`公共静态方法Parse`.\n\n以Int32类型的Parse方法为例(其他数值类型的Parse方法与此相似):\n\n```csharp\n\npublic static Int32 Parse(String s,NumberStyles style, IFormatProvider provider);\n```\n\n- `NumberStyles` 参数是标志集合,标识了Parse应在字符串查找的字符,也就是s中允许的样式,不允许的会抛出异常.(也就是说 string中不能出现不对应类型的字符)\n- `IFormatProvider` 获取语言文化特有的信息\n```csharp\n// 会抛出FormatException\n// 字符串包含了前导空白符\n// Int32 x = Int32.Parse(\" 123\",NumberStyles.None, null);\n\n// 这样修改,能跳过前导空白符\nInt32 x = Int32.Parse(\" 123\",NumberStyles.AllowLeadingWhite, null);\n\n// 解析16进制数\nInt32 x = Int32.Parse(\"1A\",NumberStyles.HexNumber, null); // x : 26\n\n// 上述方法需要传递3个参数,为了简化编程,还提供了Parse方法的4个重载版本.\n```\n\n[数字NumberStyles的详细文档.](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.numberstyles?redirectedfrom=MSDN&view=netframework-4.8)\n\n[日期的DateTimeStyles的详细文档](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.datetimestyles?redirectedfrom=MSDN&view=netframework-4.8)\n\n对日期和事件的解析比较复杂, DateTime类型的Parse方法过于宽松,还提供`ParseExact`方法,接收一个picture参数,能准确描述应该如何格式化日期/时间字符串,以及如何解析.\n\n[参考DateTimeFormatInfo的详细文档](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.datetimeformatinfo.-ctor?redirectedfrom=MSDN&view=netframework-4.7.2)\n\n## 关于Parse性能上的问题\n\n如果应用程序频繁调用Parse,而且Parse频繁抛出异常(用户无效输入),应用程序性能会显著下降.\n\n为此, Microsoft为所有的`数值数据类型`,`DateTime类型`,`TimeSpan类型`,`IPAddress类型`中加入`TryParse`方法.\n\n```csharp\n// 方法返回bool, 指出传递的字符串是否能解析成功,以传引用的方式传给result\npublic static bool TryParse(string s,NumberStyles style,IFormatProvider provider,\n  out int result);\n```\n\n\n# 编码: 字符和字节的相互转换\n\n用`System.IO.BinaryWriter`或者`System.IO.StreamWriter`类型将字符串发送给文件或网络流时，通常要进行编码。对应地，`System.IO.BinaryReader`或者`System.IO.StreamReader`类型从文件或网络流中读取字符串时，通常要进行解码。不显式指定一种编码方案，所有这些类型都默认使用UTF-8。\n\nFCL提供了一些类型来简化字符编码和解码. 两种最常用的编码方案是UTF-16和UTF-8.\n\n- `UTF-16`: 将每个16位字符编码成2个字节。不会对字符产生任何影响，也不发生压缩---性能非常出色。UTF-16编码也称为Unicode编码。(可以从`低位优先`转换成`高位优先`,或者`高位优先`转换成`低位优先`)\n\n- `UTF-8`: 将部分字符编码成1个字节，部分编码成2个字节，部分编码成3个字节或4个字节。值在0x0080之下的字符压缩成1个字节，适合表示美国使用字符。0x00800~0x07FF的字符转换成2个字节，适合欧洲和中东语言。0x0800以及之上的字符转换成3个字节，适合东亚语言。最后代理项对表示成4个字节。0x0080编码方法非常流行，但如果要编码的许多字符都具有0x0800或者之上的值，效率不如UTF-16\n\n- `ASCII`: 编码方案将16位字符编码从ASCII字符：也就是说，值小于0x0080的16位字符被转换成单字节。值超过0x007F的任何字符都不能被转换，否则字符的值会丢失。\n\n> 应该总是选择UTF-16 UTF-8编码\n\n```csharp\nString s = \"Hi there.\";\n\n// 它知道怎么使用UTF-8来进行编码和解码\nEncoding encodingUTF8 = Encoding.UTF8;\n\n// 将字符串编码成字节数组\nByte[] encodingBytes = encodingUTF8.GetBytes(s);\n\n// 显式编译好的字节值\n// 输出:48-69-20-74-68-65-72-65-2E\nConsole.WriteLine(BitConverter.ToString(encodingBytes));\n\n// 将字节数组解码回字符串\nString decodeString = encodingUTF8.GetString(encodingBytes);\n\n// 显式解码的字符串\n// 输出: Hi there.\nConsole.WriteLine(decodeString);\n```\n\n**不建议使用Encoding类的静态属性Defult,它返回的是对象使用用户当前的代码页来进行编码和解码(在用户控制面板的区域和语言选项中指定),也就有是说应用程序的行为会随着机器的设置而变.**\n\n**`UnicodeEncoding`**,**`UTF8Encoding`**,**`UTF32Encoding`**,`UTF7Encoding`提供了多个构造器, 允许对编码和前导码进行更多的控制. 前3个类还提供了特殊的构造器,允许在对一个无效的字节序列进行解码时抛出异常,**应该使用这些能抛出异常的类.**\n\n前导码: 也称`字节顺序标记`(BOM,Byte Order Mark).\n\n![](14字符字符串和文本处理2/Encoding的派生类常用的方法.png)\n\n## 字符和字节流的编码和解码\n\n字节流通常以数据块data chunk的形式传输, 可能先从流中读5个字节,然后再7个字节,因为UTF-16每个字符都是2个字节,那么调用Encoding的GetString方法传递一个5字节的数组返回的字符串只包含2个字符,后面的7个字节返回3个,显然会造成数据损坏.\n\n\n字节块解码首先要获取一个Encoding对象,在调用其`GetDecoder`方法.\n- 返回一个新构造对象的引用,从抽象类`System.Text.Decoder`派生.\n- Decoder提供了2个重要方法\n  - GetChars和GetCharCount.\n  - 它会尽可能多的解码字节数组. 如果剩余一个字节,\n  - **则会保存到Decoder对象内部,下次调用时取出,和新的字节数组合并.**\n  - 这样就能正确解码.\n\n> 从流中读取字节时,Decoder对象的作用很大.\n\n每次调用从Encoder派生的对象都会维护余下数据的状态信息,以便成块的方式对数据进行编码.\n\n## Base-64字符串编码和解码\n\n除了UTF-16和UTF-8,另一个流行方案是将`字节序列`编码成`Base-64字符串`.\n\n例外的是,Base-64编码和解码不是用Encoding派生类型来完成,而是用`Convert`的`静态方法ToBase64String或ToBase64CharArray方法`.\n\n```csharp\n// 获取10个随机生成的字节\nByte[] bytes = new Byte[10];\nnew Random().NextBytes(bytes);\n\n// 将字节解码成Base-64字节串,并显示字符串\nString s = Convert.ToBase64String(bytes);\n// 输出: usLVdVlIgAgfsw==\nConsole.WriteLine(s);\n\n// 将Base-64字符串编码回字节,并显示\nbytes = Convert.FromBase64String(s);\n// 错误用法, 显示的是类名 System.Byte[]\n// Console.WriteLine(bytes.ToString());\n// 输出: BA-C2-D5-75-59-48-80-08-1F-B3\nConsole.WriteLine(BitConverter.ToString(bytes));\n```\n\n\n# 安全字符串\n\nString对象可能包含敏感数据,比如信用卡资料,密码. String对象会在内存中包含一个字符数组. 执行不安全代码或者非托管代码就可以扫描进程的地址空间,找到包含敏感数据的字符串.\n\n即使String对象只用一小段时间就进行垃圾回收, CLR也可能无法立即重用String对象的内存, 致使String的字符长时间保留在进程的内存中. 由于字符串不可变,处理它们的时候,旧的副本会逗留在内存中,最终造成多个不同版本的字符串散布在整个内存空间中.\n\nFCL增加了一个更安全的字符串类:`System.Security.SecureString`\n\n构造`SecureString`对象时,会在内部分配一个非托管内存块,其中包含一个字符数组.\n- 使用非托管内存块是为了避开垃圾回收器的魔爪.\n- 这些字符串是经过加密的,能防范任何恶意的非安全/非托管代码获取机密信息.\n\n`SecureString`类的操作方法:\n1. `AppendChar` 附加\n2. `InsertAt` 插入\n3. `RemoveAt` 删除\n4. `SetAt` 设置一个字符\n\n但是调用这些方法时,方法内部会进行 **解密** ,执行完指定的操作再 **重新加密** 字符串.**这说明有一段时间是处于未加密的状态.** 并且这些操作性能会比较一般.\n\n`SecureString`类实现了`IDisposable`接口. 用简单的方式 **确定性** 地摧毁字符串中的安全内容. 只需要调用`SecureString`的`Dispose`方法. 在方法内部,Dispose会对内存缓冲区的内容进行清零.然后释放缓冲区.\n\nSecureString对象内部有一个SafeBuffer派生的对象负责维护字符串,SafeBuffer类最终从CriticalFinalizerObject类派生,所以在垃圾回收时,内容保证清零,缓冲区被释放.\n\n`SecureString`对象被垃圾回收后,加密的字符串的内容将不再存于内存中.\n\nFCL限制了对`SecureString类`的支持. 只有少数方法才能接受`SecureString参数`.\n\n要使用的话可以创建自己的方法来接收SecureString对象参数,方法内部必须先让SecureString对象创建一个非托管内存缓冲区,它将用于包含解密过的字符,然后才能让该方法使用缓冲区.为了最大程度降低恶意代码获取敏感数据的风险,你的代码在访问解密过的字符串时,时间应尽可能短,结束使用后,代码尽快清零并释放缓冲区. **不要将SecureString内容放到一个String中. String会在堆中保持未加密的状态.** 并且SecureString没有重写ToString方法,就是为了避免这个.\n\n```csharp\npublic static void Main(string[] args)\n{\n    // using代码块之后,SecureString被dispose,内存中无敏感数据\n    using (SecureString ss = new SecureString())\n    {\n        Console.WriteLine(\"请输入密码:\");\n        while (true)\n        {\n            // 参数true意思是,拦截输入,不显示在控制台上\n            ConsoleKeyInfo cki = Console.ReadKey(true);\n            // 回车表示输入完成\n            if (cki.Key == ConsoleKey.Enter) break;\n\n            // 将密码附加到SecureString中\n            ss.AppendChar(cki.KeyChar);\n            Console.Write(\"*\");\n        }\n\n        Console.WriteLine();\n        // 密码已经输入,出于演示的目的显示它\n        DisplaySecureString(ss);\n    }\n}\n\n// 这个代码是unsafe,要访问非托管内存\nprivate unsafe static void DisplaySecureString(SecureString ss)\n{\n    Char* pc = null;\n    try\n    {\n        // 将SecureString解密到一个非托管内存缓冲区\n        pc = (char*) Marshal.SecureStringToCoTaskMemUnicode(ss);\n\n        // 访问包含已经解密SecureString字符的非托管内存缓冲区\n        for (int i = 0; pc[i] != 0; i++)\n        {\n            Console.Write(pc[i]);\n        }\n    }\n    finally\n    {\n        // 确定清零并释放包含已解锁SecureString字符的非托管内存缓冲区\n        if (pc != null)\n        {\n            Marshal.ZeroFreeCoTaskMemUnicode((IntPtr) pc);\n        }\n    }\n}\n```\n\n### 什么情况下用SecureString?\n\n如果以下情况下，`SecureString`非常有用：\n- 您可以逐字符构建它(例如从控制台输入)，或者从非托管API获得它。\n- 您可以通过将它传递给非托管API(SecureStringToBSTR)来使用它。\n**如果您曾经将其转换为托管字符串，则您已经放弃了它的用途。**\n\n我会看到的主要用例是在客户端应用程序中，它要求用户输入高度敏感的代码或密码。用户输入可以逐字符用于构建SecureString，然后将其传递给非托管API，该API对它使用后接收的BSTR进行零。任何后续内存转储都不会包含敏感字符串。\n在服务器应用程序中，很难看出它在哪里有用。\n\n\n## Marshal类提供用于操纵安全字符串的方法\n\n`System.Runtime.InteropServices.Marshal类`提供5个方法来将一个`SecureString`的字符 **解密到非托管** 内存缓冲区. 所有方法都是静态方法.所有方法都接受一个SecureString参数,并返回IntPtr.\n\n每个方法都有一个配对方法来清零并释放内部缓冲区.\n\n![](14字符字符串和文本处理2/Marshal提供操作安全字符串的方法.png)\n","tags":["CLR读书笔记"]},{"title":"14字符字符串和文本处理","url":"/2019/08/12/14字符字符串和文本处理/","content":"\n# 字符,字符串和文本处理\n\nMicorsoft .Net Framework中处理字符和字符串的机制.\n\n- `System.Char`结构以及处理字符的多种方式.\n- `System.String` 处理不可变(immutable)字符串(一旦创建,字符串便不能以任何方式修改).\n- `System.Text.StringBuilder` 高效的动态构造字符串.\n- 如何将对象格式化成字符串, 以及如何使用各种编码方案高效率的持久化或传输字符串.\n- `System.Security.SecureString` 保护密码等敏感字符串.\n\n\n# 字符\n\n在`.Net Framework`中字符总是表示成 **16位的Unicode代码值**.\n\n每个字符都是一个`System.Char`结构(值类型)的实例. 并提供了两个公共只读常量字段:\n- `MinValue` : `'\\0'`\n- `MaxValue` : `'\\ufff'`\n\nUnicode标准定义了控制字符,货币字符,小写字母,大写字母,标点符号,数学符号还有其他符号. `System.Globalization.UnicodeCateGory枚举`定义了这些枚举类型. `Char`的实例调用静态方法`GetUnicodeCategory`方法返回这些枚举中的一个值. 反应这个字符是什么种类的.\n\nChar类型其他几个静态方法,大多数都在内部调用`GetUnicodeCategory`方法,并简单的返回true/false.\n\n> 这些方法要么获取当字符作为参数,要么获取String以及目标字符在这个String中的索引作为参数.\n\n> 关于语言文化culture, 有些方法比如ToLowerInvariant会以忽略语言文化的方式将字符转换为小写.\n> 比如土耳其语中,字母U+0069(小写拉丁字母i)转换成大写是U+0130(大写拉丁字母I上加一点).\n\nChar类型自己的实例方法:\n1. `Equals`: 两个Char实例代表同一个16位Unicode码位的前提下返回true. (ASCII码包含128个码位)\n2. `CompareTo`: 返回两个Char实例忽略语言文化的比较结果.\n3. `ConvertFromUtf32`:  从UTF-32字符生成包含1个或2个UTF-16字符的字符串\n4. `ConvertToUtf32`:  从字符串生成一个UTF-32字符\n5. `ToString`: 返回单个字符的一个String, 相反的是`Parse/TryParse`,它们获取单字符的String,返回该字符的UTF-16码位.\n6. `GetNumericValue`: 返回字符的数值形式.\n\n```csharp\n// 返回字符的数值形式\nDouble d = Char.GetNumericValue('\\u0033'); // \\u0033 是数字3\nConsole.WriteLine(d.ToString()); // 输出: 3\nd = Char.GetNumericValue('\\u00bc'); // \\u00bc 是普通分数的1/4\nConsole.WriteLine(d.ToString()); // 输出: 0.25\nd = Char.GetNumericValue('A');\nConsole.WriteLine(d.ToString()); // 输出: -1\n```\n\n三种技术实现`数值类型`与`Char实例`的互相转换. 按照优先顺序列出:\n\n1. 转型(强制类型转换)\n  1. 比如将Char转换成数值Int32最简单的办法就是强制转换. 这是三种技术中 **效率最高的,因为编译器会生成中间语言IL指令执行转换,而且不必调用方法.** 需要考虑转换时是否使用`checked`还是`unchecked`(对基元类型执行的许多算术运算符都可能造成溢出).\n2. 使用`Convert类型`\n  1. `System.Convert`类型提供了几个静态方法实现Char和数值类型的相互转换,所有这些转换都以`checked`方式执行,发现转换将造成数据丢失就抛出`OverflowException`异常.\n3. 使用`IConvertible接口`\n  1. `Char类型`和FCL中的`所有数值类型`都实现了`IConvertible`接口. 这个接口定义了像ToUInt16和ToChar这样的方法. 这种效率最差,因为值类型调用接口方法会产生装箱, **Char和所有数值类型都是值类型.** 所以许多类型(包括FCL的Char和数值类型)都将IConvertble的方法实现了 **EIMI显式接口方法成员**.  这就意味着为了调用接口的任何方法,都必须将实例显式转型为一个`IConvertible`接口变量, 转换时,大多数时候都可以忽略语言文化,为`IFormatProvider`这个参数传递null值.\n\n```csharp\npublic static void Main()\n{\n    Char  c;\n    Int32 n;\n\n    // 使用C#转型技术实现，强制类型转换\n    // 效率最高,直接编译生成中间语言IL指令执行转换\n    // 需要考虑是否会溢出,对基元类型执行的许多算术运算符都可能造成溢出\n    // 转换时是否使用`checked`还是`unchecked`\n    c = (Char)65;\n    Console.WriteLine(c); // 显示 \"A\"\n    n = (Int32)c;\n    Console.WriteLine(n); // 显示 \"65\"\n    c = unchecked((Char)(65536 + 65));\n    Console.WriteLine(c); // 显示 \"A\"\n\n\n    // 使用Convert进行转换\n    // 这些转换方法都以checked方式执行\n    // 转换出现数据丢失会抛出异常\n    c = Convert.ToChar(65);\n    Console.WriteLine(c); // 显示 \"A\"\n    n = Convert.ToInt32(c);\n    Console.WriteLine(n); // Displays \"65\"\n    // 显示Convert的范围检查\n    try {\n        // 2^16 = 65535\n        c = Convert.ToChar(70000); // 对 16-bits 来说过大,转换丢失精度\n        Console.WriteLine(c);      // !!!不执行\n    }\n    catch (OverflowException) {\n        Console.WriteLine(\"Can't convert 70000 to a Char.\");\n    }\n\n\n    // 使用IConvertible进行转换\n    // 效率最差,因为值类型调用接口方法会产生装箱(Char和所有数值类型都是值类型)\n    // IConvertble的方法实现了 EIMI显式接口方法成员,所以要转换成接口类型变量才能调用接口方法\n    // 传递参数IFormatProvider为null 是忽略语言文化\n    c = ((IConvertible)65).ToChar(null);\n    Console.WriteLine(c); // 显示 \"A\"\n    n = ((IConvertible)c).ToInt32(null);\n    Console.WriteLine(n); // 显示 \"65\"\n}\n```\n\n\n# System.String类型\n\n一个System.String代表一个不可变(immutable)的顺序字符集.\n\nString是引用类型, 对象总是存在于`堆`上,永远不会到线程`栈`.\n\n## 构造字符串\n\nC#将String视为基元类型, 编译器允许在源代码中直接使用字面值(literal)字符串, 编译器将这些字符串放到模块的元数据中,并在运行时加载和引用它们.\n\n1. 不允许用new操作符从字面值字符串构造String对象.\n\n```csharp\n// 不能使用 new + 字面值(literal)字符串 构造.\nString s = new String(\"Error\");// 错误\n\n// 必须使用简化语法\nString s = \"Hi there.\";\n```\n\n![](14字符字符串和文本处理/StringIL代码.png)\n\n用于构造对象新实例的IL指令时`newobj`. 但是上述IL代码中并没出现这个指令, 出现的是`ldstr`(load string)指令, 它使用从元数据获得的字面值literal字符串构造String对象.这证明了CLR实际用一种特殊的方式构造字面值String对象.\n\n如果使用`不安全的unsafe代码`,可以从一个`Char*`或`Sbyte*`构造一个String. 这时要使用到new操作符,调用对应参数的构造器.\n\nC#提供了一些特殊语法来帮助开发人员在源代码中输入字面值字符串. 对于`换行符`,`回车符`和`退格符`这样的特殊字符,采用如下转义机制:\n\n```csharp\n// 这是硬编码了回车符和换行符,一般不建议这样做\n// 不同底层平台使用的不一定相同\n// \\r 回车符 \\n 换行符\nString s = \"Hi\\r\\nthere.\";\n\n// 正确定义上述字符串的方式\n// Environment.NewLines属性对平台敏感, 会根据平台返回恰当的字符串\nString s = \"Hi\" + Environment.NewLine + \"there.\";\n```\n\n使用`+操作符`可以将几个字符串连接成一个, 如果都是字面值,C#编译器在编译时就能连接它们,最终将一整个字符串放到模块的元数据中, 如果存在非字面值,则会在运行时进行.\n\n**运行时连接不建议使用+操作符, 这样会在堆上创建多个字符串对象,而堆是需要垃圾回收的,对性能有影响. 应该使用StringBuilder类型.**\n\n## 逐字字符串声明(@ 操作符)\n\n采用这种方法,引号之间的所有字符都会视为字符串的一部分, 也就是不转义`\\`,视为字符串, 通常用于指定文件和目录的路径,或者与正则表达式配合使用.\n\n```csharp\n// 不使用@逐字字符串声明方式\nString s = \"C:\\\\Window\\\\System32\\\\Notepad.exe\";\n// 使用@方式\nString s = @\"C:\\Window\\System32\\Notepad.exe\";\n```\n\n两种写法在程序集的元数据中生成完全一样的字符串,但是后者可读性更好.\n\n## 字符串是不可变的\n\nString对象最重要的一点就是不可变,并且只能是密封类. 一经创建便不能更改(变长,变短,修改任何字符).\n\n好处有:\n1. 在字符串上执行各种操作,而不实际地更改字符串. 返回修改后的新建的字符串地址.\n2. 在操作字符串时不会发生线程同步问题.\n  1. `字符串留用`:CLR通过一个String对象共享多个完全一致的String内容,减少系统中的字符串数量,从而节省内存.\n\n\n## 比较字符串\n\n判断相等性或者排序. 建议调用String类定义的一下方法:\n\n```csharp\n// 建议使用以下版本, 不建议使用没有列出的重载版本\nbool Equals (string value, StringComparison comparisonType);\nstatic bool Equals (string a, string b, StringComparison comparisonType);\n\nstatic int Compare (string strA, string strB, StringComparison comparisonType);\nstatic int Compare (String strA, String strB, bool ignoreCase, CultureInfo culture);\nstatic int Compare (string strA, string strB, CultureInfo culture, CompareOptions options);\nstatic int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);\nstatic int Compare (string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);\nstatic int Compare (String strA, int indexA, String strB, int indexB, int length, bool ignoreCase, CultureInfo culture);\n\n```\n\n **比较时应该区分大小写, 原因是两个大小写不同的字符串会被视为相等.**\n\n**建议避免使用** String实现IComparable接口的`CompareTo方法`, `CompareOrdinal方法`, `==操作符`, `!=操作符`. 这是因为调用者不显式指出以什么方式执行字符串比较, 比如`CompareTo方法`默认执行语言文化敏感的比较, 而`Equals方法`执行 **不考虑语言文化的序号(ordinal)比较**.\n\n> Ordinal: 序号比较, 就是不考虑语言文化信息, 只比较字符串中每个Char的Unicode码位.\n\n\n- `comparisonType`参数,要求获取`StringComparison`枚举定义的某个值:\n\n```csharp\n// 要求传递显式传递语言文化\npublic enum StringComparison\n{\n    // 为了向用户显式一些字符串,要以语言文化正确的方式,就应该使用如下两个,\n    //使用区域敏感排序规则和当前区域比较字符串。\n    CurrentCulture,\n    //使用区域敏感排序规则、当前区域来比较字符串，同时忽略被比较字符串的大小写。\n    CurrentCultureIgnoreCase,\n    // ----------------------\n\n    // 平时不建议使用,所花的时间远超Ordinal\n    //使用区域敏感排序规则和固定区域比较字符串。\n    InvariantCulture,//固定语言文化  --- 其实就是不使用任何具体的语言文化.\n    //使用区域敏感排序规则、固定区域来比较字符串，同时忽略被比较字符串的大小写。\n    InvariantCultureIgnoreCase,\n    // ----------------------\n\n\n    // 以下选项会忽略语言文化(常用)\n    // 特别是在程序内部使用的字符串, 比如文件名,URL,注册表值,环境变量,反射,XML标记,特性等.\n    // 忽略语言文化是字符串比较最快的方式\n    //使用序号排序规则比较字符串。\n    Ordinal,\n    //使用序号排序规则并忽略被比较字符串的大小写，对字符串进行比较。\n    OrdinalIgnoreCase\n}\n```\n\n要在比较前更改字符串中的字符的大小写, 应该使用:\n1. `String.ToUpperInvariant`, **强烈建议使用此方法对字符串进行正规化(normalizing),不使用转小写**\n2. `String.ToLowerInvariant`, 建议使用.\n\n**因为Microsoft对执行`大写比较`的代码进行了优化.** , 事实上,执行不区分大小写的比较之前, FCL会自动将字符串`正规化为大写形式`.\n\n之所以使用`ToUpperInvariant`和`ToLowerInvariant`,是因为String类没有提供`ToUpperOrdinal`和`ToLowerDordinal`方法, 不使用以下2个方法是因为以下方法`对语言文化敏感`.\n\n3. `String.ToUpper` (不建议使用,因为对语言文化敏感)\n4. `String.ToLower` (不建议使用,因为对语言文化敏感)\n\n\n- `CompareOptions`参数。这个参数要获取有`CompareOptions`枚举类型定义的一个值：\n\n```csharp\npublic enum CompareOptions\n{\n    None = 0,\n\n    //指示字符串比较必须忽略大小写。\n    IgnoreCase = 1,\n\n    //指示字符串比较必须忽略不占空间的组合字符，比如音调符号。\n    IgnoreNonSpace = 2,\n\n    //指示字符串比较必须忽略符号，如空白字符、标点符号、货币符号、百分号、数学符号、“&”符等等\n    IgnoreSymbols = 4,\n\n    //指示字符串比较必须忽略 Kana 类型\n    IgnoreKanaType = 8,\n\n    //指示字符串比较必须忽略字符宽度\n    IgnoreWidth = 16,\n\n    //指示字符串比较必须使用字符串排序算法。\n    StringSort = 0x20000000,\n\n    //指示必须使用字符串的连续 Unicode UTF-16 编码值进行字符串比较（使用代码单元进行代码单元比较），这样可以提高比较速度，但不能区分区域性\n    Ordinal = 0x40000000,\n\n    //字符串比较必须忽略大小写，然后执行序号比较。\n    OrdinalIgnoreCase = 0x10000000\n}\n```\n\n## 执行语言文化正确的比较\n\n.Net Framework 使用 System.Globalization.CultureInfo 类型表示一个\"语言/国家\".\n\n- en-US 美国英语\n- en-AU 澳大利亚英语\n- de-DE 德国德语\n\n在CLR中,每个线程都关联了两个特殊属性, 每个属性都应用一个CultureInfo对象:\n- `CurrentUICulture`: 该属性获取要向用户显示的资源. 在GUI或web窗体应用程序中特别有用.\n- `CurrentCulture`:不适合CurrentUICulture属性的场合就用该属性.通过控制面板的区域和语言对话框来修改这个值.\n\n![](14字符字符串和文本处理/设置语言文化.png)\n\n如果不是序号比较(不考虑语言文化),就会进行`字符展开`,也就是将一个字符展开成忽视语言文化的多个字符. 这样比较字符串就\n\n![](14字符字符串和文本处理/展开字符.png)\n\n```csharp\nString s1 = \"Strasse\";\nString s2 = \"Straße\"; // ß 等同于ss\n\n// 忽略语言文化\nConsole.WriteLine(String.Compare(s1,s2,StringComparison.Ordinal)); // 两个字符串不同 输出 -108\n\nCultureInfo ci = new CultureInfo(\"de-DE\");\n// 设置德语文化\nConsole.WriteLine(String.Compare(s1,s2,true,ci)); // 两个字符串相同 输出 0\n```\n\n> 关于法语,日语,一些比较参考书中代码. P289页\n\n> 源代码不要用ANSI格式保存,否则日语字符会丢失,要保存的话选择另存为-并选择Unicode(UTF-8带签名)-代码页65001 , 这样C#编译器就能成功解析这个源文件代码了.\n\n\n## 字符串留用\n\n检查字符串相等性的操作,也可能是损害性能的操作,\n\n- 执行`序号(ordinal 语言文化不敏感)相等性检查`时\n  - CLR快速检测两个字符串是否包含相同数量的字符\n    - 不相同则肯定不等.\n    - 若相同,CLR必须比较每个单独的字符才能最终确认\n- 执行`语言文化敏感的比较`时:\n  - CLR必须比较所有单独的字符(因为两个字符串长度不同也可能相等)\n\n**在内存中复制一个字符串的多个实例纯属浪费. 浪费内存,只需要保留一个实例,将引用字符串的所有变量执行单独一个字符串对象.**\n\n如果应用程序经常对字符串进行区分大小写的序号比较,或者事先知道许多字符串对象都有相同的值, 既可以用CLR的`字符串留用(intering)`机制来显著提升性能.\n\n- CLR初始化会创建一个`内部哈希表`.key:字符串  value:堆中对String对象的引用\n- String提供了两个方法,访问这个内部哈希表\n  - `pulic static String Intern(String str);`  \n    - 在内部哈希表中检查是否有匹配的,\n    - 如果存在,就返回对现有String对象的引用\n    - 如果不存在,**就创建字符串副本,返回副本的引用**\n  - `pulic static String IsInterned(String str);`\n    - 和上述方法一样,不同的是如果没有找到匹配的字符串\n    - **就会返回`null`,不会将字符串添加到哈希表中.**\n\n垃圾回收器不能回收被`内部哈希表`所引用的字符串. 除非卸载AppDomain或进程终止.否则内部哈希表引用的String对象不能被释放.\n\n(**不要依赖这个行为**)CLR在程序集加载时,默认留用程序集的元数据中描述的所有字面值字符串.\n\n1. CLR的4.5版本上,会忽略编译器的CompilationRelaxations和NoStirngInterning特性和标志.\n2. 以至于CLR会对字面值字符创进行留用.(事实上用NGen.exe编译,CLR4.5版本确实会使用这些特性)\n3. **所以不要依赖这个行为.**\n\n```csharp\n// 不要以字符留用为前提来写代码\n// 即使指定了特性和标志,也可能进行字段留用,\nString s1 = \"Hello\";\nString s2 = \"Hello\";\n// 没进行留用,则2个字符串是不同的堆对象\nConsole.WriteLine(Object.ReferenceEquals(s1,s2)); // 一些特定版本,不进行字段留用,这边就会返回false\n\ns1 = String.Intern(\"Hello\");\ns2 = String.Intern(\"Hello\");\n// 显式调用字段留用之后, 以下输出就保证为true\nConsole.WriteLine(Object.ReferenceEquals(s1,s2));// 显式留用此字符串\n```\n\n## 字符串留用提升性能并减少内存消耗\n\n```csharp\n// 方式一:\n// 不利用字符串留用, 使用Equals忽略语言文化进行比较\n// 将word和String数组中的字符串比较\nprivate static Int32 NumTimesWordApperasEquals(String word, String[] wordlist)\n{\n    Int32 count = 0;\n\n    for (int wordnum = 0; wordnum < wordlist.Length; wordnum++)\n    {\n        // Ordinal序号比较(忽略语言文化)\n        // 比较字符串内的各个单独字符,这个比较可能很慢\n        // wordlist可能含有多个元素引用了含有相同内容的不同String对象,并且不会被垃圾回收掉重复的\n        if (word.Equals(wordlist[wordnum], StringComparison.Ordinal))\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\n// 方式二:\n// 利用字符串留用的机制,使用ReferenceEquals比较\n// 这个方法假定wordlist中的所有数组元素都引用已留用的字符串\nprivate static Int32 NumTimesWordApperasIntern(String word, String[] wordlist)\n{\n    word = String.Intern(word);\n    Int32 count = 0;\n\n    for (int wordnum = 0; wordnum < wordlist.Length; wordnum++)\n    {\n        if (Object.ReferenceEquals(word,wordlist[wordnum]))\n        {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n方式二假定wordlist包含对已留用字符串的引用. 如果字符串出现多次,堆中只有一个String对象. 比较指针就能知道指定单词是否在数组中.\n\n方式二的前提,是对需要留用的字符串进行留用(花费一些时间性能),应用程序总体性能是可能变慢的. 在多次要调用比较wordlist的情况下, **字符串留用是很有用的,但是使用需要谨慎. 这也是C#编译器默认不想启用字符串留用的原因.(虽然编译器应用特性并设置了不进行字符串留用的标志,但是CLR选择忽略这些设置你也没办法.)**\n\n## 字符串池\n\n编译源代码时, 编译器会处理每个字面值字符串, 并在托管模块的元数据中嵌入.\n\n如果同一个字符串在源代码中多次出现,都嵌入元数据会使生成的文件无谓地增大.\n\n为了解决这个,C#编译器只在模块的元数据中只将字符串写入一次,引用该字符串的代码都被修改成引用元数据中的同一个字符串. **编译器能将单个字符的多个实例合并成一个实例,能显著减少模块的大小.**\n\n## 检查字符串中的字符和文本元素\n\n检查字符串中的字符,String类型为此提供了几个属性和方法, 包括Length,Chars(有参属性,C#索引器),IndexOf,Contains,LastIndexOf...\n\n文本元素(抽象字符): 有的抽象Unicode字符是两个码值的组合.\n\n有的Unicode文本元素要求用两个16位值表示,\n- 第一个称为`高位代理项(high surrogate)` U+D800到U+DBFF之间\n- 第二个称为`低位代理项(low surrogate)` U+DC00到U+DFFF之间\n\n**有了代理项,Unicode就能表示100万个以上不同的字符.**\n\n为了正确处理文本元素,应当使用`System.Globalization,StringInfo`类型,\n- 向此类的构造器传递一个字符串\n- 查询`StringInfo`的`LengthTextElements`属性来了解有多少个文本元素.\n- 接着使用`StringInfo`的`SubstringByTextElements`方法来提取所有的文本元素.\n\n`StringInfo`的静态方法`GetTextElementEnumerator`返回`TextElementEnumerator`对象,允许枚举字符串中包含的所有抽象Unicode字符.\n\n`StringInfo`的静态方法`ParseCombiningCharacers`来返回一个Int32数组.从数组长度就能知道字符串包含多少个文本元素,每个数组元素都是一个文本元素的起始码值索引.\n\n\n![](14字符字符串和文本处理/StringInfo类的使用方式.png)\n\n![](14字符字符串和文本处理/StringInfo类例子输出.png)\n\n## 其他字符串操作\n\n![](14字符字符串和文本处理/复制字符串的方法.png)\n\nClone返回同一个对象(this)的引用.\n\nCopy返回指定字符串的新副本.引用(指针不同).\n\nSubstring返回代表原始字符串一部分的新字符串.\n\nToString返回对同一个对象(this)的引用.\n\n因为字符串你是不可变的,所以返回的都是新字符串的引用.(除非使用不安全代码)\n\n# 高效率构造字符串\n\n可将`StringBuilder`看成是创建String对象的特殊构造器.\n\n从逻辑上看, `StringBuilder对象`包含一个字段, 该字段引用了由`Char结构`构成的数组.可利用`StringBuilder`的各个成员来操纵该字符数组, 高效率地缩短字符串或更改字符串中的字符.\n\n如果字符串变大了,超过了事先分配的 **数组大小** , StringBuilder会自动分配一个新的,更大的数组, 复制字符,并开始使用新数组. 前一个数组被垃圾回收.\n\n用StringBuilder构造好字符串后, 调用ToString方法既可以将StringBuilder的 **字符数组** 转换成String. 这样会在堆上新建String对象,堆上还有StringBuilder中的字符数组,可以继续处理StringBuilder种的字符数组,再次调用ToString把它转换成另一个String对象.\n\n## 构造StringBuilder对象\n\n大多数语言都不将StringBuilder视为基元类型. 要像构造其他任何非基元类型那样构造StringBuilder对象.\n\nStringBuilder提供了许多构造器. 一些关键概念如下:\n1. **最大容量**\n  1. 一个Int32值,指定了能放到字符串中的最大字符数,默认是Int32.MaxValue(约20亿). 一般不用更改这个值. 有时需要指定较小的最大容量以确保不会创建超出特定长度的字符串,**构造好之后就固定下来了,不能再变.**\n2. **容量**\n  1. 一个Int32值, 指定了StringBuilder维护的字符数组的长度,默认16, 如果事先知道要放入多少,则应该在构造StringBuilder对象时自己设置容量.\n  2. 在向字符数组追加字符时, StringBuilder会检测数组会不会超过设定的容量.如果会,StringBuilder会自动 **倍增容量字段(翻倍).**  旧的数组字符数组复制到新的数组中,随后`原始数组可以被垃圾回收`. **数组动态扩展会损害性能,可以在构造时就设置一个合适的初始容量.**\n3. **字符数组**\n  1. 一个由Char结构构成的数组, 负责维护字符串的字符内容.\n  2. 可以用`StringBuilder的Length属性`来获取已经使用的字符数.\n  3. 在构造时传递一个String来初始化数组.\n  4. 不传递任何字符串,数组中就不包含任何字符,Length为0.\n\n\n## StringBuilder成员\n\nStringBuilder代表可变字符串, 大多数成员都能更改字符数组的内容, 同时不会造成在托管堆上分配新对象.\n\n**分配新对象** 只会在以下两种情况:\n1. 动态构造字符串,其长度超过了设置的容量.\n2. 调用StringBuilder的ToString方法.\n\n![](14字符字符串和文本处理/StringBuilder成员1.png)\n\n![](14字符字符串和文本处理/StringBuilder成员2.png)\n\n\n```csharp\n// 有参属性,索引器\n// IL代码 StringBuilder::get_Chars(int32)\n[IndexerName(\"Chars\")] // 不加这个,默认是 get_Item\npublic char this[int index]\n\n// 用法如同使用数组\nStringBuilder sb = new StringBuilder(\"1234567\");\nConsole.WriteLine(sb[1]);\n```\n\n- `Length` 属性设为0等同于内容重置为空字符串, 还等同于Clear方法.\n- `Append` 在字符数组 **后追加** 一个对象,有必要会进行扩充.\n- `Insert` 在字符数组 **中插入** 一个对象,有必要会进行扩充.\n- `AppendFormat` 在字符数组末尾追加0个或多个对象.\n- `AppendLine` 追加一行中止符或者一个带有中止符的字符串.\n\n>  ’\\0’字符在C#中意味着字符串结束, 后面的字符不显示. `string.Replace('\\0','*')`\n\n- `Equals` **两个StringBuilder对象具有相同最大容量,字符数组容量和字符内存才返回true.**\n\n大多数方法返回的都是对同一个StringBuilder对象的引用.\n\nString类提供的一些方法,StringBuilder类并没有提供对应的方法.\n- ToLower\n- ToUpper\n- EndsWith\n- PadLeft\n- PadRight\n- Trim\n\nStringBuilder提供了更全面的Replace方法,允许替换一部分字符串而不是整个.\n\n```csharp\n\n// 因为StringBuilder提供转换大写的方法,需要用String的方法来中转一下\nStringBuilder sb = new StringBuilder();\n\nsb.AppendFormat(\"Jeffrey Richter\").Replace(\" \", \"-\");\n\n// 推荐使用忽视语言文化的转换\n// 将StringBuilder转成string以便将所有字符串转换成大写\nString s = sb.ToString().ToUpperInvariant();\n\n// 清空StringBuilder,分配新的char数组\nsb.Length = 0;\n\n// 将全部大写的String加载到StringBuilder中执行其他操作\nsb.Append(s).Insert(8, \"Marc-\");\n\n// 再转回String ,向用户显式\ns = sb.ToString();\n\n// 输出: JEFFREY-Marc-RICHTER\nConsole.WriteLine(s);\n```\n\n因为StringBuilder提供转换大写的方法,需要用String的方法来中转一下.\n","tags":["CLR读书笔记"]},{"title":"13接口","url":"/2019/08/08/13接口/","content":"\n# 接口\n\nCLR通过`接口`提供了'缩水版'的多继承.\n\n**`接口`是引用类型**. 实际是对一组方法签名进行统一命名. 这些方法不提供任何实现.类通过指定接口名称来继承接口. **必须显式实现接口方法.**\n\n凡是能使用`具体名称接口类型的实例`的地方, 都能使用`实现了接口的类型的实例`.\n\n# 定义接口\n\n接口对一组方法签名进行了统一命名.\n\n接口能定义:\n- 方法\n- 事件\n- 无参属性\n- 有参属性(索引器)\n\n以上东西本质上都是方法,只是语法上的简化.\n\n但是接口不能定义:\n- 任何构造器方法\n- 任何实例字段\n- 静态方法\n- 静态字段\n- 常量\n- 静态构造器\n\n接口定义可以从另一个或多个接口\"继承\",但这不是严格意义上的继承, 是将其他接口的协定包括到新接口中.\n\n```csharp\n// 接口\"继承\"接口\n// 1. 继承接口ICollection<T>的任何类必须实现 ICollection<T> ,IEnumerable<T>,IEnumerable这3个接口所定义的方法\n// 2. 任何代码在引用对象时,如果实现了ICollection<T>接口,可以认为也实现了IEnumerable<T>,IEnumerable接口\npublic interface ICollection<T> : IEnumerable<T>,IEnumerable\n{...}\n```\n\n\n# 继承接口\n\nC#编译器要求:实现接口的方法标记为`public`\n\nCLR要求:将接口方法标记`virtual`\n- 如果显式标记为`virtual`,编译器就会将该方法标记为`virtual`(保持它的非密封状态),使派生类能重写它.\n- 如果不显式标记为`virtual`,编译器就会标记为`virtual`和`sealed`, 这会阻止派生类重写接口方法.\n\n派生类不能重写`sealed`的接口方法. 但派生类可以重新继承同一个接口,并为接口方法提供自己的实现.\n\n```csharp\ninternal static class InterfaceReimplementation\n{\n    public static void Go()\n    {\n        /************************* 第一个例子 *************************/\n        Base b = new Base();\n        // 结果显示: \"Base's Dispose\"\n        b.Dispose();\n\n        // 接口类型的变量  IDisposable b; 调用接口方法\n        // 用b的对象的类型来调用Dispose，结果显示: \"Base's Dispose\"\n        ((IDisposable)b).Dispose();\n\n        /************************* 第二个例子 ************************/\n        Derived d = new Derived();\n        // 结果显示: \"Derived's Dispose\"\n        d.Dispose();\n\n        // 用d的对象的类型来调用Dispose，结果显示: \"Derived's Dispose\"\n        ((IDisposable)d).Dispose();\n\n        /************************* 第三个例子 *************************/\n        b = new Derived();\n        // 用b的类型来调用Dispose，结果显示: \"Base's Dispose\"\n        // 因为子类是自己new覆盖父类的方法,并不会修改父类方法的功能\n        // 所以用Base类型的对象去调用dispose会输出Base类的方法\n        b.Dispose();\n        // 用b的对象的类型来调用Dispose，显示: \"Derived's Dispose\"\n        // 转成接口类型后, 基类的方法被隐藏,只有子类的方法\n        // 只要子类实现了接口方法,就会调用实际类型的实现\n        ((IDisposable)b).Dispose();\n\n        /************************* new和override **********************/\n\n        // Base b;\n        b.Test();\n        // 如果 子类实现Test 用new关键字, 则输出: Base Test!\n        // 如果 子类重写Test 用override关键字, 则输出: Dervied Test!\n\n    }\n}\n// 这个类型派生自 Object 并且实现了 IDisposable\ninternal class Base : IDisposable\n{\n    // 这个方法是隐式密封的，不能被重写\n    // 没标记virtual实现接口方法,是不能被子类重写的\n    public void Dispose()\n    {\n        Console.WriteLine(\"Base's Dispose\");\n    }\n    // 基类的方法\n    public virtual void Test()\n    {\n        Console.WriteLine(\"Base Test!\");\n    }\n}\n// 这个类继承了Base并且实现了IDisposable接口\n// 派生类可以重新继承同一个接口,并为接口方法提供自己的实现.  \n// new 是覆盖,不会改变父类方法的功能\ninternal class Derived : Base, IDisposable\n{\n    // 这个方法不能重写 Base's Dispose.\n    // 'new' 关键字表明重新实现了IDisposable的Dispose\n    new public void Dispose()\n    {\n        Console.WriteLine(\"Derived's Dispose\");\n\n        // 注意: 下一行展示了如何让调用基类的方法\n        // base.Dispose();\n    }\n\n    public new void Test()\n    {\n        Console.WriteLine(\"Dervied Test!\");\n    }\n}\n```\n\n> override: 重写:会重写基类的方法,如果子类转基类,用基类对象去调用也会执行子类的实现\n> new: 覆盖(隐藏):不会改变父类方法的功能,并隐藏基类的方法,如果子类转基类,用基类对象去调用会执行基类的实现.(不会判断实际的类型,只会从当前对象类型去调用)\n\n**转型`接口变量`调用接口方法和用`类的实例`调用接口方法是不同的.**\n\n1. 基类继承接口, 子类如果要实现接口方法需要加`new`.\n2. 用`类的实例`去调用(new)接口方法时,会执行`当前类型`的接口方法,不会去判断`实际类型`.\n3. 转成`接口变量`,去调用接口方法,会根据`实际类型`,如果`实际类型(子类)实现了接口方法`,就会`隐藏基类实现的接口方法`.调用`实际(子类)类型`的实现.\n\n\n# 关于调用接口方法的更多探讨\n\nCLR允许定义`接口类型`的`字段`,`参数`或`局部变量`.\n\n使用接口类型的变量可以调用该接口定义的方法.并且还可以调用Object定义的方法.\n\n但是 **不能** 用接口变量调用类本身定义的公共方法.\n\n> 值类型可实现0个或多个接口,但是值类型的实例转换为接口类型时必须装箱.因为接口变量是引用.\n\n\n# 隐式和显式接口方法实现(幕后发生的事情)\n\n\n  类型加载到CLR中时，会为该类型创建并初始化一个方法表。在这个方法表中，类型引入的每个新方法都有对应的记录项；另外，还为该类型继承的所有虚方法添加了记录项目。继承的虚方法既有继承层次结构中的各个基类型定义的，也有接口类型定义的。\n\n```csharp\ninterter sealed class SimpleType : IDisposable {\n    public void Dispose() { console.WriteLine(\"Dispose\"); }\n}\n```\n\n**接口方法签名和新增方法签名(相同的参数和返回类型)一致, 如果标记为`virtual`,C#编译器仍然会认为该方法匹配接口方法.**\n\nC#编译器将新方法和接口方法匹配起来之后,会生成元数据,指明SimpleType类型的方法表中的两个记录项应该引用同一个实现.\n\n下面的代码演示了如果调用类的`公共Dispose方法`以及如何调用`IDisposable的Dispose方法`在类中的实现：\n\n```csharp\npublic static void Main()\n{\n    SimpleType st = new SimpleType();\n\n    // 调用公共的 Dispose 方法实现\n    st.Dispose();\n\n    // 调用 IDisposable 的 Dispose 方法实现\n    IDisposable d = st;\n    d.Dispose();\n}\n// 输出:\n// Dispose\n// Dispose\n```\n\n- 在第一个dispose方法调用中，调用的是SimpleType定义的dispose方法。\n- 然后定义IDisposable接口类型的变量d，它引用SimpleType对象。\n- 调用SimpleType时，调用的是IDisposable接口的dispose方法。\n- 由于`公共dispose方法`是`IDisposable的Dispose方法`的实现，所以会执行相同的代码。\n\n\n为了看出区别\n```csharp\npublic sealed class SimpleType : IDisposable\n{\n     public void Dispose() { Console.WriteLine(\"public Dispose\"); }\n     // 显示接口方法实现 EIMI\n     // 不允许显示指定可访问性,会正在编译时自动设为private,防止其他类型直接调用\n     // 派生类也不可以调用\n     // 只能由接口类型变量才能调用\n     void IDisposable.Dispose() { Console.WriteLine(\"IDisposable Dispose\"); }\n}\n\n// 这样一下代码就会输出\nst.Dispose();\nIDisposable d = st;\nd.Dispose();\n// public Dispose\n// IDisposable Dispose\n```\n\n**显示接口方法实现EIMI**,\n1. 不能显式指定可访问性, 编译时生成private\n2. 派生类也无法调用\n3. 只有接口类型变量才能调用接口方法\n4. 不能标记virtual,所以不能被重写(这是因为EIMI方法并不是真的是类型的对象模型的一部分),只是将接口和类型连接起来,同时避免公开行为/方法.\n\n\n\n# 泛型接口\n\n泛型接口提供了出色的编译时安全性. 非泛型接口是Object参数,值类型会产生装箱,并且缺少类型安全.\n\n```csharp\nprivate static void SomeMethod1()\n{\n    Int32 x = 1, y = 2;\n    IComparable c = x;\n\n    // CompareTo 期望接口一个 Object 类型; 传递 y (一个 Int32 类型) 允许\n    c.CompareTo(y);     // y在这里装箱\n\n    // CompareTo期望接口一个 Object 类型; 传递 \"2\" (一个 String 类型) 允许\n    // 但运行是抛出 ArgumentException 异常   \n    c.CompareTo(\"2\");\n}\n\n// 修改后\n\nprivate static void SomeMethod2()\n{\n    Int32 x = 1, y = 2;\n    IComparable<Int32> c = x;\n\n    // CompareTo 期望接口一个 Int32 类型; 传递 y (一个 Int32 类型) 允许\n    c.CompareTo(y);     // y在这里不装箱\n\n    // CompareTo 期望接口一个 Int32 类型; 传递 \"2\" (一个 String 类型) 编译不通过\n    // 指出 String 不能被隐式转型为 Int32\n    // c.CompareTo(\"2\");\n}\n```\n\nFCL中有些泛型接口并未实现,而且继承了非泛型接口,如果接口的任何翻翻获取或返回Object,就会失去编译时的类型安全性,而且值类型将发生装箱, 所以利用显示接口方法EIMI实现来增强编译时类型安全性.\n\n泛型接口的好处还有,类可以实现同一个接口若干次,只要每次使用的类型参数不同.\n\n```csharp\npublic static void Go()\n{\n    Number n = new Number();\n\n    // n 与 一个 Int32类型 5 作比较\n    IComparable<Int32> cInt32 = n;\n    Int32 result = cInt32.CompareTo(5);\n\n    //  n 与一个 String类型 \"5\" 作比较\n    IComparable<String> cString = n;\n    result = cString.CompareTo(\"5\");\n}\n\n// 该类实现了 IComparable<T> 接口两次\npublic sealed class Number : IComparable<Int32>, IComparable<String>\n{\n    private Int32 m_val = 5;\n\n    // 该方法实现了 IComparable<Int32>’s CompareTo\n    public Int32 CompareTo(Int32 n)\n    {\n        return m_val.CompareTo(n);\n    }\n\n    // 该方法实现了 IComparable<String>’s CompareTo\n    public Int32 CompareTo(String s)\n    {\n        return m_val.CompareTo(Int32.Parse(s));\n    }\n}\n```\n\n泛型接口还可以标记为`逆变in`和`协变out`,为泛型接口使用提供了更大的灵活性.\n\n> 逆变in: 允许传入参数使用T的基类\n> 协变out:允许输出类型使用T的派生类\n> 逆变参数基类,协变返回子类\n>`delegate Object Method(FileStream fs); // 允许协变和逆变的转换`\n>`String Method2(Stream s); `\n\n# 泛型和接口约束\n\n泛型类型参数约束为多个接口,这样传递的参数必须要实现全部接口约束.\n\n```csharp\npublic sealed class SomeType\n{\n    private static void Test()\n    {\n        Int32 x = 5;\n        Guid g = new Guid();\n        // 对M的调用能通过编译，因为Int32实现了IComparable 和 IConvertible\n        // 不会发生装箱\n        M(x);\n        // 对M的调用能不通过编译，因为Guid实现了IComparable，但没实现了 IConvertible\n        // M(g);\n    }\n\n    // M类型参数T被约束为需要支持同时实现IComparable 和 IConvertible interfaces接口的类型\n    private static Int32 M<T>(T t) where T : IComparable, IConvertible\n    {\n        // ...\n        return 0;\n    }\n\n    // 如果这样声明,x传给M就必须装箱, 接口是引用类型.\n    private static Int32 M<IComparable t>{..}\n}\n```\n\n这很有用,, 如果参数的类型是接口, 那么实参可以是任意类类型,只要该类实现了此接口.\n\n使用多个接口约束,实际上是表示向方法传递的实参必须实现多个接口.\n\n**接口约束还可以减少传递值类型实例时的装箱**,`M(x);`上述代码向M方法传递了x（值类型int实例）。x传给M方法时不会发生装箱。M内部的代码调用t.CompareTo(..),这个调用本身也不会引发装箱,但传给CompareTo的实参可能发生装箱.\n\n**C#编译器为接口约束生成特殊的IL指令,导致直接在值类型上调用接口方法而不装箱,不用接口约束就没办法生成特殊指令. 在值类型调用接口时总是装箱,例外是这个值类型实现了一个接口方法.在值类型的实例上调用这个方法不会造成值类型的实例装箱.**\n\n\n# 实现多个具有相同方法名和签名的接口\n\n\n要定义一个实现了这两个接口的类型，必须使用`显示接口方法实现`来实现这个类型的成员.\n\n```csharp\npublic interface IWindow\n{\n     Object GetMenu();\n}\npublic interface IRestaurant\n{\n     Object GetMenu();\n}\n\n// 这个类型派生自 System.Object and\n// 并不实现 IWindow 和 IRestaurant 接口.\npublic class MarioPizzeria : IWindow, IRestaurant\n{\n    // 这是IWindow 的 GetMenu 方法.\n    Object IWindow.GetMenu()\n    {\n        // ...\n        return null;\n    }\n\n    // 这是 IRestaurant 的 GetMenu 方法.\n    Object IRestaurant.GetMenu()\n    {\n        // ...\n        return null;\n    }\n\n    // 这个GetMenu方法是可选的，与接口无关\n    public Object GetMenu()\n    {\n        // ...\n        return null;\n    }\n}\n```\n\n这个类要实现多个接口的GetMenu方法,所以要告诉编译器每个GetMenu对应的是哪个接口的实现.**在使用使用必须将对象转换为具体的接口才能调用所需的方法.**\n\n```csharp\npublic static void Go()\n{\n    MarioPizzeria mp = new MarioPizzeria();\n\n    // 这行调用 MarioPizzeria 的公共 GetMenu 方法\n    mp.GetMenu();\n\n    // 这行调用 MarioPizzeria 的 IWindow.GetMenu 方法\n    IWindow window = mp;\n    window.GetMenu();\n\n    // 这行调用 MarioPizzeria 的 IRestaurant.GetMenu 方法\n    IRestaurant restaurant = mp;\n    restaurant.GetMenu();\n}\n```\n\n# 用显式接口方法实现EIMI来增强编译时类型安全性\n\n因为有些接口不存在泛型版本,或者泛型版本是继承非泛型版本,所以仍需实现非泛型接口.\n\n非泛型接口接收任何System.Object类型的参数或返回System.Object类型的值,这样就会失去编译时的类型安全性,装箱也会发生.\n\n```csharp\n// 这个接口定义了一个方法，该方法接受一个System.Object类型的参数。\n// 可像下面一样实现该接口的一个类型：\npublic interface IComparable {\n      Int32 CompareTo(Objetc other);\n }\n\n// 值类型实现接口\ninternal struct SomeValueType : IComparable\n{\n    private Int32 m_x;\n    public SomeValueType(Int32 x) { m_x = x; }\n    public Int32 CompareTo(Object other)\n    {\n        return (m_x - ((SomeValueType)other).m_x);\n    }\n}\n\n\npublic static void Go()\n{\n   SomeValueType v = new SomeValueType(0);\n   Object o = new Object();\n   Int32 n = v.CompareTo(v);  // 出现装箱,因为参数是Object,V是值类型\n   n = v.CompareTo(o);        // 能通过编译,会InvaidCastException抛出转换异常\n}\n```\n\n为了解决上述代码的装箱问题和类型安全性问题(编译期就能报错,而不是运行时)\n\n```csharp\ninternal struct SomeValueType : IComparable\n{\n     private Int32 m_x;\n     public SomeValueType(Int32 x) { m_x = x; }\n     // 改动: 参数类型换成了SomeValueType,这样就不会发生值类型转Object时发生装箱操作\n     public Int32 CompareTo(SomeValueType other)\n     {\n         // 也不需要强制类型转换的操作\n         return (m_x - other.m_x);\n     }\n     // 因为修改了上面的CompareTo方法, 所以还需要实现接口的公共CompareTo方法来满足接口协定,这就是IComparable.CompareTo方法的作用\n     // 注意: 这个是显示实现接口EIMI  没有指定public或者private的可访问性\n     Int32 IComparable.CompareTo(Object other)\n     {\n        return CompareTo((SomeValueType)other);\n     }\n}\n```\n\n经过这样修改之后, 就不存在装箱问题,编译时期就能报错,不用在运行时才报,有了类型安全性.\n\n但如果定义接口类型的变量会再次失去编译时的类型安全性,也会发生装箱.(发生2次)\n\n```csharp\npublic static void Go()\n{\n    SomeValueType v = new SomeValueType(0);\n    // 接口类型是引用类型, 值类型赋值会装箱\n    IComparable c = v;              //第一次装箱\n\n    Object o = new Object();\n    // 这里使用的是接口类型变量去调用接口方法IComparable.CompareTo(Object other)\n    // 接口类型变量只能调用接口定义的方法,\n    Int32  n = c.CompareTo(v);       // 第二次发生装箱操作\n    // n = c.CompareTo(o);           // 运行时InvalidCastException异常           \n}\n```\n\n**实现IConvertible， ICollection，IList和IDictionary等接口时，可利用EIMI为这些接口的方法创建类型安全的版本，并减少值类型的装箱。**\n\n# 谨慎使用显式接口方法实现\n\n使用EIMI也可能造成一些严重后果，所以应该尽量避免使用EIMI。幸好，泛型接口可帮助我们在大多数时候避免使用EIMI。但有时，比如实现具有相同名称和签名的两个接口方法时，仍需要它们。\n\nEIMI最主要的问题如下：\n- 没有文档解释一个类型具体如何实现一个EIMI方法，也没有vs的智能感知。\n- 值类型的实例在转型为接口时装箱\n- EIMI不能由派生类调用\n\n\n```csharp\n// 问题1,2\n// 不能直接从一个Int32上调用一个IConvertible接口方法\n// 错误说明:int不包含ToSingle的定义,但是实际上是定义了\n// 必须先转换为IConvertible接口变量,才能调用, 还会装箱,并损害性能\npublic static void Main()\n{\n     int x=5;\n     // 无法编译此句\n     // Single s=x.ToSingle(null);\n\n     // 修改成这样才能编译\n     // 但是这又会发生装箱,浪费内存又损害性能\n     Single s=((IConvertible) x).ToSingle(null);\n\n}\n```\n\n```csharp\n// 问题3\n// 不能由派生类调用\ninternal class Base : IComparable\n{\n    // EIMI 显示接口方法实现\n    // 此方法只能通过IComparable接口类型变量来调用\n    int IComparable.CompareTo(object obj)\n    {\n        Console.WriteLine(\"Base's CompareTo\");\n        return 0;\n    }\n}\n\ninternal sealed class Derived : Base, IComparable\n{\n    public int CompareTo(object obj)\n    {\n        Console.WriteLine(\"Derived's CompareTo\");\n\n        // 情况一\n        // 试图调用基类的EIMI导致编译错误\n        // error CS0117: Base不包含CompareTo的定义\n        // base.CompareTo(obj);\n\n        // 情况二, 修改情况一\n        // 试图调用基类的EIMI导致无穷递归\n        // 通过接口变量调用接口方法, 会根据实际类型,调用到Derived的CompareTo\n        // 就产生无限递归\n        // 解决的方法是 internal sealed class Derived : Base { } 去掉IComparable接口定义\n        IComparable c = this;\n        c.CompareTo(obj);\n\n        return 0;\n    }\n}\n```\n为了解决问题3中情况二,这样的解决方式有时不能因为想在派生类中实现接口方法就将接口从类型中删除,正确定义Base类和Derived类的代码如下:\n\n```csharp\n// 用于解决 调用基类的接口方法\n// 在基类中定义个用于派生类的虚方法,\n// 这样 如果用接口类型变量就能访问到 基类的CompareTo方法,并且不会产生无限递归\ninternal static class Program\n{\n    public static void Main()\n    {\n        Base b = new Base();\n        Derived d = new Derived();\n\n        IComparable c = d;\n        // 输出\n        // Derived's CompareTo\n        // Base's virtual CompareTo\n        d.CompareTo(b);\n    }\n}\n\n\ninternal class Base : IComparable\n{\n    // EIMI 显示接口方法实现\n    Int32 IComparable.CompareTo(object obj)\n    {\n        Console.WriteLine(\"Base's CompareTo\");\n        // 调用虚方法\n        return CompareTo(obj);\n    }\n\n    // 用于派生类的虚方法(名字可以任意)\n    public virtual Int32 CompareTo(Object o)\n    {\n        Console.WriteLine(\"Base's virtual CompareTo\");\n        return 0;\n    }\n}\n\ninternal sealed class Derived : Base, IComparable\n{\n    // 公共方法,也是接口的实现\n    public override Int32 CompareTo(object obj)\n    {\n        Console.WriteLine(\"Derived's CompareTo\");\n        // 现在可以调用基类的虚接口方法\n        return base.CompareTo(obj);\n    }\n}\n```\n\nEIMI在某些情况下确实有用,但是应该 **尽量避免使用**,这样导致类型变得很不好用.\n\n# 设计:基类还是接口\n\n\n选择基类还是接口的指导性原则:\n\n- **`IS-A` vs. `CAN-DO`关系**\n\n类型 **只能继承一个实现**。如果派生类型和基类型不能建立起`is–a`关系，就不用基类而用接口。接口意味着`Can-do`关系。如果多种对象类型都能做某事，就为它们创建接口。\n\n例如，一个类型能将自己的实例转换为另一个类型（IConvertible），一个类型能序列化自己的实例(ISerializable)。注意，值类型必须从system.valueType派生，所以不能从一个任意的基类派生。这时必须使用`can-do`关系并定义接口。\n\n- **易用性**\n\n对于开发人员，定义从基类派生的新类型通常比实现接口的所有方法容易得多。基类可提供大量功能，所以派生类型可能只需要稍微改动。而提供接口的话，新类型必须实现所有成员。\n\n- **一致性的实现**\n\n无论接口协定订立得有多好，都无法保证所有人百分之百正确实现它。事实上，com颇受该问题之累。而如果为基类型提供良好的默认实现，那么一开始得到的就是能正常工作并经过良好测试的类型。以后根据需要修改就可以了。\n\n- **版本控制**\n\n向基类型添加一个方法，派生类将继承新方法。一开始使用就是一个能正常工作的类型，用户的源代码甚至不需要编译。向接口添加一个新成员，会强迫接口的实现者更改其源代码。\n\n最后要指出的是，这两件事情实际上是可以同时做：**定义一个接口，同时提供一个实现了这个接口的基类。**\n\n\nFCL中涉及数据流处理的类采用的是实现继承方法。system.IO.Stream是抽象基类，提供了包括read和write在内的一组方法。其他类（filestream，memoryStream和NetWorkStream等）都从stream派生。在这三个类中，每一个和stream类都是`is–a`关系，这使得具体类的实现变得更容易。\n\n相反，Microsoft采用基于接口的方式设计FCL中的集合。 FCL定义了`IComparer<in T>接口`,还提供了`抽象基类Compare<T>`,它实现了该接口,同时为非泛型`IComparer`的`Compare方法`提供了默认实现. 接口定义和基类同时存在带来了很大的灵活性.\n","tags":["CLR读书笔记"]},{"title":"12泛型","url":"/2019/08/05/12泛型/","content":"\n# 泛型\n\n**泛型** 支持另一种形式的代码重用,即 **算法重用**.\n\n定义算法的开发人员不设定该算法要`操作的数据类型`, 该算法可广泛的应用于不同类型的对象.\n\n## 泛型有两种表现形式:泛型类型和泛型方法。\n\n\n\nCLR允许创建:\n- 泛型引用类型\n- 泛型值类型\n- 泛型接口\n- 泛型委托\n\n不允许创建`泛型枚举类型`.\n\nCLR也允许在引用类型,值类型和接口中`定义泛型方法`.\n\n# 泛型的写法\n\n例如泛型类`List`类, 在类名后添加一个`<T>`, 表名它操作的是一个未指定的数据类型.\n\n定义泛型类或方法时, 为类型指定的任何变量(比如T),都称为`类型参数`. T是变量名,源代码能使用数据类型的任何地方都能使用T.\n\n> 命名规则: 泛型参数变量要么称为T, 要么以大写T开头(TKey,TValue) , 类似I代表接口一样.T代表类型Type.\n\n## 使用泛型\n\n```csharp\nprivate static void SomeMethod()\n{\n  // 构造一个List来操作DateTime对象\n  List<DateTime> dtList = new List<DateTime>();\n\n  dtList.Add(DateTime.Now); //不进行装箱, 值类型\n\n  dtList.Add(\"1/1/2004\");   // 编译时错误,检查类型\n\n  DateTime dt = dtList[0];  // 不需要转型\n}\n```\n\n# 使用泛型的优势\n\n1. 源代码保护\n  1. 不需要使用泛型算法的开发人员访问算法的源代码\n2. 类型安全\n  1. 将泛型算法应用于具体的类型时,编译器和CLR能保证只有与指定类型兼容的对象才能用于算法.否则编译时报错.\n3. 更清晰的代码\n  1. 由于编译器强制类型安全, 所以减少了类型强制转换次数.`DateTime dt = dtList[0];`\n4. 更佳的性能\n  1. 值类型能以传值的形式传递,不需要执行任何装箱操作.CLR无需验证这种转型是否类型安全,提高了代码的运行速度.\n\n# 比较泛型和非泛型算法的性能\n\n```csharp\npublic static class Generics\n{\n    public static void Main()\n    {\n        Performance.ValueTypePerfTest();\n        Performance.ReferenceTypePerfTest();\n    }\n}\ninternal static class Performance\n{\n    // 值类型的泛型类和非泛型类性能测试\n    public static void ValueTypePerfTest()\n    {\n        const Int32 count = 100000000;\n\n        // 泛型类List<Int32>性能测试\n        // 运行性能计时器, 在using代码块结束后会DisPose停止计时\n        using (new OperationTimer(\"List<Int32>\"))\n        {\n            List<Int32> l = new List<Int32>();\n            for (Int32 n = 0; n < count; n++)\n            {\n                l.Add(n);       // 不发生装箱\n                Int32 x = l[n]; // 不发生拆箱\n            }\n            l = null; // 使引用为null,确保进行垃圾回收\n        }\n        // 非泛型类ArrayList<Int32>性能测试\n        // 运行性能计时器, 在using代码块结束后会DisPose停止计时\n        using (new OperationTimer(\"ArrayList of Int32\"))\n        {\n            ArrayList a = new ArrayList();\n            for (Int32 n = 0; n < count; n++)\n            {\n                a.Add(n);               // 装箱\n                Int32 x = (Int32) a[n]; // 拆箱\n            }\n            a = null; // 使引用为null,确保进行垃圾回收\n        }\n    }\n    // 引用类型的非泛型和泛型性能测试\n    public static void ReferenceTypePerfTest()\n    {\n        const Int32 count = 100000000;\n\n        using (new OperationTimer(\"List<String>\"))\n        {\n            List<String> l = new List<String>();\n            for (Int32 n = 0; n < count; n++)\n            {\n                // 字符串\n                l.Add(\"X\");      // Reference copy\n                String x = l[n]; // Reference copy\n            }\n            l = null; // Make sure this gets GC'd\n        }\n\n        using (new OperationTimer(\"ArrayList of String\"))\n        {\n            ArrayList a = new ArrayList();\n            for (Int32 n = 0; n < count; n++)\n            {\n                // 字符串\n                a.Add(\"X\");               // Reference copy\n                String x = (String) a[n]; // Cast check & reference copy\n            }\n            a = null; // Make sure this gets GC'd\n        }\n    }\n\n    // 用于运行时性能计时\n    private sealed class OperationTimer : IDisposable\n    {\n        private Stopwatch m_stopwatch;\n        private String    m_text;\n        private Int32     m_collectionCount;\n\n        public OperationTimer(String text)\n        {\n            PrepareForOperation();\n\n            m_text            = text;\n            m_collectionCount = GC.CollectionCount(0);\n\n            // This should be the last statement in this\n            // method to keep timing as accurate as possible\n            m_stopwatch = Stopwatch.StartNew();\n        }\n\n        // 在using代码块结束后会Dispose会执行\n        public void Dispose()\n        {\n            Console.WriteLine(\"{0} (GCs={1,3}) {2}\",\n                (m_stopwatch.Elapsed),\n                GC.CollectionCount(0) - m_collectionCount, m_text);\n        }\n\n        // 强制垃圾回收器执行\n        private static void PrepareForOperation()\n        {\n            // 首先 GC.Collect(); 并不会立即去回收 只是告诉回收器 去回收\n            // 垃圾收集器在一次垃圾收集过程中,垃圾收集器的逻辑不能保证所有未引用的对象都从堆中删除\n\n            // 我们可以显式调用 GC.Collect();GC.WaitForPendingFinalizers();\n            // 这两行代码进行强制回收的执行\n            GC.Collect();\n            // 挂起当前线程，直到处理终结器队列的线程清空该队列为止。\n            GC.WaitForPendingFinalizers();\n            GC.Collect();\n        }\n    }\n}\n// 00:00:00.6625861 (GCs=  6) List<Int32>\n// 00:00:05.5150908 (GCs=388) ArrayList of Int32\n// 00:00:01.1244509 (GCs=  1) List<String>\n// 00:00:01.2407716 (GCs=  0) ArrayList of String\n```\n\n\n\n结果表明:\n1. 泛型List算法比非泛型ArrayList算法快得多.\n2. ArrayList会造成大量装箱,要进行频繁的垃圾回收\n3. 引用类型则区别不大\n\n> 首次为特定的数据类型调用方法时,CLR都会为这个方法生成本机代码.\n\n\n# FCL中的泛型\n\n泛型最明显的应用是集合类. Microsoft建议使用泛型集合类,不建议使用非泛型集合类.常用的接口包含在Sysytem.Collections.Generic命名空间中。\n\n`System.Array`类(即所有数组的基类)提供了大量静态泛型方法，比如，AsReadonly、FindAll、Find、FindIndex等。\n\n集合类实现了许多接口,放入集合中的对象`可实现接口`来执行排序和搜索等操作.\n\n# 泛型基础结构\n\n## CLR内部如何处理泛型\n\nCLR会为应用程序的各种类型创建称为`类型对象`的内部数据结构. 泛型类型参数仍然是类型,CLR同样会创建内部数据结构.(包括 引用类型(类),值类型(结构), 接口类型和委托类型).\n\n具有`泛型参数`的类型称为`开放类型`. **CLR禁止构造开放类型的任何实例.** 类似于禁止构造接口类型实例.\n\n代码`引用泛型类型`时,为所有类型参数传递了实际的数据类型,类型就成为`封闭类型`, CLR允许创建封闭类型的实例.如果在引用泛型类型时,留下一些泛型类型 **实参未指定**,CLR就会创建开放类型对象,而且不能创建该类型的实例.\n\n```csharp\n// 定义一个部分指定的开放类型\ninternal sealed class DictonaryStringKey<TValue> : Dictionary<String, TValue>\n{\n}\n\nstatic void Main(string[] args)\n{\n    Object o = null;\n\n    // Dictionary<,>有2个泛型参数,是开放类型,不允许创建实例\n    Type t = typeof(Dictionary<,>);\n    // 在运行时抛出异常, 创建失败\n    o = CreateInstance(t);\n\n    // DictonaryStringKey<>,有一个泛型参数没指定,所以是开放类型\n    t = typeof(DictonaryStringKey<>);\n    // 在运行时抛出异常, 创建失败\n    o = CreateInstance(t);\n\n    // 传入了确定的类型,就是封闭类型\n    t = typeof(DictonaryStringKey<Guid>);\n    // 创建成功\n    o = CreateInstance(t);\n\n    Console.WriteLine(o.GetType());\n}\n\nprivate static Object CreateInstance(Type t)\n{\n    Object o = null;\n    try\n    {\n        o = Activator.CreateInstance(t);\n        Console.WriteLine($\"已创建{t.ToString()}的实例.\");\n    }\n    catch (ArgumentException e)\n    {\n        Console.WriteLine(e.Message);\n    }\n    return o;\n}\n// 输出:\n// Cannot create an instance of System.Collections.Generic.Dictionary`2[TKey,TValue] because Type.ContainsGenericParameters is true.\n// Cannot create an instance of DictonaryStringKey`1[TValue] because Type.ContainsGenericParameters is true.\n// 已创建DictonaryStringKey`1[System.Guid]的实例.\n// DictonaryStringKey`1[System.Guid]\n```\n\n如上代码, Activator.CreateInstance在运行时试图构造开放类型的实例时,会抛出ArgumentException异常,并指明泛型参数.\n\n类型名以 `单引号+数字 `结尾, 数字代表类型的元数,也就是要求的参数个数,Dictionary类的元数是2, 要求`[TKey,TValue]` . `DictonaryStringKey`要求一个`[TValue]`, 指定元数的具体类型.\n\n- CLR会在类型对象内部分配`类型的静态字段`( 非静态的字段是实例的,这里是类型字段,回顾第四章 )\n- 每个封闭类型都有自己的静态字段\n  - 换言之:`List<T>`中定义了任何静态字段,不会在`List<A>`和`List<B>`之间共享.\n- 如果定义了泛型类的`静态构造器`,那针对每个封闭类类,构造器都会执行一次.\n  - **泛型静态构造器目的是保证传递的类型参数满足特定条件**.\n\n```csharp\ninternal sealed class MyClass<T>\n{\n    // 静态类型构造器\n    static MyClass()\n    {\n        // 这样定义只能处理枚举类型的泛型类型\n        // CLR提供了约束的功能, 可以更好的指定有效的类型实参,\n        // 但是约束无法将类型实参限制为仅枚举类型. 由于这个原因,\n        // 所以需要用静态构构造器来保证类型是一个枚举类型\n        if (!typeof(T).IsEnum)\n        {\n            throw new ArgumentException(\"T must be an Enum \");\n        }\n    }\n    // 实例构造器\n    public MyClass()\n    {\n    }\n}\n```\n\n\n## 泛型类型和继承\n\n使用泛型类型并指定类型的实参时,实际是在CLR中定义一个`新的类型对象`, `新的类型对象`从泛型类型派生自的那个类型派生.\n- `List<T>`从`Object`派生,`List<String>`和`List<Guid>`也从`Objcet`派生.\n- `DictonaryStringKey<TValue>`从`Dictionary<String, TValue>`派生, 那么`DictonaryStringKey<Guid>`是从`Dictonary<String, Guid>`派生.\n\n**指定类型实参不影响继承层次结构.** 需要判断强制类型转换是否是允许的.\n\n定义一个如下链表节点类:\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 传入构造函数需要的参数\n    Node<Char> head = new Node<Char>('C');\n    head = new Node<char>('B',head);\n    head = new Node<char>('A',head);\n    Console.WriteLine(head.ToString());// 输出ABC\n}\n// 链表节点类\ninternal sealed class Node<T>\n{\n    public T m_data;\n    public Node<T>  m_next;\n\n    public Node(T mData, Node<T> mNext)\n    {\n        m_data = mData;\n        m_next = mNext;\n    }\n    // 单参数构造函数,会通过this指针调用Node(T mData, Node<T> mNext)构造函数\n    public Node(T mData) : this(mData,null)\n    {\n    }\n    public override string ToString()\n    {\n        return m_data.ToString() + ((m_next != null) ? m_next.ToString() : String.Empty);\n    }\n}\n```\n\n在这个Node类中,对于m_next字段引用的另一个节点来说, m_data字段必须包含相同的数据类型, 例如不能一个包含Char,一个包含String,一个包含DataTime.  如果全部用`Node<Object>`,会失去编译时的类型安全性,值类型会被装箱.  \n\n很好的办法是定义`非泛型Node基类.` 再定义`泛型TypedNode类`(用`Node类`作为基类). 这样就可以创建一个链表,每个节点都可以是一种具体的数据类型(不能是Object),并防止了值类型装箱.\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 传入构造函数需要的参数\n    Node head = new TypeNode<Char>('.');\n    head = new TypeNode<DateTime>(DateTime.Now,head);\n    head = new TypeNode<String>(\"Today is \",head);\n    Console.WriteLine(head.ToString());// Today is 2019/8/5 18:06:43.\n}\n\n// 非泛型Node基类\ninternal class Node\n{\n    protected Node m_next;\n\n    public Node(Node mNext)\n    {\n        m_next = mNext;\n    }\n}\n\n// 链表节点类\ninternal sealed class TypeNode<T> : Node\n{\n    public T m_data;\n\n    // 基类没有无参构造函数,派生类要显式调用基类的\n    public TypeNode(T mData, Node mNext) : base(mNext)\n    {\n        m_data = mData;\n    }\n    // 使用单个参数构造函数用this调用TypeNode(T mData, Node mNext),\n    public TypeNode(T mData) : this(mData,null)\n    {\n    }\n    public override string ToString()\n    {\n        return m_data.ToString() + ((m_next != null) ? m_next.ToString() : String.Empty);\n    }\n}\n```\n\n## 泛型类型的同一性\n\n有些开发人员为了简化如下代码:\n\n```csharp\n// 因为源代码中大量<>符号有损可读性\nList<DateTime> dt1 = new ListList<DateTime>();\n\n// 定义个新的非泛型类,从泛型类型派生\n// 这样就只是为了简化代码没有了<>符号\ninternal sealed class DateTimeList : List<DateTime>\n{\n  //这里不用写任何代码\n}\n\n// false\nBoolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));\n```\n\n上述代码会失去类型的`同一性`和`相等性`. 如果方法原型需要的是`DateTimeList`类型参数,那么`List<DateTime>`类型就不能传递给它\n\n\n所以C#允许使用简化语法来引用泛型封闭类型,同时不影响类型的相等性. 就是在源文件顶部使用传统的`using`指令.\n\n```csharp\n// 用using指令定义DateTimeList符号.\n// 代码编译时, 所有DateTimeList替换成System.Collections.Generic.List<System.DateTime>\nusing DateTimeList = System.Collections.Generic.List<System.DateTime>;\n\n// true\nBoolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));\n\n// 还可以用var\nvar dt1 =new List<DateTime>();\n```\n\n## 代码爆炸\n\n使用泛型类型参数的方法进行JIT编译时,CLR获取方法的IL, 用指定的类型实参替换, 然后创建恰当的本机代码(这些代码是为指定数据类型量身定制). 这样CLR要为`每种不同的方法/类型组合`生成`本机代码`. 称为 **代码爆炸**.\n\nCLR的优化措施:\n\n1. **假如特性的类型实参调用了一个方法, 以后再用相同的类型实参调用这个方法,CLR只会为这`个方法/类型组合`编译一次代码.** 例如:一个程序集中使用`List<DateTime>`,另一个程序集加载到同一个AppDomain也使用`List<DateTime>`,CLR只编译一次`List<DateTime>`.\n\n2. **CLR认为所有引用类型实参都完全相同,所以代码能够共享.** 因为任何引用类型的实参或变量实际上只是指向堆上对象的指针(32位系统是32位指针,64位系统是64位指针). 所有的对象指针都以相同方式操作. 例如 List<String>编译的代码可直接用于List<Stream>的方法.\n\n3. 值类型就不能,CLR必须专门为那个值类型生成本机代码. 因为值类型的大小不定.即使值类型大小一样,仍然无法共享(Int32和UInt32都是32位). 要用不同的本机CPU指令来操纵这些值.\n\n\n# 泛型接口\n\n泛型的主要作用是定义泛型的引用类型和值类型.\n\n但是,对泛型接口的支持对CLR也很重要. 没有泛型接口,每次用非泛型接口(如`IComparable`)来操纵值类型都会发生装箱.\n\n```csharp\n// 这个泛型接口定义是FCL的一部分\npublic interface IEnumerator<T> : IDisposable, IEnumerator\n{\n  // 实现接口的需要有此属性\n  T Current {get {...}}\n}\n// 实现了泛型接口, 保持类型实参的未指定状态\ninternal sealed class ArrayEnumrator<T> : IEnumerator<T>\n{\n  private T[] m_array;\n  // IEnumerator<T>的Current是T类型.\n  public T Current { get { ... }  }\n}\n```\n\n# 泛型委托\n\nCLR支持泛型委托, 目的是保证任何类型的对象都能以类型安全的方式传给回调方法.\n\n泛型委托运行值类型实例在传给回调方法时不进行任何装箱.\n\n委托实际只是提供了4个方法的一个类定义.\n1. 构造器\n2. Invoke方法\n3. BeginInvoke方法\n4. EndInvoke方法\n\n**尽量使用FCL预定义的泛型Action和Func委托.**\n\n\n# 委托和接口的逆变和协变泛型类型实参\n\n协变性: 指定`返回类型`的兼容性.\n\n逆变性: 指定`参数`的兼容性.\n\n委托的每个泛型类型参数都可标记为协变量和逆变量.\n\n泛型类型参数形式:\n1. `不变量`: 泛型类型参数不能更改.\n2. `逆变量`: 泛型类型参数可以从一个类更改为它的某个`派生类`.  在C#中用`in`关键字标记.\n  1. 逆变量泛型类型参数只出现在输入位置,比如方法的参数.\n3. `协变量`: 泛型类参数可以从一个类更改为它的某个`基类`.  在C#中用`out`关键字标记.\n  1. 协变量泛型类型参数只能出现在输出位置,比如作为方法的返回类型.\n\n> 方便记忆: in(里面,内部,子类) 参数类型允许它的子类; out(外面,外部,基类) 返回类型允许它的基类.\n\n```csharp\n// 委托定义\n// in T 逆变量, out TResult协变量\npublic delegate TResult Func<in T, out TResult>(T arg);\n\n// 如果像这样声明一个变量\nFunc<Object, ArgumentException> fn1 = null;\n//    子类       基类\n//     ↓          ↓\n// 可以转型为另一个泛型类型参数不同的Func类型\nFunc<String, Exception> fn2 = fn1; // 不需要显式转型\nException e = fn2(\"\");\n```\n\nfn1 变量引用了一个方法, 获取一个Object, 返回一个ArgumentException.\n\nfn2 变量引用另一个方法, 获取String, 返回Exception\n\n因为`in逆变量`,`String`是从`Object`派生, 并且 `out协变量`, `Exception` 是`ArgumentException`的基类,上述代码能正确编译, 而且编译时能维持类型的安全性.\n\n由于需要装箱,所以值类型不具有这种可变性,\n\n```csharp\n// 不能再调用它时传递List<Datetime>\n// 虽然Datetime派生自Object\n// 但是Datetime值类型和Object之间不存在引用转换\n// 此外, 此方法最大的好处,JIT编译得到的代码只有一个版本\nvoid Test(IEnumerable<Object> collection) { ... }\n\n// 为了解决上面问题,可以这样声明\n// 这样写,只有在T类型是引用类型的前提下,才能共享同一个版本的JIT编译代码\n// 每个值类型都有一份不同的JIT编译代码\n// 起码能传递值类型\nvoid Test<T>(IEnumerable<T> collection) { ... }\n\n// 编译不通过, 无效的可变性,T 必须是不变量, 当前T为逆变.\n// delegate void SomeDelegate<in T>(ref T t);\n\n```\n\n**注意: 不能将`可变性(in/out)`泛型类型参数传给使用了out/ref关键字的方法. 必须是不变量**\n\n使用 要 **获取泛型参数和返回值** 的`委托`时, 尽量为逆变性参数和协变性返回值指定in和out关键字,这样做不会有不良反应,使委托能在更多的情形中使用.\n\n要使用 具有 **泛型类型参数** 的`接口`也尽量为逆变性参数和协变性返回值指定in和out关键字.\n\n```csharp\n// T可接受\npublic interface IEnumerator<in T> : IEnumerator\n{\n  Boolean MoveNext();\n  T Current{ get; }\n}\n\n// 定义一个方法,接受任意引用类型的一个IEnumerator\nInt32 Count(IEnumerator<Object> col) { ... }\n\n// 以下调用Count,传递IEnumerator<String>\n// 因为T是逆变量,String是Object的子类,所以编译没问题,可以顺利运行\nInt32 c = Count(new[] {\"Grant\"});\n\n```\n\n\n**在声明泛型类型参数时,必须由你显式使用`in/out`来标记可变性.** 这样防止以后修改类型参数时,用法与声明不符的地方编译器就会报错,提醒你违反了自己订立的协定.\n\n# 泛型方法\n\n定义泛型类,结构和接口时, 类型中定义的任何方法都可引用类型指定的类型参数. 类型参数可作为方法参数,方法返回值或方法内部定义的局部变量的类型使用.\n\nCLR还允许方法指定它自己的类型参数.\n\n```csharp\nstatic void Main(string[] args)\n{\n\n    GenericType<String> gt = new GenericType<string>(\"123\");\n    // 123 : System.Int32\n    Console.WriteLine($\"{gt.Converter<Int32>()} : {gt.Converter<Int32>().GetType()}\");\n\n}\n\n// 定义了类型参数T\ninternal sealed class GenericType<T>\n{\n    private T m_value;\n\n    public GenericType(T mValue)\n    {\n        m_value = mValue;\n    }\n    // 定义了自己的类型参数TOutput\n    // Converter方法能将m_value字段引用的对象转换成任意类型(TOutput).取决于调用时传递的TOutput参数\n    public TOutput Converter<TOutput>()\n    {\n        TOutput result = (TOutput) Convert.ChangeType(m_value, typeof(TOutput));\n        // 返回类型转换之后的结果\n        return result;\n    }\n}\n```\n\nConverter方法能将m_value字段引用的对象转换成任意类型(TOutput).取决于调用时传递的TOutput参数.\n\n```csharp\n// ref关键字标记参数,o1,o2必须先初始化,方法内能读写\n// out关键字标记 则不必需初始化,不能读取,在返回前必须写入\nprivate static void Swap<T>(ref T o1, ref T o2)\n{\n    T temp = o1;\n    o1 = o2;\n    o2 = o1;\n}\n\n// 这样调用Swap\nInt32 n1 = 1, n2 = 2l;\nSwap<Int32>(ref n1,ref n2);\n```\n\n**有ref/out参数的泛型方法, 实参传递的变量必须和方法参数相同的类型** , 不允许用可变性来标识参数,以防损害类型安全性.\n\n## 泛型方法和类型推断\n\nC#编译器支持在调用泛型方法时进行`类型推断`.(就是省略<>).\n\n```csharp\nprivate static vod Test()\n{\n  Int32 n1 = 1, n2 = 2;\n  // 编译器会推断n1,n2的类型,最后调用Swap<Int32>\n  Swap(ref n1, ref n2);\n\n  // 重要说明: C#使用的是变量的数据类型, 而不是变量引用对象的实际类型\n  String s1 = \"A\";\n  Object s2 = \"B\";\n  // 编译出错, 因为编译器无法推断用哪个传递的类型\n  // 编译器发现s1是String , s2是Object(不是String )\n  // Swap(ref s1, ref s2);\n}\n```\n\n类型可以定义多个方法,一个接受具体类型,另一个接受泛型类型.\n\n```csharp\nprivate static void Display(String s)\n{\n  Console.WriteLine(s);\n}\nprivate static void Display<T>(T t)\n{\n  // 调用Display(String)\n  Display(t.ToString());\n}\n\n// 调用的方式\n// 2个方法都可以被调用,\n// 但是C#编译器优先考虑明确的匹配, 再考虑泛型匹配\nDisplay(\"Jeff\");    // 调用Display(String)\nDisplay(123);       // 调用Display<T>(T)\n// 明确指定了泛型类型实参,告诉编译器不要尝试推断类型实参\n// 所以编译器会毫不犹豫的代用泛型方法\nDisplay<String>(\"AAA\"); // 调用Display<T>(T)\n\n```\n\n**C#编译器优先考虑参数明确的匹配, 再考虑泛型匹配, 如果指定了`<String>`,就调用泛型方法.**\n\n\n# 泛型和其他成员\n\nC#中, 属性,索引器(有参属性),事件,操作符方法,构造器,终结器本身不能有类型参数. 但他们能在泛型类型中定义,这些成员中的代码能使用类型的类型参数.\n\n# 可验证性和约束\n\nCLR支持称为`约束`的机制.\n\n```csharp\nprivate static T Min<T>(T o1,T o2)\n{\n  // 编译错误, 因为不是所有类型都能有ComparableTo方法\n  //if (o1.ComparableTo(o2))\n  {\n    return o1;\n  }\n  return o2;\n}\n\n// 通过限制类型, 可以对那些类型进行更多的操作\n// where关键字告诉编译器,为T指定的任何类型都必须实现IComparable<T>接口\nprivate static T Min<T>(T o1,T o2) where T : IComparable<T>\n{\n  if (o1.ComparableTo(o2))\n  {\n    return o1;\n  }\n  return o2;\n}\n```\n\n约束可以应用于泛型类型的类型参数,也可以用于泛型方法的类型参数(如上面的Min方法).\n\n**CLR不允许基于类型参数名称和约束来进行重载.**\n\n```csharp\n\ninternal sealed class Test<T>{}\n\n// 错误与Test<T>{}类定义冲突\n//internal sealed class Test<T> where T : IComparable<T>{}\n\nprivate static void M<T>();\n\n// 错误与M<T>方法定义冲突\n// private static void M<T> where T : IComparable<T>();\n```\n\n重写虚泛型方法时, 重写的方法必须指定相同数量的类型参数,这些类型参数会 **继承在基类方法上指定的约束**.\n\n**事实上根本不允许为重写方法的类型指定任何约束. 但是类型名称可以更改(T可以改为T1,T2之类),不能指定约束.**\n\n## 主要约束\n\n`T : Class`\n\n类型参数可以指定 **0个或1个** `主要约束` , 主要约束可是代表非密封类的一个引用类型.\n\n不能指定以下特殊类型:\n1. System.Object\n2. System.Array\n3. System.Delegate\n4. System.MulticastDelegate\n5. System.ValueType\n6. System.Enum\n7. System.Void\n\n指定引用类型约束时, 相当于向编译器承诺: **一个指定的类型实参要么是与约束类型相同,要么是从约束类型派生的类型. 如果类型参数没有指定主要约束,就默认为System.Object ,并且不能显式指定.**\n\n### 两个特殊的主要约束 class 和struct\n\n`T : class`\n\n`T : struct`\n\nclass约束是承诺类型实参是`引用类型`.\n  - 任何类,接口类型,委托类型或者数组类型都满足这个约束.\nstruct约束是承诺类型实参是`值类型`.\n  - 包括枚举在内的任何值类型都满足这个约束.\n  - CLR和编译器将任何`System.Nullable<T>`值视为`特殊类型`, 不满足这个struct约束.\n  - 原因是`Nullable<T>`类型将它的类型参数约束为struct,而CLR希望禁止这样的递归类型.\n```csharp\ninternal sealed class Test<T> where T : class\n{\n  public void M()\n  {\n    // 引用类型的变量都能设为null\n    // 值类型的变量不能设置为null\n    T temp = null; //允许,因为T约束为引用类型\n  }\n}\n\ninternal sealed class Test<T> where T : struct\n{\n  public static T Factory()\n  {\n    // 允许,因为所有值类型都隐式有一个公共无参构造器\n    // 如果约束为class, 无法通过编译,因为有的引用类型没有公共的无参构造器.\n    return new T();\n  }\n}\n\n```\n\n> 值类型都有公共的无参构造器. 不允许设置为null\n> 引用类型不一定都有无参构造器,不允许设置为null\n\n## 次要约束\n\n`T : interface`\n\n类型参数可以指定 **0个或多个** `次要约束`, 次要约束代表`接口类型`. 向编译器承诺类型实参实现了接口. 由于能指定多个接口约束,所以类型实参必须实现了所有接口约束.\n\n> 在第13章详细讲 接口约束.\n\n`T : TBase`\n\n还有一种次要约束称为 `类型参数约束`, 也称为 `裸类型约束`. 它允许一个泛型类型或方法规定: 指定的类型实参要么就是约束类型,要么是约束的类型的派生类.  一个类型参数可指定 **0个或多个** `裸类型约束`.\n\n> 意思就是: T 由 TBase 约束, 由类型参数决定约束.  List<T,TBase> where T:TBase\n\n```csharp\n// 指定了两个类型参数\n// T参数 由TBase类型参数约束, T必须兼容于TBase指定的类实参\nprivate static List<TBase> ConvertIList<T, TBase>(IList<T> list) where T : TBase\n{\n    List<TBase> baseList = new List<TBase>(list.Count);\n\n    for (int index = 0; index < list.Count; index++)\n    {\n        baseList.Add(list[index]);\n    }\n    return baseList;\n}\nstatic void Main(string[] args)\n{\n    // 初始化一个List<String> , 它实现了IList<String>\n    List<String> ls = new List<string>();\n    ls.Add(\"A String\");\n\n    // 将IList<String>转成IList<Object>\n    // 编译器检查String是否兼容于Object,由于是派生关系,所以满足约束 T(string) : TBase(Object)\n    IList<Object> lo = ConvertIList<String, Object>(ls);\n\n    // 将IList<String> 转成IList<IComparable>\n    // 编译器检查Strings是否实现了IComparable接口,由于String实现了,所以也满足约束.\n    IList<IComparable> lc = ConvertIList<String, IComparable>(ls);\n\n    // 将IList<String> 转成IList<IComparable<String>>\n    // 由于String实现了接口,所以也满足约束.\n    IList<IComparable<String>> lcs = ConvertIList<String, IComparable<String>>(ls);\n\n    //  IList<String>转成 IList<String>\n    IList<String> ls2 = ConvertIList<String, String>(ls);\n\n    // 错误,不能将IList<String>转 IList<Exception>\n    // String没有隐式引用转换到Exception\n    // IList<Exception> le = ConvertIList<String, Exception>(ls);\n}\n```\n\n\n## 构造器约束\n\n`T : new()`\n\n类型参数可以指定 **0个或1个** `构造器约束`.  它向编译器承诺类型实参是 **实现了公共无参构造器的非抽象类型**. 如果同时和struct约束一起使用,C#编译器会认为这是一个错误,因为是多余的; 所有值类型都隐式提供了公共无参构造器.\n\n```csharp\ninternal sealed class Test<T> where T : new()\n{\n  public static T Factory()\n  {\n    // 允许,因为所有值类型都隐式有一个公共无参构造器\n    // 如果约束为class, 约束也要求它提供公共无参构造器\n    return new T();\n  }\n}\n```\n\n## 其他可验证性问题\n\n几个特殊的代码构造和泛型共同使用时,可能产生不可预期的行为.\n\n1. 泛型类型变量的转型\n\n**不允许将泛型类型转型为其他类型, 除非转型为与约束兼容的类型.**\n\n```csharp\nprivate static void CastGenericType<T>(T obj)\n{\n  // T是任意类型无法保证成功转型\n  // Int32 x = (Int32) obj;   // 错误\n  // String s = (String) obj; // 错误\n\n  // 虽然能通过编译, 但是CLR仍有可能在运行时抛出InvalidCastException异常\n  Int32 x = (Int32) (Object) obj;    // 可能报异常\n  String s1 = (String) (Object) obj; // 可能报异常\n\n  // 转型为引用类型时还可以使用C# as操作符\n  // 使用了as就不会报异常\n  // 值类型不能用as\n  String s2 = obj as String; // 无错误\n}\n\n```\n\n2. 将泛型类型变量设为默认值\n\n`default(T)`\n\n**不允许将泛型类型变量设为`null`, 除非将泛型类型约束成引用类型.**\n\n由于未对T进行约束,所以可能是值类型.\n\n```csharp\nprivate static void SettingDefault<T>()\n{\n  // 编译错误,因为可能是不可以为null的值类型, 考虑改用default(T)\n  // T temp = null;\n\n  // default告诉编译器和CLR的JIT编译器,如果T是引用类型,就将temp设为null\n  // 如果temp是值类型,就将temp的所有位设为0\n  T temp = default(T);\n}\n```\n\n3. 将泛型类型变量与null进行比较\n\n不论泛型类型是否被约束,使用`==`或`!=`操作符将泛型类型与null进行比较都是可以的.\n\n```csharp\n// 由于T类型未进行约束, 所以可能是值类型或引用类型\n// 如果是值类型,obj永远不会为null\n// 如果被约束为struct, C# 编译器会报错,\n// 因为值类型的变量不能与null比较,因为结果始终一样\nprivate static void Compare<T>(T obj)\n{\n  if (obj == null)\n  {\n    // 如果obj是值类型, 这里的代码永远不会执行\n    // JIT编译器不会为此处的代码生成本机代码\n    // 如果 换成!=操作符\n    // 则不会为if (obj != null) 生成本机代码,因为永远为true\n    // 但是大括号内还是会生成\n  }\n}\n```\n\n如果是值类型,obj永远不会为null. 如果被约束为struct, C# 编译器会报错,因为值类型的变量不能与null比较,因为结果始终一样.\n\n4. 两个泛型类型变量比较\n\n如果泛型参数不限定为引用类型,对两个变量进行比较就是非法的.\n\n因为两个值类型的变量互相比较是非法的, 除非值类型重载了`==`操作符.\n\n```csharp\nprivate static void Compare<T>(T o1, T o2)\n{\n  if(o1 == o2) {} // 编译错误\n}\n\n// 对于非`基元值类型的值类型`,C#不知道如何比较,所以编译器会报错.\n//private static void Compare<T>(T o1, T o2) where T : struct\n\n\nprivate static void Compare<T>(T o1, T o2) where T : class\n{\n  if(o1 == o2) {} // 编译成功\n}\n\n```\n\n上述代码如果T约束成class,就能编译通过.\n1. 如果引用相同的对象, `==`操作符就返回`true`.\n2. 如果引用类型重载了`==`, 编译器会生成对`operator==`方法的调用代码\n\n写代码来比较基元值类型,C#编译器能知道生成正确的代码.如果约束为`struct`, 对于非`基元值类型的值类型`,C#不知道如何比较,所以编译器会报错.\n\n\n**不允许将类型参数约束成具体的值类型**, 因为值类型隐式密封,不可能存在从值类型派生的类型.如果支持,那就好比只支持该具体类型, 泛型参数的意义就不存在了.\n\nOnly class or interface could be specified as constraint 只有类或接口可以指定为约束.\n\n`private static void Test<T>(T t) where  T : Int32 // 编译错误`.\n\n\n## 泛型类型变量作为操作数使用\n\n将`操作符`用于`泛型类型的操作数`会出现大量问题. C# 知道如何解释应用于基元类型的操作符(加减乘除), **但是不能将这些操作符应用于泛型类型的变量.**\n\n编译器在编译时确定不了类型, 所以不能向泛型类型的变量应用任何操作符.\n\n因此不可能写出一个能处理任何数值数据类型的算法.\n\n```csharp\n// 尝试写一个能处理任何数据类型的算法\nprivate static T Sum<T>(T num) where T : struct\n{\n    T sum = default(T);\n    // 报错. 运算符< ++ += 无法应用于\"T\"和\"T\"类型的操作数\n    for (T n = default(T); n < num; n++)\n    {\n        // 报错. 运算符< ++ += 无法应用于\"T\"和\"T\"类型的操作数\n        sum += n;\n    }\n    return sum;\n}\n```\n\n这是CLR的泛型支持体系的一个严重限制, 许多开发人员(科学,金融,数学领域)对这个限制失望. 通过别的技术来避开这个以限制, `反射`,`dynamic基元类型`和`操作符重载`等. 但是这些技术会严重损害性能和代码的可读性.\n","tags":["CLR读书笔记"]},{"title":"11事件","url":"/2019/08/02/11事件/","content":"# 事件\n\n定义了`事件成员`的类型允许 **类型或类型实例** 通知其他对象发生了特定事情.\n\n例如: Button按钮类提供了Click事件.应用程序中的其他对象可以接收关于该事件的通知,以便在Button被点击之后采取特定的操作.\n\n定义了事件成员的`类型`能提供一下功能:\n- 方法能登记它对事件的关注.\n- 方法能注销它对时间的关注.\n- 事件发生时,登记了的方法将收到通知.\n\n`类型`之所以能提供事件通知功能,是因为类型维护了一个`已登记方法的列表`.事件发生后通知列表中的所有已登记方法.\n\nCLR事件模型是以`委托`为基础. 委托是调用`回调方法`的一种类型安全的方式.对象凭借回调方法接收它们订阅的通知.\n\n**我们可以通过为事件定义事件访问器,来控制事件运算符+=、-=运算符的行为,有两个访问器:add和remove,声明事件的访问器看上去和声明一个属性差不多.**\n\n```csharp\npublic event EventHandler Elapsed\n{\n    add\n    {\n        //... 执行+=运算符的代码\n    }\n     remove\n     {\n        //... 执行-=运算符的代码\n     }\n}\n```\n\n\n# 举例用到事件的场景\n\n设计电子邮件应用程序:\n\n功能:电子邮件到达时,将该邮件转发给传真机,将该邮件转给寻呼机.\n\n![](11事件/设计电子邮件程序.png)\n\n0) 先构建一个MailManager的一个实例. MailManager提供了NewMail事件.\n1) `构造`Fax和Pager对象时,它们向MailManager的NewMail事件`登记`它们自己的一个`实例方法`.\n2) MailManager收到新邮件时,会引发NewMail事件,使所有已登记的方法都能用自己的方式处理邮件.\n\n\n## 第一步:定义类型来容纳所有需要发送给事件通知接收者的附加信息\n\n事件引发时,引发事件的对象可能希望向接收事件通知的对象传递一些`附加信息`,这些附加信息要封装到它自己的类中, 这种类应该从`EventArgs`派生,并且类名以EventArgs结尾.\n\n```csharp\npublic  class NewMaillEventArgs : EventArgs\n{\n       // 私有只读字段\n       // 发件人\n       private readonly string _m_from;\n       // 收件人\n       private readonly string _m_to;\n       // 主题\n       private readonly string _m_subject;\n       public NewMaillEventArgs(string from,string to,string subject)\n       {\n           _m_from = from;\n           _m_to = to;\n           _m_subject = subject;\n       }\n       // 公开的只读属性(只有get访问器)\n       public string From { get { return _m_from; } }\n       public string To { get { return _m_to; } }\n       public string Subject { get { return _m_subject; } }\n}\n```\n\n### EventArgs类的定义实现\n\n实现非常简单,就是一个让其他类型继承的基类型.\n\n如果事件不需要传递附加信息,则可以直接使用EventArgs.Empty,不用构造新的EventArgs对象.  例如:Button点击事件,调用回调方法就可以了,不需要传递附加信息.\n\n```csharp\n[Serializable]\npublic class EventArgs\n{\n  public static readonly EventArgs Empty = new EventArgs();\n}\n```\n\n## 第二步:定义事件成员\n\n事件成员使用C#`关键字event`来定义。\n\n每个事件成员都要指定以下内容:\n- 一个可访问性标识符(几乎肯定是Public，这样其他代码才能访问该事件成员)；\n- 另一个委托类型，它指出要`调用的方法的原型`，以及一个名称(可以是任意有效的标识符)。\n\n\n```csharp\n//定义成员变量 NewMaill是事件名称\npublic event EventHandler<NewMaillEventArgs> NewMaill;\n```\n\n事件成员类型是`EventHandler<NewMaillEventArgs>`, 意味着所有接收者都必须提供一个原型和`EventHandler<NewMaillEventArgs>`匹配的`回调方法`.\n\n由于`泛型System.EventHandler`的委托定义如下:\n```csharp\npublic delegate void EventHandler<TEventArgs>(Object sender, TEventArgs e);\n```\n\n**所以方法的原型必须具有以下形式:**\n```csharp\nvoid MethodName(Object sender, NewMaillEventArgs e);\n```\n> 事件模式要求所有事件处理程序(方法)的返回类型都是void;\n> 因为引发事件后可能要调用好几个回调方法,但是没办法获得所有方法的返回值,将返回类型void,就不允许回调方法返回值.\n> 但是ResloveEventHandle事件没有遵循这个要求,返回了Assembly类型的对象.\n\n\n### 为什么要求sender参数是Object类型\n\n只有`MailManager对象`才会引发传递`NewMaillEventArgs对象`的事件,似乎以下回调方法更适合原型:\n```csharp\n// Object sender 改为 MailManager sender\nvoid MethodName(MailManager sender, NewMaillEventArgs e);\n```\n\n原因是:\n1. 要求Object主要是因为继承.\n\n假设: MailManager成为SmtpMailManager的基类`SmtpMailManager : MailManager` ,`SmtpMailManager`从基类继承了`事件NewMail`, 那参数类型需要由`MailManager`转换为`SmtpMailManager`,反正都是需要转换的,不如定义成`Object`.\n\n2. 另一个原因是灵活性,使委托能由多个类型使用.\n\n只要`类型`提供一个会传递`NewMaillEventArgs对象`的事件,即使`PopMailManager`类不从`MailManager`类派生,也能使用这个委托.\n\n\n## 第三步:定义负责引发事件的方法来通知事件的登记对象\n\n事件主要是在单线程情形中使用,所以线程安全不是问题.\n\n```csharp\n//如果类是密封的，该方法要声明为私有和非虚\nprotected virtual void OnNewMaill(NewMaillEventArgs e)\n{\n    //出于线程安全的考虑，现在将对委托字段的引用复制到一个临时变量时\n    // EventHandler<NewMaillEventArgs> temp = NewMaill; 也是可以的\n    // 事件主要是在单线程的情形中使用,所以线程安全不是问题\n    // (NewMaill != null) 在多线程中会出现竞态问题\n    // 以下写法是技术正确的版本.\n    EventHandler<NewMaillEventArgs> temp = Volatile.Read(ref NewMaill);\n    //任何方法登记了事件的关注,就通知它们\n    if (temp != null)\n    {\n        temp(this, e);\n    }\n}\n```\n\n> (NewMaill != null) 在多线程中会出现竞态问题,调用NewMaill之前,在另外一个线程中可能移除一个委托,使NewMaill成了null. 许多开发者就像EventHandler<NewMaillEventArgs> temp = NewMaill;这样写, 将NewMail引用复制到变量中,引用的是赋值时发生的委托链. 委托是不可变的.\n\n将MailManager作为基类,派生类可以自由重写OnNewMaill方法,一般情况下,派生类会调用基类的OnNewMaill方法,使登记的方法都能收到通知,但是派生类也可以不允许事件转发.\n\n### 定义如下扩展方法来封装这个线程安全逻辑\n\n```csharp\npublic static class EventArgExtensions\n{\n    public static void Raise<TEventargs>(this TEventargs e, Object sender, ref EventHandler<TEventargs> eventHandler)\n    {\n        EventHandler<TEventargs> temp = Volatile.Read(ref eventHandler);\n\n        if (temp != null)\n        {\n            temp(sender, e);\n        }\n    }\n}\n```\n\n为了方便起见,就可以如下重写OnNewMail方法\n\n```csharp\nprotected virtual void OnNewMaill(NewMaillEventArgs e)\n{\n  e.Raise(this, ref m_NewMail);\n}\n```\n\n## 第四步:定义方法将输入转化为期望事件\n\n```csharp\npublic void SimulateNewMaill(String from, String to, String subject)\n{\n    // 构造对象来容纳想附加给接收者的信息\n    NewMaillEventArgs e =new NewMaillEventArgs(from,to,subject);\n\n    // 调用虚方法通知事件已经发生\n    // 如果没有类型重写该方法,我们的对象将通知事件的所有登记对象\n    OnNewMaill(e);\n}\n```\n\n# 事件是什么? 是如何工作的?\n\n```csharp\n// 事件成员\npublic EventHandler<NewMaillEventArgs> NewMail = null;\n```\n\nC#编译器编译时把它转换为3个构造:\n1. 一个被初始化为null的`私有委托字段`;\n  1. **是对委托列表头部的引用.**\n2. 一个公共的`add_Xxx方法`(Xxx是事件名,例如add_NewMail)\n  1. 生成的代码总是调用`System.Delgate的静态Combine方法`,将`委托实例添加到委托列表`中,返回`新的列表头地址`, 将这个地址存回字段.\n3. 一个公共的`remove_Xxx`(Xxx是事件名,例如remove_NewMail)\n  1. 生成的代码总是调用`System.Delgate的静态Remove方法`,将`委托实例从委托列表中删除`中,返回`新的列表头地址`, 将这个地址存回字段.\n\n如果试图删除从未添加过的方法, `Delgate`内部不做任何事情,也不会抛出异常, 事件的集合保持不变.\n\n> add和remove以线程安全的一种模式更新值.\n\n事件的可访问性决定了什么代码能登记和注销对事件的关注.**无论如何只有类本身可以访问委托字段**.\n\n\n# 设计侦听事件的类型\n\n1. 在Fax类中的构造函数传入MailManager,并将对该对象的引用保存到变量中,\n2. 在构造函数中登记它对MailManager的事件的关注\n  1. `mm.NewMail += FaxMsg;`\n  2. C#编译器对`+=`操作符翻译成以下代码来添加对象对事件的关注.`mm.add_NewMail(new EventHandler<NewMaillEventArgs>(this.Msg));`\n  3. C#编译器调用了`MailManager`类的`add_NewMail`方法,传递新的委托对象(Msg).\n3. MailManager对象引发事件时, Fax对象的FaxMsg方法会被调用.\n  1. 调用时,传递的第一个参数时MailManager对象引用,`sender`.  可以用来访问MailManager对象的成员.\n  2. NewMaillEventArgs附带了信息.\n4. 类型实现了IDisposable的Dispose方法,就应该在其中注销对所有事件的关注. 用`-=`操作符(会调用remove方法).\n\n> C#要求代码使用+=和-=操作符在列表中增删委托.\n\n# 什么情况需要显式实现事件?\n\n在一个类型中定义了很多事件,也就是要很多个委托字段,但是用到的只是少数事件, 这样从这个类派生创建的对象都要浪费大量内存.\n\n因此需要开发人员显式实现一个事件,使开发人员能够`控制add和remove方法`处理回调委托.\n\n1. 高效率存储事件委托, 公开了事件的每个对象都要维护一个集合(通常是字典)\n  1. `事件标识符作`为key, `委托列表`作为值value\n  2. 新对象构造时, 集合是空白的, 登记事件时会查找集合中的键(事件标识符),如果已经有了,就将新委托和委托列表合并. 不存在就新添加.\n2. 所以这个设计,需要定义事件的那个类型开发人员去完成.\n\n\n## EventKey和EventSet设计\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\n// 此类目的:提供多一点的类型安全性和代码的可维护性\n// 用于 字典的key键存放每个事件标识符类的哈希码,以便查找这个事件的委托链表\npublic sealed class EventKey : Object\n{\n}\n\n// 用于显示实现事件的字典集合\npublic sealed class EventSet\n{\n    // 定义私有只读字典,用于维护EventKey->Delegate(委托链表)映射\n    private readonly Dictionary<EventKey, Delegate> m_events =\n        new Dictionary<EventKey, Delegate>();\n\n    // Adds an EventKey -> Delegate mapping if it doesn't exist or\n    // combines a delegate to an existing EventKey\n    public void Add(EventKey eventKey, Delegate handler)\n    {\n        // 线程安全的方式\n        Monitor.Enter(m_events);\n        Delegate d;\n        m_events.TryGetValue(eventKey, out d);\n        // 合并新的委托到委托链表中\n        // Delegate.Combine将`委托实例添加到委托列表`中,返回`新的列表头地址`, 将这个地址存回字段.\n        m_events[eventKey] = Delegate.Combine(d, handler);\n        Monitor.Exit(m_events);\n    }\n\n    // Removes a delegate from an EventKey (if it exists) and\n    // removes the EventKey -> Delegate mapping the last delegate is removed\n    public void Remove(EventKey eventKey, Delegate handler)\n    {\n        Monitor.Enter(m_events);\n        // Call TryGetValue to ensure that an exception is not thrown if\n        // attempting to remove a delegate from an EventKey not in the set\n        Delegate d;\n        // 确保从集合中删除不存在的EventKey时不会抛出异常.\n        if (m_events.TryGetValue(eventKey, out d))\n        {\n            d = Delegate.Remove(d, handler);\n\n            // 如果委托链表还存在委托,则重新设置头部的地址.\n            if (d != null) m_events[eventKey] = d;\n            // 链表为空,则移除这个键值对.\n            else m_events.Remove(eventKey);\n        }\n\n        Monitor.Exit(m_events);\n    }\n\n    // 为指定的EventKey引发事件\n    public void Raise(EventKey eventKey, Object sender, EventArgs e)\n    {\n        // 如果EventKey不在集合中,不会抛出异常\n        Delegate d;\n        Monitor.Enter(m_events);\n        m_events.TryGetValue(eventKey, out d);\n        Monitor.Exit(m_events);\n\n        if (d != null)\n        {\n            // 由于字典可能包含几个不同的类型委托\n            // 所以无法再编译时构造一个类型安全的委托调用\n            // 调用Delegate的DynamicInvoke方法,以一个对象数组的形式传递回调方法的参数\n            // 在内部,DynamicInvoke会向调用的回调方法查证参数的类型安全性.\n            // 如果类型不匹配,会抛出异常\n            d.DynamicInvoke(new Object[] {sender, e});\n        }\n    }\n}\n```\n\n## 使用EventSet类在TypeWithLotsOfEvents类中\n\nTypeWithLotsOfEvents类(使用了大量时间的类):\n\n```csharp\nusing System;\n\n// 为事件定义从EventArgs派生的附加信息类\npublic class FooEventArgs : EventArgs\n{\n}\n\n// Define the EventArgs-derived type for this event.\npublic class BarEventArgs : EventArgs\n{\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\ninternal class TypeWithLotsOfEvents\n{\n    // 定义私有只读字段来引用集合类\n    // 用于管理维护一组EventKey->Delegate(事件/委托)对.\n    private readonly EventSet m_eventSet = new EventSet();\n\n    // protected只能派生类型能访问集合\n    protected EventSet EventSet\n    {\n        get { return m_eventSet; }\n    }\n\n    // 定义Foo事件的键\n    // 2a. 构造静态只读对象来作为标识符表示这个事件\n    // 每个对象都有自己的哈希码,可以方便在对象的集合中查找这个事件的委托链表\n    protected static readonly EventKey s_fooEventKey = new EventKey();\n\n    // 2d. 定义事件的访问器, 用于在集合中增删委托\n    public event EventHandler<FooEventArgs> Foo\n    {\n        // 操作EventSet集合来 增加/删除 键值对\n        add { m_eventSet.Add(s_fooEventKey, value); }\n        remove { m_eventSet.Remove(s_fooEventKey, value); }\n    }\n\n    // 2e. 定义虚方法,用来触发事件\n    protected virtual void OnFoo(FooEventArgs e)\n    {\n        m_eventSet.Raise(s_fooEventKey, this, e);\n    }\n\n    // 2f. 定义将输入转成这个事件的方法\n    public void SimulateFoo()\n    {\n        OnFoo(new FooEventArgs());\n    }\n}\n```\n\n## 使用TypeWithLotsOfEvents类型\n\n```csharp\npublic static void Main()\n{\n  TypeWithLotsOfEvents twle = new TypeWithLotsOfEvents();\n  // 添加一个回调\n  twle.Foo += HandleFooEvent;\n  // 证明确实可行\n  twle.SimulateFoo();\n}\n\nprivate static void HandleFooEvent(object sender, FooEventArgs e)\n{\n  Console.WriteLine(\"Handling Foo Event here..\");\n}\n\n```\n","tags":["CLR读书笔记"]},{"title":"10属性","url":"/2019/08/01/10属性/","content":"\n# 属性\n\nCLR支持两种属性:\n1. 无参属性\n2. 索引器\n\n# 无参属性\n\n## 属性是用来干嘛的?解决了什么问题?\n\n1. 面向数对象设计重要原则之一,数据封装. 意味着类型的字段永远不应该公开.否则很容易因为不恰当的使用而破坏对象的状态.\n  1. 例如 `e.Age = -1; //年龄不可能为负数` ;\n2. 设置为私有字段private后,要修改字段添加`访问器(accessor)方法`,这样就要编写额外的方法\n3. 调用方法不能直接引用字段名,需要调用方法名\n  1. 例如 `e.SetAge(2);`\n\n为了解决以上问题,C#提供了`属性property`机制.\n\n```csharp\nprivate string name;\nprivate int age;\npublic string Name\n{\n    get { return name; }\n    set { name = value; }\n}\npublic int Age\n{\n    get { return age; }\n    set\n    {\n        if (age < 0 && age > 200)\n            throw new ArgumentOutOfRangeException(\"age不在正常范围\", value.ToString());\n        age = value;\n    }\n}\n\n/// 调用时,可以直接引用字段名\ne.Name = \"aaaa\";\n```\n\n## 属性的用法\n\n1. 支持静态,实例,抽象,虚属性.\n2. 可以用任意`可访问性`来修饰`get/set`.\n3. 属性不能重载,即不能定义名称相同,类型不同的属性.\n4. `只读属性`: 只写get标识; `只写属性`:只写set标识\n5. set方法中包含隐藏参数叫做`value`，表示赋给属性的值。\n\n> 私有字段 通常被称为支持字段.\n\n\n## 自动实现的属性(AIP)\n\n如果只为一个私有字段而创建属性,C#提供了更简洁的语法.称为`AIP(Automatiocally Implemented Property)`.\n\n```csharp\n// 声明属性不需要提供get/set的实现, C#会自动声明一个私有字段\npublic string Name{set;get;}\n```\n\n### 自动实现的属性(AIP)不建议使用的理由:\n\n1. 没有简单的语法初始化AIP,要在构造器中显式初始化每个AIP\n2. AIP的私有字段名称有编译器决定,每次重新编译都可能会更改这个名称.因此,**任何类型只要含有AIP就没办法对该类型进行反序列化**. 所以在想要序列化的类中不要使用AIP功能.\n3. 调用时不能再get/set上设置断点.手动实现属性方法可以设置.\n4. AIP属性必然是可读可写的.\n5. get或set方法,如果要显式实现,那么两个方法都要显式实现,不能一个自动一个显式.\n\n## 属性字段差别列表\n\n1. 属性索引器不得作为out或ref参数传递,字段可以.\n2. 属性看起来和字段相似,但是本质上是方法.\n3. 属性方法可能抛出异常;字段访问永远不会.\n4. **线程同步不要使用属性,要使用方法.** 属性方法可能花较长时间执行,字段访问总是立即完成.\n5. 属性可以只读或者只写, 字段访问总是可读或可写(一个例外是readonly字段仅在构造器中可写).\n\n**属性的唯一好处是提供了简化的语法.**\n\n## 对象和集合初始化器\n\n构造对象并设置对象的一些公共属性,为了简化这个常见的编程模式,使用下面这个语法:\n\n`Employee e = new Employee(){ Name = \"Jeff\", Age = 45 };`\n\n等同于\n\n```csharp\nEmployee e = new Employee();\ne.Name = \"Jeff\";\ne.Age = 45;\n```\n\n允许组合多个函数,增强了可读性.(函数的组合使用:扩展方法)\n\n`Employee e = new Employee(){ Name = \"Jeff\", Age = 45 }.ToString.ToUpper();`\n\n> 要用无参构造函数,可以省略大括号前的圆括号,`new Employee { Name = \"Jeff\", Age = 45 }`\n\n**如果类型的属性实现了IEnumerable或IEnumerable<T>接口, 属性就被认为是集合.**\n\n集合的初始化是一种`相加(additive)`操作,而不是`替换(replacement)`操作.\n- 编译器会假定属性类型提供了Add方法,然后生成代码来`调用Add方法`.\n- 如果属性类型`未提供Add方法`,则不允许使用集合初始化语法.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MyClass mc = new MyClass()\n        {\n            MStudent =\n            {\n                \"A\",\n                \"B\",\n                \"C\"\n            }\n        };\n\n        foreach (var student in mc.MStudent)\n        {\n            Console.WriteLine(student);\n        }\n    }\n}\n\npublic sealed class MyClass\n{\n    // 私有字段\n    private List<String> m_Student = new List<string>();\n    // 只读属性\n    public List<string> MStudent\n    {\n        // C#7 方法体表达式\n        // constructors, finalizers, get, set\n        // get只读\n        get => m_Student;\n    }\n    public MyClass() { }\n}\n```\n\n# 匿名类型\n\n利用C#的匿名类功能,可以用很简洁的语法来自动声明不可变的元组类型.\n- `元组类型`:是含有`一组属性`的类型.\n\n```csharp\n// 没有在new后指定类型名称,编译器会自动创建类型名称\n// 因为不知道类型名称,也就不知道o1声明的是什么类型\n// 可以像var\nvar o1 = new { Name = \"aa\", Year = 1989};\n\n// Nameaa,Year1989.\nConsole.WriteLine(\"Name{0},Year{1}.\",o1.Name,o1.Year);\n\nString Name = \"B\";\nDateTime dt = DateTime.Now;\n// 还可以这么写\nvar o2 = new { Name, dt.Year };\n```\n\n1. 编译器会推断每个`表达式`的类型.\n2. 创建推断类型的`私有字段`.\n3. 为每个字段创建`公共只读属性`.\n4. 创建一个`构造器`来接受所有这些表达式.\n  1. 在构造器代码中, 会用传给它的`表达式的求值结果来初始化私有只读字段`.\n5. 编译器还会重写Object的Equals,GetHashCode和ToString方法.\n  1. 任何字段不匹配就返回false,否则true.\n  2. 返回根据每个字段的哈希码生成的一个哈希码.\n  3. 返回\"属性名=值\"对的以逗号分隔的列表.\n6. 匿名类的属性是只读的. 防止对象的哈希码发生改变.如果以哈希码为键,更改了哈希码,这就造成再也找不到它.\n\n编译器在定义匿名类型时, 如果定义了多个匿名类型,而且这些类型具有相同的结构,那么它只会创建一个匿名类型定义.\n\n## 匿名类经常与LINQ(语言集成查询)配合使用\n\n可以用LINQ执行查询,从而生成由一组对象构成的集合. 这些对象都是相同的匿名类型.\n\n- 匿名类型不能泄露到方法外部.\n- 方法也不能返回对匿名类的引用,\n  - 虽然可以将匿名类视为Object,但是没法将Object类的变量转型回匿名类.因为不知道匿名类在编译时的名称.\n\n# Tuple类型\n\n和匿名类型相似,\n- `Tuple`创建好之后就`不可变`了,\n- `所有属性只读`.\n- 提供了CompareTo,Equals,GetHashCode和ToString方法,以及Size属性,\n- 可以比较两个Tuple对象,对他们的字段进行比对.\n\n```csharp\nclass CLRTuple\n {\n     private static Tuple<int, int> MinMax(int a, int b) {\n         return new Tuple<int, int>(Math.Min(a, b), Math.Max(a, b));\n     }\n     private static void TupleTypes()\n     {\n         var minmax = MinMax(6, 2);\n         // Tuple类型,属性一律被称为Item#,无法进行改变\n         // 应该在自己的代码中添加详细的注释,说明每个Item#代表着是什么\n         Console.WriteLine(\"Min{0}Max{1}\", minmax.Item1, minmax.Item2);\n     }\n }\n\n// 当需要创建多于8个元素的一个Tuple时，可以将Rest参数传递到下一个Tuple如下\nvar t=Tuple.Create(0,1,2,3,4,5,6,Tuple.Create(7,8));\n\nConsole.WriteLine(\"{0}{1}{2}{3}{4}{5}{6}{7}{8}\",\n    t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7,\n    t.Rest.Item1.Item1, t.Rest.Item1.Item2);\n)\n```\n\n## 除了匿名类型和Tuple类型,ExpandoObject类和dynamic配合使用\n\n可以用另一种方式将一系列属性(键值对)组合到一起.\n\n![](10属性/ExpandoObject&dynamic.png)\n\n\n# 有参属性(索引器)\n\n可以看成是对`[]`操作符的重载.\n\n属性的get访问器方法 **不接受参数**,所以称为 **无参属性**.\n\nC#称有参属性为 **索引器**.\n- `get访问器`:接受一个或多个参数.\n- `set访问器`:接受两个或多个参数.\n\n\n**索引器使得对象可按照与数组相似的方法进行索引。**\n\n> CLR是以相同方式对待有参属性和无参属性.\n\n```csharp\nstatic void Main(string[] args)\n{\n    TestIndex<String> str= new TestIndex<string>();\n    // 定义了索引器之后可以像数组的方式一样访问类\n    str[0] = \"A\";\n    str[2] = \"B\";\n}\n\nclass TestIndex<T>\n{\n    T[] arr = new T[100];\n\n    // 定义[]索引器\n    public T this[int i]\n    {\n        get { return arr[i]; }\n        set { arr[i] = value; }\n    }\n}\n```\n\n![](10属性/索引器.png)\n\n**提示:查看文档,留意类型是否提供了名为Item的属性,从而判断该类型是否提供了索引器.**\n\n> 例如System.Collections.Generic.List类型提供了名为Item的公共实例属性,它就是List的索引器.\n\n## 如果会有其他语言的代码访问索引器,可能需要更改get/set方法名称\n\nC#编程中永远看不到 Item这个名称,所以一般不需要关心这个.\n\n```csharp\nclass TestIndex<T>\n{\n    T[] arr = new T[100];\n\n    // 定义[]索引器\n    [IndexerName(\"Method\")]\n    public T this[int i]\n    {\n        get { return arr[i]; }\n        set { arr[i] = value; }\n    }\n}\n```\n\n![](10属性/索引器2.png)\n\nSystem.String类型是改变了索引器名称的一个例子.String的索引器名称是Chars,而不是Item. 这个只读属性允许从字符串中获得一个单独的字符,对于不用[]操作符语法来访问这个属性的编程语言,Chars是更有意义的名称.\n\n## 索引器注意事项\n\n- C#用`this[...]`作为索引器的语法.\n  - 索引器语法不允许开发人员指定名称,编译器默认生成get_Item和set_Item方法名.\n  - Item方法名可以用`[IndexerName(\"..\")]`特性修改\n- 只允许在对象的实例上定义索引器.\n- 不支持静态索引器属性.\n- 索引器可以被重载.一个类可以有多个索引器,只要参数集不同即可.\n- 索引器可以多个参数,可以像二维数组.\n\n```csharp\nclass TestIndex<T>\n    {\n        T[] arr = new T[100];\n        T[,] arr1 = new T[10,10];\n        // 定义索引器\n        public T this[int i]\n        {\n            get { return arr[i]; }\n            set { arr[i] = value; }\n        }\n\n        // 定义两个形参的索引器\n        public T this[int i,int j]\n        {\n            get { return arr1[i,j]; }\n            set { arr1[i,j] = value; }\n        }\n    }\n```\n\n- 对于CLR来说有参和无参属性是无区别的,可以用相同的`System.Reflection.PropertyInfo类`来发现`有参属性`和`它的访问器方法`之间的关联.\n\n## 调用访问器方法时的性能\n\n对于简单的get/set方法 ,JIT编译器会将代码内联(嵌入到调用它的方法中去),这样使用属性就没有性能上的损失,避免了在运行时发出调用所产生的开销,会使编译好的方法变得更大.\n\n由于属性访问器包含的代码很少,所以内联所生成的本机代码很小,执行的也会更快.\n\n- JIT编译器在 **调试代码时不会内联属性方法**. 内联代码会难以调试.\n- 发行版本中,访问属性时的性能可能比较快.\n- 字段访问在调试和发布版中,速度都很快.\n\n## 属性访问器的可访问性\n\n如果2个访问器需要不同的可访问性,\n1. C#要求必须为属性本身指定限制最小的(比访问器访问性限制小),\n2. 两个访问器只能选择一个访问器来使用限制较大的.(不能两个都用)\n\n```csharp\n// 限制最小的可访问性public\npublic String Name\n{\n  get{ return m_name; }\n  // 限制较大的protected(相对于Public)\n  protected set { m_name = value; }\n}\n\n// 例子二\nprotected string A\n{\n    // private get => a; // 会报错\n    get => a;\n    private set => a = value;\n}\n```\n\n## 泛型属性访问器方法\n\nC#不允许属性引入它自己的泛型类型参数.  属性不应该和行为沾边,公开对象的行为,无论是不是泛型都应该定义方法,而不是用属性.\n","tags":["CLR读书笔记"]},{"title":"9参数","url":"/2019/07/30/9参数/","content":"\n# 参数\n\n# 可选参数和命名参数\n\n1. 设计方法参数时,可以为部分或全部参数分配默认值.\n\n```csharp\nclass CLR可选参数\n{\n    private static int s_n = 0;\n\n    private static void M(int x = 9, string s = \"A\", DateTime dt = default(DateTime), Guid guid = new Guid())\n    {\n        Console.WriteLine($\"x={x},s={s},dt={dt},guid={guid}\");\n    }\n\n    public static void Main()\n    {\n        //等同于M(9, \"A\", default(DateTime), new Guid())\n        M();\n        //等同于M(8, \"X\", default(DateTime), new Guid())\n        M(8, \"X\");\n        //等同于M(5, \"A\", DateTime.Now, Guid.NewGuid()))\n        M(5, guid: Guid.NewGuid(), dt: DateTime.Now);\n\n        M(s_n++,s_n++.ToString());\n\n        //等同于string t1=0,t2=1;\n        //M(t2,t1,default(DateTime), new Guid())\n        M(s: (s_n++).ToString(), x: s_n++);\n    }\n}\n//输出\n//x=9,s=A,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=8,s=X,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=5,s=A,dt=2019/7/31 11:03:00,guid=afb6f487-dc69-4ae4-ba58-588982d1e68a\n//x=0,s=1,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=3,s=2,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n```\n\n## 部分参数指定默认值的规则和原则\n\n1. 可以为方法,构造器方法,有参属性(C#索引器)的参数指定默认值.\n2. **有默认值的参数必须放在没有默认值的所有参数之后.**\n3. **\"参数数组\"必须放到所有参数之后(包括有默认值的这些),而数组本身不能由默认值.**\n4. 默认值必须是编译时能确定的常量值.\n  1. 值类型参数可将默认值设为值类型的实例. default()关键字和new关键字会生成完全一致的IL代码.`DateTime dt = default(DateTime), Guid guid = new Guid()`\n5. 不要重命名参数变量,不然之后的指定赋值时变量名就需要修改.`s: (s_n++).ToString(), x: s_n++`就会报错.\n6. 更改参数的默认值具有潜在危险性. call site在它的调用中嵌入`默认值`, **建议将默认值0/null作为哨兵值使用**.\n  1. 如果方法被模块外部调用,外部使用默认值,如果以后修改方法的默认值,没有重新编译call site外部的代码.那它在调用方法时,传递的还是旧的默认值.\n\n```csharp\n// 不要这样做\nprivate static String MakePath(String filename = \"Untitled\")\n// 参数中的默认值会被直接嵌入到方法调用中的IL代码里\n// 如果修改默认参数后,call site代码没有重新编译,仍旧会使用旧默认值\n{\n  return String.Format($\"C:\\{filename}.txt\");\n}\n\n// 建议这样做\n// 默认值用0/null作为哨兵值使用\nprivate static String MakePath(String filename = null)\n{\n  // 在语句中就不会出现这样的问题\n  return String.Format(\"C:\\{0}.txt\", filename ?? \"Untitled\");\n}\n```\n\n7. 如果参数用ref或out关键字进行标识,就不能设置默认值. 没办法为这些参数传递有意义的默认值.\n\n使用可选或命名参数调用方法时,\n1. 实参可按任意顺序传递,命名实参只能出现在实参列表的尾部.( `x: s_n++` 命名实参:值)\n2. C#不允许省略逗号之间的实参.(如果想省略, 就用要以传递`参数名:`的方式传递实参就可以)\n3. 如果参数要求ref/out, 为了以传参数名的方式传递实参,使用以下语法\n\n```csharp\n// 方法声明\nprivate static void M(ref Int32 x){ ... }\n\n// 方法调用\nInt32 a = 5;\nM(x: ref a);\n```\n\n\n# 隐式类型( var )的局部变量\n\n1. 不能用var声明参数,因为编译器必须根据在call site传递的实参来推断类型,但是call site可能一处没有,也可能有很多处.\n2. 不能用var声明字段. 应该显式陈述.\n\n\n> 不要混淆dynamic和var\n> 用var声明局部变量只是一种简化语法.\n\n# 以传引用的方式向方法传递参数\n\nCLR默认所有方法参数都传值. 传递引用类型的对象时, 引用(或指针)本身是传值的.\n\n- 引用类型: 方法能修改对象,而调用者能看到这些修改\n- 值类型:传给方法的是实例的一个副本,调用者的实例不受影响.\n\n## ref和out关键字\n\nCLR运行以传引用而非传值的方式传递参数. C#用关键字`out/ref`来支持这个功能. 两个关键字都告诉C#编译器生成元数据来指明该参数时传引用的. **编译器会生成代码来传递参数的地址,而不是传递参数本身.**\n\nCLR不区分关键字`out/ref`,都会生成相同的IL代码,元数据几乎完全一致,只有一个bit除外,记录指定的是out还是ref.\n\nC#编译器则是区别对待`out/ref`的.\n- `out标记`:被传入调用方法的参数 **不必要初始化**, 被调用的方法 **不能读取参数值**, 在返回前\n**必须向这个值写入**.\n- `ref标记`:调用方法前 **必须先初始化被ref标记的参数**, 被调用的方法 **可以读写** 这个参数值.\n\n\n## 值类型使用ref和out关键字\n\n```csharp\npublic static void Main()\n{\n    int x;                //x没有初始化\n    GetVal(out x);        //x不必初始化\n    Console.WriteLine(x); //显示10\n}\n\nprivate static void GetVal(out int v)\n{\n    // 访问前必须先赋值v\n    // Console.WriteLine(v); 这句话编译时会报错\n    v = 10; //该方法必须初始化v\n}\n```\n1. x在Main的栈帧(当前线程的调用栈中的一个方法调用)\n2. x的地址传递给GetVal, GetVal的参数v是一个指针,指向Main栈帧中的Int32值.\n3. 在GetVal方法内部,v指向的那个Int32值被更改为10.\n\n> 栈帧: 在执行线程的过程中进行的每个方法调用都会在调用栈中创建并压入一个StackFrame\n\n **用处: 为 `大的值类型`使用out, 可以避免在进行方法调用时复制值类型实例的字段.**\n\n```csharp\npublic static void Main()\n{\n    int x = 5;            //已经初始化\n    AddVal(ref x);        //x必须初始化\n    Console.WriteLine(x); //显示15\n}\n\nprivate static void AddVal(ref int v)\n{\n    v += 10; //该方法可使用v的已初始化的值\n}\n```\n1. 和out不同的是,在AddVal内部,v指向的那个Int32值必须是已经初始化的.\n2. AddVal可以对v进行读写\n\n\n综上所述:\n1. 从IL和CLR角度看,out和ref是同一回事: **都传递指向实例的一个指针.**\n2. 从编译器角度看,两者的区别在于:**会按不同的标准验证你写的代码是否正确,是否已赋值.**\n3. 为值类型使用out/ref,效果等同于以传值的方式传递引用类型.\n\n## 为什么C#要求必须在调用方法时指定out或ref\n\nC#语言设计者认为调用者应该显式表明意图,只有这样,在`call site(调用位置)`那里,才能清楚地知道被调用的方法`是否需要对传递的变量值`进行更改.\n\nC#允许 使用out/ref参数对方法进行重载.但是两个不能同时出现,因为2个签名的元数据形式完全相同.\n\n```csharp\npublic sealed class Point\n{\n  static void Add(Point p){ ... }\n  static void Add(ref Point p){ ... }\n  // Add不能定义仅在ref和out上有差别的重载方法\n  // 因为这两个方法签名生成的元数据形式完全相同\n  // static void Add(out Point p) { ... }\n}\n```\n\n## 引用类型使用ref和out关键字\n\n和值类型使用out/ref参数的区别:\n1. `值类型`:调用者必须 **为实例分配内存**. 被调用者则操作该内存中的内容.\n2. `引用类型`:调用代码 **为一个指针分配内存**,指针指向引用类型的对象. 被调用者操纵这个指针.\n\n```csharp\npublic static void Main()\n{\n    FileStream fs = null; // 初始化为null (必要操作)\n\n    // 打开第一个待处理的文件\n    for(; fs != null; ProcessFiles(ref fs))\n    {\n      //处理文件\n      fs.Read(...);\n    }\n}\n\nprivate static void ProcessFiles(ref FileStream fs)\n{\n    // 如果先前的文件是打开的,就将其关闭\n    if (fs!=null) fs.Close();\n\n    // 打开下一个文件,如果没有,就返回null\n    if (noMoreFilesToProcess) fs = null;\n    else\n    {\n        fs = new FileStream(...);\n    }\n}\n```\n\n### 是ref关键字实现一个用于交换两个引用类型\n\n```csharp\npublic static void Main()\n{\n    String s1 = \"111\";\n    String s2 = \"222\";\n    // 无法通过编译,参数类型不匹配\n    // 它的类型必须与签名中声明的类型相同\n    // Swap需要的是两个Object的引用,而不是String\n    // Swap(ref s1,ref s2);\n\n\n    // 需要进行转型\n    Object o1 = s1, o2 = s2;\n    Swap(ref o1,ref o2);\n    // 完事后,再将Object转型为String\n    s1 = (String) o1;\n    s2 = (String) o2;\n\n}\n\npublic static void Swap(ref Object a,ref Object b)\n{\n    Object t = b;\n    b = a;\n    a = t;\n}\n\n// 泛型版本\n// 这样之前就不需要再转型了,能直接通过编译完美运行\npublic static void Swap<T>(ref T a,ref T b)\n{\n    T t = b;\n    b = a;\n    a = t;\n}\n```\n**传递参数的类型必须与签名中声明的类型相同.**\n\n# 向方法传递可变数量的参数（params）\n\n```csharp\n// 用params关键字\nstatic int Add(params int[] values)\n{\n    int sum = 0;\n    if (values != null)\n    {\n        for (int x = 0; x < values.Length; x++)\n            sum += values[x];\n    }\n\n    return sum;\n}\n\n//调用方法1\nAdd(new int[]{1,2,3,4,5,6});\n//调用方法2，\nAdd(1,2,3,4,5,6);\n```\n\nparams关键字告诉编译器向参数定制特性System.ParamArrayAttribute的一个实例.\n\nC#编译器检测方法调用时,会先检查所有具有指定名称,同时参数没有应用ParamArray的方法.如果没有找到,就检查应用了ParamArray特性的方法,生成代码来构造数组,填充它的元素,再生成代码来调用所选的方法.\n\n\n1. 只有方法的`最后一个参数`才可以用`params关键字`(ParamArrayAttribute)标记.\n2. **只能标识一维数组(任意类型)**.\n3. 可为这个参数传递null值. `Console.WriteLine(Add(null));//生成的结果是0,不会分配数组`\n\n## 获取任意数量,任意类型的参数方法\n\n只需要修改方法原型,让它获取`Object[]`而不是`Int32[]`;\n\n```csharp\nstatic void Main(string[] args)\n{\n    DisplayTypes(new object(),new Random(),\"Jeff\",5);\n}\n\nprivate static void DisplayTypes(params Object[] objects)\n{\n    if (objects!=null)\n    {\n        foreach (object o in objects)\n        {\n            Console.WriteLine(o.GetType());\n        }\n    }\n}\n// System.Object\n// System.Random\n// System.String\n// System.Int32\n```\n\n使用params会对性能有所影响\n1. 数组必须在堆上分配\n2. 数组元素必须初始化\n3. 数组内存最终需要垃圾回收\n\n# 参数和返回类型的设计规范\n\n这里例子讨论的是集合,是用接口体系结构来设计的.\n1. 声明方法的参数类型时, **应尽量指定最弱的类型,宁愿要接口也不要基类.** 最好是使用接口声明参数比如`IEnumerable<T>`\n\n```csharp\n// 好: 方法使用弱参数类型\n// 参数的类型只要实现了IEnumerable<T>接口就可以\n// 方法更灵活,适合更广泛的情形\npublic void MainpulateItems<T>(IEnumerable<T> collection) { ... }\n\n// 不好: 方法使用强参数类型\n// 参数不接受数组或String对象\npublic void MainpulateItems<T>(List<T> collection) { ... }\n```\n\n2. 如果方法需要的是列表,就应该将参数类型声明为`IList<T>` ,避免声明为`List<T>`\n3. 强参数类型和弱参数类型,`参数类型`最好是弱类型\n4. `返回类型`最好是声明为最强的类型\n\n```csharp\n// 好: 方法使用弱参数类型\n// 能处理任何流包括FileStream,NetworkStream,MemoryStream等\npublic void ProcessBytes(Stream someStream){ ... }\n\n// 不好: 方法使用强参数类型\n// 只能处理FileStream\npublic void ProcessBytes(FileStream someStream){ ... }\n\n// 好: 方法使用强返回类型\npublic FileStream OpenFile(){ ... }\n// 不好: 方法使用弱返回类型\npublic Stream OpenFile(){ ... }\n```\n\n\n# 常量性\n\n1. 不能将方法或参数声明为常量.\n2. CLR也没提供对常量对象/实参的支持.\n\n> String类就没有提供任何能更改String对象的方法,所以字符串是不可变的(immutable).\n","tags":["CLR读书笔记"]},{"title":"8方法","url":"/2019/07/28/8方法/","content":"# 方法\n\n# 实例构造器和类(引用类型)\n\n构造器方法在`方法定义元数据表`中始终叫做`.ctor`(constructor简称).\n\n创建引用类型的实例时\n- 首先,为实例的数据字段分配内存\n- 初始化对象的附加字段(`类型对象指针`和`同步索引块`)\n  - 这些附加字段称为`overhead fields`,创建对象时必须的开销.\n- 最后调用类型的`实例构造器`,来设置对象的初始状态.\n\n构造引用类型对象时,在调用类型的实例构造器之前,为对象分配的内存总是先被归零,**没有被构造器显示重写的字段都保证获得0或null值.**\n\n- 实例构造器不能使用以下修饰符: `virtual`,`new`,`override`,`sealed`,`abstract`.\n- 没有显示定义任何构造器时,C#编译器将定义一个默认的`无参构造器`.\n- 如果是抽象类(abstract),那么编译器生成的默认构造器可访问性是`protected`,否则就是`public`.\n- 如果基类没有提供 **无参构造器**,那么派生类必须 **显式调用一个基类构造器**.\n- 如果是静态类(static),编译器不会再定义中生成默认构造器.\n\n```csharp\npublic class SomeType {}\n// 等价于\npublic class SomeType\n{\n  public SomeType() : base() {}\n}\n```\n\n- 类的实例构造器在访问从基类继承的任何字段之前,都必须先调用基类的构造器.\n- 如果派生类的构造器没有显式调用一个基类构造器,C#编译器会自动生成对默认的基类构造器的调用.(System.Object的无参构造器会得到调用,直接返回什么都不做)\n- 极少数情况可以在不调用构造器的前提下创建类型的实例.\n  - 一个典型的例子是Object的`MemberwiseClone`方法.该方法的作用是分配内存,初始化对的额外开销成员,然后将源对象的字节数据复制到新对象中.(不需要构造器去初始化成员)\n  - 另外`运行时序列化器`反序列化对象时也不需要调用构造器.反序列化代码使用`System.Runtime.Serialization.FormatterServices`类型的`GetUninitializedObject`或者`GetSafeUninitializedObject`方法为对象分配内存. 期间不会调用一个构造器.\n\n## 不要在构造器中调用虚方法\n\n- 假如基类构造器中调用了虚方法,派生类重写了虚方法, 派生类被实例化时,会先调用基类的构造器,但是基类构造器中的虚方法会使用派生类重写后的虚方法,但是派生类构造器还没运行,所以会导致无法预测的行为.\n- 尚未完成对继承层次结构中所有字段的初始化.\n\n归根到底,这是由于调用虚方法时,直到运行之前都不会选择执行该方法实际的类型.\n\n```csharp\ninternal sealed class SomeType\n{\n  // C# 编译器允许嵌入方式初始化实例字段\n  // 但是在幕后,它会将语法转换成构造器方法中的代码来初始化. <----代码膨胀效应\n  private Int32 m_x = 5;\n}\n```\n这段代码在IL代码如下工作:\n1. SomeType的构造器把值5存储到m_x.\n2. 再调用基类构造器`System.Object::.cotr()`.\n\n```csharp\ninternal sealed class SomeType\n{\n  // 内联方式初始化实例字段   等同于嵌入代码的形式\n  // 会将此种语法转换成代码在构造器方法中来执行初始化\n  // 所以有多少个构造器,都会生成多少次所有字段初始化的代码\n  private Int32  m_x = 5;\n  private String m_s = \"Hi there\";\n  private Double m_d = 3.1415;\n  private Byte   m_b;\n\n  public SomeType(){...}\n  public SomeType(Int32 x){...}\n  // 此构造器的执行过程\n  // 1. 编译器生成代码 初始化m_x,m_s和 m_d(没有显示初始化也保证会被初始化为0)\n  // 2. 调用基类构造器 base()  基类的无参构造器调用\n  // 3. 再调用SomeType(String s) 类型自己的构造器\n  // 4. 用10覆盖掉m_d值\n  public SomeType(String s){...; m_d=10;}\n}\n\n.method public hidebysig specialname rtspecialname\n        instance void  .ctor(string s) cil managed\n{\n  // 代码大小       64 (0x40)\n  .maxstack  2\n  //////////////////////////////////////////////////////////////////\n  IL_0000:  ldarg.0\n  IL_0001:  ldc.i4.5\n  IL_0002:  stfld      int32 ConsoleApp1.SomeType::m_x\n  IL_0007:  ldarg.0\n  IL_0008:  ldstr      \"Hi there\"\n  IL_000d:  stfld      string ConsoleApp1.SomeType::m_s\n  IL_0012:  ldarg.0\n  IL_0013:  ldc.r8     3.1415000000000002\n  IL_001c:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_0021:  ldarg.0\n  ////////////////////以上就是每个构造器都要生成的初始化m_x,m_s和 m_d代码\n  // 调用基类构造器\n  IL_0022:  call       instance void [System.Runtime]System.Object::.ctor()\n  IL_0027:  nop\n  IL_0028:  nop\n  // 调用自己的构造器\n  IL_0029:  ldarg.0\n  IL_002a:  ldarg.1\n  IL_002b:  stfld      string ConsoleApp1.SomeType::m_s\n  // m_d=10;用10覆盖掉m_d值\n  IL_0030:  ldarg.0\n  IL_0031:  ldc.r8     10.\n  IL_003a:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_003f:  ret\n} // end of method SomeType::.ctor\n```\n\n1. **编译器为这3个构造器方法生成代码时,在每个方法的开始位置,都会包含用于初始化m_x,m_s和m_d的代码.**\n2. **在这些初始化代码之后,编译器会插入对基类构造器的调用.**\n3. **再然后,会插入构造器自己的代码.**\n\n\n_**编译器在调用基类构造器前使用简化语法对所有字段初始化.**_\n\n因此上述3个构造器就要生成3次这样相同的代码(初始化m_x,m_s和 m_d代码).\n\n## 优化构造器代码膨胀效应的方法\n\n如果有几个已初始化的实例字段和许多重载构造器方法,可以创建单个构造器来执行公共的初始化. 让其他构造器都显示调用这个公共初始化构造器.  不显示初始化字段(不在定义时赋值初始化).\n\n```csharp\n    public sealed class SomeType\n    {\n        // 不要显示初始化下面的字段,减少生成相同的代码\n        // 不然会在没个构造器中生成相同的初始化代码,\n        private Int32  m_x;\n        private String m_s;\n        private Double m_d;\n        private Byte   m_b;\n\n        public SomeType()\n        {\n            m_x = 5;\n            m_s = \"ssss\";\n            m_d = 3.1415;\n            m_b = 0xff;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        public SomeType(Int32 x) : this()\n        {\n            m_x = x;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        // 用10覆盖m_d\n        public SomeType(String s) : this()\n        {\n            m_s = s;\n            m_d = 10;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        public SomeType(Byte b) : this()\n        {\n            m_b = b;\n        }\n    }\n\n.method public hidebysig specialname rtspecialname\n        instance void  .ctor(string s) cil managed\n{\n  // 代码大小       31 (0x1f)\n  .maxstack  8\n  IL_0000:  ldarg.0\n  IL_0001:  call       instance void ConsoleApp1.SomeType::.ctor()\n  IL_0006:  nop\n  IL_0007:  nop\n  IL_0008:  ldarg.0\n  IL_0009:  ldarg.1\n  IL_000a:  stfld      string ConsoleApp1.SomeType::m_s\n  IL_000f:  ldarg.0\n  IL_0010:  ldc.r8     10.\n  IL_0019:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_001e:  ret\n} // end of method SomeType::.ctor\n```\n\n> 如果还在字段定义时赋值, 其他构造器使用:this(),则不会在这些构造器中生成字段初始化的代码,而会在无参构造器中生成. 关键在于:this()\n\n\n# 实例构造器和结构(值类型)\n\n值类型(struct)构造器的工作方式与引用类型(class)的构造器截然不同. CLR总是允许创建值类型的实例,并且没有办法阻止类型的实例化.\n\n- 值类型构造器需要显示调用才会执行.\n- 不显式调用构造器都将初始化为0或null\n- C#编译器不允许结构包含显式的无参构造器.\n- 由于不能定义无参构造器,所以编译器永远不会生成自动调用它的代码\n\n> **引用类型中的字段** 保证初始化为0或null, C#是能生成\"可验证\"代码的编译器,可以保证所以 **基于栈的值类型字段** 对它们进行\"置零\".\n\n## 关于值类型的实例构造器\n\n1. C#不允许 值类型带有无参构造器\n2. 也就不允许值类型使用内联实例字段的初始化语法\n  1. `private Int32 m_x =5;` 在结构中会编译出错.\n3. 值类型的任何构造器都必须初始化值类型的全部字段. 否则编译出错.\n\n```csharp\npublic SomeType(Int32 x)\n{\n  // 值类型结构中,this代表值类型本身的一个实例, 可以赋值(引用类型this是只读的)\n  // 显示调用无参值类型构造函数, 所有值类型字段初始化为0或null\n  this = new SomeType();\n\n  // 覆盖原始的0\n  m_x = x;\n  // m_y已经初始化,所以不会编译出错.\n}\n```\n\n# 类型构造器\n\n除了实例构造器,CLR还支持类型构造器.也称为静态构造器,类构造器,类型初始化器.\n\n- 类型构造器的作用是`设置类型`的初始状态.\n  - 实例构造器作用是`设置类型实例`的初始状态.\n- 类型构造器永远没有参数\n- 类型构造器必须标static,且默认不可更改,访问性是private\n\n类型默认没有定义类型构造器, 如果定义也只能定义一个.\n\n```csharp\ninternal sealed class SomeRefType\n{\n    // 类型构造器必须标static,且默认不可更改访问性是private\n    static SomeRefType()\n    {\n        // SomeRefType被首次访问时,执行这里的代码\n    }\n}\n\n/// 永远不要定义值类型类型构造器, CLR有时不会调用值类型的静态类型构造器\ninternal struct SomeValType\n{\n    // C#允许值类型定义无参的构造类型\n    // 类型构造器必须标static,且默认不可更改访问性是private\n    static SomeValType()\n    {\n        // SomeValType被首次访问时,执行这里的代码\n    }\n}\n```\n之所以是私有,是为了防止任何开发人员写代码去调用它,**对它(类型构造器)的调用总是由CLR负责.**\n\n\n\n1. 不要在静态构造函数中执行复杂的逻辑、它只是为了对静态字段进行初始化而设置的,并且只能访问静态字段.\n2. 不要出现两个或者多个类的静态构造函数相互调用的情况，因为它是线程安全的，是要加锁的，如果出现相互调用，可能导致死锁。\n3. 不要在类的静态构造函数中写你期望按照某个顺序执行的代码逻辑，因为静态构造函数的调用时由CLR控制的，程序员不能准确把握运行时机。\n4. **永远不要定义值类型类型构造器, CLR有时不会调用值类型的静态类型构造器**\n5. 如果在类型构造器中抛出未处理的异常,CLR会认为类型不可用,访问该类型的字段或方法都会抛出`System.TypeInitializationException`异常.\n\n\n> CLR并不支持静态的Finalize方法, 就是在类型卸载时执行一些代码,类型只有在AppDomain卸载时才会卸载,AppDomain卸载时,用于标识类型的对象将成为不可达的对象,垃圾回收期会回收类型对象的内存.\n> 要实现这样的需求,要在AppDomain卸载时执行一些代码,可向System.AppDomain类型的DomainUnload啥时间登记一个回调方法.\n\n\n# 操作符重载方法\n\nCLR对操作符重载一无所知.甚至不知道什么是操作符.\n\n- 操作符重载必须是 public static\n- 操作符重载方法的参数类型至少有一个和当前定义这个方法的类型相同.(能在合理的时间内找到要绑定的操作符重载方法)\n- 编译器会为名为op_Addition的方法生成元数据方法定义项,还会设置一个specialname标志.表明这是一个特殊的方法.\n\n\n```csharp\npublic sealed class Complex\n{\n  public static Complex operator+(Complex c1, Complex c2){...}\n}\n```\n\n\n> FCL的System.Decimal类型很好地演示了如何重载操作符并根据Microsoft的设计规范定义友好的方法名.\n\n## 操作符方法的友好名称方法\n\n![](8方法/操作符.png)\n\n```csharp\npublic sealed class Complex\n{\n  // 重载操作符方法\n  public static Complex operator+(Complex c1, Complex c2){...}\n  // 定义友好方法,内部调用操作符重载方法\n  public static Complex Add(Complex c1, Complex c2){ return c1+c2;}\n}\n```\n\n> 作者认为这种额外的复杂性没必要,调用它们导致额外的性能损失.\n\n# 转换操作符方法\n\n将对象从一种类型转换为另一种类型.\n- 如果源类型和目标类型都是编译器识别的基元类型,编译器自己就知道如何生成转换对象所需的代码.\n- 如果不是,编译器会生成代码,要求CLR执行强制转型.\n- 转换操作符重载方法必须是 public static\n\n```csharp\ninternal sealed class Rational\n{\n    public Rational(Int32 num)\n    {...}\n\n    public Rational(Single num)\n    {...}\n\n    public Int32 ToInt32()\n    {...}\n\n    public Single ToSingle()\n    {...}\n\n    // implicit关键字告诉编译器为了生成代码来调用方法. 不需要在源代码中进行显示转换.\n    // 由一个Int32隐式构造并返回一个Rational\n    public static implicit operator Rational(Int32 num)\n    {\n        return new Rational(num);\n    }\n\n    // 由一个Single隐式构造并返回一个Single\n    public static implicit operator Rational(Single num)\n    {\n        return new Rational(num);\n    }\n\n    // explicit关键字告诉编译器只有在发现了显示转型时,才调用方法.\n    // 由一个Rational 显式返回一个Int32\n    public static explicit operator Int32(Rational r)\n    {\n        return r.ToInt32();\n    }\n\n    // 由一个Rational 显式返回一个Single\n    public static explicit operator Single(Rational r)\n    {\n        return r.ToSingle();\n    }\n}\n```\n\n- `implicit关键字`\n  - 该关键字告诉编译器为了生成代码来调用方法. 不需要在源代码中进行显示转换.\n- `explicit关键字`\n  - 该关键字告诉编译器只有在发现了显示转型时,才调用方法.\n\n关键字之后要指定operator关键字告诉编译器该方法是一个转换操作符, 在operator之后,指定对象要转换成什么类型,圆括号内指定要从什么类型转换.\n`public static explicit/implicit operator 目标类型(源类型 r)`\n\n定义完转换操作符之后,就可以写出像下面这样的C#代码:\n```csharp\nRational r1 = 5; // Int32隐式转型为Rational\nRational r2 = 2.5f;// Single隐式转型为Rational\n\nInt32 x = (Int32) r1; // Rational 显示转型为Int32\nSingle s = (Single) r2;// Rational显示转型为Single\n```\n\n**使用强制类型转换表达式时,C#生成代码来调用显示转换操作符方法, 使用C#的as或is操作符时,则永远不会调用这些方法.**\n\n要理解操作符重载和转换操作符方法. 建议用`System.Decimal`类型作为典型来研究.\n\n\n# 扩展方法\n\n理解C#扩展方法最好是从例子中学习.\n\n允许定义一个静态方法,并用实例方法的语法来调用. 只需要在第一个参数前添加this关键字.\n\n```csharp\npublic static class StringBuilderExtensions\n{\n    public static Int32 IndexOf(this StringBuilder sb, Char value)\n    {\n        ....\n    }\n}\n```\n\n这样就可以通过`Int32 index = sb.IndexOf('X');`方式去调用.\n\n编译这句话的过程:\n1. 首先检查`StringBuilder`类或者它的任何基类是否提供了参数为Char,名为IndexOf的一个实例方法.\n2. 如果有,就生成IL代码来调用它.\n3. 如果没有找到匹配的实例方法,就继续检查是否有任何静态类定义了名为IndexOf的静态方法,方法的第一个参数和类型和当前调用方法的表达式类型匹配,必须用this关键字标识.\n4. 编辑器就会找到`IndexOf(this StringBuilder sb, Char value)`方法,生成对应的IL代码来调用这个静态方法.\n\n\n## 扩展方法的规则和原则\n\n- C#**只支持扩展方法**,不支持扩展属性,扩展事件,扩展操作符等等.\n- 扩展方法(第一个参数前面有this的方法)必须在 **非泛型的静态类** 中声明.\n- 类名没有限制.\n- 至少要有一个参数,而且第一个参数能用 **this关键字标记**.\n- 扩展方法必须在 **顶级静态类** 中定义.具有 **整个文件的作用域** (不能嵌套在另一个类中而只有该类的作用域).\n- C#要求导入扩展方法所在的命名空间. 例如:在`Wintellect`命名空间下定义了一个扩展方法,那么别人访问这个扩展方法就需要添加`using Wintellect;`语句.\n- 如果多个静态类存在相同的扩展方法,就必须显示指定静态类(扩展方法所在类)的名称,明确指定.\n- 同时也会扩展派生类型.\n- 如果`StringBuilder`未来提供了`IndexOf`方法,则程序不会调用我的静态扩展方法,而是绑定微软提供的`IndexOf`方法.\n- 由于扩展方法实际是一个静态方法的调用.**CLR不会对调用的表达式进行null值检查(不保证非空)**.\n\n```csharp\nStringBuilder sb = null;\n// 调用扩展方法: NullReferenceException异常不会在调用IndexOf时抛出\n// 而会在,IndexOf内部的for循环中抛出\nsb.IndexOf('x');\n// 调用实例方法,NullReferenceException异常在调用Replace时抛出\nsb.Replace('x','!');\n```\n\n\n## 为接口类型定义扩展方法\n\n\n```csharp\nclass Program\n{\n\n    static void Main(string[] args)\n    {\n        // 每个char在控制台上单独显示一行\n        \"Grant\".ShowItems();\n\n        // 每个String在控制在单独显示一行\n        new[]{\"Jeff\",\"Kristin\"}.ShowItems();\n\n        // 每个Int32在控制台上单独显示一行\n        new List<Int32>(){1,2,3}.ShowItems();\n    }\n}\n\nstatic class ExClass\n{\n    // // 任何表达式只要它最终的类型实现了IEnumerable<T>接口,就能此调用扩展方法\n    public static void ShowItems<T>(this IEnumerable<T> collection)\n    {\n        foreach (var item in collection)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n```\n\n任何表达式只要它最终的类型实现了`IEnumerable<T>`接口,就能调用此扩展方法.\n\n### LINQ (Language Integrated Query) 语言集成查询\n\n想要仔细研究提供了许多扩展方法的一个典型类, System.LinQ.Enumerable及其所有静态扩展方法.这个类中每个扩展方法.\n\n\n##  为委托类型定义扩展方法\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 抛出NullReferenceException\n        Action<Object> action = o => Console.WriteLine(o.GetType());\n        // 吞噬NullReferenceException\n        action.InvokeAndCatch<NullReferenceException>(null);\n    }\n}\n\nstatic class ExClass\n{\n    public static void InvokeAndCatch<TException>(this Action<Object> d, Object o) where TException : Exception\n    {\n        try { d(o); }\n        catch (TException) { }\n    }\n}\n```\n\n## 向枚举类型添加扩展方法\n\n在15.3节有例子.\n\n## 创建委托来引用对象上的扩展方法\n\n```csharp\nAction a = \"Jeff\".ShowItems;\n\n// 调用(Invoke)委托,后者调用(call)ShowItems\n// 并向它传递对字符串\"Jeff\"的引用\na();\n```\n\n1. 编译器生成IL代码来构造一个Action委托.\n2. 创建委托时,会向构造器传递应调用的方法,同时传递一个对象引用,这个引用传给方法的隐藏this阐述.\n3. 正常情况下,创建引用静态方法的委托时,对象引用为null,因为静态方法没有this参数\n4. 这个例子中,C#编译器生成特殊代码创建一个委托来引用静态方法(ShowItems),而静态方法的目标对象是\"Jeff\"字符串的引用.\n5. 这个委托被调用时,CLR会调用静态方法,并向其传递对\"Jeff\"字符串的引用.\n\n\n\n### 关于invoke和call的翻译区别\n调用:\n- `invoke`:理解为`唤出`更为恰当,  需要先唤出某个东西帮你调用一个信息不明的方法时,用invoke比较恰当.\n- `call`:调用, 在执行一个所有信息都已知的方法时,用call比较恰当.\n\n## ExtensionAttribute特性类\n\n1. 一旦用this关键字标记了某个静态方法的第一个参数\n2. 编辑器就会在内部向该方法应用一个定制特性\n3. 此特性会在最终生成的文件的元数据中持久性的存储下来.\n4. 任何静态类只要包含扩展方法,它的元数据也会应用这个特效.\n\n\n# 分部方法\n\n假设用某个工具生成了C#源代码文件,并且这个类会让你定制类型的行为.\n一般做法:\n1. 定义个虚方法\n2. 从这个类派生并定义自己的类\n3. 重写虚方法,实现定制的行为\n\n```csharp\n//工具生成的代码，存储在某个代码文件中\ninternal class Base\n{\n    private String m_name;    \n    // 虚方法定义\n    protected virtual void OnNameChanging(String value){}\n\n    public String Name\n    {\n        get{return m_name;}\n        set{\n            OnNameChanging(value.ToUpper());\n            m_name=value;\n        }\n    }\n}\n//开发人员生成的代码。存储在另一个源代码文件中\ninternal class Derived:Base\n{\n    protected override void OnNameChanging(string value)\n    {\n        if(String.IsNullOrEmpty(value))\n            throw new ArgumentNullException(\"value\");\n    }\n}\n```\n\n这个做法有几个问题:\n1. 因为用到继承,所以基类不能是密封类,也不能用于值类型(值类型隐式密封).\n2. 不能用于静态方法,静态方法不能重写.\n3. 效率问题,如果派生类不重写方法,也会生成对ToUpper()进行调用的IL代码\n\n以下用 **分部方法** 功能来解决,并且在一些情况下能提升运行时性能:\n\n```csharp\n//工具生成的代码，存储在某个代码文件中\ninternal sealed partial class Base\n{\n    private String m_name;\n\n    // 分部方法的声明\n    partial virtual void OnNameChanging(String value);\n    public String Name\n    {\n        get{return m_name;}\n        set{\n            OnNameChanging(value.ToUpper());\n            m_name=value;\n        }\n    }\n}\n//开发人员生成的代码。存储在另一个源代码文件中\ninternal sealed partial class Base\n{\n    partial void OnNameChanging(string value)\n    {\n        if(String.IsNullOrEmpty(value))\n            throw new ArgumentNullException(\"value\");\n    }\n}\n```\n1. 类可以是密封类,静态类,值类型.\n2. 工具生成的代码包含分部方法的声明,要用partial关键字标记,无主体.\n3. 开发者生成的代码实现这个声明. 该方法也要用partial关键字标记,有主题.\n\n> 输入partial按空格能智能感知列出当前类型定义的还没有匹配实现的所有分部方法声明.\n\n**如果不提供自己的源文件(不需要修改工具生成的类型的行为),编译器编译工具生成的代码就不会包含任何代表分部方法的元数据,也不会生成任何调用分部方法的IL指令. 而且, 编译器不会生成对本该传给分部方法的实参进行求值的IL指令.** 在此例中,编译器不会生成调用ToUpper方法的代码. 使运行时的性能得到了提升.\n\n## 分部方法的规则和原则\n\n1. 只能在分部类或结构中声明.\n2. 分部方法的返回类型始终是void, 任何蚕食都不能用out修饰符来标记.\n  1. 是因为运行时,方法可能不存在(之前说过,可以不提供自己的实现代码),不能进行初始化(out参数必须进行初始化)\n3. 分部方法可以有ref参数,可以是泛型方法,可以使实例或静态方法,而且可以标记为unsafe.\n4. 分部方法的声明和实现必须有完全一致的签名.\n5. 分部方法总是被视为private方法,但C#编译器禁止在分部方法声明之前添加private关键字.\n6. 如果没有对应的实现部分,便不能在代码中创建一个委托来引用这个分部方法.\n","tags":["CLR读书笔记"]},{"title":"7常量和字段","url":"/2019/07/27/7常量和字段/","content":"\n# 常量\n\n`常量`是从不变化的符号. 它的值必须能在编译时确定. 编译器将常量值保存到程序集的元数据中. 这意味着只能定义编译器识别的基元类型常量.\n- Boolean\n- Char\n- Byte\n- SByte\n- Int16\n- UInt16\n- Int32\n- UInt32\n- Int64\n- UInt64\n- Single (float)\n- Double\n- Decimal\n- String\n\n特殊的是: C#允许定义非基元类型的常量变量,但是必须为null;\n\n`public const SomeType Empty = null;`\n\n定义常量将导致创建元数据,总是被视为静态成员,而不是实例成员.\n\n>  C#不允许为常量指定static关键字,因为常量是总是隐式的static.\n\n## 常量是怎么保存的?\n\n1. 代码引用常量符号时, 编译器在定义常量的程序集的元数据中查找符号,提取常量的值,将值嵌入生成的IL代码中.\n2. 由于常量的值直接嵌入代码,所以运行时不需要为常量分配任何内存.\n3. 不能获取常量的地址,也不能以传引用的方式传递常量\n4. 不能很好的支持跨程序集的版本控制\n\n## 常量的跨程序集问题\n\n```csharp\n// 程序集A 类TypeA\npublic const A = 50;\n```\n\n```csharp\n// 程序集B,引用了程序集A\nConsole.WriteLine(TypeA.A);\n```\n\n程序集B生成应用程序B之后, 用IL代码看出, **常量值直接嵌入IL代码**.\n\n如果程序集A,开发人员改变常量值为1000,只重新生成程序集A,应用程序B不会被影响,常量值还是50. 只有重新编译程序集B并生成才可以.\n\n如果希望在运行时从一个程序集中提取另一个程序集的值,不应该使用常量,而应该使用`readonly`字段.\n\n# 字段\n\n`字段`是一种数据成员,其中容纳了一个值类型的实例或者对一个引用类型的引用.\n\n\n![](7常量和字段/字段修饰符.png)\n\n> volatile 翻译为可变的, 其实它是短暂存在,易变的意思,因为可能有多个线程都想对这个字段进行修改. \"易变/易失\" 翻译更佳.\n\nCLR支持\n- 类型字段.(**静态**)\n  - 容纳字段数据所需的动态内存是在`类型对象`中创建时分配的. `类型对象`是在类型加载到`AppDomain`时创建的.\n\n> 类型对象通常是在引用了 **该类型的任何方法首次进行JIT编译** 的时候,将该类型加载到AppDomain中.\n\n- 实例字段.(**非静态**)\n  - 容纳字段数据所需的动态内存是在 **构造类型的实例时分配** 的.\n\n\n字段存储在动态内存中,它们的值在运行时才能获取.(字段还解决了常量存在版本控制问题). 此外字段可以使任何数据类型,不像常量仅仅局限于编译器内置的基元类型.\n\nCLR支持`readonly字段`和`read/write字段`.\n- `readonly字段`\n  - 只能在构造器方法中写入.(构造器方法只调用一次,即对象首次创建的时.)\n  - 编译器和验证机制确保readonly字段不会被构造器以外的任何方法写入.\n  - **可以利用反射来修改readonly字段(非常规手段反射,操作内存)**.\n\n更改上一段代码,程序集B的代码不需要改,这样如果修改程序集A的值为1000,程序集B不需要重新编译就能获取到新值.\n```csharp\n// 程序集A 类TypeA\n// 字段和类型关联需要用static关键字\npublic static readonly A = 50;\n```\n\n**当某个字段是引用类型,并且该字段被标记为readonly时,`不可变的是引用`,而不是`字段引用的对象`.**\n\n```csharp\n\npublic static readonly Char[] cc = new Char[]{'a','b','c'};\n...\n// 合法的,可以通过编译\ncc[0] = 'A';\n\n// 非法的,无法通过编译,因为不能让cc引用别的东西\ncc = new Char[]{'x','y','z'};\n```\n\n\n## 如何定义一个与类型本身关联的字段\n\n```csharp\n// 这是一个静态的readonly字段; 在运行时对它初始化\n// 它的值会被计算并存储到内存中\npublic static readonly Random s_random = new Random();\n\n// 静态的可读可写字段\nprivate static Int32 s_numberOfWrites = 0;\n\n// 实例只读的字段\npublic readonly String Pathname = \"Untitled\";\n\n// 实例可读可写的字段\nprivate System.IO.FileStream m_fs;\n\npublic SomeType(String pathname)\n{\n    // 修改只读字段Pathname\n    // 在构造器中可以这样做\n    this.Pathname = pathname;\n}\n```\n\n上述代码许多字段都是`内联初始化`的. C#允许使用这种内联初始化语法来初始化类的`常量`,`可读可写字段`和`readonly字段`.\n\nc#其实是在构造器对字段进行初始化的, 字段的内联初始化只是一种语法上的简化.(有些情况用内联语法需要考虑性能问题)\n\n> 内联初始化: 代码中直接赋值来初始化,而不是将对构造器的调用写出来.\n","tags":["CLR读书笔记"]},{"title":"6类型和成员基础","url":"/2019/07/23/6类型和成员基础/","content":"\n# 类型的各种成员\n\n- **常量**\n  - 是指出`数据值恒定不变`的符号, 总与类型关联,不与类型实例关联. 逻辑上总是静态成员.\n- **字段**\n  - 表示只读或可读/可写的数据值.\n  - 字段可以是静态的,这种被认为是`类型`状态的一部分.\n  - 字段也可以是实例非静态,这种被认为是`对象`状态的一部分.\n- **实例构造器**\n  - 将`新对象的实例字段`初始化的特殊方法.\n- **类型构造器**\n  - 将`类型的静态字段`初始化的特殊方法.\n- **方法**\n  - 是更改或查询类型或对象状态的函数.\n  - 作用于类型称为静态方法.\n  - 作用于对象称为实例方法.\n- **操作符重载**\n  - 实际上是方法.定义了操作符用于对象时应该如何操作该对象. 不是所有编程语言都支持,所以不属于CLS.\n- **转换操作符**\n  - 定义如何隐式或显示将对象从一种类型转换为另一种类型的方法.不是所有编程语言都支持,所以不属于CLS.\n- **属性**\n  - 允许用简单的字段风格的语法设置或查询类型或对象的逻辑状态,同时保证状态不被破坏.\n  - 作用于类型的称为静态属性.\n  - 作用于对象的称为实例属性.\n  - 属性可以无参(非常普遍)\n  - 多个参数(集合类用得多)\n- **事件**\n  - 静态事件允许`类型`向一个或多个`静态或实例方法`发送通知.\n  - 非静态(实例)事件允许`对象`向一个或多个静态或实例方法发送通知.\n  - 事件包含两个方法:允许静态或实例方法`登记`或`注销`对该事件的关注.\n  - 通常还用一个`委托字段`来维护`已登记`的方法集\n- **类型**\n  - 可以定义其他嵌套`类型` (`内/外部类`).\n\n > 元数据是整个Microsoft .Net Framework开发的关键 .元数据实现了编程语言,类型和对象的无缝集成.\n\n源代码中定义的所有成员都造成编译器生成元数据.有些数据还造成编译器生成额外的成员和额外的元数据.\n\n```csharp\n   public sealed class SomeType                              // 1\n   {\n       // 嵌套类\n       private class SomeNestedType { }                      // 2\n\n       // 常量\n       private const Int32 c_SomeConstant = 1;               // 3\n       // 只读\n       private readonly String m_SomeReadOnlyField = \"2\";    //4\n       // 静态可读/可写字段\n       private static Int32 s_SomeReadWriteField = 3;        // 5\n\n       // 类型构造器\n       static SomeType(){}                                    // 6\n\n       // 实例构造器\n       public SomeType(Int32 x){}                             // 7\n       public SomeType(){}                                    // 8\n\n       // 实例方法和静态方法\n       private String InstanceMethod(){ return null; }        // 9\n       public static void Main(){}                            // 10\n\n       // 实例属性\n       public Int32 SomeProp                                  // 11\n       {\n           get { return 0;}                                   // 12\n           set {  }                                           // 13\n       }\n\n       // 实例有参属性\n       public Int32 this[String s]                            // 14\n       {\n           get { return 0; }                                  // 15\n           set { }                                            // 16\n       }\n\n       // 实例事件\n       public event EventHandler SomeEvent;                   // 17\n```\n![](6类型和成员基础/IL成员代码.png)\n\n![](6类型和成员基础/IL图示.png)\n\n例如: 事件成员(17)造成编译器生成\n- 一个字段\n- 两个方法\n- 事件(一些额外的元数据)\n\n\n# 类型的可见性\n\n- **public** 类型:不仅对`定义程序集`中的所有代码可见,还对`其他程序集`中的代码可见.\n- **internal** 类型: 仅对`定义程序集`中的所有代码可见. 对其他程序集代码不可见.\n\n定义类型时如果不显示指定可见性,C#编译器会指定为`internal`.\n\n\n## 什么情况下要友元程序集?\n\n假设下述情形:\n一个公司有A团队和B团队, A团队定义了一组工具类,并希望团队使用这些类型. 但是他们不能将所有类型都生成到一个程序集中,而都要生成自己的程序集.\n\n为了使B团队使用A的工具类,A团队必须将工具类定义为`public`. 这样意味着工具类对所有程序集公开,连C团队也能使用. 这不是A团队所希望的.\n\n为了做到用`internal`定义工具类,同时B团队也能访问,C#可以通过`友元程序集`功能实现.\n\n### 示例做法\n\n1. 生成程序集时,用System.Runtime.CompilerServices命名空间下的InternalsVisibleTo特性,**标明它认为是友元的其他程序集**.\n2. 传入标识 **友元程序集名称** 和 **公钥的字符串参数**(不能包含版本,语言文化和处理器架构)\n3. 之后被标注的程序集能访问该程序集的 **所有internal类型**,以及 **这些类型的internal成员**.\n\n\n```csharp\nusing System.Runtime.CompilerServices;\n\n// 这里指定Wintellect和Microsoft是友元程序集\n[Assembly:InternalsVisibleTo(\"Wintellect, Publickey=12314..sbasd\")]\n[Assembly:InternalsVisibleTo(\"Microsoft, Publickey=asdas...basd\")]\n\ninternal sealed class SomeInternalType{...}\ninternal sealed class AnotherSomeInternalType{...}\n```\n\n\n> C#编译器在编译友元程序集(不含InternalsVisibleTo特性的程序集)要求使用/out:<file>开关, 因为编译器要知道准备编译的程序集的名称,从而判断生成的程序集是不是友元程序集.(意思是编译Wintellect和Microsoft程序集时,在代码编译结束前,C#编译器是不知道输出文件名的,因此使用/out:<file>能极大增强编译性能.)\n\n> 使用/t:module开关来编译模块,而且该模块还是友元程序集的一部分,那就需要C#编译器使用/moduleassemblyname:<string>开关来编译该模块.\n\n\n# 成员的可访问性\n\n每种编程语言都有自己的一组术语以及相应的语法. CLR自己定义了一组可访问性修饰符.\n\n例如:\n- CLR使用`Assembly`表明成员对同一程序集内的所有代码可见.\n- C#对应的术语是 `internal`\n\n![](6类型和成员基础/成员可访问性.png)\n\n表中总结了6个应用于成员的可访问性修饰符. 从第一行到最后一行按照限制最大到限制最小的顺序排列.\n\n- `private`:只能由`定义类型`和`任何嵌套类型`中的方法访问\n- `protected`: 能被`定义类型的方法`,`任何嵌套类型中的方法` 和`无论在什么程序集中`的`派生类型中的方法`访问.\n- `internal`: 只能被`当前定义的程序集中`的方法访问. (比public限制高,限制了程序集)\n- `protected internal`:能被`任何内/外部类(嵌套类)`, `无论在什么程序集中的派生类型`,`当前程序集中的任何方法`访问.\n- `public`: 能被`任何程序集中的任何方法`访问.\n\n\n在C#中,如果没有显示声明成员的可访问性,编译器通常默认选择private.\n\n> CLR 要求接口类型的所有成员都具有public可访问性. C#编译器因此禁止开发人员显示指定接口成员的可访问性.自动设为public.\n\nC#限制派生类重写基类方法需要具有相同的可访问性.\n\nCLR允许`放宽限制`,但不允许`收紧限制`(基类protected,派生类可以public,但不可以是private). 否则就无法派生类转为基类时,获取不到基类方法的访问权.\n\n\n# 静态类\n\n例如Console,Math,Environment,ThreadPool类,永远不需要实例化的类,只有static成员.\n\n`static`关键字定义不可以实例化的类. 只能应用于类,不能应用于结构(值类型). CLR总是允许值类型实例化.\n\n## C#编译器对静态类做了如下限制\n\n1. 静态类必须直接从基类System.Object派生. 继承只适用于对象,静态类不能创建实例.因此从其他任何积累下派生都没有意义.\n2. 静态类不能实现任何接口. 只有使用类的实例时,才能调用类的接口方法.\n3. 静态类只能定义静态成员(字段,方法,属性和事件).\n4. 静态类不能作为字段,方法参数或局部变量使用. 因为它们都代表引用实例的变量.\n\n> IL会将static定义类标记为absrtact和sealed. 并且不生成实例构造器方法.\n\n\n# 分部类,结构和接口\n\n`partial` 关键字告诉C#编译器: 类,结构或接口的定义源代码可能要分散到一个或多个源代码文件中.\n\n1. 源代码控制\n  - 多个程序员修改一个类,使用`partial`为多个文件后,每个文件可以单独签出,多个程序员能同时编辑类型.\n2. 在同一个文件中将类或结构分解不同的逻辑单元\n  - 有时会创建一个类型提供多个功能,为简化实现,会在源代码中重复声明一个分部类型,分部类型的每个部分都实现一个功能.也可以完整的删除一个功能.\n3. 代码拆分\n\n\n**要将`partial`关键字应用于所有文件中的类型. 编译到一起时, 编译器会合并代码. 分部类功能完全由C#编译器实现. CLR对此一无所知.**\n\n# C#关键字及其对组件版本控制的影响\n\n![](6类型和成员基础/C#关键字及其对组件版本控制的影响.png)\n\n这些关键字直接对应CLR用于支持组件版本控制的功能.\n\n# CLR如何调用虚方法,属性和事件\n\n> 属性和事件实际作为方法实现.\n\n## 方法是什么?\n\n方法代表类型或类型上的实例上执行某些操作的代码. 在类型上操作是静态方法,在实例上操作是非静态方法.\n\n## CLR允许定义多个同名方法,根据返回类型不同或者参数不同\n\n**除了IL语言,包括C#大多数语言在判断方法的唯一性时,除了方法名之外,都只以参数为准,方法返回类型会被忽略.**\n\n- 非虚实例方法 `public Int32 MethodA()`\n- 虚方法`public virtual String MethodB()`\n- 静态方法`public static Int32 MethodC()`\n\n 编译这些方法,编译器会在程序集的方法定义表中写入记录项,每个记录项都用一组`flag标志`指明方法的类型.\n\n 调用这些方法时, 生成调用代码的编译器会检查方法定义的`标志flag`,来生成对应的IL代码来调用.\n\n## callvirt和call指令调用非虚方法,虚方法,静态方法\n\n CLR提供两个方法调用指令:\n 1. call\n   - 用call指令调用静态方法,必须指定定义此静态方法的类型.\n   - 用call指令调用实例方法或虚方法,必须指定引用了对象的变量(就是调用方法的变量的定义类型).\n     - 如果调用方法的变量没有定义此方法,就会检查基类来查找匹配方法.\n   - 常用于以非虚方式调用虚方法.\n 2. callvirt\n   - 用callvirt可调用实例方法和虚方法,不能调用静态方法.\n   - 必须指定引用了对象的变量.\n   - 用callvirt调用非虚方法,变量的类型指明了方法的定义类型.\n   - 用callvirt调用虚实例方法,CLR会调查发出的调用对象的实际类型,然后以多态方式调用方法.\n   - 为了确定类型,发出调用的变量不能为null. JIT编译器会生成代码来验证变量的值是不是null.(抛出NUllReferenceException异常)\n   - 用callvirt调用非虚实例方法也会执行这种null检查. 所以用callvirt指令执行速度比call指令稍慢.\n\n\n```csharp\n// 调用静态方法\nConsole.WriteLine();\n\nObject o = new Object();\n// 调用虚方法\no.GetHashCode();\n// 调用非虚方法\no.GetType();\n```\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       28 (0x1c)\n  .maxstack  1\n  .locals init (object V_0)\n  IL_0000:  nop\n  // 静态方法会使用call指令\n  IL_0001:  call       void [System.Console]System.Console::WriteLine()\n  IL_0006:  nop\n  IL_0007:  newobj     instance void [System.Runtime]System.Object::.ctor()\n  IL_000c:  stloc.0\n  IL_000d:  ldloc.0\n  // 这里用callvirt 是因为GetHashCode是虚方法\n  IL_000e:  callvirt   instance int32 [System.Runtime]System.Object::GetHashCode()\n  IL_0013:  pop\n  IL_0014:  ldloc.0\n  // 这里用callvirt , Type是非虚方法,在JIT编译好的代码中会以非虚方式调用\n  // 为什么不用直接用call指令呢? 因为C#团队认为JIT编译器应生成代码来验证发出调用的对象不为null\n  IL_0015:  callvirt   instance class [System.Runtime]System.Type [System.Runtime]System.Object::GetType()\n  IL_001a:  pop\n  IL_001b:  ret\n} // end of method Program::Main\n\n```\n\n如果调用非虚方法时, C#编译器生成的是callvirt指令,那么发出调用的对象如果为null就会抛出异常.\n\nC#用`callvirt`指令调用所有 **实例方法**. 用`call`指令调用 **静态方法**.\n\n> 不建议把非虚方法改为虚方法. 这是因为某些编译器会用call而不是callvirt指令调用非虚方法. 并且引用此方法的代码没有重新编译,就会造成应用程序行为无法预料. 用C#写的引用代码不会出问题,因为C#用callvirt指令调用所有实例方法.\n\n## 编译器有时用call而不是callvirt调用虚方法.\n\n特殊的语句:`base.ToString();`\n\n```csharp\npublic override String ToString()\n{\n  // 编译器使用IL指令call\n  // 以非虚方式调用Object的ToString方法\n\n  // 如果编译器用callvirt而不是call\n  // 那么该方法将递归调用自身,直至栈溢出\n  return base.ToString();\n}\n// 如果编译器生成的是callvirt,那么是以虚方式(多态方式)调用, base.ToString还是会调用到重写的当前方法中\n// 再次执行base.ToString导致循环\n// call则是以非虚的方式调用,不会调用到重写的方法中,而是基类自己的ToString方法.\n```\n\n因为callvirt是以虚方式调用, 会导致base.ToString递归执行,直至线程栈溢出.\n\n**编译器调用值类型定义的方法时倾向于使用call指令,因为值类型时密封的,即使有虚方法也不用考虑多态性. 值类型的实例的本质保证它永不为null. 所以永远不抛出NullReferenceException异常.**\n\n如果以虚方式调用值类型的虚方法,CLR要获取对值类型的对象的引用,以便引用方法表.需要装箱.\n\n## call和callvirt的区别\ncall的callvirt的区别主要有两点：\n\n- `call`可以调用 **静态方法**，`实例方法和虚方法`\n- `call`一般是以 **非虚的方式** 来调用函数的.\n\n- `callvirt`不能调用 **静态方法**,只能调用`实例方法和虚方法`，\n- `callvirt`是以 **已多态(虚方式)的方式** 来调用函数的.\n\n## 设计类型时要注意\n\n1. 虚方法的调用速度比调用非虚方法慢.\n2. JIT编译器不能内嵌虚方法. 进一步影响性能\n3. 使最复杂(参数最多)的方法成为虚方法,使所有重载的简便方法成为非虚方法.\n\n\n```csharp\nprivate Int32 m_lenth = 0;\n\n// 重载的简便方法是非虚的\npublic Int32 Find(Object value)\n{\n    return Find(value,0,m_lenth);\n}\n\n// 重载的简便方法是非虚的\npublic Int32 Find(Object value, Int32 startIndex)\n{\n    return Find(value,0,m_lenth -startIndex);\n}\n\n// 功能最丰富的方法是虚方法,可以被重写\npublic virtual Int32 Find(Object value, Int32 startIndex, Int32 endIndex)\n{\n    // 可被重写的实现写这里..\n    //.....\n}\n```\n\n\n# 合理使用类型的可见性和成员的可访问性\n\n默认生成的类是非密封里, 允许使用关键字`sealed`将类型显示标记为密封.\n\n- 性能更好\n  - **如果调用的是密封类的虚方法(C#编译器在生成callvirt指令), JIT会优化并生成代码用非虚方式调用.**\n\n调用虚方法在性能上不及调用非虚方法, 因为CLR必须在运行时查找对象的类型,判断要调用的方法由哪个类型定义.\n\n如果JIT编译器看到使用的是密封类型的虚方法调用, 密封类不会有派生类,就可以采用非虚的方式调用虚方法(call指令),从而生成更高效的代码.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Point p = new Point(3,4);\n        // C#编译器在此生成callvirt调用虚方法\n        // 但是JIT编译器会优化这个调用,并生成\n        // 代码来非虚地调用ToString,是因为Point是密封类\n        Console.WriteLine(p.ToString());\n    }\n}\npublic sealed class Point\n{\n    private Int32 m_x, m_y;\n\n    public Point(int mX, int mY)\n    {\n        m_x = mX;\n        m_y = mY;\n    }\n    public override string ToString()\n    {\n        return String.Format($\"{m_x},{m_y}\");\n    }\n}\n```\n\n开发人员希望从现有类型派生出一个类,在其中添加额外字段或状态信息. 还希望在派生类中定义`帮助方法(helper method)`或`简便方法(convenience method)`来操作这些额外的字段. 如果是密封类就不合适,可以利用C#的扩展方法来模拟`帮助方法`, 还可以利用`ConditionalWeakTable类`模拟跟踪状态.\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型3","url":"/2019/07/19/5基元类型引用类型和值类型3/","content":"# 回顾总结\n\n2019年8月23日\n\n1. 需要装箱的情况\n\t- 值类型重写的虚方法如果要调用基类的实现,就需要装箱传this指针引用给基方法\n\t- 如果重写基类的虚方法(不需要调用基类实现)就不需要装箱\n\t- 要调用非虚的,继承的方法(GetType)无论如何都要对值类型进行装箱\n\t- 将值类型转型为接口时,进行装箱. 因为接口变量是引用类型\n\n2. 使用接口方法修改已装箱值类型中的字段,在C#中,不用接口方法便无法做到.\n\t- `((IChangeBoxedPoint) o).Change(5,5); // 修改已装箱对象中的值`\n\t- `((Point) o).Change(3, 3); // 值复制到栈上,只在栈上修改`\n\n3. 值类型应该是不可变的,不应该定义任何会修改实例字段的成员,建议标记成`readonly`\n\n4. dynamic(动态绑定)基元类型\n\t- C#编译器允许将表达式/变量的类型标记为`dynamic`\n\t- 对于CLR, `dynamic`与`Object`完全一致.\n\t- C#编译器会生成`payload有效载荷`代码,在运行时检查`var`的实际类型,调用对应的重载版本.\n\t- 编译器 **不允许** 写代码将表达式从Object隐式转成其他类型. 必须显示转型.\n\t- 编译器 **允许** 使用隐式转型语法将表达式从dynamic转型为其他类型.\n\t\t- 运行时,dynamic类型不兼容要转型的类型,则会抛出`InvalidCastException`.\n\t\t- 返回值result具有dynamic类型. 如果运行时调用M方法.返回类型是void,将抛出RuntimeBinderException异常.\n\t- 变量/表达式用dynamic会生成 payload代码,进行动态调度.\n\t- 不能定义对dynamic进行扩展的扩展方法.\n\t- 不能将lanmbda表达式和匿名方法作为实参传给dynamic方法调用. 因为编译器推断不了类型.\n\t- 在foreach或者using语句中的资源被指定了dynamic表达式, 编译器分别将表达式转型为非泛型System.IEnumerable接口或System.IDispose接口.\n\t\t- 转型失败会抛出`RuntimeBinderException`异常.\n\n5. var和dynamic\n\t- var只能用在方法内部声明局部变量,必须显式初始化此变量\n\t- 表达式不能转型为var,但是能转型dynamic,也无需初始化用dynamic声明的变量.\n\n6. dynamic可以显著简化一些反射的代码\n\t- 但是会对性能产生影响\n\t- 如果只是一两个地方需要动态行为,反射做法或许更高效\n\t- dynamic的一个限制是只能访问对象的实例成员,因为dynamic变量必须引用对象\n\n\n# 什么时候需要装箱\n\n- 第一种情况: 将`值类型的实例`传给需要`获取引用类型`的方法.\n\n要获取`值类型`的引用,实例就必须`装箱`.\n\n未装箱值类型比引用类型更\"轻\",归结于\n1. 不在托管堆上分配\n2. 没有堆上的每个对象都有的额外成员:`类型对象指针`和`同步块索引`\n\n其中,由于未装箱值类型没有`同步块索引`,所以不能使用`System.Threading.Monitor(提供同步访问对象的机制)`类型的方法(或C#lock语句),让多个线程同步对实例的访问.\n\n- 第二种情况: 值类型如果`重写的虚方法`(例如Equals,ToString...)方法要`调用基类的实现`时,会`装箱`,通过this指针将`引用`传给基方法.\n\n虽然未装箱的值类型没有`类型对象指针`,但仍可以调用由类型`继承或重写的虚方法`.(比如Equals,GetHashCode,ToString).\n\n值类型可以重写Equals, GetHashCode或者ToString的虚方法，CLR可以非虚地调用该方法，因为值类型是隐式密封的（即不存在多态性），没有任何类型能够从它们派生。如果你重写的虚方法要`调用方法在基类中的实现`，那么在调用基类的实现时，`值类型实例就会装箱`，以便通过`this指针`将对一个堆对象的`引用`传给基方法。\n\n- 第三种情况:\n\n调用非虚的,继承的方法时(比如`GetType`或者`MemberwiseClone`),**无论如何都要对值类型进行装箱**, 因为这些方法由`System.Object`定义,要求this实参是指向`堆对象`的指针.\n\n- 第四种情况:\n\n将值类型的未装箱实例 **转型为某个接口时** 要对实例进行装箱. 是因为接口变量必须包含对堆对象的引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point : IComparable\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        // 重写从System.ValueType继承的ToString方法.\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n        // 实现类型安全的CompareTo方法\n        public Int32 CompareTo(Point other)\n        {\n            // Math.sign方法用来判断一个数到底是正数、负数、还是零。\n            // 利用勾股定理计算哪个Point离(0,0)更远\n            return Math.Sign(\n                Math.Sqrt(m_x * m_x + m_y * m_y) - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));\n        }\n        // 实现IComparable接口的CompareTo方法\n        public int CompareTo(object obj)\n        {\n            if (GetType() != obj.GetType()) throw new ArgumentException(\"obj is not a point\");\n            // 调用类型安全的CompareTo方法\n            return CompareTo((Point) obj);\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p1 = new Point(10,10);\n            Point p2 = new Point(20,20);\n\n            // 调用Point重写的ToString(虚方法)方法,不装箱p1\n            Console.WriteLine(p1.ToString());\n\n            // 调用GetType(非虚方法)时, 要对p1进行装箱\n            // 调用非虚的,继承的方法时, 无论如何都要对值类型进行装箱\n            // 因为这些方法由System.Object定义,要求this实参是指向堆对象的指针.\n            Console.WriteLine(p1.GetType()); // 显示ConsoleApp1.Point\n\n            // p1调用的是CompareTo(Point other),所以p2不需要装箱\n            Console.WriteLine(p1.CompareTo(p2)); // 显示 -1\n\n            // 装箱p1, 引用放到c中\n            // 将值类型的未装箱实例 转型为某个接口时 要对实例进行装箱\n            IComparable c = p1;\n            Console.WriteLine(c.GetType()); // 显示ConsoleApp1.Point\n\n            // 由于向CompareTo传递的不是Point变量,\n            // 所以调用的是CompareTo(object obj),c不需要装箱,\n            // 因为已经是引用了已装箱的Point\n            Console.WriteLine(p1.CompareTo(c)); // 显示0\n\n            // c是引用类型,不需要装箱\n            // c调用的是IComparable的CompareTo(object obj)方法\n            // 所以p2要装箱\n            Console.WriteLine(c.CompareTo(p2)); // 显示-1\n\n            // 对c拆箱, 字段复制到p2中\n            p2 = (Point) c;\n            Console.WriteLine(p2.ToString()); // 显示(10,10)  证明已经复制到栈\n        }\n    }\n}\n```\n\n上述代码演示了涉及装箱和拆箱的几种情形\n1. 调用ToString\n  - p1.ToString()时, p1不必装箱,**因为ToString是从基类System.ValueType继承的虚方法.**\n\n> 通常,为了调用虚方法,CLR需要判断对象的类型来定位类型的方法表,由于p1是未装箱的值类型,,所以不存在 **类型对象指针** 这个成员. 但是JIT编译器发现Point重写了ToString方法,所以会 **直接生产代码来直接(非虚地)调用重写的这个ToString方法** . 这里不存在多态性,没有类型能从它派生以提供虚方法的另一个实现. **但是如果Point.ToString方法内部调用了base.ToString() ,那么调会调用System.ValueType的ToString方法,值类型实例就会装箱.**\n\n2. 调用GetType\n  - 调用非虚方法GetType时,p1必须装箱.  因为Point的`GetType`方法从`System.Object`继承的,**CLR必须使用指向类型的指针,这个指针只能通过装箱p1来获得.**\n3. 调用CompareTo第一次\n  - p1.CompareTo(p2)时,p1不用装箱,因为Point实现了CompareTo(Point other)方法,编译器直接调用它,并且传递的是值类型对象,不需要装箱.\n4. 转型为IComparable\n  - p1转型为接口类型c时必须装箱. **因为接口被定义为引用类型.**\n5. 调用CompareTo第二次\n  - p1.CompareTo(c)时,传递的是接口变量c,所以编译器调用的是重载版本的CompareTo(object obj),要传递引用指针, c是引用了一个已装箱的Point,所以无序额外装箱.\n6. 调用CompareTo第三次\n  - c.CompareTo(p2)时,c是引用堆上的已装箱Point对象,还是IComparable接口类型,只能调用接口的CompareTo(object obj)方法, 因此p2需要装箱.\n7. 转型为Point\n  - 将c引用的堆上对象拆箱成Point复制到栈上的p2.\n\n\n## 使用接口更改已装箱值类型中的字段(不应该这样做)\n\n来看看你的理解程度,答出控制台输出什么.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point\n    {\n        private Int32 m_x, m_y;\n\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p);\n\n            p.Change(2, 2);\n            Console.WriteLine(p);\n\n            Object o = p;\n            Console.WriteLine(o);\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o);\n        }\n    }\n}\n```\n答案:\n1,1\n2,2\n2,2\n2,2\n\n解析:\n重点说下`((Point) o).Change(3, 3);`\n\n`Object o`对象对于`Change`方法一无所知, 所以需要`拆箱转型到Point`.\n  - 拆箱转型过程\n    - 将已装箱的Point中的字段 **复制到线程栈** 上的一个 **临时Point** 中.\n    - 这个栈上的Point的m_x和m_y字段会变成3,3\n    - 但是在堆上已装箱的Point里的值不受这个Change调用的影响.所以最后输出的Object o是堆上的2,2\n\n\n有的语言(比如C/C++)允许更改已装箱值中的字段,但是C#不允许. 不过,可以用接口欺骗C#,让它允许这个操作.代码如下:\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal interface IChangeBoxedPoint\n    {\n        void Change(Int32 x, Int32 y);\n    }\n    internal struct Point : IChangeBoxedPoint\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }    \n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p); // 1,1\n\n            p.Change(2, 2);\n            Console.WriteLine(p); // 2,2\n\n            Object o = p;\n            Console.WriteLine(o); // 2,2\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o); // 2,2\n\n            // 将P转型接口,装箱\n            // 在已装箱的值上调用Change, 堆上已装箱的值就变为4,4\n            // 并没有引用指向这个已装箱值,即将被垃圾回收掉\n            // 未装箱的Point p仍然是2,2\n            ((IChangeBoxedPoint) p).Change(4,4);\n            Console.WriteLine(p);// 2,2\n\n            // 将引用类型o转成IChangeBoxedPoint,才能使用Change方法\n            // 不需要装箱,因为o本来就是已装箱的Point\n            // Change(5,5);正确修改了已装箱的值\n            ((IChangeBoxedPoint) o).Change(5,5);\n            Console.WriteLine(o); //  5,5\n        }\n    }\n}\n```\n**演示接口方法如何修改已装箱值类型中的字段,在C#中,不用接口方法便无法做到.**\n\n**值类型应该是\"不可变\"(immutable). 也就是说我们不应该定义任何会修改实例字段的成员.建议将值类型字段都标记为readonly.** 否则容易写出一个试图更改字段的方法,就会产生非预期的行为. 标记readonly后,编译时就会报错.前面的例子清楚的揭示了为什么这样做.\n\n**FCL的核心值类型(Byte,Int32,UInt32,Int64,UInt64,Single,Double,Decimal,BigInteger,Complex以及所有枚举)都是`不可变`的.**\n\n> 不可变(immutable)： 即对象一旦被创建初始化后，它们的值就不能被改变，之后的每次改变都会产生一个新对象。\n\n所以，对于不变对象来说，调用对象自身的任意方法，也`不会改变该对象自身的内容`。相反，这些方法会创建`新的对象`并返回，这样，就保证了不可变对象本身永远是不可变的。\n\n\n# dynamic(动态绑定)基元类型\n\nC#是类型安全的编程语言. 意味着所有表达式都解析成类型的实例,编译器生成的代码只执行对该类型有效的操作.\n\n类型安全的优势:\n1. 许多错误能在编译时检测到\n2. 能编译出更小,更快的代码. 是因为能在编译时进行更多预设,并在生成的IL和元数据中落实预设.\n\n\n为了方便开发人员使用`反射`或者与其他组件通信.C#编译器允许将`表达式/变量的类型`标记为`dynamic`.\n\n**对于CLR, dynamic与Object完全一致.**\n\n\n## dynamic 变量/表达式\n\n**变量/表达式 使用dynamic的话,编译器会生成`payload有效载荷代码`根据运行时具体的类型来决定执行的操作.**\n\n> 编译器生成特殊IL代码来描述所需操作,这种特殊的代码称为payload有效载荷.\n\n在运行时,`payload有效载荷`代码根据dynamic`表达式/变量`引用的对象的实际类型来决定具体执行的操作.\n\n\n```csharp\nstatic void Main(string[] args)\n{\n    // dynamic 局部变量:编译器会将dynamic转成System.Object.\n    // 值类型会装箱.\n    dynamic val;\n    for (Int32 demo = 0;  demo<2 ;demo ++)\n    {\n        // dynamic 表达式 : 编译器会生成payload代码\n        val = (demo == 0) ? (dynamic) 5 : (dynamic) \"A\";\n        // 两个操作数的类型是dynamic\n        val = val + val;\n        // 传入dynamic类型参数, C#编译器会生成payload代码\n        // 在运行时检查val的实际类型.\n        // 调用对应的重载版本.\n        M(val);\n    }\n}\nprivate static void M(Int32 n)\n{\n    Console.WriteLine($\"M(Int32):{n}\");\n}\n\nprivate static void M(String s)\n{\n    Console.WriteLine($\"M(String):{s}\");\n}\n```\n输出:\nM(Int32):10\nM(String):AA\n\n由于val是dynamic类型,C#编译器生成payload代码在`运行时`检查value的实际类型,然后决定`+`操作符实际要做什么.\n1. 第一个循环中: val = 5(Int32值),结果是10 .\n2. `M(val);`传入dynamic类型参数, C#编译器会生成`payload有效载荷代码`,在`运行时`检查val的实际类型,调用对应的重载版本.\n\n**所有表达式都能隐式转型为dynamic,因为所有表达式最终都生成从Object派生的类型(值类型需要装箱).**\n\n正常情况下:\n1. 编译器 **不允许** 写代码将`表达式`从`Object`隐式转成其他类型. 必须显示转型.\n2. 但是,编译器 **允许** 使用隐式转型语法将`表达式`从`dynamic`转型为其他类型.\n  - 虽然编译器允许省略显示转型,但CLR会在运行时验证来确保类型的安全性.\n  - 运行时,dynamic类型不兼容要转型的类型,则会抛出InvalidCastException.\n\n```csharp\nObject o1 = 123;    // OK: 从值类型隐式转型为Object,装箱\n//Int32 n1 = o1;    // Error: 不允许从Object隐式转型到Int32\n\nInt32 n2 = (Int32) o1; // OK: 显示转型, 拆箱\n\ndynamic d1 = 123;    // OK: 从值类型隐式转为dynamic,装箱\nInt32 n3 = d1;       // OK: 从dynamic隐式转为值类型,拆箱\n```\n\n```csharp\n// 编译出的IL代码会对值类型123进行装箱\ndynamic d = 123;\n// d引用了已装箱的Int32\nvar result = M(d); // var result 等同于 dynamic result\n```\n上述代码之所以能通过编译,是因为编译器不知道调用哪个方法,也不知道返回的类型,所以编译器假定result具有dynamic类型. 如果运行时调用M方法.返回类型是void,将抛出`Microsoft.CSharp.RuntimeBinder.RuntimeBinderException`异常.\n\n> var声明局部变量是一种简化语法,要求编译器根据表达式推断具体数据类型. 只能用在方法内部声明局部变量,必须显式初始化用var声明的变量.\n\n表达式不能转型为var,但是能转型dynamic,也无需初始化用dynamic声明的变量.\n\n\n\n## dynamic 字段/方法参数/方法返回值\n\n**字段/方法参数/方法返回值 是dynamic类型, 编译器会将dynamic转成System.Object.**\n\nC#编译器会将该类型转换为`System.Object`,并在元数据中向`字段/参数/返回类型`应用`System.Runtime.CompilerServices.DynamicAttribute`的实例.\n\n如果指定`局部变量`被指定为dynamic, 则变量类型也会成为Object,局部变量不会应用`DynamicAttribute`,因为限制在方法内部使用.\n\n**由于dynamic其实就是Object,所以方法签名不能仅靠dynamic和Object来区分.**\n\n## dynamic 泛型类(引用类型),结构(值类型),接口,委托,方法的泛型类型实参\n\n**泛型类(引用类型),结构(值类型),接口,委托,方法** 的`泛型类型实参`也可以是dynamic,编译器将dynamic转为Object. 向必要的元数据应用`DynamicAttribute`.\n\n> 泛型方法是已经编译好的,会将类型视为Object,**编译器不在泛型代码中生成`payload`代码.所以不会执行动态调度.**\n\n\n重要提示:\n1. **对于CLR, dynamic与Object完全一致.**\n2. `变量/表达式`用dynamic会生成 payload代码,进行动态调度.\n3. 不能定义对dynamic进行扩展的扩展方法.\n4. 不能将`lanmbda表达式`和`匿名方法`作为实参传给dynamic方法调用. 因为编译器推断不了类型.\n5. 在`foreach`或者`using语句中的资源`被指定了`dynamic表达式`, 编译器分别将表达式转型为非泛型System.IEnumerable接口或System.IDispose接口.\n  - 转型成功,就是用表达式,代码正常运行.\n  - 失败就抛出Microsoft.CSharp.RuntimeBinderException异常.\n\n\n\n\n# dynamic 具体用法\n\n什么是动态化(dynamification)?\n- 在为COM对象生成可由\"运行时\"调用的包装(warpper)程序集是,COM方法中使用任何`VARIANT`实际都转换成`dynamic`.\n\n```csharp\n// 如果没有dynamic类型,就需要转型成Range类型,才能访问Value属性\n((Range)execel.Cells[1,1]).Value = \"Text\";\n\n// 由于excel.Cells[1,1]是dynamic类型,所以不需要显示转型.\nexecel.Cells[1,1].Value = \"Text\";\n```\n\n## 利用反射和dynamic的例子\n\n```csharp\nObject target = \"ABC\";\nObject arg    = \"ff\";\n\n// 在目标上查找和希望的实参类型匹配的方法.\n// 从目标target的String类型上查找 方法名MethodA,参数的类型String的方法信息\nType[]     argTypes = new Type[] {arg.GetType()};\nMethodInfo method   = target.GetType().GetMethod(\"MethodA\", argTypes);\n\n// 在目标上调用方法,传递实参\"ff\"\nObject[] arguments = new Object[] {arg};\nBoolean  result    = Convert.ToBoolean(method.Invoke(target, arguments));\n\n\n// 利用dynamic简化上述代码写法\ndynamic target1 = \"ABC\";\ndynamic arg1    = \"ff\";\nresult = target1.MethodA(arg1);\n```\n\n可以看到显著简化的语法.\n\n## payload代码\n\nC#编译器会生成payload代码,在运行时根据对象的实际类型判断要持续什么操作.\n\n这些payload代码使用了称为`运行时绑定器(RuntimeBinder)`的类.\n\nC# `运行时绑定器(RuntimeBinder)`的代码在Microsoft.CSharp.dll程序集中. 生成使用dynamic关键字就必须引用该程序集(默认的csc.rsp中已经引用了该程序集).\n\n> 是这个程序集中的代码知道在运行时生成代码,在+操作符2个Int32执行加法,+操作符两个string时执行连接.\n> 运行时绑定器(RuntimeBinder) 首先检查类型是否实现了IDynamicMetaObjectProvider接口. 如果是就调用接口的GetMetaObject方法, 返回的类型`DynamicMetaObject的派生类型`能处理对象的多有成员,方法和操作符绑定.\n\n\npayload代码执行时,会在运行时生成动态代码; 这些代码进入驻留于内存的程序集,即\"匿名寄宿的DynamicMethods程序集(Anonymously Housted DynamicMethods Assembly)\",作用是当特定的`call site(发生调用处)`使用具有相同运行时类型的动态参数发出大量调用时增强动态调度的性能.\n\n### C#内建的动态功能所产生的额外开销不容忽视\n\n虽然动态功能能简化语法,但也要加载这些程序集以及额外的内存消耗,会对内存造成额外的影响.\n- Microsoft.CSharp.dll\n- System.dll\n- System.Core.dll\n- System.Dynamic.dll (如果使用dynamic与COM组件互操作)\n\n## 什么时候使用dynamic\n\n1. 如果程序只是 一两个地方需要动态行为,传统(反射)做法或许更高效. 托管对象则调用反射方法,COM对象则进行手动类型转换.\n2. 如果在动态表达式中使用的对公对象未实现IDynamicMetaObjectProvider接口,C#编译器会将对象视为C#定义的普通类型的实例,利用反射在对象上执行操作.\n\n## dynamic的限制\n\ndynamic的一个限制是只能访问对象的实例成员,因为dynamic变量必须引用对象.但有时需要动态调用运行时才能确定一个类型的静态成员.\n\n## 实现动态调用类型的静态成员方法\n\n作者实现的`StaticMemberDynamicWrapper`从`DynamicObject`派生,实现了接口`IDynamicMetaObjectProvider`.\n```csharp\n        /// <summary>\n        /// 构造一个 'dynamic' 的实例派生类，来动态调用类型的静态成员\n        /// </summary>\n        internal sealed class StaticMemberDynamicWrapper : DynamicObject //P(132)\n        {\n            private readonly TypeInfo m_type;\n            public StaticMemberDynamicWrapper(Type type) { m_type = type.GetTypeInfo(); }\n\n            public override IEnumerable<String> GetDynamicMemberNames()\n            {\n                return m_type.DeclaredMembers.Select(mi => mi.Name);\n            }\n\n            public override bool TryGetMember(GetMemberBinder binder, out object result)\n            {\n                result = null;\n                var field = FindField(binder.Name);\n                if (field != null) { result = field.GetValue(null); return true; }\n\n                var prop = FindProperty(binder.Name, true);\n                if (prop != null) { result = prop.GetValue(null, null); return true; }\n                return false;\n            }\n\n            public override bool TrySetMember(SetMemberBinder binder, object value)\n            {\n                var field = FindField(binder.Name);\n                if (field != null) { field.SetValue(null, value); return true; }\n\n                var prop = FindProperty(binder.Name, false);\n                if (prop != null) { prop.SetValue(null, value, null); return true; }\n                return false;\n            }\n\n            public override Boolean TryInvokeMember(InvokeMemberBinder binder, Object[] args, out Object result)\n            {\n                MethodInfo method = FindMethod(binder.Name, args.Select(a => a.GetType()).ToArray());\n                if (method == null) { result = null; return false; }\n                result = method.Invoke(null, args);\n                return true;\n            }\n\n            private MethodInfo FindMethod(String name, Type[] paramTypes)\n            {\n                return m_type.DeclaredMethods.FirstOrDefault(mi => mi.IsPublic && mi.IsStatic && mi.Name == name && ParametersMatch(mi.GetParameters(), paramTypes));\n            }\n\n            private Boolean ParametersMatch(ParameterInfo[] parameters, Type[] paramTypes)\n            {\n                if (parameters.Length != paramTypes.Length) return false;\n                for (Int32 i = 0; i < parameters.Length; i++)\n                    if (parameters[i].ParameterType != paramTypes[i]) return false;\n                return true;\n            }\n\n            private FieldInfo FindField(String name)\n            {\n                return m_type.DeclaredFields.FirstOrDefault(fi => fi.IsPublic && fi.IsStatic && fi.Name == name);\n            }\n\n            private PropertyInfo FindProperty(String name, Boolean get)\n            {\n                if (get)\n                    return m_type.DeclaredProperties.FirstOrDefault(\n                       pi => pi.Name == name && pi.GetMethod != null &&\n                       pi.GetMethod.IsPublic && pi.GetMethod.IsStatic);\n\n                return m_type.DeclaredProperties.FirstOrDefault(\n                   pi => pi.Name == name && pi.SetMethod != null &&\n                      pi.SetMethod.IsPublic && pi.SetMethod.IsStatic);\n            }\n        }\n```\n\n为了调用静态成员,传递想要操作的Type来构建上述类的实例, 将引用放到dynamic变量中, 再用实例成员语法调用所需静态成员.\n\n```csharp\ndynamic stringType = new StaticMemberDynamicWrapper(typeof(String));\nvar r = stringType.Concat(\"A\",\"B\");// 动态调用String 的静态Concat方法\nConsole.WriteLine(r); // 显示AB\n```\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型2","url":"/2019/07/16/5基元类型引用类型和值类型2/","content":"# 回顾总结\n\n2019年8月22日\n\n1. 值类型一般在线程栈上分配\n\t- 值类型不受垃圾回收器控制\n\t- 随着变量生命周期结束而被栈释放\n\t- 所有值类型都是隐式密封的\n\t- 值类型称为结构或枚举.\n\t- `System.ValueType`的后代不全是值类型,`System.Enum`就是唯一的特例.\n\t- 它直接继承自System.ValueType，`System.Enum`和`System.ValueType`本身是引用类型。\n\n2. new操作符,编译器会判断类型是值类型和引用类型\n\t- 会生成正确的IL代码分配在线程栈 或者 堆中.\n\n3. 值类型对象有 未装箱和已装箱两种形式. 引用类型总是处于已装箱形式.\n\n4. 值类型如果不与非托管代码互操作,就应该覆盖C#编译器的默认设定改为[StructLayout(LayoutKind.Auto)]\n\t- 不覆盖默认是LayoutKind.Sequential\n\n5. 拆箱就是获取指针的过程\n\t- 拆箱不要求在内存中复制任何字节,指针指向的是已装箱实例中的未装箱部分\n\t- 然后进行一次字段复制到线程栈过程.\n\t- 已装箱对象在拆箱过程时,如果引用对象不是所需的值类型,会抛InvalidCastException\n\t- 先拆箱为正确类型,再转型,`Int16 y = (Int16)(Int32)o;// o里存放的是Object->Int32的已装箱对象 `\n\n6. ToString方法 代替 直接使用值类型传递给object参数的方法, 可以减少一个装箱操作.\n\t- 例如:Console.WriteLine编辑器选择Concat的重载版本去实现3个参数的合并\n\t- `Concat(object,object,object)`\n\t- 不建议使用 `Console.WriteLine(v + \",\" + o );` 建议使用`Console.WriteLine(v.ToString() + \",\" + (Int32) o );` 减少装箱操作.\n\n7. 大多数方法重载的目的是减少常用的值类型装箱次数.\n\t- 可以将方法定义为泛型,通过约束限制为值类型,这样获取任何值类型而不必装箱.\n\t- 如果要对一个值类型反复装箱, 建议手动写代码装箱`Object o = v;` 减少装箱次数\n\n\n# 引用类型和值类型\n\nCLR支持两种类型: 引用类型和值类型.\n\n引用类型总是从`托管堆`分配. C#的`new`操作符返回对象内存地址----指向对象数据的内存地址.\n\n**使用引用类型必须留意性能问题.**\n\n1. 内存必须从托管堆分配.\n2. 堆上分配的每个对象都有一些额外成员,这些额外成员必须初始化.\n3. 对象中的其他字节(为字段设置的字节)总是设为0.\n4. 从对管堆分配对象时,可能强制执行一次垃圾回收.\n\n为了提高性能,CLR提供了名为\"值类型\"的轻量级类型.\n\n**值类型** 的实例一般在线程栈上分配.\n\n1. 可以作为字段嵌入引用类型的对象中\n2. 在代表值类型实例的变量中 **不包含指向实例的指针**.\n3. 实例中包含了实例本身的字段(值). 所以操作实例中的字段(值)不需要提领指针.\n4. 值类型不受垃圾回收器的控制.\n5. 所有值类型都是隐式密封,防止用作其他应用类型或值类型的基类.\n\n\n**值类型缓解了使用托管堆的压力,并减少了应用程序生存期内的垃圾回收次数.**\n\n> 在非托管环境(C/C++)中声明类型后, 使用该类型的代码会决定是在线程栈上还是应用程序的堆中分配该类型的实例.\n> 托管代码中,要由定义类型的开发人员决定在什么地方分配类型实例,使用此类型的人对此没有控制权.\n\n# 查看文档区分引用类型和值类型\n\n1. 在文档中查看类型时, 任何称为 **类** 的类型都是引用类型. 例如System.Exception类...\n2. 所有值类型都称为 **结构** 或 **枚举**. 例如:System.Int32结构...\n\n\n## 结构&枚举\n\n所有`结构`都是抽象类型`System.ValueType`的直接派生类.`System.ValueType`本身又直接从`System.Object`派生.\n\n1. 根据定义, 所有值类型都必须从`System.ValueType`派生.\n2. 所有枚举都从`System.Enum`抽象类型派生,`System.Enum`从`System.ValueType`派生.\n\n> CLR和所有编程语言都会给予枚举特殊待遇(直接支持各种强大的操作,非托管环境中就不这样了.)\n\n# 引用类型和值类型的区别\n\n```csharp\n// 引用类型,因为class\nclass SomeRef { public Int32 x; }\n// 值类型\nstruct SomeVal{ public Int32 x; }\n\nstatic void ValueTypeDemo()\n{\n    // 图示左边部分\n    SomeRef r1 = new SomeRef();    // 在堆上分配\n    // 使用new看似是要在托管堆上分配实例,实际是C#编译器知道SomeVal是值类型\n    // 所以会正确的生成IL代码,在线程栈上分配,\n    // C#还会确保值类型中的所有字段都初始化为零.\n    // SomeVal v1; 还可以这么写. 但是C#认为此处v1没有初始化.\n    // 如果直接使用Int32 a = v1.x;将不能通过编译\n    SomeVal v1 = new SomeVal();    // 在栈上分配. 使用new操作符,C#会认为已经初始化.\n    r1.x = 5;                      // 提领指针\n    v1.x = 5;                      // 在栈上修改\n\n    // 图示右边部分\n    SomeRef r2 = r1;               // 只复制引用(指针)\n    SomeVal v2 = v1;               // 在栈上分配并复制成员\n    r1.x = 8;                      // r1.x和r2.x都会更改\n    v1.x = 9;                      // v1.x会更改,v2.x不变,为5\n}\n\n```\n\n![](5基元类型引用类型和值类型2/5-2.png)\n\n在代码中使用类型时, 必须注意是引用类型还是值类型,这会极大的影响在代码中表达自己意图的方式.\n\n# 设计类型时,满足什么条件才声明为值类型?\n\n1. 类型具有基元类型的行为. 是十分简单的类型,没有成员会修改类型的任何实例字段.\n  - 如果类型没有提供会更改字段的成员,就说该类型不可变(immutable).\n2. 类型不需要从其他任何类继承.\n3. 类型也不派生出其他任何类型\n\n类型实例大小也应该在考虑范围内,因为`实参`默认以`值方式传递`,造成对值类型实例中的字段进行复制,影响性能.\n1. 类型的实例较小(16字节或更小)\n2. 类型的实例较大(大于16字节),但不作为方法实参传递,也不从方法返回\n\n# 值类型的主要优势以及自身的局限\n\n1. `值类型`主要的优势是**不作为对象在托管堆上分配**.\n2. `值类型`对象有两种表示形式: `未装箱`和`已装箱`.  引用类型总是处于`已装箱`形式.\n3. `值类型`从`System.ValueType`派生. 该类型提供了与`System.Object`相同的方法,但重写了`Equals`方法,能在两个对象的字段值完全匹配的前提下返回true.还重写了GetHashCode方法.会将字段中的值都考虑在内.但是这个实现存在性能问题.所以定义自己的值类型时应该重写Equals和GetHashCode方法,并提供显式实现.\n4. 由于不能将`值类型`作为基类或新的引用类型,所以不应当在值类型中引入任何新的虚方法,所有方法不能是抽象的,并且隐式密封不可重写.\n5. `引用类型`的变量包含堆中对象的地址.引用类型的变量创建时默认初始化为`null`(表示当前不指向任何有效对象). 试图使用null引用时会报`NullReferenceException`异常.`值类型`的变量总是包含其基础类型的一个值.而`值类型`的初始化都为0. 值类型变量不是指针,不会报`NullReferenceException`异常.CLR允许为值类型添加`可空`标识.\n6. 将`值类型`变量赋给另一个`值类型`变量,会执行`逐字段复制`. `引用类型`的变量赋给另一个`引用类型`的变量值`只复制内存地址`.\n7. 两个或多个`引用类型`变量能引用堆中的同一对象,所以对一个变量操作可能会影响到另一个变量引用的对象.`值类型`则不会影响另一个值类型变量.\n8. 由于`未装箱的值类型`不在堆上分配, 定义了该类型的实例的方法不再活动(变量的生命周期结束),为它们分配的栈存储就会被释放.\n\n# CLR如何控制类型中的字段布局?\n\n为了提高性能,CLR能按照它所选择的任何方式排列`类型的字段`. 例如:CLR可以在内存中重新安排`字段的顺序`,将对象引用分为一组,同时正确排列和填充数据字段.\n\n定义类型时,针对类型的各个字段,你可以告诉CLR按照指定的顺序排列,还是按照CLR自己认为合适的方式重新排列.\n\n## 如何告诉CLR怎么排列?\n\n1. 要为自己定义的类或结构应用`System.Runtime.InteropServices.StructLayoutAttribute`特性.\n  - 向该特性的构造器传递`LayoutKind.Auto`          : 让CLR自动排列字段.  \n  - 顺序布局:传递`LayoutKind.Sequential`         : 让CLR保持你的字段布局.\n  - 精确布局:传递`LayoutKind.Explicit`           : 指定每个字段的偏移量,利用偏移量在内存中显示排列字段.\n2. 如果不指定`StructLayoutAttribute`,则CLR按照自己的方式.\n3. **注意:C#编译器有默认设定:**\n  - 默认`引用类型`选择`LayoutKind.Auto`\n  - 默认`值类型`选择`LayoutKind.Sequential`\n  - 这是因为C#编译器团队认为和`非托管代码`互操作时会经常用到`结构`.为此,字段必须保持程序员定义的顺序.\n  - 假如创建的值类型不与`非托管代码`互操作,就应该覆盖C#编译器的默认设定.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\n// 让CLR自动排列字段以增强这个值类型的性能\n// 覆盖掉C#编译器默认的`LayoutKind.Sequential`设置\n[StructLayout(LayoutKind.Auto)]\ninternal struct SomeValType\n{\n    private readonly Byte m_b;\n    ....\n}\n```\n\n### LayoutKind.Explicit说明\n\n构造器传递了`LayoutKind.Explicit`之后, 要向值类型中的每个字段都应用`System.Runtime.InteropServices.FieldOffsetAttribute`特性的实例.并且向该特性传递Int32值来指出字段第一个字节距离实例起始处的偏移量(以字节为单位).  \n\n显示布局常用来模拟非托管C/C++中的`union`,因为多个字段可起始于内存的相同偏移位置.\n\n注意在类型中:一个引用类型和一个值类型互相重叠是不合法的.多个值类型相互重叠则是合法的.为了是这样的类型能够验证,所有重叠字节都必须能通过公共字段访问.\n\n\n> union是特殊类,union中的数据成员在内存中的存储是相互重叠.每个数据成员都从相同的内存地址开始.\n> 分配给union的存储区数量是包含它最大数据成员所需的内存数, 同一时刻只有一个成员可以被赋值.\n> （1）同一个内存段可以用来存放几种不同类型的成员，但在每一个时刻只能存在其中一种，而不能同时存放几种，即每一瞬间只有一个成员起作用，其它的成员不起作用，不能同时都存在和起作用；\n> （2）共用体变量中起作用的成员是最后一个存放的成员，在存入一个新的成员后，原有的成员就会失去作用，即所有的数据成员具有相同的起始地址。\n> （3）union和struct都是由多个不同的数据成员组成，但是union所有成员共享一段内存地址，只存放最后一次赋值的成员值，而struct可以存放所以有成员的值。\n> （4）union的大小是所有成员中所占内存最大的成员的大小，struct是所有成员的大小的“和”。\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n// 让开发人员显示排列这个值类型的字段\n[StructLayout(LayoutKind.Explicit)]\ninternal struct SomeValType\n{\n    [FieldOffset(0)]\n    private readonly Byte m_b;// m_b和m_x字段在该类型的实例中相互重叠\n\n    [FieldOffset(0)]\n    private readonly Int16 m_x; // m_b和m_x字段在该类型的实例中相互重叠\n}\n```\n\n\n# 值类型的装箱和拆箱\n\n值类型不作为对象在托管堆中分配,不被垃圾回收,也不通过指针进行引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    struct Point{public Int32 x, y;}\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ArrayList a = new ArrayList();\n            Point p;                        // 分配一个Point,不在堆中分配\n            // 每次迭代都初始化一个`Point值类型字段`, 并将该Point存储到ArrayList中.\n            for (int i = 0; i < 10; i++)\n            {\n                p.x = p.y = i;     // 初始化值类型中的成员\n                a.Add(p);          // 对值类型进行装箱,将引用添加到ArrayList中\n            }\n        }\n    }\n}\n```\n\n## ArrayList中究竟存储了什么? 是Point结构还是Point结构的地址?\n\n想要知道答案需要研究ArrayList的Add方法.\n\nAdd方法原型:`public virtual Int32 Add(object value);`\n\n1. 参数是`object`,也就是说Add获取对托管堆上的一个对象的引用(指针)来作为参数.\n2. a.Add(p); 之前的代码传递的是Point,是值类型.\n3. 为了使代码正确工作,Point值类型必须转换成真正的,在堆中托管的对象,而且必须获取对该对象的引用\n4. 对`值类型`转成`引用类型`要使用`装箱机制`.\n\n## 装箱机制发生的事情\n\n1. 在托管`堆`中分配内存. 分配的内存是值类型各字段所需的内存量(还要加上托管堆所有对象都有的两个额外成员:类型对象指针和同步块索引所需的内存量).\n2. **值类型的字段复制到新分配的堆内存.**\n3. 返回对象地址, 现在该地址是对象引用:值类型成了引用类型.\n\n在托管堆中分配相应的内存.  \n\n**C#编译器自动生成对值类型实例进行装箱所需的IL代码.** 但是仍需要理解内部的工作机制才能体会到代码的大小和性能问题.\n\n在运行时,当前存在于`Point值类型实例p`中的字段复制到`新分配的Point对象`中. 已装箱`Point对象`(现在是引用类型)的地址传给Add方法. `Point对象`一直存在于堆中,直至被垃圾回收.\n\n> FCL现在包含一组新的泛型集合类, 非泛型集合类已经是过时的东西.\n> 例如:应该使用`System.Collections.Generic.List<T>`类而不是`System.Collections.ArrayList`类.\n> `泛型集合类`对`非泛型集合类`进行了大量改进.\n> 1. API得到简化和增强,性能也得到显著提升\n> 2. 允许开发人员在操作`值类型的集合`时不需要对`集合中的项`进行`装箱/拆箱`\n> 3. 开发人员还获得编译时的类型安全性, 减少强制类型转换次数.\n\n## 拆箱机制\n\n要从上面代码中的`ArrayList a`取第一个元素.\n\n```csharp\nPoint p = (Point)a[0];\n```\n\n1. 它获取ArrayList的元素0包含的引用(指针), 试图放到`Point值类型`的实例p中.\n2. 为此,`已装箱Point对象`中的所有字段都必须复制到`值类型变量`p中. 后者在`线程栈`上.\n3. CLR分两步完成复制\n  - 第一步: 获取`已装箱Point对象`的`各个Point字段`的地址.  **← 此过程称为拆箱.**\n  - 第二步: 将字段包含的值从`堆`复制到`栈`的值类型实例中.\n\n拆箱不是直接将装箱过程倒过来, **装箱的代价被拆箱高得多.**\n1. 拆箱就是获取指针的过程.\n2. **拆箱不要求在内存中复制任何字节. 指针指向的是已装箱实例中的未装箱部分.**\n3. 拆箱操作后紧接着一次字段复制.\n\n\n### 已装箱值类型在拆箱时的过程\n\n1. 如果包含\"对已装箱值类型实例的引用\"的变量为null,抛出NullReferenceException.\n  - `Point p = (Point)a[0];// a为null时`\n2. 如果引用的对象不是所需值类型的已装箱实例,抛出InvalidCastException.\n\n```csharp\npublic static void Main()\n{\n  Int32 x = 5;\n  object o = x;              // 对x装箱,o引用已装箱对象\n  // 在对对象进行拆箱时,只能转型为最初未装箱的值类型(本例是Int32)\n  // 所以以下写法会抛出异常\n  Int16 y = (Int16)o;        // 抛出InvalidCastException.\n\n  // 正确写法\n  Int16 y = (Int16)(Int32)o; // 先拆箱为正确类型,再转型\n}\n```\n\n#### 拆箱和复制例子\n```csharp\npublic static void Main()\n{\n  Point p;\n  p.x = p.y = 1;\n  Object o = p;   // 对p装箱;  o引用已装箱实例\n\n  // 将Point的x字段变成2\n  p = (Point)o;   // 对o拆箱, 将字段从已装箱的实例复制到[栈]变量中 (复制所有字段)\n  p.x = 2;        // 更新[栈]变量的状态\n  o = p;          // 对p装箱;o引用新的已装箱实例 (复制所有字段)\n}\n```\n\n首先进行一次拆箱,再执行一次字段复制(到栈变量中),最后再执行一次装箱(在托管堆上创建全新的已装箱实例).\n\n这个过程对应用程序性能影响较大.\n\n> 此段代码用C++/CLI来写,效率会高很多,因为它允许在不复制字段的前提下,对已装箱的值类型进行拆箱,拆箱返回的是已装箱对象中的未装箱部分的地址(忽略对象的类型对象指针和同步索引块这两个额外成员),接着可以用这个指针来操作未装箱实例的字段(这些字段恰好在堆上的已装箱对象中).\n> C++/CLI直接在已装箱Point实例中修改Point的x字段的值. 就这避免了在堆上分配新对象和复制字段两次.\n\n### 从IL代码查看编译器隐式生成的装箱代码\n\n\n如果关心特定算法的性能,可以用ILDasm.exe这样的工具查看方法的IL代码,观察IL指令box都在哪些地方出现.\n\n#### 例子一\n\n```csharp\n// 以下代码发生了3次装箱\npublic static void Main()\n{\n  Int32 v = 5; // 值类型变量\n  object o = v; // 一次装箱\n  v = 123; // 将未装箱的值修改为123\n\n  Console.WriteLine(v + \",\" + (Int32) o );// 显示123,5\n}\n```\n\n解析:\n1. 首先在栈上创建一个Int32未装箱值类型实例`v` , 将其初始化为5.\n2. 创建Object类型的变量`o`, 让它指向`v`.\n  - 因为`引用类型的变量`始终是指向`堆`中的对象,所以C#生成正确的IL代码对`v`进行装箱,(复制所有字段到堆中)\n  - 让`v`的已装箱拷贝的地址存储到`o`中.\n3. 接着,值123被放到`未装箱值类型`实例`v`中, 但这个操作不会影响已装箱的Int32,后者值依然是5.\n4. 接着调用WriteLine方法, 由于方法需要string对象作为参数,编辑器选择Concat的重载版本去实现3个参数的合并\n5. `Concat(object,object,object)`\n  - 第一个参数传递v(未装箱的值参数),需要进行装箱操作\n  - 第二个参数\",\",作为string对象,引用传递.\n  - 第三个参数,`(Int32) o`, 先进行拆箱(但不紧接着执行复制),获取到在已装箱Int32中的未装箱Int32的地址.这个未装箱的Int32实例必须再次装箱. 将实例的内存地址传给arg2参数\n6. Concat方法调用每个对象的ToString方法,将每个对象的字符串连接起来.返给给WriteLine方法以最终显示.\n\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       47 (0x2f)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop       // nop:没有什么意义；\n\n  // Int32 v = 5;\n  IL_0001:  ldc.i4.5  // Ldc.I4 将所提供的 int32 类型的值作为 int32 推送到计算堆栈上。\n  IL_0002:  stloc.0   //从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。\n\n  // object o = v;\n  // 局部变量object o,位置设定为索引0\n  IL_0003:  ldloc.0   //将索引 0 处的局部变量加载到计算堆栈上。\n  IL_0004:  box        [System.Runtime]System.Int32  // 将值类转换为对象引用（O 类型）。\n  IL_0009:  stloc.1   //从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。\n\n  // v = 123;\n  IL_000a:  ldc.i4.s   123  // 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。\n  IL_000c:  stloc.0\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // 在WriteLine方法参数(object引用类型)中, 会对值类型的v产生装箱操作\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"    // 推送对元数据中存储的字符串的新对象引用。\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // (Int32) o 拆箱操作,拆成原始的Int32值类型.\n  IL_0018:  ldloc.1\n  IL_0019:  unbox.any  [System.Runtime]System.Int32\n  // 由于被作为WriteLine方法参数(object引用类型), 再进行装箱操作\n  IL_001e:  box        [System.Runtime]System.Int32\n  // 调用string的Concat方法连接字符串\n  IL_0023:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  // 将Concat返回的string 传给WriteLine方法\n  IL_0028:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_002d:  nop\n\n  // 从Main返回,终止应用程序\n  IL_002e:  ret\n} // end of method Program::Main\n\n```\n\n如果改进一下,如下:\n```csharp\n// 此处如果修改成如下代码,效率更高,避免了2次操作:一次装箱一次拆箱\nConsole.WriteLine(v + \",\" + o );// 显示123,5\n```\n对比一下IL代码\n1. 比之前版本小了10个字节. 第一个版本`额外的拆箱/装箱`显然会产生更多的代码. 额外的装箱操作步骤会从托管堆中分配一个额外的对象, 将来对其进行垃圾回收.\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       37 (0x25)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop\n  IL_0001:  ldc.i4.5\n  IL_0002:  stloc.0\n  IL_0003:  ldloc.0\n  IL_0004:  box        [System.Runtime]System.Int32\n  IL_0009:  stloc.1\n  IL_000a:  ldc.i4.s   123\n  IL_000c:  stloc.0\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"\n  IL_0018:  ldloc.1\n  IL_0019:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  IL_001e:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_0023:  nop\n  IL_0024:  ret\n} // end of method Program::Main\n```\n\n进一步提升代码的性能:\n\n**v.ToString(),返回是的String,是引用类型,不需要装箱,减少一个装箱操作.**\n\n`Console.WriteLine(v.ToString() + \",\" + (Int32) o );`\n\n对应的IL代码则是: `IL_000f:  call       instance string [System.Runtime]System.Int32::ToString()`\n\n#### 例子二\n\n```csharp\n// 以下代码只发生了一次装箱.\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // 装箱\n    Object o = v;\n    // 修改栈, 不影响已装箱的o\n    v = 123;\n    // public static void WriteLine(int value)\n    // 方法WriteLine是传值的方式,不需要装箱\n    Console.WriteLine(v); // 123\n    // 拆箱\n    v = (Int32) o;\n    Console.WriteLine(v); // 5\n}\n```\n\n### FCL重载了很多常用值类型的方法,减少常用值类型的装箱次数\n```csharp\npublic static void WriteLine(double value);\npublic static void WriteLine(float value);\npublic static void WriteLine(int value);\n...\n```\n\n**大多数方法进行重载唯一的目的就是减少常用值类型的装箱次数.**\n\n但是FCL不可能接受你自己定义的值类型. 也可能FCL没有提供对应的重载版本,那调用方法传递值类型参数时,就是调用Object参数的重载版本. 将值类型实例作为Object传递会造成装箱.\n\n定义自己的类时, 可将类中的方法定义为泛型(通过泛型约束将类型参数限制为值类型), 这样方法就可以获取任何值类型而不必装箱.\n\n#### 例子三(如果要反复对一个值类型装箱,请改为手动方式)\n\n```csharp\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // v会被装箱3次,浪费时间和内存\n    Console.WriteLine($\"{v}+{v}+{v}\");\n\n    // 对v手动装箱一次\n    Object o = v;\n    // 编译下一行不会发生装箱行为\n    // 内存利用还是执行速度都比上一段代码更胜一筹\n    Console.WriteLine($\"{o}+{o}+{o}\");\n}\n```\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型","url":"/2019/07/15/5基元类型引用类型和值类型/","content":"# 回顾总结\n\n2019年8月22日\n\n1. 允许转换安全的隐式转换.\n\t- 转换安全: 不发生数据丢失的情况.比如从`Int32`转换为`Int64`.\n\t- 隐式转换: 不用写 (类型) 的方式\n\t- 显示转型: 用()注明类型\n\n2. 丢失精度时, 会向下取整.\n\t- 在转型时,`float` 6.8 放入`int`中会截断小数点后的数,放入6\n\n3. 字面值会在编译期就完成表达式求值.\n\t- `String s = \"a \" + \"bc\";// 生成的代码将s设为\"a bc\" `\n\n4. 算术运算符溢出处理\n\t- checked / unchecked\n\t- 将有溢出风险的计算语句放入块中, 如果块中调用方法不会有任何作用.\n\t- 捕捉`OverflowException`异常\n\n5. Decimal是特殊的基元类型,CLR不会为此生成特殊的指令\n\t- 编译器会生成代码来调用Decimal的成员方法,处理速度慢于其他基元类型\n\t- 溢出检查操作符无效\n\n6. BigInteger\n\t- `UInt32`数组来表示任意大的整数\n\t- 没有上限和下限\n\t- 不会抛`OverflowException`可能会抛`OutOfMemoryException`\n\n\n\n\n\n# 编程语言的基元类型\n\n## 什么是基元类型\n\n编译器直接支持的数据类型称为`基元类型(primitive type)`.\n\n基元类型直接映射到Framework类库FCL中存在的类型.例如C#中的`int`直接映射到的`System.Int32`类型.\n\n> MSDN文档将primitive type翻译成\"基元类型\",而不是容易混淆的\"基本类型\".\n\n以下四行代码都能正确编译,并能生成完全相同的`IL代码`.\n```csharp\n// 最方便的语法\nint a = 0;\n// 方便的语法\nSystem.Int32 a = 0;\n// 不方便的语法\nint a = new int();\n// 最不方便的语法\nSystem.Int32 a = new System.Int32();\n\n// 从另外一个角度可以认为C#编译器自动假定所有源代码都添加了一下using指令(取别名作用)\nusing sbyte = System.SByte;\nusing byte = System.Byte;\nusing short = System.Int16;\nusing ushort = System.UInt16;\nusing int = System.Int32;\nusing uint = System.UInt32;\n...\n```\n\n## 基元类型对应的FCL类型\n\n是要是符合CLS公共语言规范的类型,其他语言都提供了类似的基元类型. 不符合的就不一定支持了.\n\n![](5基元类型引用类型和值类型/5-1.png)\n\n## 关于关键字和完整的系统类型名称\n\nC#语言规范:\"从风格上说,最好使用关键字,而不是使用完整的系统类型名称.\"\n作者认为: 更好的是使用FCL类型名称,完全不用基元类型名称.\n\n事实上,作者希望编译器根本不提供`基元类型名称`, 而是强迫开发人员使用`FCL类型名称`.理由如下:\n\n1. 有些程序员纠结用`string`还是`String` . 由于C#的`string`(这是关键字)直接映射到`System.String`类型(这是FCL库中的类型). 所以两者没有区别.\n\n> 误区: 有些开发人员说32位系统上int代表32位整数,64位系统上int代表64位整数,这个说法是错误的.\n> 因为c#的`int`始终映射到`System.Int32`类型. 所以不管在什么操作系统上运行,代表的都是32位整数.\n> 如果用Int32,这样的误解就没有了.\n\n2. C#的`long`类型映射到的是`System.Int64`,而其他编程语言中可能映射到Int16或Int32. 例如C++/CLI就将long视为Int32. 事实上大多数语言不将long当做关键字.根本不编译使用了它的代码.\n\n3. FCL的许多方法都将类型名作为方法名的一部分.例如BinaryReader类型的方法包括ReadBoolean,ReadInt32,ReadSingle等, 而System.Convert类型的方法包括ToBoolean,ToInt32,ToSingle等.\n\n```csharp\n// 虽然语法上没问题, 但float的那一行无法一下子判断该行的正确性.\nBinaryReader br = new BinaryReader(...);\n// 使用float C#关键字\nfloat val = br.ReadSingle(); // 正确,但感觉别扭\n// 使用Single FCL类型名称\nSingle val = br.ReadSingle();// 正确,感觉自然\n\n```\n\n4. 平时只用C#的许多程序员逐渐忘了还可以用其他语言写面向CLR的代码.`C#主义逐渐入侵类库代码`.例如:FCL几乎完全是用C#写的,FCL团队向库中引入了`Array`的`GetLongLength`这样的方法,该方法返回的是`Int64`值.这种值在C#中确实是long,但是在其他语言比如C++/CLI中不是. 另一个例子是:`System.Linq.Enumerable`的`LongCount`方法.\n\n**考虑到以上原因,本书坚持使用FCL类型名称.**\n\n## System.Int32 为什么能转 System.Int64?\n\n在许多编程语言中,一下代码都能正确编译并运行:\n\n```csharp\nInt32 i = 5;//32位值\nInt64 i = i;//隐形转型为64位值\n```\n但是根据上一章内容,对类型转换的讨论,你或许认为上述代码无法编译. 毕竟`System.Int32`和`System.Int64`是不同的类型.互相不存在派生关系. 但是能正确编译上述代码,运行起来也没有问题.\n\n原因是: C#编译器非常熟悉基元类型,会在编译代码时应用自己的特殊规则.\n1. 具体的说,C#编译器支持与`类型转换`,`字面值(直接量或文字常量)`以及`操作符`有关的模式.\n\n### 转型\n\n编译器能执行`基元类型之间`的隐式或显示转型.\n```csharp\nInt32 i = 5; //从Int32隐式转型为Int32\nInt64 l = i; //从Int32隐式转型为Int64\nSingle s =i; //从Int32隐式转型为Single\nByte b = (Byte)i;// 从Int32显示转型为Byte\nInt16 v = (Int16)s;//从Single显示转型为Int16\n```\n\n只有在转换`安全`的时候,C#才允许隐式转型.\n- 什么是转换`安全`的时候?\n  - 是指不会发生数据丢失的情况. 比如从`Int32`转换为`Int64`.\n\n- 如果可能`不安全`,C#就要求显示转型.\n  - 对于数值类型,`不安全`意味着转换后丢失精度或数量级.\n  - 例如`Single(float IEEE32位浮点值)`,转换为`Int16(short 有符号16位)`也要求显示转型.因为Single能表示比Int16更大数量级的数字(会丢失精度).\n\n#### C#编译器总是对转型结果进行截断\n\n比如 6.8的`Single(float IEEE32位浮点值)`转型为`Int32`,\n**C#总是对结果进行截断(向下取整)**, 结果是将6放入`Int32`类型中.\n\n> 有些编译器可能会将结果向上取整为7.\n\n### 字面值\n\n`字面值`可被看成是类型本身的实例.\n\n```csharp\n// 实例 调用 实例方法\nConsole.WriteLine(123.ToString() + 456.ToString()); // 123456\n\n// 如果表达式由字面值构成, 编译器在编译时就能完成表达式求值.从而增强应用程序性能.\nBoolean found = false;// 生成的代码将found设为0\nInt32 x = 100 + 20 + 3;// 生成的代码将x设为123\nString s = \"a \" + \"bc\";// 生成的代码将s设为\"a bc\"\n```\n\n## checked 和 unchecked 基元类型操作\n\n对基元类型执行的许多算术运算符都可能造成溢出:\n\n```csharp\n// byte 2^8 = 256\nByte b = 100;\n// 100 +200 = 300\n// 执行此处算术运算符时, 要求所有的操作数扩大到32位(64位,如果有操作数需要超过32位来表示的话)\n// b 和 200 都不超过32位,则先转换成32位值,然后加到一起,结果是一个32位的十进制300.\n// 然后该值存回b变量前**必须转型为Byte, C#不隐式执行此操作.**\nb = (Byte)(b + 200); // b 现在为 44\n```\n\n## 溢出处理\n\n1. 溢出大多数时候是不希望出现的,会导致应用程序行为失常.但是极少数时候计算哈希值和校验和,这种溢出可以接受.\n2. 不同语言处理溢出的方式不同, C/C++不将溢出视为错误,允许值回滚.VB则视为错误,并抛出异常.\n\n> 回滚:一个值超出允许的最大值时,回滚到一个非常小的,负的或者未定义的值.\n\nCLR提供了一些特殊的IL指令. 允许程序员自己决定如何处理溢出. CLR有一个add指令,作用是将两个值相加,但不执行溢出检查,还有一个add.ovf指令,会在溢出时抛System.OverfolwException异常.\n\n1. `溢出检查`默认是关闭的. 编译器生成IL代码时,将自动使用加减乘和转换指令的无溢出检查版本.代码能更快的运行.\n2. `/checked+`编译器开关在生成代码时使用溢出检查版本.这样CLR会检查这些运算,判断是否发生溢出,并抛出异常.\n3. 除了全局性的打开和关闭溢出检查, 程序员可以在代码的特定区域控制.\n   - unchecked 操作符\n   - checked 操作符\n\n```csharp\nUInt32 invalid = unchecked( (UInt32) (-1)); // OK\n\nByte b = 100;\n// 会抛出OverflowException异常\n// 这个过程中,b和200会转成32位值,\n// 300 转成 Byte就会抛出异常\nb = checked((Byte)(b + 200));\n\n// b包含44, 不会抛出异常.\nb = (Byte)checked(b + 200);\n```\n\nC#还支持checked和unchecked语句. 可以是语句块中的代码都进行或不进行溢出检查.\n\n> checked和unchecked语句 唯一作用就是决定生成哪个版本的加减乘和数据转换的IL指令.\n> **所以在checked操作符或语句中 调用方法,不会对该方法造成任何影响.**\n\n```csharp\nchecked\n{\n  Byte b = 100;\n  //简化 b = (Byte)(b + 200)\n  b += 200;\n}\n\nchecked\n{\n  // 假定SomeMethod试图把400加载到一个Byte中\n  SomeMethod(400);\n  // SomeMethod 可能会,也可能不会抛出OverflowException异常\n  // 如果SomeMethod使用checked指令编译,就可能会抛出异常.\n  // 但这和当前的checked语句无关.\n}\n```\n\n## 应对无效输入的建议\n\n1. 尽量使用有`符号数值类型`比如:Int32和Int64,而不是`无符号数值类型`UInt32和UInt64.\n  - 这允许编译器检测更多的上溢/下溢的错误.\n  - 类库的多个部分,比如Array和String的Length属性 被硬编码为返回有符号的值.\n  - 减少强制类型转换,无符号数值类型不符合CLS.\n\n2. 写代码时,如果代码可能发生你想不到的溢出(可能是无效的输入,使用用户或客户机提供的数据), 就把这些代码放到`checked块`中. 同时捕捉`OverflowException`异常.\n\n3. 将允许发生溢出的代码显示放到`unchecked块`中,比如在计算校验和时.\n\n4. 对于没有使用`unchecked`和`checked`的语句,都假定发生溢出时抛出异常.\n\n![](5基元类型引用类型和值类型/5-1-1.png)\n\n勾选 `检查运算上溢/下溢` 相当于打开了编译器的`/checked+开关`进行调试性生成.应用程序运行起来会慢一点.可以进行比较完整的溢出检查.\n\n## System.Decimal是非常特殊的类型\n\n1. C#和VB视为基元类型. 但是CLR不这样. CLR没有知道如何处理Decimal值的IL指令.\n2. Decimal类型自己定义一系列方法,包括Add,Subtract,Multiply,Divide. 还为`+-*/`等提供了操作符重载方法.\n3. 编译使用了Decimal值的代码时,**编译器会生成代码来调用Decimal的成员方法**,并**通过这些成员方法来进行实际的运算**. 这也意味着Decimal值的处理速度慢于CLR基元类型的值.\n4. 由于没有相应的IL指令来处理Decimal值, 所以checked和unchecked操作符,编译器开关都失去作用.\n\n## System.Numerics.BigInteger类型\n\n1. 类似的,BigInteger类型也在内部使用了`UInt32`数组来表示任意大的整数,它的值没有上限和下限.\n2. 因此对于BigInteger类型执行运算永远不会造成OverflowException异常\n3. 如果值太大,没有足够的内存来改变数组大小,BigInteger的运算可能会抛出`OutOfMemoryException`异常.\n","tags":["CLR读书笔记"]},{"title":"4类型基础","url":"/2019/07/08/4类型基础/","content":"\n# 所有类型都从System.Object派生\n\n**`运行时`要求每个类型都从`System.Object`派生**.\n\n```csharp\n//隐式派生自Object\nclass Employee｛\n  ...\n｝\n//显式派生自Object\nclass Employee: System.Object{\n  ...\n}\n```\n\n## System.Object的公共方法Equals\n| 公共方法 | 说明 |\n| :------| ------ |\n| Equals  | 如果两个对象具有`相同的值`就返回true  |\n\n### 对象的相等性和同一性\n\n#### 同一性\n\n```csharp\n// 此虚方法实现的是同一性,而非相等性.\n// 因为obj引用的对象如果不是引用相同对象,那就无法比较值是否相等.\npublic virtual Boolean Equals(Object obj)\n{\n  // 如果两个引用指向同一个对象,它们肯定包含相同的值\n  if (this == obj) return true;\n  // 假定对象包含不同的值\n  return false;\n}\n```\n\n| 静态方法 | 说明 |\n| :------| ------ |\n| ReferenceEquals  | 检查两个引用是否指向同一对象  |\n\n> 检查同一性务必调用ReferenceEquals,不应该使用C#的== 操作符 (除非都转成Object), 因为某个操作数可能重载了==操作符.\n\n```csharp\n// 上述方法是不合理的,因此Microsft提供了检查同一性的方法\npublic static bool ReferenceEquals (Object objA, Object objB) {\n    return objA == objB;\n}\n```\n#### 重写Equals方法\n\n1. Equals 必须自反: x.Equals(x)肯定返回true\n2. Equals 必须对称:  x.Equals(y)和y.Equals(x)返回相同\n3. Equals 必须可传递:  x.Equals(y)返回true,  y.Equals(z)返回true,那么 x.Equals(z)肯定是true\n4. Equals 必须一致:比较的两个值不变,返回值也不能变.\n\n### 值类型的基类ValueType重写了Equals方法\n\n```csharp\npublic override bool Equals(object obj)\n{\n  // 1.判断实参obj是否为null\n  if (obj == null)\n    return false;\n  RuntimeType type = (RuntimeType) this.GetType();\n  // 2.this和obj实参引用不同类型的对象,返回false\n  if ((RuntimeType) obj.GetType() != type)\n    return false;\n  object a = (object) this;\n\n  // 3. 如果对象的成員中存在对于堆上的引用，那么返回false，\n  // 如果不存在，返回true。例如按照ValPoint的定义，它仅包含一个int类型的字段x，自然不存在对堆上其他对象的引用，所以返回了true\n  if (ValueType.CanCompareBits((object) this))\n    return ValueType.FastEqualsCheck(a, obj);\n\n  // 4.利用反射获取值的所有字段\n  FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n  for (int index = 0; index < fields.Length; ++index)\n  {\n    object obj1 = ((RtFieldInfo) fields[index]).UnsafeGetValue(a);\n    object obj2 = ((RtFieldInfo) fields[index]).UnsafeGetValue(obj);\n    // 5. 判断是否为null\n    if (obj1 == null)\n    {\n      if (obj2 != null)\n        return false;\n    }\n    // 6. 通过调用字段的Equals方法进行比较\n    else if (!obj1.Equals(obj2))\n      return false;\n  }\n  return true;\n}\n```\n由于CLR反射机制慢,定义自己的值类型时应重写`Equals`方法来提供自己的实现.从而提高用自己类型的实例进行值相等性比较的性能. **当然,自己的实现不调用 `base.Equals`**.\n\n### 重写Equals方法还需要做的事\n\n1. 让类型实现`System.IEquatable<T>`接口的`Equals`方法\n  - 泛型接口,定义类型安全的`Equals`方法` bool Equals(T other)`;\n2. 重载==和!=操作符方法( 这些方法内部调用了类型安全的`CompareTo`方法. )\n3. 如果需要排序,类型还应该实现`System.IComparable`的`CompareTo`方法和泛型接口`System.IComparable<T>`的类型安全的`CompareTo`方法.\n4. 重载比较操作符方法<,<=,>,>= ( 这些方法内部调用了类型安全的`CompareTo`方法.)\n\n\n\n## System.Object的公共方法GetHashCode\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetHashCode  | 返回对象值的哈希码.如果某个类型的对象要在哈希表集合(比如`Dictionary`)中作为键使用,类型应重写该方法.  |\n\n### 对象哈希码\n\nFCL的设计者认为,如果能将任何对象的任何实例放到`哈希集合`中,能带来很多好处。为此`System.Object`提供了虚方法`GetHashCode`,它能获取任意对象的Int32哈希码.\n\n如果你定义的类型重写了Equals方法,还应该重写GetHashCode方法. 这是因为`System.Collections.Hashtable`类型,`System.Collections.Generic.Dictionary`类型以及一些其他的集合中,要求两个对象必须具有**相同哈希码才能被视为相等**. 确保相等性算法和对象哈希码算法一致.\n\n- 添加\n  - 向集合添加`键/值对`,首先要获取`键`对象的哈希码, 该哈希码指出这个`键/值对`要存储到哪个`哈希桶bucket`中.\n- 查找\n  - 集合需要查找`键`时候, 会获取`键`对象的哈希码, 此哈希码标识了现在要以顺序的方式搜索的哈希桶. 在这个哈希桶中查找哈希码相同的`键`对象,以及对应的`值`对象.\n- 修改\n  - **错误的方式: 直接修改集合中的`键`对象,修改后的键对象的哈希码与原来不同,就会去搜索错误的哈希桶,找不到对应的值对象.**\n  - 正确做法: 从集合中移除原来的`键/值对`, 修改键对象, 重新将新的键值对添加回哈希表.\n\n### 自己实现哈希算法\n自定义GetHashCode方法,取决于数据类型和数据分布情况, 需要设计出能返回良好分布值的哈希算法.\n\n要遵循的规则:\n1. 算法要提供良好的随机分布,使哈希表获得最佳性能.\n2. 一般不要调用Object或ValueType的GetHashCode方法, 因为两者的实现与高性能哈希算法不沾边.\n3. 算法至少使用一个实例字段.\n4. 理想情况下, 算法使用的字段值应该不可变,也就是说,字段在对象构造时初始化,在对象的生存期永不言变.\n5. 算法执行速度尽量快.\n6. 包含相同值的不同对象应返回相同的哈希码.\n\n> System.Object实现的GetHashCode方法对派生类型和其中的字段一无所知,所以返回一个在对象生存期保证不变的编号.\n\n> 最好不要将哈希码持久化, 因为生成哈希码的算法可能会发生改变. 例如:CLR版本升级后,String的GetHashCode方法发生了改变. 之前如果存储的是string的哈希码,则导致全部不对应了.\n\n\n## System.Object的公共方法ToString\n| 公共方法 | 说明 |\n| :------| ------ |\n| ToString  | 默认返回类型的完整名称`this.GetType().FullName` . 经常用于调试的目的重写该方法,返回一些值的字符串表示. |\n\n## System.Object的公共方法GetType\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetType  | 返回从Type派生的一个类型的实例,指出调用GetType的对象是什么类型. |\n\n### GetType是非虚方法.\n\n目的是`不允许重写`. 防止类重写该方法,隐瞒其类型,进而破坏类型安全性.(用new关键字告诉编译器定义一个新方法`new public void F()`)\n\n\n> 返回的Type对象可以和反射类配合,获取与对象的类型有关的元数据信息.\n\n\n## System.Object的受保护方法MemberwiseClone\n| 受保护方法 | 说明 |\n| :------| ------ |\n| MemberwiseClone  | 就是创建一个浅表副本的新对象，然后将当前对象的非静态字段复制到该新对象. |\n\n`MemberwiseClone` 方法创建一个`浅表副本`，。如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则**复制引用但不复制引用的对象**；因此，原始对象及其复本引用同一对象。\n\n```csharp\npublic DemoClass Clone1() //浅CLONE\n{\n    return this.MemberwiseClone() as DemoClass;\n}\n\npublic DemoClass Clone2() //深clone\n{\n    MemoryStream stream = new MemoryStream();\n    BinaryFormatter formatter = new BinaryFormatter();\n    formatter.Serialize(stream, this);\n    stream.Position = 0;\n    return formatter.Deserialize(stream) as DemoClass;\n}\n```\n\n\n### 什么是浅表副本?\n- 浅度拷贝( **浅表副本** )\n  - 一个集合的浅度拷贝意味着只拷贝集合中的元素，不管他们是引用类型或者是值类型，但是它`不拷贝引用所指的对象`。这就是说新集合中的引用和原始集合中的`引用所指的对象是同一个对象`。\n- 深度拷贝( **深表副本** )\n  - 深度拷贝不仅拷贝集合中的元素，而且还拷贝了这些元素直接或者间接引用的所有内容。这也就意味着，新集合中的引用和原始集合中的`引用所指的对象是不同的`.\n\n### 深度复制原理\n为了实现`深度复制`，我们就必须遍历有相互引用的对象构成的图，并需要处理其中的循环引用结构。这无疑是十分复杂的。幸好借助.Net的`序列化和反序列化机制`，可以十分简单的深度Clone一个对象。原理很简单，首先将对象序列化到内存流中，此时对象和对象引用的所用对象的状态都被保存到内存中。.Net的序列化机制会自动处理循环引用的情况。然后将内存流中的状态信息反序列化到一个新的对象中。这样一个对象的深度复制就完成了。在原型设计模式中CLONE技术非常关键。\n\n### 深拷贝的帮助类\n```csharp\npublic static class ObjectCopier\n{\n    /// <summary>\n    /// Perform a deep Copy of the object.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of object being copied.</typeparam>\n    /// <param name=\"source\">The object instance to copy.</param>\n    /// <returns>The copied object.</returns>\n    public static T Clone<T>(T source)\n    {\n        // 判断泛型T是否能序列化\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(\"The type must be serializable.\", \"source\");\n        }\n\n        // Don't serialize a null object, simply return the default for that object\n        // 不能序列化一个null对象\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n\n        // 流操作\n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n    }\n}  \n```\n\n\n## System.Object的受保护方法Finalize\n| 受保护方法 | 说明 |\n| :------| ------ |\n| Finalize  | 在垃圾回收器判断此对象作为垃圾被回收之后,在对象的内存被实际回收之前,调用此虚方法. |\n\n需要在回收之前执行清理工作的类型应重写此方法.\n\n\n# 所有对象都要用new操作符\n\n> 实例字段(实例成员)是非静态字段  --- 属于类的对象\n> 静态成员----------------------- 属于类\n\n\n**new 操作符所做的事情**\n1. 计算类型及其所有基类(一直到System.Object)中定义的所有实例字段需要的字节数. (计算需要的字节数 )\n  - `堆`上的每个对象都需要有`开销成员overhead`,包括 `类型对象指针(type object pointer)`和`同步块索引sync block index`.\n  - CLR利用这些`开销成员`管理对象. `开销成员`的字节数要计入对象的大小.\n2. 从`托管堆`中分配类型要求的字节数, 从而分配对象的`内存`, 分配的所有字节都设置为`零(0)`.\n3. 初始化对象的`开销成员`:`类型对象指针(type object pointer)`和`同步块索引sync block index`.\n4. 调用类型的实例化`构造器`,传递在new调用中指定的`实参`.\n  - 每个类型的构造器都负责初始化该类型定义的实例字段. 最终调用System.Object的构造器,该构造器什么都不做,简单地返回.\n5. 返回新建对象的一个引用(或指针).\n\n\n> 没有delete操作符用来显示释放为对象分配的内存, CLR采用垃圾回收机制.\n\n# 类型转换及类型安全性\n\n> CLR最重要的特性就是类型安全. 在运行时,CLR总是知道对象的类型是什么.\n> 调用GetType方法即可知道对象的确切类型.\n> 由于它是非虚方法,所以不可能伪装成别的类型.\n\nCLR运行将对象转换为`它的(实际)类型`或者`它的任何基类型`.\n\n- `对象类型` --转换成--> `该对象的基类型`\n  - C#中, `向基类型的转换`是一种安全的**隐式转换** .\n- 而将`对象类型` --转换成--> `该对象的某个派生类型`\n  - C#要求开发人员只能进行 **显示转换(强制类型转换)** .\n\n\n```csharp\n// Employee的基类是Object\n// 不需要转换, 派生类对象转基类对象是类型安全的隐式转换\nObject o = new Employee();\n\n// Employee是Object的派生类,需要进行转型\n// 必须用强制类型转换\nEmployee e = (Employee)o;\n```\n\n> 为了方便记忆,打个比方\n>- `公交汽车(派生类)` 可以认为是 `汽车(基类)` , 因为包含`汽车(基类)`都存在的东西.\n>- 但是, `汽车(基类)` 并不只有`公交汽车(派生类)`,还有其他类型的汽车.\n\n这样才能让编译器顺利编译这些代码.\n\n运行时做的事:\n1. CLR检查转型操作, 确保总是转换为对象的实际类型或者它的任何基类.\n\n```csharp\n// 在运行时, CLR会检查转换,判断o的实际类型是否是Employee类型或者它的派生类.\nEmployee e = (Employee) o;\n```\n( `A` ) >= `A/A的派生类`.\n\n因此,类型安全是CLR及其重要的一个特点.\n```csharp\nclass A{..}\n\nclass B:A{..}\n\nMain()\n{\n  B b = new B();\n  test(b);\n\n  DateTime t = new DateTime(...);\n  // 编译期 t的基类也是object,能通过编译\n  test(t);\n}\n\nstatic test(Object o)\n{\n  // 运行期会CLR会进行类型检查,\n  // 传进来的参数t类型基类不是A,也不是A的派生类,\n  // 会报System.InvalidCastException异常\n  A a = (A)o;\n}\n```\n给方法合适的参数能在编译期就能发现错误,而非运行期报错.例如改为`test(A a){}`而不是`Object`参数类型.\n\n\n# 使用C#的is和as操作符来转型\n\n> 相较于is操作符,使用as操作符来简化写法和提升性能.\n\n相较于之前的`()`强转语法,C#还有另外一方式进行类型转换. 是使用`is`操作符,区别如下\n1. 返回Boolean值true或false;\n2. 并且永远不会抛出异常.\n3. 如果对象引用null,is操作符总是返回false.\n\n通常使用方法:\n```csharp\n// 这种用法有个缺点,\n// CLR实际检查两次对象类型.\n// 1. is操作符首先核实o是否兼容于A类型,\n// 2. 如果是,在if内部转型时,CLR再次核实o是否引用一个A类型.\n// 这样对性能造成了一定的影响\nif(o is A)\n{\n  A a = (A)o;\n  // 在if剩余语句使用a\n}\n```\n\n**这种写法对性能造成影响,是因为CLR必须遍历继承层次结构,用每个基类型去核对指定的类型(上述例子中的A类型).**\n\nC#专门提供了as操作符,目的就是简化这种写法,同时提升性能.\n1. `as`操作符返回对同一个对象的`非null引用`.\n2. 工作方式与强制转换一样,并且不会抛出异常.\n3. 如果对象不能转型,则返回`null`.\n4. `as`操作符造成CLR值校验一次对象类型\n\n```csharp\n// as操作符造成CLR值校验一次对象类型\n// 从而提高性能\nA a = o as A;\nif (a != null)\n{\n  // 在if语句中使用a\n}\n\n```\n\n> 编译时错误 Complier Time Error 运行时错误Run Time Error\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 向基类型的转换是一种安全的隐式转换\n        Base b2 = new Dervied();\n\n        // CTE 编译时错误\n\n        // Base派生自object,不能由new基类创建子类. new子类可以创建基类\n        // Base b3 = new Object(); // CTE\n        Object o2 = new Base();\n\n        // Dervied d3 = new Object(); // CTE\n        Object o3 = new Dervied();\n\n        // new Dervied()隐式转为Base类. b2要转成原本的Dervied类型需要显示转换\n        // Dervied d3 = b2; // Base b2 = new Dervied();  // CTE\n        Dervied d3 = (Dervied)b2;\n\n        // RTE 运行时错误\n\n        // 不能由new基类转换子类,CLR会在运行期检查类型,判断 (Dervied) >= new Base()\n        Dervied d6 = (Dervied) new Base(); // RTE\n        Base b5 = (Base) new Object(); //RTE\n    }\n}\n\nclass Base{}\nclass Dervied : Base{}\n```\n\n**注意: C#允许类型定义`转换操作符`方法, 只有在使用转型表达式时才调用这些方法,使用C# `as/is操作符`永远不会调用它们.**\n\n\n\n# 命名空间和程序集\n\n1. 命名空间和程序集不一定相关, 同一个命名空间中的类型可能在不同程序集中实现.同一程序集也可能包含不同命名空间中的类型.\n2. 使用命名空间用`using`指令\n  - 引用类库,标记命名, 少写代码.\n  - 为类型和命名空间创建别名, 消除歧义.\n\n```csharp\nusing Microsoft; // 可以少写Microsoft.前缀\nusing Wintellect;// 可以少写Wintellect.前缀\n\nusing WintellectWidget = Wintellect.Widget; //\n\npublic class Program\n{\n  // 这样写会有歧义,不明确引用. 两个命名空间中都包含Widget类\n  // Widget w = new Widget();\n\n  // 消除了歧义, 需要多打一点字\n  Wintellect.Widget w = new Wintellect.Widget();\n\n  // 使用using别名方式\n  WintellectWidget w = new WintellectWidget();\n}\n```\n3. `外部别名extren alias` 用于更精细的消除歧义\n  - 公司Axxxx Bxxxx Cxxxxx和Ayyyy Byyyy Cyyyyy公司都发布一个`BuyProduct`类型\n  - 如果他们都用ABC作为命名空间, 那同时引用这2个公司的dll就会出现一个问题\n    - `ABC.BuyProduct`方法会报不明确引用.\n\n![](4类型基础/外部别名.png)\n\n\n> 为此,为了降低冲突发生的概率,应该使用全称来作为自己的顶级命名空间名称.\n\n# 运行时的相互关系\n\n- C#中`栈` 是**编译期间就分配好的内存空间**，因此你的代码中必须就`栈的大小`有明确的定义；\n- `堆` 是**程序运行期间动态分配的内存空间**，你可以根据程序的运行情况确定要分配的堆内存的大小.\n\n## 创建线程栈\n\n已加载CLR的一个Windows进程，进程中可能有多个线程。\n\n**线程创建时会分到1MB的栈。**\n- 栈空间用于向方法`传递实参`\n- 方法内部定义的`局部变量`也在栈上。\n- 栈从高位内存地址向地位地址构建。\n\n## 开始调用一个方法M1\n\n在开始调用之前,\n- `序幕(prologue)代码`对其进行初始化.\n\n在方法做完工作后\n- `尾声(epilogue)代码`对其进行清理,以便返回至调用者.\n\n![](4类型基础/4-2.png)\n\n1. 假定线程执行的代码要调用M1方法\n2. M1方法开始执行时,它的`序幕代码`在线程栈上分配`局部变量name`的内存,如4-3图示.\n\n![](4类型基础/4-3.png)\n\n3. 然后M1调用M2方法, 将`局部变量name`作为`实参`传递,将这个实参也`压入栈`,并且将`返回地址`压栈.\n  - `返回地址`:被调用的方法在结束之后应该回至该位置.如4-4图示.\n\n![](4类型基础/4-4.png)\n\n4. M2方法开始执行时, 它的`序幕代码`在线程栈上分配`局部变量length和tally`的内存. 如4-5所示.\n\n![](4类型基础/4-5.png)\n\n5. M2方法内部开始执行,最终达到`return`语句,CPU的指令指针被设置成`返回地址`. M2的`栈帧展开(unwind)`.恢复成4-3所示.\n\n> `栈帧展开(unwind)` : 这个翻译来源自生活,把线缠到线圈上称为wind,从线圈上搜开称为unwind.同样的调用方法时压入栈帧称为wind,方法执行完毕弹出栈帧称为unwind.\n\n6. 最终M1会返回到它的调用者. 这同样通过将CPU的指令指针设置成返回地址来实现.\n\n\n# 围绕CLR来观察,来演示CLR如何工作的\n\n```csharp\ninternal class Employee {\n    public               int32         GetYearsEmployed()       { ... }\n    public    virtual    String        GenProgressReport()      { ... }\n    public    static     Employee      Lookup(String name)      { ... }    \n}\ninternal sealed class Manager : Employee {\n    public    override   String         GenProgressReport()    { ... }\n}   \n```\n\n1. Window进程已经启动,CLR已经加载到其中,托管堆已经初始化,而且创建了一个线程(连同它的1MB栈空间).\n2. 准备要调用M3方法.\n\n![](4类型基础/4-6.png)\n\n3. **JIT编译器** 将M3的`IL代码`转换成`本机CPU指令`时, CLR需要确认定义了这些类的类型都已加载.\n  - `Employee`,`Int32`,`Manager`,以及`String`(因为存在一个\"Joe\"的字符串).\n4. 然后利用程序集的`元数据`,CLR提取与这些类型有关的信息. 并创`建一些数据结构`来表示类型本身.\n  - 图4-7展示了`Employee`和`Manager`类型对象使用的`数据结构`.\n  - 至于`Int32`,`String`的`数据结构`可以认为之前已经定义好了.因为它们都是很常用的类型.所以图中没显示它们.\n\n![](4类型基础/4-7.png)\n\n- 堆上所有对象都包含两个额外成员:\n  - `类型对象指针(type object pointer)`\n  - `同步索引块(sync block index)`\n- 静态数据字段.\n- 方法表: 定义的所有方法都有一个对应的记录项.\n\n5. 当CLR确认方法需要的所有类型对象都已创建,M3的代码编译之后,就允许线程执行M3的`本机代码`.\n  - M3的`序幕代码`执行时必须在线程栈中为局部变量分配内存.\n  - 在调用类型构造器之前,CLR会先初始化同步块索引,将对象的所有实例字段设为null或者0.\n  - CLR自动将所有局部变量初始化为`null`或者`0`.\n  - Manager只定义了1个方法(GetProgressReport的重写)\n\n![](4类型基础/4-8-9.png)\n\n6. 任何时候在堆上新建对象,CLR都自动初始化内部的`类型对象指针`成员来引用和对象对应的类型对象.\n7. new 操作符返回Manager对象的内存地址. 该地址保存到变量e中,(e在线程栈上).\n8. M3下一行代码调用Employee的`静态方法Lookup`.\n  - CLR定位类型对象\n  - JIT编译器查找类型对象的方法表中对应的记录项, 对方法进行JIT(如果需要的话).\n  - 再调用JIT编译好的代码.\n9. 假定`静态方法Lookup`会从数据库找出一名经理Joe.\n  - 在方法内会在堆上构造一个新的Manager对象, 用Joe的对象初始化它.返回该对象的地址.\n  - 该地址保存到变量e中\n  - 这里e不再引用第一个Manager对象, 第一个对象会被垃圾回收.\n10. M3的下一行代码调用Employee的非虚实例方法GetYearsEmployed\n  - JIT编译器会找到 **发出调用的那个变量(e)的类型 对应的类型对象(Employee)**.\n  - 此时e的类型定义为`Employee`类型\n    - 如果此类型中没有定义被调用的方法\n    - JIT编译器会**回溯类层次结构**(一直到Object),并沿途的每个类型中查找该方法.\n\n> 之所以能`回溯`,是因为每个类型对象都有一个字段引用了它的`基类型`.\n\n![](4类型基础/4-10.png)\n\n11. JIT编译器找到了被调用方法的记录项, 进行JIT编译,再调用JIT编译好的代码,将返回的数据放到临时变量中保存.\n\n12. M3的下一行代码调用了Employee的`虚实例方法(虚方法,重写过的)`GetProgressReport.\n  - `调用虚方法`时,JIT编译器要在方法中生成一些额外的代码.\n  - 方法每次调用都会执行这些代码, 这些代码首先\n    - 检查`发出调用的变量`, 并跟随地址来到`发出调用的对象`\n    - 变量e当前引用的是代表\"Joe\"的Manager对象.\n    - 代码检查对象内部的`类型对象指针`成员, 该成员指向对象的实际类型.\n    - 代码在类型对象的方法表中查找对应调用方法的`记录项`,对方法进行JIT编译\n    - 再调用编译好的代码.\n    - 由于目前e引用的是一个Manager对象,所以会调用Manager的GetProgressReport实现\n\n![](4类型基础/4-11-12.png)\n\n\n> 注意:  如果Employee对象的`Lookup方法`发现\"Joe\"是`Employee`而不是`Manager`,则Lookup会在内部构造一个Employee对象,它的类型对象指针将引用Employee类型, 最终执行的则是Employee的GetProgressReport实现,而不是Manager的.\n\n\n# CLR内部发生的事情\n\nEmployee和Manager类型对象都包含\"类型对象指针\"成员. 这是由于类型对象本质上也是对象.\n\nCLR创建类型对象时, 必须初始化这些成员.\n\n## 初始化什么呢?\n\n1. CLR开始在一个进程中运行时, 会立即为MSCorLib.dll中定义的`System.Type`类型创建一个特殊的类型对象.\n2. Employee和Manager类型对象都是该类型的\"`实例`\"``\n3. System.Object的`GetType方法`返回存储在指定对象的`类型对象指针`成员中的地址.\n  - 也就是说,GetType方法返回`指向对象的类型对象`的指针.\n  - 这样就可以判断系统中任何对象的真实类型.\n\n![](4类型基础/4-13.png)\n","tags":["CLR读书笔记"]},{"title":"3CLR基础4","url":"/2019/07/07/3CLR基础4/","content":"# 程序集种类和部署方式\n\n本章将解释 .Net Framework为了解决版本控制问题而建立的基础结构.\n\n## 为什么要有强命名程序集?\n\n因为只根据文件名来区分程序集明显不够, CLR必须支持对程序集进行唯一性标识的机制. 这就需要`强命名程序集`.\n\n## 私有部署 & 全局部署\n\n- 私有部署:程序集部署到应用程序`基目录`或者`某个子目录`.\n- 全局部署:部署到`公认位置`的程序集.\n\n## 强命名程序集 & 弱命名程序集\n\n- 强命名程序集\n  - 使用了发布者的公钥/私钥进行了`签名`.\n  - 这对秘钥允许对程序集进行唯一性的标识.\n  - 私有部署和全局部署都可以.\n- 弱命名程序集\n  - 只能以私有方式部署.\n\n### 在生成的程序集中引用强命名程序集\n\n1. CSC.exe编译器 /r 开关引用,如果不指定目录,按照以下顺序查找\n  - 工作目录\n  - CSC所在目录\n  - 使用/lib 编译器开关指定的目录\n  - 使用LIB环境变量指定的任何目录\n\n## 唯一性标识技术\n- GUID(Globally Unique Identifier) 全局唯一标识符\n- URL(Uniform Resource Locator) 统一资源定位符\n- URN(Uniform Resource Name)\n\n没有使用以上技术,使用了 `标准的公钥/私钥加密技术`\n\n![](3CLR基础4/公钥.png)\n\n`PublicKeyToken`:公钥标记, 如果没null,则是弱命名程序集.\n\n## 创建强命名程序集\n\n可以使用SN.exe(Strong Name)工具来生成公钥/私钥对。\n\n在VS中,新建`公钥/秘钥文件`,可显示项目属性,点击`签名`标签,勾选`为程序集签名`,然后从选择`强名称秘钥文件`中新建.\n\n\n# 全局程序集缓存\n\n1. 如果一个程序集要由多个应用程序访问，必须把它放到一个已知的目录中，而且clr在检测到对该程序集的一个引用时，必须知道自动检查该目录。这个已知的位置成为`全局程序集缓存(GAC,Global Assmbly Cache)`。\n2. GAC通常位于`%SystemRoot%\\Microsoft\\Assembly`\n3. GAC目录是结构化的：其中包含许多子目录，并用一个算法来生成这些子目录的名称。不要手动复制.要用工具完成.\n4. 可以使用GACUtil.exe在GAC中安装一个强命名程序集.\n5. 无法将弱命名程序集安装到GAC.\n\n\n# \"运行时\"如何解析类型引用\n\n1. 运行应用程序,CLR会加载并初始化自身\n2. 读取程序集的`CLR头`,查找标识了应用程序入口方法(Main)的`MethodDefToken`\n3. 检索`MethodDef元数据表`,找到方法的的IL代码在文件中的偏移量\n4. 将IL代码JIT编译成本机代码.\n5. 最后执行本机代码.\n\n\n解析引用的类型时候,CLR可以在三个地方找到类型：\n- 同一个文件（早期绑定）\n- 不同的文件但同一个程序集（当前程序集清单目录）\n- 不同的文件不同的程序集（其他程序集清单目录）。　　\n\n\n- `早期绑定early binding`: 编译时便能发现对相同文件中的类型的访问.\n- `晚期绑定late binding`: 在运行时通过反射机制绑定到类型并调用方法.\n\n1. 对于CLR来说，所有程序集都是根据名称、版本、语言文化和公钥来标识的。\n2. GAC根据名称、版本、语言文化和`cpu架构`来标识程序集。\n","tags":["CLR读书笔记"]},{"title":"2CLR基础3","url":"/2019/07/07/2CLR基础3/","content":"# .Net Framework部署目标\n\n## 什么是DLL Hell?\n\n> Windows早期并没有很严谨的DLL版本管理机制，以致经常发生安装了某软件后，因为其覆盖了系统上原有的同一个DLL文件，而导致原有可运行的程序无法运行。但还原回原有的DLL文件之后，所新安装的软件就无法运行。若影响到系统所使用的重要DLL时也可能让系统容易死机甚至无法正常启动。\n\n[別再掉進DLL地獄的陷阱裡(DLL Hell)~.NET解決之道 資策會數位教育研究所講師 王芳芳](https://web.archive.org/web/20080208173943/http://www.iiiedu.org.tw/knowledge/knowledge20021130_1.htm)\n\n总结:\n\n1. The .NET Framework NET Assembly 自描述与版本管理功能让 zero-impact(零影响) 的部署安装成为可能，同時也终结了DLL Hell 。\n\n2. Application-Private Assemblies (or 被隔离的assembly) 只能被一个应用程式所使用- 它不会被其他的应用程式所影响。 隔离的assembly 让程式开发者对应用程式有着绝对的控制权，开发好的Application-Private Assemblies只要部署在和应用程式同一目录即可。\n\n3. 透过Side by side execution(并行执行)的技术，应用程式只要安装成功之后，就不用担心DLL更新版本，或规格的改变， 它允许一个assembly 的多个版本在一个机器上同时被安装并执行， 而且每一个应用程式都可以要求和不同的Assembly 版本系结。\n\n4. The .NET Framework 纪录应用程式版本资讯，并在执行应用程式时使用此资讯载入应用程式所需依赖的正确版本的Assemblies。\n\n# 将类型生成到模块中\n\n```csharp\npublic sealed class Program{\n        public static void Main()\n        {\n          // 由于引用了Console类的WriteLine方法\n          // 要顺利通过编译，必须向C#编译器提供一组程序集\n          // 使他能解析对外部类型的引用\n          System.Console.WriteLine(\"Hi\");\n        }\n}\n```\n>System.Console是Microsoft实现好的类型，用于实现这个类型的各个方法的IL代码存储在MSCorLib.dll\n\n> 此处”r“意为`reference`\n\n因此需要添加`r:MSCorLib.dll` 开关命令，完整编译命令行应如下：\n`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs `\n\n但由于其他命令均为默认命令，本例中的编译命令行可以简化为\n`csc.exe Program.cs `\n\n如果不想C#编译器自动引用`MSCorLib.dll`程序集，可以使用`/nostdlib`开关。\n\n## 生成三种应用程序的编译器开关\n\n> 此处”t“意为`target`\n\n- 生成控制台用户界面(Console User Interface, CUI)应用程序使用`/t:exe`开关；\n- 生成图形用户界面(Graphical User Interface, GUI)应用程序使用`/t:winexe`开关；\n- 生成Windows Store应用程序使用`/t:appcontainerexe`开关；\n\n## 集合开关命令的文件:响应文件\n\n编译时可以指定包含编译器设置命令的响应文件，例如：假定响应文件`MyProject.rsp`包含以下文本\n\n```csharp\n// MyProject.rsp\n/out:MyProject.exe\n/target:winexe\n```\n为了让CSC.exe使用该响应文件，可以像下面这样调用它\n\n`csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs`\n\nC#支持多个响应文件，其先后顺序服从就近原则，优先级为`控制台命令>本地>全局`。\n\n.NET Framework具有一个默认的全局CSC.rsp文件，在运行CSC.exe进行编译时会自动调用，全局CSC.rsp文件中列出了所有的程序集，就不必使用C#的/reference开关显式引用这些程序集，这会对编译速度有一些影响，但不会影响最终的程序集文件，以及执行性能，开发者也可以自己为全局CSC.rsp添加命令开关，但这可能为在其他机器上重现编译过程带来麻烦。\n\n另外，指定/noconfig开关后，编译器将忽略本地和全局CSC.rsp文件。\n\n# 什么是元数据? 元数据概述\n\n> 元数据（英语：metadata），又称诠释数据、中介数据、中继数据、后设数据等，为描述其他数据信息的数据.\n\n>元数据概述：元数据是一种二进制信息，用以对存储在公共语言运行库可移植可执行文件 (PE) 文件或存储在内存中的程序进行描述。将您的代码编译为 PE 文件时，便会将元数据插入到该文件的一部分中，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中。在模块或程序集中定义和引用的每个类型和成员都将在元数据中进行说明。当执行代码时，运行库将元数据加载到内存中，并引用它来发现有关代码的类、成员、继承等信息。\n\n首先回顾一下`托管模块(Managed Module)`。`托管模块`是一个需要`CLR`才能执行的`标准WindowsPE(Portable executable，简称PE)文件`。\n\n- `PE32(+)头` :PE 文件主要部分的索引和入口点的地址。运行库使用该信息确定该文件为 PE 文件并确定当将程序加载到内存时执行从何处开始。\n- `CLR表头`:是一个小的信息块，是托管模块特有的，包含生成时所面向的版本号、一些标志、和一个MethodDef token用来指定模块的入口方法，最后，CLR头还包含模块内部的一些元数据表的大小的偏移量\n- `中间语言(IL)代码` : 编译器在编译源代码时产生的指令。CLR在运行时会将IL代码编译成本地CPU指令\n- `元数据`: 元数据表和堆,是由三种表构成的二进制数据块，这三种表分别为`定义表(definiton talbe)`、`引用表(reference table)`和`清单表(mainfest table)`。运行库使用该部分记录您的代码中每个类型和成员的信息。本部分还包括自定义属性和安全性信息。\n\n## 元数据描述的信息\n\n元数据以非特定语言的方式描述在代码中定义的每一类型和成员。元数据存储以下信息：\n\n- 程序集的说明\n  - 标识（名称、版本、区域性、公钥）。\n  - 导出的类型\n  - 该程序集所依赖的其他程序集。\n  - 运行所需的安全权限。\n- 类型的说明\n  - 名称、可见性、基类和实现的接口。\n  - 成员（方法、字段、属性、事件、嵌套的类型）。\n- 属性\n  - 修饰类型和成员的其他说明性元素。\n\n### 定义表(definiton talbe)\n\n**代码中定义的任何东西都将在上表中的某个表创建一个记录项。**\n\n| `定义表`名称 | 说明 |\n| :------| ------ |\n| ModuleDef\t| 包含`模块`文件名,扩展名(不含路径),编辑器创建的GUID 的 记录项.|\n| TypeDef\t| 每个`类型`都在这个表中有一个记录项,包含类型的名称,基类,标志(public/private等),一些索引.这些索引指向MethodDef中属于该类型的方法、FieldDef表中该类的字段、PropertyDef表中该类型的属性以及EventDef表中该类型的时间.|\n| MetodDef  | 每个`方法`(包括入口方法)都在这个表中有一个记录项, 包含方法的名称,标志,签名,以及方法的IL代码在模块中的偏移量(位置),每个记录项还引用了ParamDef表中的一个记录项，后者包括与方法参数有关的更多信息。 |\n|FieldDef   |\t模块定义的每一个`字段`在这个表中都有一个记录项。每个记录项都包括标志、类型和名称。   |\n| ParamDef  |  关于`参数`的记录项 |\n| PropertyDef\t  |  模块定义的每个`属性`在这个表中都有一个记录项。每个记录项都包含标志、类型和名称。 |\n|EventDef\t   | 模块定义的每个事件在这个表中都有一个记录项。每个记录项都包含标志和名称。  |\n\n### 引用表(reference table)\n| `引用表`名称 | 说明 |\n| :------| ------ |\n| AssemblyRef  | `引用的每个程序集`的记录项,每个记录项都包含绑定(bind)该程序集所需的信息：程序集名称(不包含路径和扩展名)、版本号、语言文化及公钥Token(根据发布者的公钥生成一个小的哈希值，标识了所引用程序集的发布者)。  |\n| ModuleRef  | 实现该模块所引用的类型的`每个PE模块`在这个表中都有一个记录项。每个记录项都包含模块的文件名和扩展名(不含路径),如果存在别的模块实现了你需要的类型，这个表的作用便是同哪些类型建立绑定关系  |\n| TypeRef  | 模块引用的每一个`引用类型`.....  |\n| MemberRef   | 模块引用的`每个成员`（字段和方法，以及属性方法和事件方法）在这个表中都有一个记录项。每个记录项都包含成员的名称和签名，并指向对成员进行定义的那个类型的TypeRef记录项  |\n\n### 清单表(mainfest table)\n\n| `引用表`名称 | 说明 |\n| :------| ------ |\n|AssemblyDef   | 如果模块标识的是程序集，这个元数据表就包含`单一记录项来列出程序集名称`(不包含路径和扩展名)、版本(major，minor，build和revision)、语言文化、标志、哈希算法以及发布者公钥(可为null)  |\n|FileDef   | 每个`PE文件和资源文件`在这个表中都有一个记录项(清单本身所在的文件除外，该文件在AssemblyDef表的单一记录项中列出) 在每个记录项中，都包含文件名和扩展名(不含路径)、哈希值和一些标志。如果程序集只包含他的主模块，不包含其他非主模块和资源文件。FileDef将无记录 |\n|ManifestResourceDef   | 每个`资源`在这个表中都有一个记录项 .记录项中包含资源名称、一些标志(如果程序集外部可见，就为public，否则为private)以及FileDef表的一个索引(指出资源或流包含在哪个文件中)。如果资源不是独立文件(比如.jpg或者.gif文件)，那么资源就是包含在PE文件中的流。对于嵌入资源，记录项还包含一个偏移量，指出资源流在PE文件中的起始位置|\n|ExportedTypesDef   | 从程序集的所有PE模块中`导出的每个public类型`在这个表中都有一个记录项。  |\n\n\n# 将模块合并成程序集\n\n## Microsoft为何考虑要引入程序集这一概念?\n\n这是因为使用程序集，`可重用类型`的`逻辑表示`和`物理表示`就可以分开。\n- 物理上，可以将常用的类型放在一个文件中，不常用的程序放在另一些文件中，只在使用时加载，\n- 在逻辑上，这些程序仍然被组织于同一程序集中，不需要编写额外的代码显式进行链接。\n\n## 程序集(Assembly)是什么组成的?\n\n程序集(Assembly)是一个或多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了`清单(Manifest)`，如上一节一开始所述，`清单`也是`元数据`的组成部分之一，表中主要包含作为程序集组成部分的那些文件的名称。此外还描述程序集的版本、语言文化、发布者、公开导出类型以及构成程序集的所有文件。\n\n`CLR`操作的是程序集，对于程序集，有以下几点重要特性：\n- 程序集定义了可重用的类型。\n- 程序集用一个版本号标记。\n- 程序集可以关联安全信息。\n\n**程序集是进行重用、版本控制和应用安全性设置的基本单元。**\n\n对于一个程序集来说，除了包含清单元数据表的文件，程序集中的其他文件独立时不具备以上特点.\n\n## 编译生成含有清单元数据表的PE文件\n\nC#编译器都会生成程序集： `/t: exe`, `/t: winexe`, `/t: appcontainerexe`, `/t: library` 或者`/t: winmdobj`。这些开关会指示编译器生成含有清单元数据表的PE文件。\n\nC#编译器还支持`/t: module`开关。这个开关指示编译器生成一个不包含清单元数据表的PE文件。这样生成的肯定是一个DLL PE文件。CLR要想访问其中的任何类型，必须先将该文件添加到一个程序集中。使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\n\n例如:\n将不常用类型编译到一个单独模块，这样一来如果程序集的用户永远不使用不常用类型，就不需要部署这个模块。\n```csharp\n// 使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\ncsc /t:module 不常用类型.cs\n```\n\n`不常用类型.netmodule`这是一个标准的DLL PE文件，但是CLR不能但单独加载它。\n\n将输出的文件名改为MultiFileLibrary.dll, 目标是生成库文件,添加`不常用类型`的模块, 编译`FUI.cs`\n```csharp\n// 指定了/t: library开关，所以生成的是含有清单元数据表的DLL PE文件\n// /addmodule:不常用类型.netmodule 开关告诉编译器不`常用类型.netmodule`文件是程序集的一部分，从而将其添加到FileDef清单元数据表，并将`不常用类型.netmodule`的公开导出类型添加到ExportedTypesDef清单源数据表。\ncsc /out:NultiFileLibray.dll /t:library /addmodule:不常用类型.netmodule FUT.cs\n```\n\n## 使用程序集链接器(AL.exe)生成程序集\n\n除了使用C#编译器，还可以使用”程序集链接器“实用程序AL.exe来创建程序集。如果程序集要求包含由不同编译器生成的模块(而这些编译器不支持与C#编译器的/addmodule开关等家的几种机制)，程序集连接器就显得相当有用。\n\n**AL.exe能生成EXE文件，或者生成只包含清单的DLL PE文件。程序集链接器不能将多个文件合并成一个文件。**\n\n```csharp\ncsc /t:module RUT.cs\ncsc /t:module FUT.cs\nal /out:MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule\n```\n## 为程序集添加资源文件\n\n- 用AL.exe创建程序集时，可用`/enbed [resource]`开关将文件作为资源添加到程序集。该开关获取任意文件，并将文件内容嵌入最终的PE文件。也可用`/Link [resource]`开关获取资源文件，但只指出资源包含在程序集的哪个文件，并不嵌入到PE文件中；该资源文件独立，并必须与程序集文件一同被打包部署\n- C#编译器用`/resource`开关将资源嵌入PE文件，用`/linkresource`开关添加记录项引用资源文件。以上开关均会修改ManifestResourceDef清单表添加记录项，外部引用的开关还会修改FileDef表以指出资源包文件。\n\n\n\n# 程序集版本资源信息\n\n> Visual Studio新建C#项目时会在一个Properties文件夹中自动创建AssemblyInfo.cs文件。可直接打开该文件并修改自己的程序集特有信息。\n\n在应用程序代码中调用`System.Diagnostics.FileVersionInfo的`静态方法`GetVersionInfo`并传递程序集路径作为参数可以获取并检查这些信息。\n\n![](2CLR基础3/版本资源字段和对应的特性.png)\n\n```csharp\n// 有关程序集的一般信息由以下\n// 控制。更改这些特性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle(\"LentilToolbox\")]\n[assembly: AssemblyDescription(\"Licensed under the MIT license\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"LentilToolbox\")]\n[assembly: AssemblyCopyright(\"Copyright ©  2016 Lentil Sun\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n//将 ComVisible 设置为 false 将使此程序集中的类型\n//对 COM 组件不可见。  如果需要从 COM 访问此程序集中的类型，\n//请将此类型的 ComVisible 特性设置为 true。\n[assembly: ComVisible(false)]\n\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid(\"ac315d57-80ca-4e7a-b55c-064b94547552\")]\n\n// 程序集的版本信息由下列四个值组成:\n//\n//      主版本\n//      次版本\n//      生成号\n//      修订号\n//\n//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值，\n// 方法是按如下所示使用“*”: :\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.1.0.2\")]\n[assembly: AssemblyFileVersion(\"1.1.0.2\")]\n\n```\n\n| - | \tmajor（主版本号）|\tminor（次版本号）|\tbuild（内部版本号）|\trevision（修订号）|\n| :-----:| :-----: | :-----: | :-----: | :-----: |\n|示例  | 2  | 5  | 719  | 2  |\n\n\n注意：程序集有三个版本号，每个版本号都有不同的用途：\n- `AssemblyFileVersion`：这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号的作用是说明**该程序集的版本**。\n- `AssemblyInformationalVersion`：同上，这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号作用是说明**使用该程序集的产品的版本**。\n- `AssemblyVersion`：存储在AssemblyDef清单元数据表中，CLR在绑定到强命名程序集时会用到它。这个版本号很重要，它**唯一性地标识了程序集。**\n\n\n\n\n# 语言文化\n\n![](2CLR基础3/语言文化标记.png)\n\n未指定具体语言文化的程序集成为`语言文化中性(Culture neutral)`。\n\n```csharp\n// 将程序集的语言文化设为瑞士德语\n[assembly: AssemblyCulture(\"de-CH\")]\n```\n\n# CLR探测程序集文件会扫描的目录\n","tags":["CLR读书笔记"]},{"title":"1CLR基础2","url":"/2019/07/06/1CLR基础2/","content":"> 温故而知新\n\n# CLR功能\n\n## JIT(just-in-time 运行时编译技术)\n\n>通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。\n\n>`即时编译器`则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。\n\n>即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。\n\n为了执行方法，首先必须将方法的IL转换成本机(native)CPU指令。这是CLR的JIT编译器的职责。\n\n### 流程讲解\n\n![](1CLR基础2/方法的首次调用.png)\n\n1. 在Main方法执行之前,CLR会检测出Main的`代码引用`的所有类型.\n  - CLR分配一个`内部数据结构`来管理对引用类型的访问.\n  - 图中,Main方法引用了Console类型,CLR分配了一个`内部结构`.\n  - Console类型定义的每个方法都在`内部结构`中存在一个`记录项 entry`.\n  - 根据这个记录项可以找到方法的实现.\n  - 对这个`内部结构`进行初始化,每个方法都指向包含在CLR内部的一个`未编档函数`,称之为`JITCompiler`.\n2. 进入Main方法,首次调用`WriteLine方法`时, `JITCompiler函数`被调用.\n3. `JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的`IL代码`.\n4. 然后`JITCompiler`验证`IL代码`,将`WriteLine方法`的`IL代码`编译成`本机CPU指令`.\n5. `本机CPU指令`保存到动态分配的内存块中.`JITCompiler`将在CLR为类型创建的`内部数据结构`中,修改引用.\n6. 指向到刚才动态分配的内存块地址. 最后`JITCompiler`跳转到内存块中的代码(`WriteLine方法`的具体实现).\n7. 返回到Main中的代码.\n\n![](1CLR基础2/方法的第二次调用.png)\n8. 第二次调用`WriteLine方法`,由于已经进行了验证和编译,会直接跳转到已经编译好的`本机CPU指令`代码块中执行.\n\n方法仅在首次调用时才会有一些性能损失,之后调用全是以本机代码的形式全速运行.\n\n## JIT 编译技术特点\n\n1. JIT编译器将本机CPU指令存储到动态内存中.意味着一旦应用程序终止,编译好的代码也会被丢弃.\n2. JIT编译器会对`本机代码`进行优化.类似于C++编译器后端所做的事情. 可能花较多的时间生成优化代码.\n> 在Visual Studio中新建C#项目时，”调试“(Debug)配置指定的是/optimize-/debug:full，而”发布“(release)配置指定的是/optimize+/debug:pdbonly。\n\n3. JIT能够针对本机CPU为IL代码生成指令，以利用本机指定CPU的任何特殊指令进行编译。相反，非托管应用程序通常是针对具有最小功能集合的CPU编译的。\n\nJIT编译器能够判断一个特定的测试在它运行的机器上是否总是失败，例如，假定有一个方法包含以下代码\n```csharp\n// 如果主机只有一个CPU，JIT编译器不会为此代码生成任何CPU指令。\nif(numberofCPUs>1){\n    ...//Do something\n}\n```\n\n## 将IL代码编译成本机代码的验证过程\n\n将IL代码编译成本机代码的过程中,CLR会执行验证过程,根据元数据检查类型,返回值,返回语句,参数是否正确等等.\n\n\n## NGen.exe生成的本机代码与JIT生成的本机代码对比\n\n1. NGen生成的代码**不会**像JIT编译器生成的代码进行高度优化.较差的执行时性能.\n2. CLR加载程序集时,会检查是否存在一个对应的,由NGen生产的本机文件.\n3. NGen.exe生成的本机文件没有知识产权保护.\n4. NGen生成的文件可能失去同步.版本不匹配,系统升级过等,就无法使用.\n\n\n# 基类库支持功能\n\n> .Net Framework 包含 Framework类库(Framework Class Library,FCL).\n\n1. FCL是一组DLL程序集的统称.\n\n![](1CLR基础2/FLC部分常规命名空间.png)\n","tags":["CLR读书笔记"]},{"title":"1CLR基础","url":"/2019/07/05/1CLR基础/","content":"\n> 对真正的力量一无所知。\n\n# 程序执行基础概念\n- 代码\n- 翻译器\n  - 编译器\n  - 优化编译器\n- 中间语言\n- 执行\n  - 运行时系统\n    - 运行期\n  - 可执行文件\n  - 解释器\n  - 虚拟机\n\n---\n- 代码类型\n  - 源代码\n  - 目标代码\n  - 字节码\n  - 机器代码\n  - 微程序\n\n\n# CLR和 .Net Framework的关系\n\n>.NET框架 （.NET Framework） 是由微软开发，一个致力于敏捷软件开发（Agile software development）、快速应用开发（Rapid application development）、平台无关性和网络透明化的软件开发平台。.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、VB.NET、C++、Python等）的开发。\n\n由此可见，`.Net Framework`是一个支持多种开发语言的开发平台，而这种多语言支持的特性又要以CLR为基础。CLR是一个.Net产品的运行环境。`公共语言运行时(Common Language Runtime)`和 `.Net Framework Library(FCL)`是`.Net Framework`的两个主要组成部分。\n\n\n# 什么是CLR?\n\n> 通用语言运行平台（Common Language Runtime，简称CLR）是微软为他们的.NET的虚拟机所选用的名称。它是微软对通用语言架构（CLI）的实现版本，它定义了一个代码运行的环境。CLR运行一种称为通用中间语言的字节码，这个是微软的通用中间语言实现版本。\n\n1. `CLR`是一个类似`JVM`的虚拟机, 为.NET的程序提供运行的环境.\n2. `CLR`中运行的是一种字节码形态的` Microsoft Intermediate Language，简称MSIL \"微软中间语言\"`.\n3. 在.Net开发平台下，所有语言（C#、VB.NET、J#、C++/CLI）都会被编译为`MSIL`\n\n## CLR做了什么?\n\n1. 将`IL`代码在`运行时`编译成`本机代码Native Code`.(`JIT(just-in-time 运行时编译技术)`)\n> 本机代码Native Code,是面向特定CPU架构(x86,x64,ARM)的代码\n\n![](1CLR基础/1.png)\n\n## CLR有哪些功能?\n\n- 基类库支持 Base Class Library Support\n- 内存管理 Memory Management\n- 线程管理 Thread Management\n- 垃圾回收 Garbage Collection\n- 安全性 Security\n- 类型检查 Type Checker\n- 异常管理 Exception Manager\n- 调试管理 Debug Engine\n- 中间码(MSIL)到机器代码(Native)编译 (即时编译 (JIT just-in-time))\n- 类别装载 Class Loader\n\n\n# CIL是什么?如何生成?\n\n>字节码现在已经官方地成为了CIL (通用中间语言（Common Intermediate Language，简称CIL)\n\n1. 在编译.NET编程语言时，源代码被翻译成`CIL`,再由`CLR`负责运行\n2. `IL代码`有时又称为`托管代码(managed code)`.\n3. `IL代码`只是`面向CLR的编译器`生成的其中一部分.\n\n## IL代码\n\n1. `IL`是与CPU无关的面向对象的机器语言.\n\n## 非托管代码\n\n1. C++编译器默认生成包含`非托管代码`的EXE/DLL模块.\n2. 并且在运行时操纵非托管数据(`native 内存`).\n3. 不需要CLR就能运行.\n4. 只有C++编译器允许开发人员同时写`托管代码`和`非托管代码`,并生成到同一模块中.\n\n### 非托管代码和托管代码的互操作性\n\n- 托管代码能调用DLL中的非托管函数：托管代码通过`P/invoke机制`调用DLL中的函数\n- 托管代码可以使用现有的COM组件：详情可参考 .NET Framework SDK提供的TlbImp.exe\n- 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。详情可以参考 .NET Framework SDK提供的TlbExp.exe和RegAsm.exe工具。\n\n\n# 面向CLR的编译器生成了什么?\n\n> 微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。\n\n1. 不同语言的`编译器(Compiler)`就相当于一个这种语言的代码审查者(Checker),所做的工作就是检查源码语法是否正确，然后将源码编译成`CLR`所需要的`中间语言(IL)`.\n2. `C#语言编译器`编译C#源码文件之后生成`托管模块`.\n\n![](1CLR基础/将源代码编译成托管模块.png)\n\n## C#编译器做的工作\n\n1. C#编译器(CSC.exe)默认将生成的**托管模块转换成程序集**,也就是生成的是**含有清单的托管模块**.\n2. 生成的是PE32(+)文件.\n3. 这个PE32(+)文件包含一个名为`清单(manifest)`的数据块. `清单`也是`元数据表`的集合.\n\n![](1CLR基础/将托管模块合并成程序集.png)\n\n\n# 托管模块是什么?由哪些组成?\n\n1. 无论是什么编译器，最后都是生成`托管模块`。\n2. `托管模块`是标准的32位的可移植执行体（PE32）文件，或者是64位的（PE32+）\n3. 需要`CLR`才能运行。\n4. 其中托管模块中还包含完整的`元数据`.\n\n![](1CLR基础/托管模块的各个部分.png)\n- `CLR头`：包含使这个模块成为托管模块的信息。\n- `IL中间语言代码`：编译器编译源码的时候生成的代码。运行时，`CLR`将`IL`编译成`本机CPU指令`\n- `元数据`：面向CLR的每个编译器要在每个托管模块中生成完整的元数据。元数据是一个数据表的集合。一些数据描述了模块中定义了什么，另一些描述了模块中引用了什么。由于编译器同时生成元数据和代码，把他们绑在一起，并嵌入最终生成的托管模块。所以元数据和他描述的代码不会失去同步。\n-\n\n## 可移植执行体PE文件的结构\n\n![](1CLR基础/PE文件架构.png)\n\n# 元数据是什么?\n\n1. `元数据`简单的说是一个数据表的集合.\n2. 主要包含两种表:\n  - 描述源代码中定义的类型和成员\n  - 描述源代码`引用的`类型和成员\n3. 元数据有多种用途\n  - 避免了编译时对原生C/C++数据头和库文件的需求. 因为IL代码中已经包含了全部信息.编译器直接读取元数据.\n  - `智能感知IntelliSense`技术解析元数据,提示帮助写代码.\n  - CLR验证代码使用元数据确保只执行`类型安全`的操作.\n  - `元数据`允许将对象的字段序列化到内存块,发到另一台机器反序列化,重建对象状态.\n  - `元数据`允许垃圾回收器跟踪对象的生存期.\n\n\n\n# CTS通用类型系统是什么?\n\n> 通用类型系统 (Common Type System) 定义了运行期引擎如果使用程序中的数据类型，以及如何配置数据在存储器中的一种标准，依照此种标准所撰写的编程语言，都可以在同一个运行期引擎中使用，因此它是跨语言支持的重要部分，亦即匹配 CTS 规范的编程语言所撰写出的程序，都可以在 CLR 中使用。\n\n> CTS与CLI规格都是由微软所发展，当前已标准化为 ECMA 335 标准：“Common Language Infrastructure (CLI) Partitions I to VI.”，并且由 Microsoft 在 .NET Framework 中完全的实现。\n\n**由于类型是CLR的根本，微软专门为如何定义、使用和管理类型定义了一个正式的规范-- 通用类型系统(Common Type System)，即CTS。**\n\n事实上, 不根本不需要专门学习CTS规则本身,因为你选择的余元会采用你熟悉的方式公开它自己的`语言语法`与`类型规则`,通过编译来生成程序集时,会将语言特有的语法映射到IL---也就是CLR的`语言`.\n\n无论使用哪一种语言,类型的行为都完全一致,因为最终是由CLR的CTS来定义类型的行为.\n\n## 类型可见性和访问规则\n\n- `private`           : 成员只能由同一个类(class)类型中的其他成员访问.\n- `protected`         : 成员可以从派生类型访问,不管是不是在同一个程序集中.\n- `internal`          : 成员可以由同一个程序集中的任何代码访问.\n- `protected internal`: 可以由任何程序集中的派生类型访问.\n- `public`            : 成员可由任何程序集中的任何代码访问.\n\n\n\n# CLS通用语言规范是什么?\n\n > 定义了一个最小公共集，任何编译器只有支持这个功能集，生成的类型才能兼容其他符合CLS、面向CLR的语言生成的组件\n\n![](1CLR基础/CLS图示.png)\n\n在开发类型和方法的时候，如果希望它们对外“可见”，能够从符合 CLS 的任何一种编程语言中访问，就必须遵守由 CLS 定义的规则。注意， 假如代码只是从定义（这些代码的）程序集的内部访问，CLS 规则就不适用了。\n\n```csharp\nusing System\n\n//告诉编译器检查CLS相容性\n[assembly:CLSCompliant(true)]\n\nnamespace SomeLibrary\n{\n    //因为是public类，所以会显示警告\n    public sealed class SomeLibrarytype\n    {\n        //警告：SomeLibrary.SomeLibraryType.Abc()的返回类型不符合CLS\n        public UInt32 Abc(){return 0;}\n\n        //警告：仅大小写不同的标识符SomeLibrary.SomeLibraryType.abc()不符合CLS\n        public void abc(){ }\n\n        //不显示警告：该方法是私有的\n        private UInt32 ABC(){return 0;}\n    }\n}\n```\n- 第一个警告是因为Abc方法返回了无符号整数，一些语言是不能操作无符号整数值的\n- 第二个警告是因为该类型公开了两个public方法，这两个方法只是大小写和返回类型有别，VB和其他一些语言无法区分这两个方法。\n\n# 关于window32位和64位版本\n1. 如果程序集文件只包含`类型安全`的`托管代码`在32位和64位上都能运行.\n> 类型安全代码指访问被授权可以访问的内存位置.有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。(直接访问内存的其他位置)\n\n2. 如果要使用`不安全的代码`, 需要用到`/playform`命令行开关.如果指定了,则只能在对应平台上使用.默认`anycpu`.\n3. 可执行文件执行时,Windows会检查文件头,64位系统会通过`WoW64(Windows on Windows64)`技术运行32位应用程序.\n\n![](1CLR基础/platform对生成的模块的影响.png)\n\n4. Windows启动托管应用程序的流程.\n\n![](1CLR基础/Windows运行EXE流程.png)\n\n5. 可在代码中查询\n  - `Environment.Is64BitOperatingSystem`属性,判断是否在64位系统上运行.\n  - `Environment.Is64BitProcess`属性,判断是否在64位地址空间中运行\n\n# 不安全的代码\n\nC#编译器默认生成的是安全代码.\n\nC#允许开发人员通过`unsafe`关键字标记包含不安全代码的方法.\n\n# 保护IL代码\n\n1. 混淆器\n2. 在非托管模块中实现想保密的算法, 利用CLR的互操作功能实现应用程序的托管和非托管部分之间的通讯.\n\n# 一些微软提供的实用工具\n- CSC.exe C#编译器:将多个托管模块和资源文件合并成程序集的工具.\n- AL.exe 程序集链接器:将一组文件合并到程序集中.\n- CLRVer.exe 列出机器上安装的所有CLR版本\n  - `-all` 或者指定 `目标进程ID` 列出正在允许的进程使用的CLR版本号.\n- DumpBin.exe 和 CorFlags.exe:可以用来检查编译器生成的托管模块所嵌入的信息.\n- ILAsm.exe IL汇编器\n- ILDasm.exe IL反汇编器\n>用IL反编译工具查看生成的IL代码。这里使用的是ILDasm.exe，当然，你也可以使用一些其他的工具，例如.Net Reflector、ILSpy等。\n\n- NGen.exe 本机代码生成器: 将程序集的所有IL代码编译成本机代码.并将本机代码保存到一个磁盘文件中.\n- PEVerify.exe 检查一个程序集的所有方法,并报告其中含有不安全代码的方法.\n- MPGO.exe 分析客户端应用程序启动需要哪些东西,会写入一个profile并嵌入程序集中.NGen能根据这个更好的优化生成本机映像.\n- TlbImp.exe 托管代码可以使用现有的COM组件.\n- TlbExp.exe和RegAsm.exe 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。\n- FusLogVw.exe 帮助你了解CLR在运行时与程序集的绑定.\n- SN.exe 获取秘钥(生成公钥/私钥对),未提供显示私钥的功能.\n- GACUtil.exe在GAC中安装一个强命名程序集\n","tags":["CLR读书笔记"]},{"title":"HelloWorld","url":"/2019/07/05/HelloWorld/","content":"\n\n![](https://portablehexo.bitmoe.cn/hexopp/hexop.png)\n\n>**本版本仅适用于Win环境**\n>本文关键字： **Hexo绿色版**，**Hexo便携版**，**Hexo配置**，**Hexo**，**U盘**\n\n[Hexo](https://hexo.io/)是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。\n\n但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。\n\n所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。\n\n#### **版本介绍**\n那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。\n\n本便携版（Release 1.0.0）所包含的软件如下：\n>- Git: 2.7.4\n>- Nodejs: 6.10.1\n>- Npm: 4.4.1\n>- Hexo: 3.2.2\n\n# 用到的主题和插件\n\n1. 兼容Markdown图片语法和Hexo图片语法插件:https://github.com/7ym0n/hexo-asset-image\n2. 主题:https://github.com/aircloud/hexo-theme-aircloud\n3. Tag-Cloud插件 https://github.com/MikeCoder/hexo-tag-cloud\n4. 代码高亮插件:https://github.com/ele828/hexo-prism-plugin\n","tags":["HEXO"]},{"title":"ET入门小指南 v19.7.4","url":"/2019/07/04/ET入门小指南/","content":"\n![](ET入门小指南/1.jpg)\n\n# 了解ET\n\n[[Github]](https://github.com/egametang/ET)\n[[ET论坛]](https://bbs.honorworkroom.com/forum.php)\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端.\n\n[[具体介绍]](https://github.com/egametang/ET/blob/master/README.md)\n\n- [为什么使用C# .net core做服务端？](https://github.com/egametang/ET/blob/master/Book/1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.md)\n  - ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。\n- **为什么选择Unity作为客户端?**\n  - 当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。 客户端可以不使用Unity3d,需要自己对接协议.\n- [为什么后端选MongoBson序列化库?](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n- [为什么选MongoDB数据库?](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=183&extra=page%3D1)\n- [为什么选择ProtoBuf?](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 基于google官方3.4.1版本的protobuf c#-runtime以及3.4.0版本的protoc修改而来，还增加了0gc功能。仍然是标准的pb协议\n  - [ET使用精简过的PB库](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n- **为什么选择ILRuntime热更?**\n  - 因为ios的限制，之前unity热更新一般使用lua，导致unity3d开发人员要写两种代码，麻烦的要死。之后幸好出了ILRuntime库，利用ILRuntime库，unity3d可以利用C#语言加载热更新dll进行热更新。ILRuntime一个缺陷就是开发时候不支持VS debug，这有点不爽。ET框架使用了一个预编译指令ILRuntime，可以无缝切换。平常开发的时候不使用ILRuntime，而是使用Assembly.Load加载热更新动态库，这样可以方便用VS单步调试。在发布的时候，定义预编译指令ILRuntime就可以无缝切换成使用ILRuntime加载热更新动态库。这样开发起来及其方便，再也不用使用狗屎lua了\n- [什么是组件式设计?](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n\n\n# 运行Demo前的准备事项\n\n1. IDE选择\n  - **VS**\n    - ET 5.0(master)\n      - 建议使用VS2019 ( 用2017就自己去官网下 .net core 2.2)\n    - ET 4.0分支使用vs2017（更新到最新版）,并且要勾选\n      - a. .net 桌面开发\n      - visual studio tools for unity\n      -  .net core 2.1\n  - **Rider**\n    - 安装 .net core 2.2\n  - other.....\n\n2. Unity版本选择\n  - ET4.0请使用unity2017.4版\n  - ET5.0(master)需要unity2018.4版\n  - [为什么是.4版本](https://www.bilibili.com/video/av49789692)\n  - 别问怎么破解.问就是个人免费版.\n    - 如果只是为了黑色皮肤, 请参考 [UnityDarkSkin](https://github.com/Gluschenko/UnityDarkSkin)\n\n\n3. 安装MongoDB数据库(Demo中注释了数据库组件,只为了运行demo,就随意)\n\n\n# 准备运行Demo\n\n- [运行指南](https://github.com/egametang/ET/blob/master/Book/1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.md)\n\n- [常见的错误解决方法](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=203&extra=page%3D1)\n\n\n\n\n## 测试状态同步Demo\n\n打包一个客户端,unity开一个客户端.就会出现2个小人.点击鼠标右键即可移动人物.看到效果.\n\n## 帧同步Demo\n\n在4.0分支.\n\n# 学习ET\n\n\n\n\n你可能需要如下知识储备:\n- C# 语言基础 ([你渴望力量吗?](https://pan.baidu.com/s/1mqaaVIxOVo02pg8aXaQKXg)s1fz )\n- 设计模式    ([你渴望知识吗?](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 数据结构    ([那就看完吧](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 反射\n- 特性\n- 异步/协程\n- 了解ECS\n- 了解actor模型\n- 网络层TCP/UDP/KCP/ENET\n- MongoDB数据库\n- MongoBson\n- Protobuf\n- 服务器分布式相关\n- [网络同步模型的认识](https://www.gameres.com/849046.html?tdsourcetag=s_pcqq_aiomsg)\n\n客户端\n- Unity基础\n- UGUI\n- AssetBundle流程\n- 热更ILRuntime\n\n其余\n- AstarPathfinding\n- Behavior Designer\n- FGUI\n- NLog\n\n\n>猫大语录:\n应该先去提高下c#基础跟编程基础，再来看ET，碰到问题自己想办法解决，谷歌，打log。你现在好比初中基础却来做大学题目一样，到处碰壁，碰到问题自己不研究指望别人给你找问题，这样编程技术是无法提高的.\n群里能力有高有低，问问题也没什么。但是我是希望群里提问题前能够经过自己一番摸索，经过自己思考，经过谷歌，经过调试log等等再问。很多问题经过自己摸索查找资料能够增长很多知识。其实程序开发就是在不断找bug，在找bug中提升自己。\n\n# ET框架设计大纲\n\n- 公共部分\n  - ET的特色\n  - 什么是ECS\n- async await 协程\n\t- 什么是异步? 单线程？多线程？\n      - [ET/Book/2.1CSharp的协程](https://github.com/egametang/ET/blob/master/Book/2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n      - [ET/Book/2.2更好的协程](https://github.com/egametang/ET/blob/master/Book/2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n\t- 为什么需要async await，await是多线程吗？\n    \t- [ET/Book/2.3单线程异步](https://github.com/egametang/ET/blob/master/Book/2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md)\n\t- 更好的Task：ETTask\n    \t- [群内讨论/ETTask](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=204&extra=page%3D1)\n- [一切皆组件（Entity&Component）](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n  - [事件机制EventSystem](https://github.com/egametang/ET/blob/master/Book/3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.md)\n  - [强大的mongo bson](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n  - 设计一个双端网络库\n  - 协议格式的设计\n  - [protobuf](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 使用Kcp协议\n      - [kcp-bulild](https://github.com/egametang/kcp-bulild)\n  - 应用层循环缓冲区\n  - 消息打包解包\n  - 消息的分发处理\n  - 远程过程调用RPC\n  - 客户端无GC处理\n- 服务端\n\t- 服务端架构简介\n    \t- [服务器命名以及消息类的X2X代表意思](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=161&extra=page%3D1)\n\t- 组件式的服务器\n\t- [Actor模型](https://github.com/egametang/ET/blob/master/Book/5.4Actor%E6%A8%A1%E5%9E%8B.md)\n\t- [ActorLocation](https://github.com/egametang/ET/blob/master/Book/5.5Actor%20Location.md)\n\t- 设计一个计时器( TimerCompoent组件 )\n\t- 服务端热更\n    \t- [群内讨论/热更层和Model层/逻辑与数据相关](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=146&extra=page%3D1)\n\t- Config\n\t- [数值组件](https://github.com/egametang/ET/blob/master/Book/5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.md)\n    \t- [群内讨论/数值组件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=139&extra=page%3D1)\n\t- Repl\n    \t- [Nlog配置和Repl](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=151&extra=page%3D1)\n- 客户端\n\t- 客户端架构简介\n\t- 客户端资源管理\n\t- UI框架\n\t- 客户端热更 (ILRuntime)\n\t- 抛弃unity的协程，使用await\n\t- 组件可视化\n- Demo\n\t- demo的架构, 消息路径\n    \t- [Demo消息流转时序图](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=145&extra=page%3D2)\n\t- recast 3d寻路\n\n\n# ET的一些教学视频\n- [肉饼老师主讲](https://www.taikr.com/my/course/972) : ET3.0时期教程,可以学习如何分离客户端和服务器端,和一些开发思路\n- [初见主讲(B站)](https://www.bilibili.com/video/av33280463/?redirectFrom=h5) - [优酷](https://i.youku.com/i/UNTQ3MjU4MDEy?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DT~A):ET4.0教程,工具使用及demo运行,ET入门教程\n- [ET在Mac上运行指南-L主讲](http://www.liuocean.com/index.php/2018/07/25/et-kuang-jiamac-duan-gong-ju-zhi-chi/)百度云视频链接失效，参考文章吧\n\n\n# 群内大佬的Github\n- [C# 实现的十字链表的AOI算法](https://github.com/qq362946/AOI) by 初见\n  - [群内讨论/十字链表+快慢针方式的AOI算法可用于双端](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=174&extra=page%3D1)\n- [在初见的AOI（2D）的基础改成3D AOI](https://github.com/yhr28/3D_AOI) by yhr28\n- [ET-RPG-DEMO(基于ET框架的RPG游戏DEMO)](https://github.com/AnotherEnd15/ET-RPG-DEMO)   by AE\n  - [一种完全组合式的技能系统的设计思路](https://blog.csdn.net/qq_32270109/article/details/88551196?tdsourcetag=s_pcqq_aiomsg)\n- [RVO2](https://github.com/AnotherEnd15/RVO2) by AE\n- [Box2DSharp(BOX2D物理引擎C#版)](https://github.com/Zonciu/Box2DSharp)  by 白纸无字Zonciu\n- [Bullet版本(.netCore封装)](https://gitee.com/fengssy/ET-Platform-Bullet?tdsourcetag=s_pcqq_aiomsg) by 风恒\n- [FGUI/双端行为树](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n  - [群内讨论/Behavior Designer全热更行为树插件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=170&extra=page%3D1)\n- [NKGNMobaBasedOnET(基于ET框架的Moba游戏DEMO)](https://gitee.com/NKG_admin/MKGMobaBasedOnET) by 烟雨迷离半世殇\n- [ET斗地主Demo](https://github.com/Viagi/LandlordsCore)\n  - [斗地主架构图](https://pan.baidu.com/s/1wyv6ihefBjQmVynIUBumKA) o05k\n- [ET-MultiplyDemos小游戏集合](https://github.com/Acgmart/ET-MultiplyDemos) by 咲夜詩\n- [五星麻将](https://github.com/wufanjoin/fivestar) by 間 間 單 單\n- [苏伟涛大佬的github库](https://github.com/swicksu/ET-Plus)  ([B站主页](https://space.bilibili.com/72371081))\n\n# 群内大佬分享的一些工具/组件\n\n- [[Debug组件]DebuggerComponent.cs](https://pan.baidu.com/s/1bGJxNGu5P9KB8czCK1NRtw)  mcyz\n- [[Console插件]DebugCodeLocation.cs ](https://pan.baidu.com/s/1mptlsaf9L4w0x5pIRTvA9Q)\n  - log双击利用Console插件能够方便的跳到Hotfix代码中\n- [[AspNet组件]AspNetCoreComponent](https://pan.baidu.com/s/1q6KEgLY08pdht6IioVekVQ) z84o\n- [[Http请求帮助类]HttpRequestHelper](https://pan.baidu.com/s/15sf7KuMvN0NU_Dsx0frtiQ) 7mvr\n- [ET心跳组件2.0](https://pan.baidu.com/s/1oR8f9fSE91bsfmyPCjCTZg) 8p0b\n  - [这篇是初见早期写的心跳文章](http://www.tinkingli.com/?p=111) 不会心跳的可以看下原理\n- [增加工具封装模板github](https://github.com/swicksu/ET-Plus) by 苏伟涛\n  - [[AutoGenerateCodeEditor]](https://github.com/swicksu/ET-Plus/blob/master/Unity/Assets/Editor/PlusEditor/AutoGenerateCodeEditor.cs)\n  - Unity中创建新脚本自动生成ET模板代码\n  - [演示视频](https://pan.baidu.com/s/12F-K2pyab61VJ77bhAmqlw)\n  - ETConfig制作流程简化\n  - [演示视频](https://pan.baidu.com/s/1uG7Lb6JimEBukxBTsCudYw)\n  - 使用Scp同步ET热更资源到服务器\n  - [演示视频](https://pan.baidu.com/s/1-9AShPBswKNg5y3v3ynC2g)\n\n# ET学习笔记/博客/公众号\n\n- [ET Mac环境运行和iOS打包指南.pdf](https://pan.baidu.com/s/1LyDaeA3l3skySb3ECu3VvA ) 9bzj\n- [Tinkingli博客教程](http://www.tinkingli.com/?cat=8)\n- [ECS概要--ET游戏框架详解](https://mp.weixin.qq.com/s/tDgqE_Ah8PWfnAGfi_R-aQ)  by 122304518\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n- [咲夜詩的博客](https://acgmart.com/unity/)\n- [群内分享的一些ET笔记](https://pan.baidu.com/s/1KqtGWVbFBRtQ_RJZTMYFww) ho3e\n- [ET5.0学习思维导图](https://pan.baidu.com/s/14XLl0v9oDlA72VxkdPtnEQ)  by 小豆子\n- [ET网络消息流程(Send) & ET网络消息流程(Connect&Recive) & (DateFlow)](https://pan.baidu.com/s/1jz66RNsZmlUhvFDg6h5ZBQ) by 小豆子\n- [Atheos的笔记](https://www.processon.com/view/link/5cb935fae4b0bab9095ebbd0#map)\n\n# 相关技术的教学文章\n\n## 大学生学习资源表\n- [为大学生策划的资源列表A-to-Z-Resources-for-Students](https://github.com/dipakkr/A-to-Z-Resources-for-Students)\n\n\n\n## MongoDB\n- [官方Driver教程](https://mongodb.github.io/mongo-csharp-driver/2.7/getting_started/)\n- [官方API文档](http://api.mongodb.com/csharp/current/html/R_Project_CSharpDriverDocs.htm)\n- [菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [Working with MongoDB in .NET (Part 1): Driver Basics & Inserting Documents](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz)\n- [Working with MongoDB in .NET (Part 2): Retrieving Documents with Filter Clause](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-2-retrieving-mrlbeanm5)\n- [Working with MongoDB in .NET (Part 3): Skip, Sort, Limit, & Projections](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka)\n\n\n## ILRuntime\n\n- [官方主页](https://ourpalm.github.io/ILRuntime/public/v1/guide/index.html)\n- [Github-Demo](https://github.com/Ourpalm/ILRuntimeU3D/)\n- QQ群:512079820\n- [ILRuntime技术相关的总结](https://pan.baidu.com/s/1Re-mM-9KEoO3D7VXePdyIg) vz3q\n- [群内讨论/ILRuntime剪裁相关问题](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=195&extra=page%3D1)\n\n\n## FGUI\n\n- [官方主页](http://www.fairygui.com/guide/index.html)\n- [官方教程](http://www.sikiedu.com/course/139)\n- QQ群:614444599\n- [ET+FGUI+BD](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n","tags":["ET"]},{"title":"test","url":"/2019/07/04/test/","content":"# Test!!!!!!!!!!\n\n\n```csharp\nusing System;\nusing MongoDB.Driver;\n\nnamespace ETModel\n{\n\t[ObjectSystem]\n\tpublic class DBQueryTaskSystem : AwakeSystem<DBQueryTask, string, ETTaskCompletionSource<ComponentWithId>>\n\t{\n\t\tpublic override void Awake(DBQueryTask self, string collectionName, ETTaskCompletionSource<ComponentWithId> tcs)\n\t\t{\n\t\t\tself.CollectionName = collectionName;\n\t\t\tself.Tcs = tcs;\n\t\t}\n\t}\n\n\tpublic sealed class DBQueryTask : DBTask\n\t{\n\t\tpublic string CollectionName { get; set; }\n\n\t\tpublic ETTaskCompletionSource<ComponentWithId> Tcs { get; set; }\n\n\t\tpublic override async ETTask Run()\n\t\t{\n\t\t\tDBComponent dbComponent = Game.Scene.GetComponent<DBComponent>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// 执行查询数据库任务\n\t\t\t\tIAsyncCursor<ComponentWithId> cursor = await dbComponent.GetCollection(this.CollectionName).FindAsync((s) => s.Id == this.Id);\n\t\t\t\tComponentWithId component = await cursor.FirstOrDefaultAsync();\n\t\t\t\tthis.Tcs.SetResult(component);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthis.Tcs.SetException(new Exception($\"查询数据库异常! {CollectionName} {Id}\", e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","tags":["Test"]}]