[{"title":"一CLR基础2","url":"/2019/07/06/一CLR基础2/","content":"> 温故而知新\n\n#CLR功能\n\n## JIT(just-in-time 运行时编译技术)\n\n>通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。\n\n>`即时编译器`则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。\n\n>即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。\n\n为了执行方法，首先必须将方法的IL转换成本机(native)CPU指令。这是CLR的JIT编译器的职责。\n\n### 流程讲解\n\n![](一CLR基础2/方法的首次调用.png)\n\n1. 在Main方法执行之前,CLR会检测出Main的`代码引用`的所有类型.\n  - CLR分配一个`内部数据结构`来管理对引用类型的访问.\n  - 图中,Main方法引用了Console类型,CLR分配了一个`内部结构`.\n  - Console类型定义的每个方法都在`内部结构`中存在一个`记录项 entry`.\n  - 根据这个记录项可以找到方法的实现.\n  - 对这个`内部结构`进行初始化,每个方法都指向包含在CLR内部的一个`未编档函数`,称之为`JITCompiler`.\n2. 进入Main方法,首次调用`WriteLine方法`时, `JITCompiler函数`被调用.\n3. `JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的`IL代码`.\n4. 然后`JITCompiler`验证`IL代码`,将`WriteLine方法`的`IL代码`编译成`本机CPU指令`.\n5. `本机CPU指令`保存到动态分配的内存块中.`JITCompiler`将在CLR为类型创建的`内部数据结构`中,修改引用.\n6. 指向到刚才动态分配的内存块地址. 最后`JITCompiler`跳转到内存块中的代码(`WriteLine方法`的具体实现).\n7. 返回到Main中的代码.\n\n![](一CLR基础2/方法的第二次调用.png)\n8. 第二次调用`WriteLine方法`,由于已经进行了验证和编译,会直接跳转到已经编译好的`本机CPU指令`代码块中执行.\n\n方法仅在首次调用时才会有一些性能损失,之后调用全是以本机代码的形式全速运行.\n\n## JIT 编译技术特点\n\n1. JIT编译器将本机CPU指令存储到动态内存中.意味着一旦应用程序终止,编译好的代码也会被丢弃.\n2. JIT编译器会对`本机代码`进行优化.类似于C++编译器后端所做的事情. 可能花较多的时间生成优化代码.\n> 在Visual Studio中新建C#项目时，”调试“(Debug)配置指定的是/optimize-/debug:full，而”发布“(release)配置指定的是/optimize+/debug:pdbonly。\n\n3. JIT能够针对本机CPU为IL代码生成指令，以利用本机指定CPU的任何特殊指令进行编译。相反，非托管应用程序通常是针对具有最小功能集合的CPU编译的。\n\nJIT编译器能够判断一个特定的测试在它运行的机器上是否总是失败，例如，假定有一个方法包含以下代码\n```csharp\n// 如果主机只有一个CPU，JIT编译器不会为此代码生成任何CPU指令。\nif(numberofCPUs>1){\n    ...//Do something\n}\n```\n\n## 将IL代码编译成本机代码的验证过程\n\n将IL代码编译成本机代码的过程中,CLR会执行验证过程,根据元数据检查类型,返回值,返回语句,参数是否正确等等.\n\n\n## NGen.exe生成的本机代码与JIT生成的本机代码对比\n\n1. NGen生成的代码**不会**像JIT编译器生成的代码进行高度优化.较差的执行时性能.\n2. CLR加载程序集时,会检查是否存在一个对应的,由NGen生产的本机文件.\n3. NGen.exe生成的本机文件没有知识产权保护.\n4. NGen生成的文件可能失去同步.版本不匹配,系统升级过等,就无法使用.\n\n\n# 基类库支持功能\n\n> .Net Framework 包含 Framework类库(Framework Class Library,FCL).\n\n1. FCL是一组DLL程序集的统称.\n\n![](一CLR基础2/FLC部分常规命名空间.png)\n","tags":["CLR读书笔记"]},{"title":"一CLR基础","url":"/2019/07/05/一CLR基础/","content":"\n> 对真正的力量一无所知。\n\n# 程序执行基础概念\n- 代码\n- 翻译器\n  - 编译器\n  - 优化编译器\n- 中间语言\n- 执行\n  - 运行时系统\n    - 运行期\n  - 可执行文件\n  - 解释器\n  - 虚拟机\n\n---\n- 代码类型\n  - 源代码\n  - 目标代码\n  - 字节码\n  - 机器代码\n  - 微程序\n\n\n# CLR和 .Net Framework的关系\n\n>.NET框架 （.NET Framework） 是由微软开发，一个致力于敏捷软件开发（Agile software development）、快速应用开发（Rapid application development）、平台无关性和网络透明化的软件开发平台。.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、VB.NET、C++、Python等）的开发。\n\n由此可见，`.Net Framework`是一个支持多种开发语言的开发平台，而这种多语言支持的特性又要以CLR为基础。CLR是一个.Net产品的运行环境。`公共语言运行时(Common Language Runtime)`和 `.Net Framework Library(FCL)`是`.Net Framework`的两个主要组成部分。\n\n\n# 什么是CLR?\n\n> 通用语言运行平台（Common Language Runtime，简称CLR）是微软为他们的.NET的虚拟机所选用的名称。它是微软对通用语言架构（CLI）的实现版本，它定义了一个代码运行的环境。CLR运行一种称为通用中间语言的字节码，这个是微软的通用中间语言实现版本。\n\n1. `CLR`是一个类似`JVM`的虚拟机, 为.NET的程序提供运行的环境.\n2. `CLR`中运行的是一种字节码形态的` Microsoft Intermediate Language，简称MSIL \"微软中间语言\"`.\n3. 在.Net开发平台下，所有语言（C#、VB.NET、J#、C++/CLI）都会被编译为`MSIL`\n\n## CLR做了什么?\n\n1. 将`IL`代码在`运行时`编译成`本机代码Native Code`.(`JIT(just-in-time 运行时编译技术)`)\n> 本机代码Native Code,是面向特定CPU架构(x86,x64,ARM)的代码\n\n![](一CLR基础/1.png)\n\n## CLR有哪些功能?\n\n- 基类库支持 Base Class Library Support\n- 内存管理 Memory Management\n- 线程管理 Thread Management\n- 垃圾回收 Garbage Collection\n- 安全性 Security\n- 类型检查 Type Checker\n- 异常管理 Exception Manager\n- 调试管理 Debug Engine\n- 中间码(MSIL)到机器代码(Native)编译 (即时编译 (JIT just-in-time))\n- 类别装载 Class Loader\n\n\n# CIL是什么?如何生成?\n\n>字节码现在已经官方地成为了CIL (通用中间语言（Common Intermediate Language，简称CIL)\n\n1. 在编译.NET编程语言时，源代码被翻译成`CIL`,再由`CLR`负责运行\n2. `IL代码`有时又称为`托管代码(managed code)`.\n3. `IL代码`只是`面向CLR的编译器`生成的其中一部分.\n\n## IL代码\n\n1. `IL`是与CPU无关的面向对象的机器语言.\n\n## 非托管代码\n\n1. C++编译器默认生成包含`非托管代码`的EXE/DLL模块.\n2. 并且在运行时操纵非托管数据(`native 内存`).\n3. 不需要CLR就能运行.\n4. 只有C++编译器允许开发人员同时写`托管代码`和`非托管代码`,并生成到同一模块中.\n\n### 非托管代码和托管代码的互操作性\n\n- 托管代码能调用DLL中的非托管函数：托管代码通过`P/invoke机制`调用DLL中的函数\n- 托管代码可以使用现有的COM组件：详情可参考 .NET Framework SDK提供的TlbImp.exe\n- 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。详情可以参考 .NET Framework SDK提供的TlbExp.exe和RegAsm.exe工具。\n\n\n# 面向CLR的编译器生成了什么?\n\n> 微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。\n\n1. 不同语言的`编译器(Compiler)`就相当于一个这种语言的代码审查者(Checker),所做的工作就是检查源码语法是否正确，然后将源码编译成`CLR`所需要的`中间语言(IL)`.\n2. `C#语言编译器`编译C#源码文件之后生成`托管模块`.\n\n![](一CLR基础/将源代码编译成托管模块.png)\n\n## C#编译器做的工作\n\n1. C#编译器(CSC.exe)默认将生成的**托管模块转换成程序集**,也就是生成的是**含有清单的托管模块**.\n2. 生成的是PE32(+)文件.\n3. 这个PE32(+)文件包含一个名为`清单(manifest)`的数据块. `清单`也是`元数据表`的集合.\n\n![](一CLR基础/将托管模块合并成程序集.png)\n\n\n# 托管模块是什么?由哪些组成?\n\n1. 无论是什么编译器，最后都是生成`托管模块`。\n2. `托管模块`是标准的32位的可移植执行体（PE32）文件，或者是64位的（PE32+）\n3. 需要`CLR`才能运行。\n4. 其中托管模块中还包含完整的`元数据`.\n\n![](一CLR基础/托管模块的各个部分.png)\n- `CLR头`：包含使这个模块成为托管模块的信息。\n- `IL中间语言代码`：编译器编译源码的时候生成的代码。运行时，`CLR`将`IL`编译成`本机CPU指令`\n- `元数据`：面向CLR的每个编译器要在每个托管模块中生成完整的元数据。元数据是一个数据表的集合。一些数据描述了模块中定义了什么，另一些描述了模块中引用了什么。由于编译器同时生成元数据和代码，把他们绑在一起，并嵌入最终生成的托管模块。所以元数据和他描述的代码不会失去同步。\n-\n\n## 可移植执行体PE文件的结构\n\n![](一CLR基础/PE文件架构.png)\n\n# 元数据是什么?\n\n1. `元数据`简单的说是一个数据表的集合.\n2. 主要包含两种表:\n  - 描述源代码中定义的类型和成员\n  - 描述源代码`引用的`类型和成员\n3. 元数据有多种用途\n  - 避免了编译时对原生C/C++数据头和库文件的需求. 因为IL代码中已经包含了全部信息.编译器直接读取元数据.\n  - `智能感知IntelliSense`技术解析元数据,提示帮助写代码.\n  - CLR验证代码使用元数据确保只执行`类型安全`的操作.\n  - `元数据`允许将对象的字段序列化到内存块,发到另一台机器反序列化,重建对象状态.\n  - `元数据`允许垃圾回收器跟踪对象的生存期.\n\n\n\n# CTS通用类型系统是什么?\n\n> 通用类型系统 (Common Type System) 定义了运行期引擎如果使用程序中的数据类型，以及如何配置数据在存储器中的一种标准，依照此种标准所撰写的编程语言，都可以在同一个运行期引擎中使用，因此它是跨语言支持的重要部分，亦即匹配 CTS 规范的编程语言所撰写出的程序，都可以在 CLR 中使用。\n\n> CTS与CLI规格都是由微软所发展，当前已标准化为 ECMA 335 标准：“Common Language Infrastructure (CLI) Partitions I to VI.”，并且由 Microsoft 在 .NET Framework 中完全的实现。\n\n**由于类型是CLR的根本，微软专门为如何定义、使用和管理类型定义了一个正式的规范-- 通用类型系统(Common Type System)，即CTS。**\n\n事实上, 不根本不需要专门学习CTS规则本身,因为你选择的余元会采用你熟悉的方式公开它自己的`语言语法`与`类型规则`,通过编译来生成程序集时,会将语言特有的语法映射到IL---也就是CLR的`语言`.\n\n无论使用哪一种语言,类型的行为都完全一致,因为最终是由CLR的CTS来定义类型的行为.\n\n## 类型可见性和访问规则\n\n- `private`           : 成员只能由同一个类(class)类型中的其他成员访问.\n- `protected`         : 成员可以从派生类型访问,不管是不是在同一个程序集中.\n- `internal`          : 成员可以由同一个程序集中的任何代码访问.\n- `protected internal`: 可以由任何程序集中的派生类型访问.\n- `public`            : 成员可由任何程序集中的任何代码访问.\n\n\n\n# CLS通用语言规范是什么?\n\n > 定义了一个最小公共集，任何编译器只有支持这个功能集，生成的类型才能兼容其他符合CLS、面向CLR的语言生成的组件\n\n![](一CLR基础/CLS图示.png)\n\n在开发类型和方法的时候，如果希望它们对外“可见”，能够从符合 CLS 的任何一种编程语言中访问，就必须遵守由 CLS 定义的规则。注意， 假如代码只是从定义（这些代码的）程序集的内部访问，CLS 规则就不适用了。\n\n```csharp\nusing System\n\n//告诉编译器检查CLS相容性\n[assembly:CLSCompliant(true)]\n\nnamespace SomeLibrary\n{\n    //因为是public类，所以会显示警告\n    public sealed class SomeLibrarytype\n    {\n        //警告：SomeLibrary.SomeLibraryType.Abc()的返回类型不符合CLS\n        public UInt32 Abc(){return 0;}\n\n        //警告：仅大小写不同的标识符SomeLibrary.SomeLibraryType.abc()不符合CLS\n        public void abc(){ }\n\n        //不显示警告：该方法是私有的\n        private UInt32 ABC(){return 0;}\n    }\n}\n```\n- 第一个警告是因为Abc方法返回了无符号整数，一些语言是不能操作无符号整数值的\n- 第二个警告是因为该类型公开了两个public方法，这两个方法只是大小写和返回类型有别，VB和其他一些语言无法区分这两个方法。\n\n# 关于window32位和64位版本\n1. 如果程序集文件只包含`类型安全`的`托管代码`在32位和64位上都能运行.\n> 类型安全代码指访问被授权可以访问的内存位置.有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。(直接访问内存的其他位置)\n\n2. 如果要使用`不安全的代码`, 需要用到`/playform`命令行开关.如果指定了,则只能在对应平台上使用.默认`anycpu`.\n3. 可执行文件执行时,Windows会检查文件头,64位系统会通过`WoW64(Windows on Windows64)`技术运行32位应用程序.\n\n![](一CLR基础/platform对生成的模块的影响.png)\n\n4. Windows启动托管应用程序的流程.\n\n![](一CLR基础/Windows运行EXE流程.png)\n\n5. 可在代码中查询\n  - `Environment.Is64BitOperatingSystem`属性,判断是否在64位系统上运行.\n  - `Environment.Is64BitProcess`属性,判断是否在64位地址空间中运行\n\n# 不安全的代码\n\nC#编译器默认生成的是安全代码.\n\nC#允许开发人员通过`unsafe`关键字标记包含不安全代码的方法.\n\n# 保护IL代码\n\n1. 混淆器\n2. 在非托管模块中实现想保密的算法, 利用CLR的互操作功能实现应用程序的托管和非托管部分之间的通讯.\n\n# 一些微软提供的实用工具\n- CSC.exe C#编译器:将多个托管模块和资源文件合并成程序集的工具.\n- AL.exe 程序集链接器:将一组文件合并到程序集中.\n- CLRVer.exe 列出机器上安装的所有CLR版本\n  - `-all` 或者指定 `目标进程ID` 列出正在允许的进程使用的CLR版本号.\n- DumpBin.exe 和 CorFlags.exe:可以用来检查编译器生成的托管模块所嵌入的信息.\n- ILAsm.exe IL汇编器\n- ILDasm.exe IL反汇编器\n>用IL反编译工具查看生成的IL代码。这里使用的是ILDasm.exe，当然，你也可以使用一些其他的工具，例如.Net Reflector、ILSpy等。\n\n- NGen.exe 本机代码生成器: 将程序集的所有IL代码编译成本机代码.并将本机代码保存到一个磁盘文件中.\n- PEVerify.exe 检查一个程序集的所有方法,并报告其中含有不安全代码的方法.\n- MPGO.exe 分析客户端应用程序启动需要哪些东西,会写入一个profile并嵌入程序集中.NGen能根据这个更好的优化生成本机映像.\n- TlbImp.exe 托管代码可以使用现有的COM组件.\n- TlbExp.exe和RegAsm.exe 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。\n","tags":["CLR读书笔记"]},{"title":"HelloWorld","url":"/2019/07/05/HelloWorld/","content":"\n\n![](https://portablehexo.bitmoe.cn/hexopp/hexop.png)\n\n>**本版本仅适用于Win环境**\n>本文关键字： **Hexo绿色版**，**Hexo便携版**，**Hexo配置**，**Hexo**，**U盘**\n\n[Hexo](https://hexo.io/)是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。\n\n但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。\n\n所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。\n\n#### **版本介绍**\n那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。\n\n本便携版（Release 1.0.0）所包含的软件如下：\n>- Git: 2.7.4\n>- Nodejs: 6.10.1\n>- Npm: 4.4.1\n>- Hexo: 3.2.2\n\n# 用到的主题和插件\n\n1. 兼容Markdown图片语法和Hexo图片语法插件:https://github.com/7ym0n/hexo-asset-image\n2. 主题:https://github.com/aircloud/hexo-theme-aircloud\n3. Tag-Cloud插件 https://github.com/MikeCoder/hexo-tag-cloud\n4. 代码高亮插件:https://github.com/ele828/hexo-prism-plugin\n","tags":["HEXO"]},{"title":"ET入门小指南 v19.7.4","url":"/2019/07/04/ET入门小指南/","content":"\n![](ET入门小指南/1.jpg)\n\n# 了解ET\n\n[[Github]](https://github.com/egametang/ET)\n[[ET论坛]](https://bbs.honorworkroom.com/forum.php)\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端.\n\n[[具体介绍]](https://github.com/egametang/ET/blob/master/README.md)\n\n- [为什么使用C# .net core做服务端？](https://github.com/egametang/ET/blob/master/Book/1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.md)\n  - ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。\n- **为什么选择Unity作为客户端?**\n  - 当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。 客户端可以不使用Unity3d,需要自己对接协议.\n- [为什么后端选MongoBson序列化库?](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n- [为什么选MongoDB数据库?](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=183&extra=page%3D1)\n- [为什么选择ProtoBuf?](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 基于google官方3.4.1版本的protobuf c#-runtime以及3.4.0版本的protoc修改而来，还增加了0gc功能。仍然是标准的pb协议\n  - [ET使用精简过的PB库](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n- **为什么选择ILRuntime热更?**\n  - 因为ios的限制，之前unity热更新一般使用lua，导致unity3d开发人员要写两种代码，麻烦的要死。之后幸好出了ILRuntime库，利用ILRuntime库，unity3d可以利用C#语言加载热更新dll进行热更新。ILRuntime一个缺陷就是开发时候不支持VS debug，这有点不爽。ET框架使用了一个预编译指令ILRuntime，可以无缝切换。平常开发的时候不使用ILRuntime，而是使用Assembly.Load加载热更新动态库，这样可以方便用VS单步调试。在发布的时候，定义预编译指令ILRuntime就可以无缝切换成使用ILRuntime加载热更新动态库。这样开发起来及其方便，再也不用使用狗屎lua了\n- [什么是组件式设计?](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n\n\n# 运行Demo前的准备事项\n\n1. IDE选择\n  - **VS**\n    - ET 5.0(master)\n      - 建议使用VS2019 ( 用2017就自己去官网下 .net core 2.2)\n    - ET 4.0分支使用vs2017（更新到最新版）,并且要勾选\n      - a. .net 桌面开发\n      - visual studio tools for unity\n      -  .net core 2.1\n  - **Rider**\n    - 安装 .net core 2.2\n  - other.....\n\n2. Unity版本选择\n  - ET4.0请使用unity2017.4版\n  - ET5.0(master)需要unity2018.4版\n  - [为什么是.4版本](https://www.bilibili.com/video/av49789692)\n  - 别问怎么破解.问就是个人免费版.\n\n\n3. 安装MongoDB数据库(Demo中注释了数据库组件,只为了运行demo,就随意)\n\n\n# 准备运行Demo\n\n- [运行指南](https://github.com/egametang/ET/blob/master/Book/1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.md)\n\n- [常见的错误解决方法](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=203&extra=page%3D1)\n\n\n\n\n## 测试状态同步Demo\n\n打包一个客户端,unity开一个客户端.就会出现2个小人.点击鼠标右键即可移动人物.看到效果.\n\n## 帧同步Demo\n\n在4.0分支.\n\n# 学习ET\n\n\n\n\n你可能需要如下知识储备:\n- C# 语言基础 ([你渴望力量吗?](https://pan.baidu.com/s/1mqaaVIxOVo02pg8aXaQKXg)s1fz )\n- 设计模式    ([你渴望知识吗?](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 数据结构    ([那就看完吧](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 反射\n- 特性\n- 异步/协程\n- 了解ECS\n- 了解actor模型\n- 网络层TCP/UDP/KCP/ENET\n- MongoDB数据库\n- MongoBson\n- Protobuf\n- 服务器分布式相关\n\n客户端\n- Unity基础\n- UGUI\n- AssetBundle流程\n- 热更ILRuntime\n\n其余\n- AstarPathfinding\n- Behavior Designer\n- FGUI\n- NLog\n\n>猫大语录:\n应该先去提高下c#基础跟编程基础，再来看ET，碰到问题自己想办法解决，谷歌，打log。你现在好比初中基础却来做大学题目一样，到处碰壁，碰到问题自己不研究指望别人给你找问题，这样编程技术是无法提高的.\n群里能力有高有低，问问题也没什么。但是我是希望群里提问题前能够经过自己一番摸索，经过自己思考，经过谷歌，经过调试log等等再问。很多问题经过自己摸索查找资料能够增长很多知识。其实程序开发就是在不断找bug，在找bug中提升自己。\n\n# ET框架设计大纲\n\n- 公共部分\n  - ET的特色\n  - 什么是ECS\n- async await 协程\n\t- 什么是异步? 单线程？多线程？\n      - [ET/Book/2.1CSharp的协程](https://github.com/egametang/ET/blob/master/Book/2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n      - [ET/Book/2.2更好的协程](https://github.com/egametang/ET/blob/master/Book/2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n\t- 为什么需要async await，await是多线程吗？\n    \t- [ET/Book/2.3单线程异步](https://github.com/egametang/ET/blob/master/Book/2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md)\n\t- 更好的Task：ETTask\n    \t- [群内讨论/ETTask](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=204&extra=page%3D1)\n- [一切皆组件（Entity&Component）](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n  - [事件机制EventSystem](https://github.com/egametang/ET/blob/master/Book/3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.md)\n  - [强大的mongo bson](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n  - 设计一个双端网络库\n  - 协议格式的设计\n  - [protobuf](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 使用Kcp协议\n      - [kcp-bulild](https://github.com/egametang/kcp-bulild)\n  - 应用层循环缓冲区\n  - 消息打包解包\n  - 消息的分发处理\n  - 远程过程调用RPC\n  - 客户端无GC处理\n- 服务端\n\t- 服务端架构简介\n    \t- [服务器命名以及消息类的X2X代表意思](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=161&extra=page%3D1)\n\t- 组件式的服务器\n\t- [Actor模型](https://github.com/egametang/ET/blob/master/Book/5.4Actor%E6%A8%A1%E5%9E%8B.md)\n\t- [ActorLocation](https://github.com/egametang/ET/blob/master/Book/5.5Actor%20Location.md)\n\t- 设计一个计时器( TimerCompoent组件 )\n\t- 服务端热更\n    \t- [群内讨论/热更层和Model层/逻辑与数据相关](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=146&extra=page%3D1)\n\t- Config\n\t- [数值组件](https://github.com/egametang/ET/blob/master/Book/5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.md)\n    \t- [群内讨论/数值组件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=139&extra=page%3D1)\n\t- Repl\n    \t- [Nlog配置和Repl](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=151&extra=page%3D1)\n- 客户端\n\t- 客户端架构简介\n\t- 客户端资源管理\n\t- UI框架\n\t- 客户端热更 (ILRuntime)\n\t- 抛弃unity的协程，使用await\n\t- 组件可视化\n- Demo\n\t- demo的架构, 消息路径\n    \t- [Demo消息流转时序图](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=145&extra=page%3D2)\n\t- recast 3d寻路\n\n\n# ET的一些教学视频\n- [肉饼老师主讲](https://www.taikr.com/my/course/972) : ET3.0时期教程,可以学习如何分离客户端和服务器端,和一些开发思路\n- [初见主讲(B站)](https://www.bilibili.com/video/av33280463/?redirectFrom=h5) - [优酷](https://i.youku.com/i/UNTQ3MjU4MDEy?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DT~A):ET4.0教程,工具使用及demo运行,ET入门教程\n- [ET在Mac上运行指南-L主讲](http://www.liuocean.com/index.php/2018/07/25/et-kuang-jiamac-duan-gong-ju-zhi-chi/)百度云视频链接失效，参考文章吧\n-  [ET框架学习日记 by SwickSu](https://www.bilibili.com/video/av50871743?from=search&seid=9593939068874626189)\n\n# 群内大佬的Github\n- [C# 实现的十字链表的AOI算法](https://github.com/qq362946/AOI) by 初见\n  - [群内讨论/十字链表+快慢针方式的AOI算法可用于双端](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=174&extra=page%3D1)\n- [在初见的AOI（2D）的基础改成3D AOI](https://github.com/yhr28/3D_AOI) by yhr28\n- [ET-RPG-DEMO(基于ET框架的RPG游戏DEMO)](https://github.com/AnotherEnd15/ET-RPG-DEMO)   by AE\n  - [一种完全组合式的技能系统的设计思路](https://blog.csdn.net/qq_32270109/article/details/88551196?tdsourcetag=s_pcqq_aiomsg)\n- [RVO2](https://github.com/AnotherEnd15/RVO2) by AE\n- [Box2DSharp(BOX2D物理引擎C#版)](https://github.com/Zonciu/Box2DSharp)  by 白纸无字Zonciu\n- [Bullet版本(.netCore封装)](https://gitee.com/fengssy/BulletSharpPInvoke?tdsourcetag=s_pcqq_aiomsg) by 风恒\n- [FGUI/双端行为树](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n  - [群内讨论/Behavior Designer全热更行为树插件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=170&extra=page%3D1)\n- [NKGNMobaBasedOnET(基于ET框架的Moba游戏DEMO)](https://gitee.com/NKG_admin/MKGMobaBasedOnET) by 烟雨迷离半世殇\n- [ET斗地主Demo](https://github.com/Viagi/LandlordsCore)\n  - [斗地主架构图](https://pan.baidu.com/s/1wyv6ihefBjQmVynIUBumKA) o05k\n- [ET-MultiplyDemos小游戏集合](https://github.com/Acgmart/ET-MultiplyDemos) by 咲夜詩\n\n#群内大佬分享的一些工具/组件\n\n- [[Debug组件]DebuggerComponent.cs](https://pan.baidu.com/s/1bGJxNGu5P9KB8czCK1NRtw)  mcyz\n- [[AspNet组件]AspNetCoreComponent](https://pan.baidu.com/s/1q6KEgLY08pdht6IioVekVQ) z84o\n- [[Http请求帮助类]HttpRequestHelper](https://pan.baidu.com/s/15sf7KuMvN0NU_Dsx0frtiQ) 7mvr\n- [ET心跳组件2.0](https://pan.baidu.com/s/1oR8f9fSE91bsfmyPCjCTZg) 8p0b\n  - [这篇是初见早期写的心跳文章](http://www.tinkingli.com/?p=111) 不会心跳的可以看下原理\n\n\n\n# ET学习笔记/博客/公众号\n\n- [ET Mac环境运行和iOS打包指南.pdf](https://pan.baidu.com/s/1LyDaeA3l3skySb3ECu3VvA ) 9bzj\n- [Tinkingli博客教程](http://www.tinkingli.com/?cat=8)\n- [ECS概要--ET游戏框架详解](https://mp.weixin.qq.com/s/tDgqE_Ah8PWfnAGfi_R-aQ)  by 122304518\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n- [咲夜詩的博客](https://acgmart.com/unity/)\n- [群内分享的一些ET笔记](https://pan.baidu.com/s/1KqtGWVbFBRtQ_RJZTMYFww) ho3e\n\n\n\n# 相关技术的教学文章\n\n## MongoDB\n- [官方Driver教程](https://mongodb.github.io/mongo-csharp-driver/2.7/getting_started/)\n- [官方API文档](http://api.mongodb.com/csharp/current/html/R_Project_CSharpDriverDocs.htm)\n- [菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [Working with MongoDB in .NET (Part 1): Driver Basics & Inserting Documents](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz)\n- [Working with MongoDB in .NET (Part 2): Retrieving Documents with Filter Clause](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-2-retrieving-mrlbeanm5)\n- [Working with MongoDB in .NET (Part 3): Skip, Sort, Limit, & Projections](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka)\n\n\n## ILRuntime\n\n- [官方主页](https://ourpalm.github.io/ILRuntime/public/v1/guide/index.html)\n- [Github-Demo](https://github.com/Ourpalm/ILRuntimeU3D/)\n- QQ群:512079820\n- [ILRuntime技术相关的总结](https://pan.baidu.com/s/1Re-mM-9KEoO3D7VXePdyIg) vz3q\n- [群内讨论/ILRuntime剪裁相关问题](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=195&extra=page%3D1)\n\n\n## FGUI\n\n- [官方主页](http://www.fairygui.com/guide/index.html)\n- [官方教程](http://www.sikiedu.com/course/139)\n- QQ群:614444599\n- [ET+FGUI+BD](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n","tags":["ET"]},{"title":"test","url":"/2019/07/04/test/","content":"# Test!!!!!!!!!!\n\n\n```csharp\nusing System;\nusing MongoDB.Driver;\n\nnamespace ETModel\n{\n\t[ObjectSystem]\n\tpublic class DBQueryTaskSystem : AwakeSystem<DBQueryTask, string, ETTaskCompletionSource<ComponentWithId>>\n\t{\n\t\tpublic override void Awake(DBQueryTask self, string collectionName, ETTaskCompletionSource<ComponentWithId> tcs)\n\t\t{\n\t\t\tself.CollectionName = collectionName;\n\t\t\tself.Tcs = tcs;\n\t\t}\n\t}\n\n\tpublic sealed class DBQueryTask : DBTask\n\t{\n\t\tpublic string CollectionName { get; set; }\n\n\t\tpublic ETTaskCompletionSource<ComponentWithId> Tcs { get; set; }\n\n\t\tpublic override async ETTask Run()\n\t\t{\n\t\t\tDBComponent dbComponent = Game.Scene.GetComponent<DBComponent>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// 执行查询数据库任务\n\t\t\t\tIAsyncCursor<ComponentWithId> cursor = await dbComponent.GetCollection(this.CollectionName).FindAsync((s) => s.Id == this.Id);\n\t\t\t\tComponentWithId component = await cursor.FirstOrDefaultAsync();\n\t\t\t\tthis.Tcs.SetResult(component);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthis.Tcs.SetException(new Exception($\"查询数据库异常! {CollectionName} {Id}\", e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","tags":["Test"]}]