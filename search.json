[{"title":"Unity可寻址资产系统AddressableAssetSystem","url":"/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/","content":"\n[Addressable Asset System 官方文档](https://docs.unity3d.com/Packages/com.unity.addressables@1.1/manual/index.html)\n\n# 什么是asset?\n\n资产是您用于创建游戏或应用程序的内容。资产的常见示例包括预制件(Prefabs)，纹理(textures)，材料(materials)，音频剪辑(audio clips)和动画(animations)。\n\n# 什么是Addressable Asset?\n\n使资产“可寻址”允许您使用该资产的唯一地址从任何地方调用它。无论该资产是在 **本地应用程序中** 还是在 **内容交付网络(资源服务器)** 上，可寻址资产系统都会找到并返回该资产。您可以通过其地址加载单个可寻址资产，或使用您定义的 **自定义组标签** 加载许多可寻址资产。\n\n# 为什么要使用可寻址资产?\n\nAddressable 缩短了迭代周期:\n- `迭代时间`: 通过其地址引用类型非常有效.对内容的优化不需要更改代码.\n- `依赖关系管理`: 系统返回所请求内容的所有依赖关系, 方便在内容返回之前加载所有依赖的网格,着色器,动画等.\n- `内存管理`: 系统的卸载资产并加载它们,自动计算引用并提供强大的分析器以帮助您发现潜在的内存问题。\n- `内容打包`: 由于系统映射并理解复杂的依赖关系链, 因此即使在移动或重命名资产时，也可以有效地打包捆绑包。您可以轻松地为本地和远程部署准备资产，以支持可下载内容和减少应用程序大小。\n\n# 概述\n\n可寻址资产系统包括两个包：\n- Addressable Assets package (主要包)\n- Scriptable Build Pipeline package (依赖)\n\n> 安装Addressable Assets包时，Scriptable Build Pipeline包将同时安装。\n\n## 概念\n\n- `Address(地址)`: 资产的位置标识符，便于运行时检索.\n- `AddressableAssetData directory(可寻址资产元数据目录)`: 将您的可寻址资产元数据存储在Project的Assets目录.\n- `Asset group(资产组)`: 一组可用于 **构建时处理的** 可寻址资产.\n- `Asset group schema(资产组架构)`: 定义一组数据，您可以将这些数据分配给组并在构建期间使用。\n- `AssetReference(资产引用)`: 一个对象，其操作类似于直接引用，但具有 **延迟初始化**。该AssetReference对象将GUID存储为可按需加载的Addressable。\n- `Asynchronous loading(异步加载)`: 允许在整个开发过程中更改资产及其依赖项的位置，而无需更改游戏代码。异步加载是可寻址资产系统的基础。\n- `Build script(构建脚本)`: 运行 **资产组处理器** 以打包资产，并提供资源管理器的地址和资源位置之间的映射。\n- `Label(标签)`: 为类似项的运行时加载提供附加的 **可寻址资产标识符** (例如, `Addressables.DownloadDependenciesAsync(\"spaceHazards\");`).\n\n# 入门\n\n**重要提示：可寻址资产系统需要Unity版本2018.3或更高版本**\n\n## 使Asset成为AddressableAssets\n\n两种标记方式:\n1. 在对象的`Inspector`面板中 -> 单击`Address`复选框 -> 输入用于标识资产的名称。\n\n![](Unity可寻址资产系统AddressableAssetSystem/inspectorcheckbox.png)\n\n2. 选择 Window > `Asset Management` > `Addressables` 去打开 `Addressables window`. 然后, 将所需的资产从项目窗口拖进`Addressables window`的资产组。\n\n![](Unity可寻址资产系统AddressableAssetSystem/addressableswindow.png)\n\n## 指定地址\n\n资产的 **默认地址** 是项目中资产的路径（例如，`Assets/images/myImage.png`）。**要从`Addressables window`更改资产的地址，请右键单击该资源，然后选择`Rename`。**\n\n当您第一次开始使用可寻址资产时，系统会在`Assets/AddressableAssetsData`文件中为您的项目保存一些编辑时和运行时数据资产，这些资产应添加到您的版本控制签入中。\n\n## 构建可寻址内容\n\n在构建应用程序之前，**Addressables资产系统需要将您的内容构建为正在运行的游戏可以使用的文件。** 此步骤不是自动的。您可以通过编辑器或API构建此内容：\n\n- 要在Editor中构建内容，请打开`Addressables window`，然后选择`Build` -> `Build Player Content`。\n- 要使用API​​构建内容，请使用`AddressableAssetSettings.BuildPlayerContent()。`\n\n## 使用可寻址资产\n\n### 按地址加载或实例化\n\n您可以在运行时加载或实例化可寻址资产。**加载资产会将所有依赖项加载到内存中（包括资产的捆绑数据，如果适用）**，允许您在需要时使用该资产。**这实际上并没有将所需资产放入场景中。要将资源添加到场景中，您必须实例化。** 使用Addressables实例化接口将加载资源，然后立即将其添加到场景中。\n\n要使用字符串地址从游戏脚本访问资产，请声明UnityEngine.AddressableAssets命名空间，然后调用以下方法：\n```csharp\n// 这会使用指定的地址加载资产。\nAddressables.LoadAssetAsync<GameObject>(\"AssetAddress\");\n// 这会将具有指定地址的资产实例化到场景中。\nAddressables.InstantiateAsync(\"AssetAddress\");\n```\n\n> 注意：`LoadAssetAsync`和`InstantiateAsync`是异步操作。您可以在完成加载时提供回调以使用资产。\n\n\n\n```csharp\nusing UnityEngine.AddressableAssets;\nusing UnityEngine;\n\npublic class AddressablesExample : MonoBehaviour\n{\n\n    GameObject myGameObject;\n\n        // ...\n\n        // 使用指定的地址加载资产,完成时回调OnLoadDone方法\n        Addressables.LoadAssetAsync<GameObject>(\"AssetAddress\").Completed += OnLoadDone;\n    }\n\n    private void    OnLoadDone(UnityEngine.ResourceManagement.AsyncOperations.AsyncOperationHandle<GameObject> obj)\n    {\n        // 在生产环境中，您应该添加异常处理来捕获诸如null结果之类的场景。\n        myGameObject = obj.Result;\n    }\n}\n\n```\n\n### 子资产和组件\n\n`子资产`和`组件`是资产加载的特殊情况。\n\n- `组件`：您 **无法** 直接将GameObject的组件作为资源加载。您必须加载或实例化GameObject，然后从中检索组件引用。\n- `子资产`：系统支持加载子资产，但需要特殊语法。潜在子资产的示例包括`sprite sheet`中的`sprites`或FBX文件中的动画片段。要加载它们，请使用以下示例语法：\n\n```csharp\n// 系统支持加载子资产，但需要特殊语法\n// 例如`sprite sheet`中的`sprites`\n// FBX文件中的动画片段\nAddressables.LoadAssetAsync<IList<Sprite>>(\"MySpriteSheetAddress\");\n```\n\n\n## 使用AssetReference类\n\n本`AssetReference类`提供一种方法来访问寻址的资产，而无需知道他们的地址。要使用`AssetReference类`访问可寻址资产：\n1. 从`Scene hierarchy`结构或`Project window`中选择一个GameObject 。\n2. 在Inspector中，单击`Add Component`按钮，然后选择组件类型。任何可序列化组件都可以支持`AssetReference变量`（例如，`a game script`，`ScriptableObject`或`其他可序列化类`）。\n3. `AssetReference`在组件中添加公共变量（例如，`public AssetReference explosion;`）。\n4. 在Inspector中，选择要链接到对象的可寻址资产，方法是将资源从`Project window`拖动到公开AssetReference字段中，或者从项目中先前定义的可寻址资产的下拉列表中进行选择（如下所示）。\n\n![](Unity可寻址资产系统AddressableAssetSystem/Inspectorreferenceselection2.png)\n\n5. 要加载或实例化AssetReference资产，请调用其相应的方法。\n  1. `AssetRefMember.LoadAssetAsync<GameObject>();`\n  2. 或者 `AssetRefMember.InstantiateAsync(pos, rot);`\n\n## 建立考虑因素\n\n### StreamingAssets中的本地数据\n\n可寻址资产系统在运行时需要 **一些文件来知道要加载什么以及如何加载它**。这些文件是在构建Addressables数据时生成的，**并在StreamingAssets文件夹中生成**，该文件夹是Unity中包含构建中所有文件的特殊文件夹。构建Addressables内容时，系统会在库中对这些文件进行分级。然后，在构建应用程序时，**系统会将所需文件复制到StreamingAssets**，构建并从文件夹中 **删除它们**。这样，您可以为多个平台构建数据，同时只在每个构建中包含相关数据。\n\n除了特定于Addressables的数据之外，构建其本地数据的任何组也将使用特定于库平台的分段位置。\n\n要验证这是否有效，请将构建路径和加载路径设置为分别以\n`[UnityEngine.AddressableAssets.Addressables.BuildPath]`和开头的配置文件变量`{UnityEngine.AddressableAssets.Addressables.RuntimePath}`。您可以在`AddressableAssetSettings`的`Inspector`中指定这些设置（默认情况下，此对象位于Project的`Assets/AddressableAssetsData`目录中）。\n\n### 提前下载\n\n调用该`Addressables.DownloadDependenciesAsync()`方法会加载您传入的地址或标签的依赖关系。通常，这是资产包。\n\n`AsyncOperationHandle`此调用返回的结构包含一个`PercentComplete`可用于监视和显示下载进度的属性。您还可以让应用程序等到内容加载完毕。\n\n如果您希望在下载之前询问用户是否同意，请使用`Addressables.GetDownloadSize()`返回从给定地址或标签下载内容所需的空间。请注意，这会考虑任何以前下载的仍在Unity资产包缓存中的捆绑包。\n\n虽然提前为您的应用程序下载资产可能是有利的，**但有些情况下您可能选择不这样做**。例如：\n- 如果您的应用拥有大量在线内容，并且您通常希望用户只与其中的一部分进行互动。\n- 您有一个必须在线连接才能运行的应用程序。如果您的所有应用内容都是小型捆绑包，您可以选择根据需要下载内容。\n\n您可以使用预加载功能显示下载已开始，然后继续，而不是使用百分比完成值等待内容加载。此实现需要加载或等待屏幕来处理资产在需要时尚未完成加载的实例。\n\n### 构建多个平台\n\n在构建应用程序内容时，可寻址资产系统会生成包含可寻址资产的资产包。**资产包依赖于平台，因此必须为您打算支持的每个独特平台重建。**\n\n默认情况下，在构建Addressables应用程序数据时，给定平台的数据存储在Addressables构建路径的特定于平台的子目录中。运行时路径考虑了这些平台文件夹，并指向适用的应用程序数据。\n\n注意：如果`BuildScriptPackedPlayMode`在编辑器播放模式下使用Addressables 脚本，则Addressables将尝试加载`当前活动构建目标(your current active build target)`的数据。因此，**如果您当前的构建目标数据与当前的编辑器平台不兼容，则可能会出现问题。** 有关更多信息，请参阅有关Play mode scripts.的文档。\n\n\n# 开发周期\n","tags":["Unity资源管理系统","Addressable Asset System"]},{"title":"17委托","url":"/2019/08/27/17委托/","content":"\n# 委托\n","tags":["CLR读书笔记"]},{"title":"16数组","url":"/2019/08/16/16数组/","content":"\n# 数组\n\nCLR支持一维,多维和交错数组(数组构成的数组).\n\n**所有数组类型** 隐式地从`System.Array抽象类`派生, `System.Array`又派生自`System.Object`. 数组 **始终是引用类型**, 是在托管堆上分配的.\n\n```csharp\n// 刚开始声明变量, 没有分配数组,所以为null\nInt32[] myInts; // 声明一个数组引用\n// 在托管堆上分配了100个未装箱Int32所需的内存块,返回该内存块的地址\n// 所有Int32都被初始化为0。因为数组是引用类型,\n// 所以内存块中还包含类型对象指针,同步索引块,一些开销字段(额外成员)\nmyInts = new Int32[100]; //创建含有100个Int32的数组\n\n\nControl[] myCon;\n// Control是引用类型,50个引用全部被初始化为null\nmyCon = new Control[50];\n\n// 执行一些代码\nmyCon[1] = new Button();\nmyCon[2] = new TextBox();\nmyCon[3] = myCon[2]; //两个元素引用同一个对象\nmyCon[1] = new DataGrid();\nmyCon[1] = new ComboBox();\nmyCon[1] = new Button();\n```\n\n![](16数组/值类型和引用类型数组在托管堆中.png)\n\n所有数组必须是0基数组(最小索引为0). CLR支持非0基数组,只是不提倡使用,性能会下降.\n\n每个数组都关联了一些额外的开销信息,\n- 数组的秩(数组的维数).\n- 数组的每一维的下限(几乎总是0)和每一维的长度.\n- 数组的元素类型\n\n> 应尽可能的使用一维0基数组,也称为SZ数组或向量. 向量性能是最佳的,因为可以使用一些特殊的IL指令.\n\n```csharp\n// 创建一个二维数组，由Double值构成\nDouble[,] myDoubles = new Double[10,20];\n\n// 创建一个三维数组，由String引用构成\nString[,,] myStrings = new String[5,3,10];\n\n//CLR还支持交错数组，即由数组构成的数组。下面例子演示了如何创建一个多边形数组，其中每一个多边形都由一个Point实例数组构成。\n// 创建一个含有Point数组的一维数组\nPoint[][] myPolygons = new Point[3][];\n\n// myPolygons[0]引用一个含有10个Point实例的数组\nmyPolygons[0] = new Point[10];\n\n// myPolygons[1]引用一个含有20个Point实例的数组\nmyPolygons[1] = new Point[20];\n\n// myPolygons[2]引用一个含有30个Point实例的数组\nmyPolygons[2] = new Point[30];\n\n// 显示第一个多边形中的Point\nfor (Int32 x =0 ; x < myPolygons[0].Length; x++)\n{\n    Console.WriteLine(myPolygons[0][x]);\n}\n```\n\n访问数组范围之外的会导致`System.IndexOutOfRangeException`异常.\n\n> 数组索引范围检查对性能的检查微乎其微,JIT编译器通常只在循环开始之前检查一次数组边界,而不是每次循环迭代都检查, 还可以用C#的unsafe代码来访问数组,规避这个CLR索引检查造成的性能损失.\n\n# 初始化数组元素\n\n大括号中的以逗号分隔的数据项称为`数组初始化器`,每个数据项都可以是一个复杂的表达式.\n\n```csharp\nString[] names = new String[] { \"Aidan\", \"Grant\" };\n```\n\n## C#的隐式类型的局部变量功能 var\n\n隐式类型的局部变量功能, 让编译器推断`=操作符`右侧的表达式类型.\n\n```csharp\n// 用var代替String\nvar names = new String[] { \"Aidan\", \"Grant\" };\n```\n\n## C#的隐式类型的数组功能\n\n隐式类型的数组功能让编译器推断`数组元素的类型`.省略了new和[]之间的类型.\n\n```csharp\n// 省略了new和[]之间的类型\n// 选择所有数组元素最接近的共同基类来作为数组的类型\n// 本例中,2个string和一个null , 因为null可以隐式转型为任意盈余类型,所以编译器创建为String数组\nvar names = new[] { \"Aidan\", \"Grant\", null};\n\n// 错误的, 因为这样编译器只能推断为共同基类Object\n// 这会造成123数值类型进行隐式装箱, 这个操作代价高昂,所以要在编译时报错\n// var names = new[] { \"Aidan\", \"Grant\", 123};\n\n// 额外语法,还可以这么写, 省略new 和[] 和类型.\n// 但是这种写法不允许使用var\nString[] names = { \"Aidan\", \"Grant\" };\n```\n\n## 匿名类型 与 隐式类型的数组 与 隐式类型的局部变量组合使用\n\n```csharp\n// 两个匿名类具有一致的结构, 表示有一个string类型的Name字段的类.\n// 所以编译器知道这两个对象具有相同的类型\nvar kids = new[] { new { Name = \"Aidan\" }, new { Name = \"Grant\" }};\n\nforeach(var kid in kids)\n Console.WriteLine(kid.Name);\n```\n\n# 数组转型\n\n对于元素为引用类型的数组，CLR允许将数组元素从一种类型隐式转型到另一种类型。为了成功转型，两个数组类型必须维数相等，而且从源类型到目标类型，必须存在一个隐式或显示转换。CLR不允许将值类型元素的数组转型为其他任何类型。(不过为了模拟实现这种效果，可利用`Array.Copy方法`创建一个新数组并在其中填充数据)。\n\n`Array.Copy方法`是浅拷贝.\n\n\n```csharp\n// 创建一个二维FileStream数组\nFileStream[,] fs2dim = new FileStream[5, 10];\n\n// 隐式转型为一个二维Object数组\nObject[,] o2dim = fs2dim;\n\n// 不能从二维数组转型为一维数组\n//Stream[] s1dim = (Stream[]) o2dim;\n\n// 显式转型为二维Stream数组\nStream[,] s2dim = (Stream[,]) o2dim;\n\n// 显式转型为二维String数组\n// 能通过编译，但在运行时会抛出异常,InvalidCastException\n// String[,] st2dim = (String[,]) o2dim;\n\n// 创建一个意味Int32数组(元素是值类型)\nInt32[] i1dim = new Int32[5];\n\n// 不能将值类型的数组转型为其他任何类型\n// Object[] o1dim = (Object[]) i1dim;\n\n// 创建一个新数组，使用Array.Copy将元数组中的每一个元素\n// 转型为目标数组中的元素类型，并把它们复制过去\n// 下面的代码创建一个元素为引用类型的数组，\n// 每个元素都是对已装箱的Int32的引用   ←-------------------重点\nObject[] o1dim = new Object[i1dim.Length];\nArray.Copy(i1dim, o1dim, 0);\n```\n\n## 数组协变性,数组间转型\n\nArray.Copy方法的处理:\n- 将值类型的元素 **装箱** 为引用类型的元素\n- 将引用类型的元素 **拆箱** 为值元素, 比如将Object[]复制到Int32[]中.\n- 加宽CLR基元值类型, 比如将Int32[]元素复制到Double[]中\n- **在两个数组之间复制时, 如果仅从数值类型证明不了两者的兼容性, (比如Object[]转型为IFormattable) 就需要对元素进行向下类型转换. 如果Object[]中的每个对象都实现了IFormattable,那么Copy方法就能执行.**\n\n> 向下类型转换:  把父类对象转为子类对象。\n> 向上类型转换: 将子类对象转为父类对象。此处父类对象可以是接口。\n\n\n```csharp\n// 定义实现了一个接口的值类型\ninternal struct MyValueType : IComparable\n{\n    public int CompareTo(object obj)\n    {\n        throw new NotImplementedException();\n    }\n}\n\npublic static void Main(string[] args)\n{\n    // 创建包含值类型的数组\n    var src = new MyValueType[100];\n    // 创建接口引用数组\n    var comparables = new IComparable[src.Length];\n    // 使他们引用src数组元素的已装箱版本\n    Array.Copy(src,comparables,src.Length);\n}\n\n// 性能损失\nString[] sa = new String[100];\nObject[] oa = sa;  // oa引用了一个String数组\n\noa[5] = \"Jeff\"; // 性能损失,CLR检查oa元素类型是不是String类型,检查通过\n// 运行时抛出ArraryTypeMismatchException\n// 因为CLR要保证赋值的合法性\noa[3] = 5;      // 性能损失,CLR检查oa元素类型是不是Int32; 发现有错,会抛出异常\n\n```\n\n将数组从一种类型转换为另一种类型. 这种功能称为 **数组协变性** (协变out). 会带来性能损失.\n\n## 关于复制数组到另一个数组\n\n`Array.Copy`方法\n- 能正确处理内存的重叠区域\n- 能在复制每个数组元素时进行必要的转换\n- 拆箱装箱,向下类型转换\n\n`System.Buffer的BlockCopy`方法.\n- 它比`Array的Copy方法`快.\n- 它只支持基元类型\n- 不提供Copy方法那样的转型能力.\n- 方法的Int32参数时数组中的字节偏移量,而非元素索引.\n- 用于将Unicode字符的一个Byte[] (按字节的正确顺序) 复制到一个Char[]中.\n\n要将一个数组的元素`可靠地`复制到另一个数组,应该使用`System.Array的ConstrainedCopy`.\n- **该方法要么完成复制,要么抛出异常,总之不会破坏目标数组中的数据.**\n- 这就允许ConstrainedCopy在`约束执行区域`中执行,为了这种保证\n  - 要求`源数组的元素类型`和`目标数组的元素类型`相同或者 **派生自** 目标数组的元素类型.\n  - 不执行任何装箱,拆箱或向下类型转换.\n\n# 所有数组都隐式派生自System.Array\n\n`FileStream[] fsArray;`\n\n`System.Array`类型定义的所有实例方法和属性都将由`FileStream[]`继承.\n\n# 所有数组都隐式实现IEnumerable, ICollection, IList\n\n许多方法都能操纵各种各样的集合对象,因为它们声明为获取`IEnumerable`, `ICollection`, `IList`等参数. `System.Array`也实现了这些非泛型接口.\n\n\nCLR没有为`System.Array`实现泛型接口,而是在创建一维0基数数组类型时,CLR自动使数组类型实现`IEnumerable<T>`, `ICollection<T>`, `IList<T>`,同时还为数组类型的所有基类型实现这三个接口,只要它们是引用类型(数组是值类型则不会).\n\n`FileStream[] fsArray;` 会在CLR下产生如下结构:\n\n![](16数组/CLR自动为数组实现泛型接口.png)\n\nfsArray可以传给以下任何一种原型方法:\n\n```csharp\nvoid M1(IList<FileStream> fsList){...}\nvoid M2(ICollection<Stream> sCollection){...}\nvoid M3(IEnumerable<Object> oEnumerable){...}\n```\n\n如果数组包含值类型元素,数组类型不会为元素的基类型实现接口.例如:一个值类型数组`DateTime[] dtArray;` 只会为此数组类型实现3个泛型接口,CLR不会为它的基类包括ValueType,Object实现这些泛型接口. 这是因为值类型的数组在内存中的布局与引用类型的数组不同.\n\n\n# 数组的传递和返回\n\n数组作为实参传递给方法时, 传递的是`数组的引用`,如果不想被修改,则需要生成数组的拷贝给方法. **Array.Copy方法执行是对原始数组的浅拷贝**, 如果数组中的元素类型是引用类型,新数组还是引用现有的对象.\n\n定义返回数组引用的方法,  如果数组中不包含元素, 不要返回null,建议返回对包含零个元素的一个数组的引用. 这这就不需要进行null检测. `if (xxx != null) ...`\n\n# 创建下限非零的数组\n\n可以调用数组的静态方法`CreatInstance`来动态的创建自己的数组. 允许指定数组的类型,维数,每一维的下限和每一维的元素数目.\n\n静态方法`CreatInstance`为数组分配内存,将参数信息保存到数组的内存块的开销(overhead)部分,然后返回对该数组的引用.\n- 如果维数是二维及以上,可以把返回的引用转型为一个`ElementType[]`变量(名称替换为类型名称),来简化对数组元素的访问.\n- 如果是一维,C#要求必须使用该Array的GetValue和SetValue方法访问数组元素.\n\n\n```csharp\n// 创建一个二维数组{2005...2009} {1...4}\nInt32[] lowerBounds = {2005, 1};\nInt32[] lengths     = {5, 4};\n// 传入元素的类型, 5行4列\nDecimal[,] quarterlyRevenue = (Decimal[,])\n    Array.CreateInstance(typeof(Decimal), lengths, lowerBounds);\n\n// Array的Rank 属性：得到Array的秩（维数）  quarterlyRevenue.Rank等于2;\n// GetUpperBound(int dimension) 用于获取 Array 的指定维度的上限。\n// GetLowerBound(int dimension) 用于获取 Array 的指定维度的下限。\n\n// 取得第一维的下限 , 如果传入1, 则表示取得第二维的下限\nInt32 firstYear = quarterlyRevenue.GetLowerBound(0);\nInt32 lastYear  = quarterlyRevenue.GetUpperBound(0);\nConsole.WriteLine(\"{0,4}  {1,9}  {2,9}  {3,9}  {4,9}\", \"Year\", \"Q1\", \"Q2\", \"Q3\", \"Q4\");\n\nRandom r = new Random();\nfor (Int32 year = firstYear; year <= lastYear; year++)\n{\n    Console.Write(year + \"  \");\n\n    // 把二维数组看成表格,从(1,1)开始, 小于第二维的个数,横向遍历\n    for (Int32 quarter = quarterlyRevenue.GetLowerBound(1);\n        quarter <= quarterlyRevenue.GetUpperBound(1);\n        quarter++)\n    {\n        quarterlyRevenue[year, quarter] = r.Next(10000);\n        // C 表示格式化为货币\n        Console.Write(\"{0,9:C}  \", quarterlyRevenue[year, quarter]);\n    }\n    Console.WriteLine();\n}\n\n// Year         Q1         Q2         Q3         Q4\n// 2005  ￥2,102.00  ￥7,295.00    ￥105.00  ￥5,846.00\n// 2006  ￥6,331.00  ￥1,955.00    ￥879.00  ￥8,752.00\n// 2007    ￥912.00  ￥1,105.00  ￥6,960.00  ￥7,205.00\n// 2008  ￥6,479.00  ￥6,034.00  ￥6,182.00  ￥3,565.00\n// 2009    ￥558.00  ￥8,291.00  ￥4,028.00  ￥1,740.00\n```\n\n\n# 数组内部的工作原理\n\nCLR支持两种不同的数组:\n- 下限为0的一维数组或向量\n- 下限未知的一维或多维数组\n\n\n```csharp\nArray a;\n\n// 定义一维的0基数组,不包含任何元素\na = new String[0];\nConsole.WriteLine(a.GetType()); // System.String[]\n\n// 定义一维的0基数组,不包含任何元素\na = Array.CreateInstance(typeof(String), new Int32[] {0}, new Int32[] {0});\nConsole.WriteLine(a.GetType()); // System.String[]\n\n// 定义一维的1基数组,不包含任何元素\n// 1基数组显示的类型是System.String[*], *号表示CLR知道该数组不是0基的.\n// C#不允许声明String[*]类型的变量,因此不能使用C#语法来访问一维非0基数组.\n// 可以用Array的GetValue和SetValue来访问,但是速度较慢,调用方法有开销.\na = Array.CreateInstance(typeof(String), new Int32[] {0}, new Int32[] {1});\nConsole.WriteLine(a.GetType()); // System.String[*]  <-- INTERESTING!\n\n\n// 定义二维的0基数组,不包含任何元素\na = new String[0, 0];\nConsole.WriteLine(a.GetType()); // System.String[,]\n\n// 定义二维的0基数组,不包含任何元素\na = Array.CreateInstance(typeof(String), new Int32[] {0, 0}, new Int32[] {0, 0});\nConsole.WriteLine(a.GetType()); // System.String[,]\n\n// 定义二维的1基数组,不包含任何元素\n// CLR会将多维数组都视为非0基数组,CLR决定对多维数组不使用*号\na = Array.CreateInstance(typeof(String), new Int32[] {0, 0}, new Int32[] {1, 1});\nConsole.WriteLine(a.GetType()); // System.String[,]\n```\n\n- 1基数组显示的类型是`System.String[*]`, `*`号表示CLR知道该数组不是0基的.\n- C#不允许声明`String[*]`类型的变量,因此不能使用C#语法来访问一维非0基数组.\n- 可以用Array的GetValue和SetValue来访问,但是速度较慢,调用方法有开销.\n\n对于多维数组,CLR会将多维数组都视为非0基数组,会让别人觉得类型是这样`System.String[*,*]`,但是CLR决定对于多维数组,不使用`*`号,大量星号容易产生混淆.\n\n访问1维0基数组的元素比访问非0基一维或多维元素稍快.\n- 有特殊的IL指令用于处理0基数组,可以让JIT编译器生成优化代码\n  - JIT编译器生成的代码假定数组是0基的,访问元素时不需要从指定索引中减去一个偏移量\n- JIT编译器能将索引范围检查代码从循环中拿出,导致它只执行一次\n\n\n```csharp\nvar ints = new Int32[5];\n// ints.Length调用属性方法\nfor (int i = 0; i < ints.Length; i++)\n{\n    // 对ints[i]操作\n}\n```\n\nJIT编译器知道`Length`是`Array类的属性`,**所以生成的代码中实际只调用该属性一次,结果保存到临时变量中** , 之后的每次迭代检查的都是这个临时变量,这就加快了JIT编译的代码速度.\n\n因此,最好保持对数组`Length`属性的调用,而 **不要自己用什么局部变量来缓存它的值**. 这种自作聪明的尝试几乎肯定会对性能造成负面影响,还会使代码更难阅读.\n\nJIT编译器知道for循环要访问0到Length-1的数组元素,JIT编译器会生成代码,在运行时测试所有数组元素的访问都在有效范围内.\n- 也就是来检查是否 `(0 >= ints.GetLowerBound(0)) && ((Length -1)) <= ints.GetUpperBound(0)`\n- 这个检查在循环之前发生,如果都在有效范围内,JIT编译器不会在每一次数组访问时再检查验证. 这样一来访问变得非常快.\n\n**对于非0基数组和多维数组,JIT编译器不会将索引检查从循环中拿出来,所以每次访问都要验证指定的索引.导致访问速度比不上一维0基数组.** 还要添加代码从指定索引中减去数组下限,进一步影响了代码执行速度.\n\n**如果很关心性能. 考虑用由数组构成的数组(`交错数组`)代替矩形数组.**\n\nC#和CLR还允许使用unsafe代码访问数组.这种技术实际能在访问数组时关闭索引上下限检查.\n- 适用于以下元素类型的数组:\n  - SByte,Byte,Int16,UInt16,Int32,UInt32,Int64,UInt64,Char,Single,Double,Decimal,Boolean,枚举类型或任何类型的值类型结构.\n\n> 这个功能很强大,但是使用需要谨慎,它允许直接内存访问,访问越界不会抛出异常.但会损坏内存中的数据.破坏类型的安全性.\n\n\n# 访问二维数组的三种方式(安全,交错和不安全):\n\n```csharp\nprivate const Int32 c_numElements = 10000;\n\npublic static void Go()\n{\n    // 声明二维数组\n    Int32[,] a2Dim = new Int32[c_numElements, c_numElements];\n\n    // 将二维数组声明为交错数组\n    Int32[][] aJagged = new Int32[c_numElements][];\n    for (Int32 x = 0; x < c_numElements; x++)\n        aJagged[x] = new Int32[c_numElements];\n\n\n    // 1: 用普通的安全技术访问数组中的所有元素\n    // 二维数组对象 a[x, y];\n    Safe2DimArrayAccess(a2Dim);\n\n    // 2: 用交错数组技术访问数组中的所有元素\n    // 交错数组对象 a[x][y]\n    SafeJaggedArrayAccess(aJagged);\n\n    // 3: 用unsafe技术访问数组中的所有元素\n    Unsafe2DimArrayAccess(a2Dim);\n}\n\nprivate static Int32 Safe2DimArrayAccess(Int32[,] a)\n{\n    Int32 sum = 0;\n    for (Int32 x = 0; x < c_numElements; x++)\n    {\n        for (Int32 y = 0; y < c_numElements; y++)\n        {\n            sum += a[x, y];\n        }\n    }\n    return sum;\n}\n\nprivate static Int32 SafeJaggedArrayAccess(Int32[][] a)\n{\n    Int32 sum = 0;\n    for (Int32 x = 0; x < c_numElements; x++)\n    {\n        for (Int32 y = 0; y < c_numElements; y++)\n        {\n            sum += a[x][y];\n        }\n    }\n    return sum;\n}\n\n// fixed 语句必须要用unsafe方法修饰符\nprivate static unsafe Int32 Unsafe2DimArrayAccess(Int32[,] a)\n{\n    Int32 sum = 0, numElements = c_numElements * c_numElements;\n    fixed (Int32* pi = a)\n    {\n        for (Int32 x = 0; x < numElements; x++)\n        {\n            sum += pi[x];\n        }\n    }\n    return sum;\n}\n\n```\n\n不安全数据访问技术的三处不足之处:\n- 处理数组元素的代码更复杂,不容易读写,因为要使用C#的`fixed`语句,要执行内存地址计算.\n- 计算过程出错,会损坏内存数据,破坏类型安全性,并可能造成安全漏洞.\n- 因为这些潜在问题,CLR禁止在降低了安全级别的环境中运行不安全代码.\n\n\n# 单维数组\n\n```csharp\n// 可以在声明时初始化数组,在这种情况下，无需长度说明符，因为它已由初始化列表中的元素数目提供。\n// 并且可以省略new int[]\nint[] array1 = new int[] { 1, 3, 5, 7, 9 };\nint[] array2 = { 1, 3, 5, 7, 9 };\n\n\n// 可以在不初始化的情况下声明数组变量，但必须使用 new 运算符向此变量分配数组。\nint[] array3;\narray3 = new int[] { 1, 3, 5, 7, 9 };   // OK\n//array3 = {1, 3, 5, 7, 9};   // Error\n```\n\n# 多维数组\n\n二维数组,逗号分隔,几行几列.\n\n```csharp\n// 以下声明创建一个具有四行两列的二维数组。\n// 也可以\nint[,] array = new int[4, 2];\n\n// 三维数组\nint[, ,] array1 = new int[4, 2, 3];\n\n// Two-dimensional array.\nint[,] array2D = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// The same array with dimensions specified.\nint[,] array2Da = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// A similar array with string elements.\nstring[,] array2Db = new string[3, 2] { { \"one\", \"two\" }, { \"three\", \"four\" },\n                                        { \"five\", \"six\" } };\n\n// 可以简化写法\nint[,] array4 = { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };\n// 如果选择在不初始化的情况下声明数组变量，则必须使用 new 运算符将数组赋予变量。\nint[,] array5;\narray5 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };   // OK\n//array5 = {{1,2}, {3,4}, {5,6}, {7,8}};   // Error\n\n\n// 以下代码示例将数组元素初始化为默认值（交错数组除外）\nint[,] array6 = new int[10, 10];                                      \n```\n\n\n# 交错数组\n\n交错数组是元素为数组的数组。 交错数组元素的维度和大小可以不同。 交错数组有时称为“数组的数组”\n\n\n```csharp\n// 声明三个元素,每个元素都是一维整数数组\nint[][] jaggedArray = new int[3][];\n\n\n// 必须初始化 jaggedArray 的元素后才可使用它。\njaggedArray[0] = new int[5];\njaggedArray[1] = new int[4];\njaggedArray[2] = new int[2];\n\n// 也可使用初始化表达式通过值来填充数组元素，这种情况下不需要数组大小\njaggedArray[0] = new int[] { 1, 3, 5, 7, 9 };\njaggedArray[1] = new int[] { 0, 2, 4, 6 };\njaggedArray[2] = new int[] { 11, 22 };\n\n// 不能从元素初始化中省略 new 运算符，因为不存在元素的默认初始化：\n// 可以省略 new int[][]\nint[][] jaggedArray3 = // new int[][]\n{\n    new int[] { 1, 3, 5, 7, 9 },\n    new int[] { 0, 2, 4, 6 },\n    new int[] { 11, 22 }\n};\n\n// 混合使用多维数组和交错数组\nint[][,] jaggedArray4 = new int[3][,]\n{\n    new int[,] { {1,3}, {5,7} },\n    new int[,] { {0,2}, {4,6}, {8,10} },\n    new int[,] { {11,22}, {99,88}, {0,9} }\n};\n// 访问个别元素，示例显示第一个数组的元素 [1,0] 的值\nSystem.Console.Write(\"{0}\", jaggedArray4[0][1, 0]);// 5\n// 方法 Length 返回包含在交错数组中的数组的数目\nSystem.Console.WriteLine(jaggedArray4.Length); // 3\n```\n\n## 对数组使用foreach\n\n- 对于单维数组，foreach 语句以递增索引顺序处理元素（从索引 0 开始并以索引 Length - 1 结束）\n- 对于多维数组，遍历元素的方式为：首先增加最右边维度的索引，然后是它左边的一个维度，以此类推，向左遍历元素\n\n```csharp\n// 一维数组的foreach\nint[] numbers = { 4, 5, 6, 1, 2, 3, -2, -1, 0 };\nforeach (int i in numbers)\n{\n    System.Console.Write(\"{0} \", i);\n}\n// Output: 4 5 6 1 2 3 -2 -1 0\n\n\n// 多维数组的foreach\nint[,] numbers2D = new int[3, 2] { { 9, 99 }, { 3, 33 }, { 5, 55 } };\n//省略 new int[3, 2]写法\n//int[,] numbers2D = { { 9, 99 }, { 3, 33 }, { 5, 55 } };\n\nforeach (int i in numbers2D)\n{\n    System.Console.Write(\"{0} \", i);\n}\n// Output: 9 99 3 33 5 55\n```\n\n# 不安全的数组访问和固定大小的数组\n\n`不安全的数组`访问能力非常强大,因为它允许访问:\n- `堆上`的托管数组对象中的元素\n- `非托管堆上的数组中的元素`.(14章的ScureString演示了调用Marshal类的SerureStringToCoTaskMemUnicode方法来返回一个数组,并对这个数组进行不安全的数组访问)\n- `线程栈上`的数组中的元素\n\n如果考虑性能是首要目标,请避免在堆上分配托管的数组对象.在线程栈上分配数组. 这是通过C#的`stackalloc`语句来完成的. **并且只能创建一维0基,由值类型元素构成的数组.** 值类型中不能包含任何引用类型的字段. 实际上可以看做是分配了一个内存块,这个内存块可以使用不安全的指针来操作. 所以不能将这个内存缓冲区的地址传给大部分FCL方法. 栈上分配的内存会在返回时自动释放.\n\n\n```csharp\nprivate static void StackallocDemo()\n{\n    unsafe\n    {\n        const Int32 width = 20;\n        // 在栈上分配数组\n        Char*       pc    = stackalloc Char[width];\n        // 15 个字符\n        String s = \"Jeffrey Richter\";\n\n        for (Int32 index = 0; index < width; index++)\n        {\n            pc[width - index - 1] =\n                (index < s.Length) ? s[index] : '.';\n        }\n        // 输出 \".....rethciR yerffeJ\"\n        Console.WriteLine(new String(pc, 0, width));\n    }\n}\n\nprivate static void InlineArrayDemo()\n{\n    unsafe\n    {\n        // 在栈上分配数组\n        CharArray ca;\n        Int32     widthInBytes = sizeof(CharArray);\n        Int32     width        = widthInBytes / 2;\n        // 15 个字符\n        String s = \"Jeffrey Richter\";\n\n        for (Int32 index = 0; index < width; index++)\n        {\n            ca.Characters[width - index - 1] =\n                (index < s.Length) ? s[index] : '.';\n        }\n        // 输出 \".....rethciR yerffeJ\"\n        Console.WriteLine(new String(ca.Characters, 0, width));\n    }\n}\n\nprivate unsafe struct CharArray\n{\n    // 这个数组内联嵌入到结构中\n    public fixed Char Characters[20];\n}\n```\n\n由于数组是引用类型,所以结构中定义的数组字段实际只是指向数组的`指针或引用`. **数组本身在结构的内存的外部.** 不过可以像上述代码`public fixed Char Characters[20];` 嵌入到结构中,但是需要满足以下条件:\n- 类型必须是`结构(值类型)`; 不能再类(引用类型)中嵌入数组.\n- 字段或其定义结构必须用`unsafe`关键字标记\n- 数组字段必须用`fixed关键字`标记.\n- 数组必须是一维0基数组.\n- 数组的元素类型必须是以下类型之一:\n  - Char,SByte,Byte,Int16,UInt16,Int32,UInt32,Int64,UInt64,Char,Single,Double,Boolean\n\n要和非托管代码进行互操作,而且非托管数据结构也有一个内联数组,就特别适合使用内联的数组.\n","tags":["CLR读书笔记"]},{"title":"15枚举类型和位标志","url":"/2019/08/15/15枚举类型和位标志/","content":"# 枚举类型和位标志\n\nCLR和FCL结合起来之后, 枚举类型和位标志才真正成为面向对象的类型. 提供了一些强大的功能.大部分开发人员并不熟悉.\n\n# 枚举类型\n\n**枚举类型(enumerated type)** 定义了一组 \"符号名称/值\" 配对. 例如:\n\n```csharp\n// 每个符号标识一种颜色, 也可以用0标识白色\ninternal enum Color\n{\n  White,    // 赋值0\n  Red,      // 赋值1\n  Green,    // 赋值2\n  Blue,     // 赋值3\n  Orange    // 赋值4\n}\n```\n\n不应该将数字硬编码到代码中,而应该使用枚举类型.\n1. 更容易阅读和理解代表的含义. 调试程序能向开发人员显示有意义的符号名称.\n2. 枚举是强类型的. 比如Color.Orange和Fruit.Orange是不同的,虽然都有一个Orange.\n\n在.Net Framework中, 枚举类型不只是编译器所关心的符号, 还是类型系统中的一等公民, 能实现很强大的操作.(在其他环境比如非托管C++中,枚举没有这个特点的).\n\n**每个枚举都直接从`System.Enum`派生** , `System.Enum`从`System.ValueType`派生.`System.ValueType`又从`System.Object`派生.\n\n枚举都是 **值类型** . 可以用未装箱和已装箱的形式来表示,但是区别于其他值类型, 枚举类型不能定义任何方法,属性,事件.  可以用`扩展方法`功能模拟向枚举类型添加方法.(在最后会举例)\n\n编译枚举类型时,C#编译器把每个符号转换成类型的一个 **常量字段**.\n\n```csharp\n// 此代码是伪类型定义,用来了解内部的工作方式\n// 实际上编译器不会编译以下代码,禁止定义从System.Enum派生的类型.\ninternal struct Color : System.Enum\n{\n  // 以下是一些公共常量,它们定义了Color的符号和值\n  public const Color White  = (Color)0;\n  public const Color Red    = (Color)1;\n  ....\n\n  // 以下是一个公共实例字段.包含Color变量的值\n  // 不能写代码来直接引用该字段\n  public Int32 value__;\n}\n```\n\n简单地说,枚举类型只是一个结构,其中定义了:\n- 一组常量字段\n  - 会嵌入程序集的元数据中,并可以通过反射来访问(有静态方法和实例方法可以操作,不是必须要用反射)\n- 一个实例字段\n\n可以在运行时获得与枚举类型关联的所有符号及其值. 可以将字符串符号转换成对应的数值.`System.Eunm`基类型提供了这些操作, 还提供了几个静态和实例方法, 可利用它们操作枚举类型的实例,从而避免了必须使用反射的麻烦.\n\n> 枚举类型定义的符号是常量值, 编译器发现代码引用了枚举类型的符号时,会在编译时用数值替换符号,代码不再引用定义了符号的枚举类型.\n> 也就是说:运行时可能不需要定义了枚举类型的程序集,编译时才需要.\n> 如果代码引用了枚举类型,而不是只引用了枚举类型定义的符号,那么运行时也需要包含定义枚举所在的程序集.\n> 版本问题: 因为枚举类型符号是常量, 而不是只读的值. 常量值直接嵌入IL代码. 如果枚举常量所在的程序集改动了, 引用此程序集的应用程序没有重新编译,使用的就是旧值.而不会重新从那个程序集中获取常量的新值.\n\n## 返回枚举基础类型的方法\n\n例如，System.Enum类型有一个`GetUnderlyingType`的静态方法，而`System.Type`类型有一个 `GetEnumUnderlyingType`的实例方法。\n\n```csharp\npublic static Type GetUnderlyingType (Type enumType); //System.Enum中定义\npublic Type GetEnumUnderlyingType (Type enumType);    //System.Type中定义\n```\n\n这些方法返回用于容纳一个枚举类型的值的`基础类型`. **每个枚举类型都有一个基础类型.** int最常用,也是C#默认选择的.\n\nC#编译器要求只能指定基元类型名称. 使用FCL类型名称会报错. 应输入类型byte,sbyte,short,ushort,int,uint,long,ulong.\n\n```csharp\ninternal enum Color : byte\n{\n  White,\n  Red,\n  Green\n}\n\n// 以下代码都会显示 System.Byte\nConsole.WriteLine(Enum.GetUnderlyingType(typeof(Color)));\nConsole.WriteLine(typeof(Color).GetEnumUnderlyingType());\n```\n\n\nC#编译器将枚举类型视为基元类型. 所以可用操作符(==,!=,<,>....)来操纵枚举类型的实例.可以显式将`枚举类型`转型为`不同的枚举类型`,可以显式将`枚举类型实例`转换为`数值类型`.\n\n```csharp\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        Color c = Color.Green;\n        Console.WriteLine(c);                            // Green\n        Console.WriteLine(c.ToString());                 // Green\n        Console.WriteLine(c.ToString(\"G\"));              // Green 常规格式\n        Console.WriteLine(c.ToString(\"D\"));              // 2     十进制\n        // 使用十六进制是, ToStirng总是输出大写字母\n        // 输出的位数取决于枚举的基础类型\n        // byte/sbyte: 2位, short/ushort: 4位 int/uint:8位 long/ulong: 16位\n        // 如果有必要会添加前导零\n        Console.WriteLine(c.ToString(\"X\"));              // 02    十六进制\n        Console.WriteLine(Color2.Green.ToString(\"X\"));   // 00000002 十六进制\n    }\n}\n\ninternal enum Color : byte\n{\n    White,\n    Red,\n    Green\n}\ninternal enum Color2 : int\n{\n    White,\n    Red,\n    Green\n}\n```\n## 枚举类型格式化输出的方法\n\n除了ToString方法,System.Enum类型还提供了静态Fotmat方法.\n\n- `ToSring方法`: 代码少,容易调用.\n- `Fotmat方法`: 可以传递value值,而不需要获取枚举的实例. 代码多.\n\n```csharp\n// 比ToString方法好的一个地方是,允许为value传递参数的值,这样就不需要获取枚举的实例\npublic static String Format(Type enumType,Object value, String format);\n\n// 输出: Blue\nConsole.WriteLine(Enum.Format(typeof(Color), 3, \"G\"));\n```\n\n## 返回枚举名称(值)的Array数组方法\n\n声明枚举类型时, 所有符号都可以有相同的数值. 使用常规格式将数值转换为符号时,Enum的方法会返回其中的一个符号,如果没有对应的数值定义的符号时,会返回包含该数值的字符串.\n\n```csharp\n// 返回的数组中每个元素都对应枚举类型中的一个符号名称,每个元素都包含符号名称的数值\npublic static Array GetValues(Type enumType); //System.Enum中定义\npublic Array GetEnumValues(Type enumType);    //System.Type中定义\n\n// 返回一个数组\nColor[] colors = (Color[]) Enum.GetValues(typeof(Color));\n\nConsole.WriteLine(\"定义枚举的个数: \" + colors.Length);\nConsole.WriteLine(\"Value\\tSymbol\\n-----\\t------\");\n\nforeach (Color color in colors)\n{\n    // 以十进制和常规格式显示每个符号\n    // 0代表第0个参数, {0,5:D} 5个占位符,color的十进制   {0:G} color的常规格式(符号名称)\n    Console.WriteLine(\"{0,5:D}\\t{0:G}\", color);\n}\n//    输出:\n//    定义枚举的个数: 3\n//    Value Symbol\n//    -----   ------\n//        0   White\n//        1   Red\n//        2   Green\n```\n\n`GetEnumValues和GetValues`方法返回Array,必须转型成恰当的数组类型. 所以定义了一个自定义的方法:\n```csharp\n// 使用下面自定义的泛型方法可以获得更好的编译时类型安全性\npublic static TEnum[] GetEnumValues<TEnum>() where TEnum :struct\n {\n     return (TEnum[]) Enum.GetValues(typeof(TEnum));\n }\n\n // 使用如下\n Color[] colors = GetEnumValues<Color>();\n```\n\n## 返回枚举符号名称的方法\n\n要显示符号名称时,ToString(常规格式)方法是经常使用的,前提是字符串不需要本地化(枚举类型没有提供本地化支持). 除了GetValues,还提供了以下方法来返回枚举类型的符号.\n\n```csharp\n// 返回数值的字符串表示\npublic static String GetName(Type enumType, Object value); // System.Enum中定义\npublic String GetEnumName(Object value); // System.Type中定义\n\n// 返回一个String数组,枚举中每个符号都对应一个String\npublic static String[] GetName(Type enumType);// System.Enum中定义\npublic String[] GetEnumName();  // System.Type中定义\n```\n\n## 返回与符号对应的值的方法\n\n来查找与符号对应的值. 可以利用这个操作转换用户在文本框中输入的一个符号.利用Enum提供的`静态Parse和TryParse方法`.\n\n```csharp\npublic static Object Parse(Type enumType, String value);\npublic static Object Parse(Type enumType, String value, Boolean ignoreCase);\npublic static Boolean TryParse<TEnum>(String value, out TEnum result) where TEnum : struct;\npublic static Boolean TryParse<TEnum>(String value, Boolean ignoreCase, out TEnum result) where TEnum : struct;\n\n\n// 使用方法\n// 因为orange定义为4, 所有c被初始化为4\nColor c = (Color) Enum.Parse(typeof(Color), \"orange\", true);\n\n// 运行时异常, 没有定义此Brown符号\n// Color c1 = (Color) Enum.Parse(typeof(Color), \"Brown\", false);\n\n// 创建值为1的Color枚举类型的实例.\nEnum.TryParse<Color>(\"1\", false, out c);\nConsole.WriteLine(c.ToString(\"D\")  + \":\" + typeof(Color).GetEnumName(c));\n\n// 创建值23的Color枚举类型的实例.\nEnum.TryParse<Color>(\"23\", false, out c);\nConsole.WriteLine(c + \":\" + typeof(Color).GetEnumName(c));\n\n```\n\n## 判断数值对于某枚举类型是否合法\n\nIsDefined方法经常用于参数校验.\n\n```csharp\npublic static Boolean IsDefined(Type enumType, Object value); // System.Enum中定义\npublic Boolean IsEnumDefined(Object value);// System.Type中定义\n\n\n// 用法\n// 输出 true , Red定义为1\nConsole.WriteLine(Enum.IsDefined(typeof(Color),1));\n// 输出 true , white定义为0\nConsole.WriteLine(Enum.IsDefined(typeof(Color),\"White\"));\n\n// 输出 false , 会检查区分大小写,并没有定义小写的white\nConsole.WriteLine(Enum.IsDefined(typeof(Color),\"white\"));\n// 输出 false , 没有和值10对应的符号\nConsole.WriteLine(Enum.IsDefined(typeof(Color),10));\n\n// IsDefined方法经常用于参数校验.\npublic void SetColor(Color c)\n{\n    if (!Enum.IsDefined(typeof(Color),c))\n    {\n        throw (new ArgumentOutOfRangeException(\"c\",c,\"无效颜色值.\"));\n    }\n    //.....\n}\n```\n\n参数校验是很有用的一个功能,防止别人这样调用`SetColor((Color) 100);` 并没有对应100的颜色,抛出异常指出参数无效.\n\n`IsDefined` 需要慎用\n1. 总是执行 **区分大小写** 的查找,没有办法让它执行不区分大小写的查找\n2. **执行速度慢**,因为内部使用了 **反射**.(如果写代码来手动检查每一个可能的值,性能极有可能变得更好)\n3. 只有枚举类型本身在调用IsDefined在同一个 **程序集** 时才可以使用.(枚举类型是常量,内联到IL代码中的,版本控制问题)\n4. **不要对位标志枚举使用IsDefined方法**. 因为如果传递字符串,它不会把字符串拆分为单独的token来进行查找,而是查找整个字符串, 把它看成是一个包含逗号的更大的符号.由 **于不能再枚举中定义包含逗号的符号**,所以永远找不到. 传递数值,它会检查枚举类型是否定义了其数值和传入的数值匹配,位标志不能简单的这样匹配,所以不要用这个方法.\n\n## ToObject方法\n\n将byte,sbyte,Int16,UInt16,Int32,UInt32,Int64,UInt64等类型的实例转换为 **枚举类型** 的实例.\n\n枚举一般来说应该定义在和需要它的类型同级.\n\n# 位标志\n\n位标志(bit flag), System.IO.File类型的GetAttributes方法,会返回一个`FileAttributes`的实例,\n`FileAttributes`是Int32类型的枚举, 每一个位都反映了文件的一个特性.\n\n```csharp\n[Flags]\n// Int32 有4个字节 每个字节8个位\npublic enum FileAttributes\n{\n    //                十进制        二进制\n    ReadOnly          = 1,      // 0001\n    Hidden            = 2,      // 0010\n    System            = 4,      // 0100\n    Directory         = 16,     // 0001 0000\n    Archive           = 32,     // 0010 0000\n    Device            = 64,     // 0100 0000\n    Normal            = 128,    // 1000 0000\n    Temporary         = 256,    // 0001 0000 0000\n    SparseFile        = 512,    // 0010 0000 0000\n    ReparsePoint      = 1024,   // 0100 0000 0000\n    Compressed        = 2048,   // 1000 0000 0000\n    Offline           = 4096,   // 0001 0000 0000 0000\n    NotContentIndexed = 8192,   // 0010 0000 0000 0000\n    Encrypted         = 16384,  // 0100 0000 0000 0000\n    IntegrityStream   = 32768,  // 1000 0000 0000 0000\n    NoScrubData       = 131072, // 0010 0000 0000 0000 0000\n}\n```\n\n\n```csharp\n// 判断文件是否隐藏可以执行以下代码:\nString file = Assembly.GetEntryAssembly().Location;\n// 获取文件的特性的枚举位标志\nFileAttributes attributes = File.GetAttributes(file);\n// 用& 与操作进行判断,如果attributes对应的Hidden位标志是1,那么1&1 就是true.\nConsole.WriteLine(\"Is {0} hidden? {1}\", file, (attributes & FileAttributes.Hidden) != 0);\n// HasFlag方法获取Enum参数,Enum参数是引用类型.\n// Console.WriteLine(\"Is {0} hidden? {1}\", file, attributes.HasFlag(FileAttributes.Hidden) );\n\n// 设置文件只读和隐藏特性\n// 用 |\nFile.SetAttributes(file, FileAttributes.Hidden | FileAttributes.ReadOnly);\n```\n\n**避免使用Enum提供的HasFlag方法**, 理由是,由于它获取Enum类型的参数,所以传给它的任何值都必须装箱,产生一次内存分配.\n\n## 关于为什么传入结构会进行装箱的问题\n\n在本例中，在进入`HasFlags`方法之前，需要两个装箱调用。\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var f = Fruit.Apple;\n        var result = f.HasFlag(Fruit.Apple);\n\n        Console.ReadLine();\n    }\n}\n\n[Flags]\nenum Fruit\n{\n    Apple\n}\n\n.method private hidebysig static\n    void Main (\n        string[] args\n    ) cil managed\n{\n    // Method begins at RVA 0x2050\n    // Code size 28 (0x1c)\n    .maxstack 2\n    .entrypoint\n    .locals init (\n        [0] valuetype ConsoleApplication1.Fruit f,\n        [1] bool result\n    )\n\n    IL_0000: nop\n    IL_0001: ldc.i4.0\n    IL_0002: stloc.0\n    IL_0003: ldloc.0\n    IL_0004: box ConsoleApplication1.Fruit\n    IL_0009: ldc.i4.0\n    IL_000a: box ConsoleApplication1.Fruit\n    IL_000f: call instance bool [mscorlib]System.Enum::HasFlag(class [mscorlib]System.Enum)\n    IL_0014: stloc.1\n    IL_0015: call string [mscorlib]System.Console::ReadLine()\n    IL_001a: pop\n    IL_001b: ret\n} // end of method Program::Main\n```\n\n- 第一次是将值类型上的方法调用解析为`基类型`方法，\n  - 调用基类型的方法会导致装箱\n- 第二次是参数时引用类型`Enum`, 要对枚举值类型进行装箱.\n\n**调用非虚的,继承的方法时(比如GetType或者MemberwiseClone),无论如何都要对值类型进行装箱, 因为这些方法由System.Object定义,要求this实参是指向堆对象的指针.**\n\n“值类型都是`System.ValueType`的后代”，**但System.ValueType的后代不全是值类型**，`System.Enum`就是唯一的特例！在System.ValueType的所有后代中，除了System.Enum之外其它都是值类型。事实上，我们可以在.NET的源代码中找到System.Enum的声明.\n\n`public abstract class Enum : ValueType, IComparable, IFormattable, IConvertible`\n\n### C#枚举类型、System.Enum、System.ValueType、值类型和引用类型之间存在着什么样的关系？\n\n1. 所有`枚举类型（enum type）`都是值类型。\n2. `System.Enum`和`System.ValueType`本身是引用类型。\n3. `枚举类型（enum type）`都是隐式的直接继承自`System.Enum`，并且这种继承关系只能由编译器自动展开。但`System.Enum`本身 **不是枚举类型（enum type）** 。\n4. `System.Enum`是一个特例，它直接继承自`System.ValueType`，但本身却是一个引用类型。\n\n\n```csharp\n// 结果是什么都没输出\nstatic void Main()  \n{  \n    Type t = typeof(System.Enum);  \n\n    if (t.IsEnum)  \n        Console.WriteLine(\"I'm enum type.\");  \n\n    if (t.IsValueType)  \n        Console.WriteLine(\"I'm value type.\");  \n}\n```\n\n对于第一个判断，`我们很清楚System.Enum并不是枚举类型`。但第二个判断呢？System.Enum明明继承自System.ValueType，却不承认是System.ValueType的后代！这是.NET上的一个特例，恰恰体现出System.Enum是特殊性。\n\n\nQ：既然枚举类型是值类型，自然会涉及到装箱和拆箱（boxing and unboxing）的问题，那么枚举类型会被装箱成什么呢？\n\nA：枚举类型可以被装箱成`System.Enum`、`System.ValueType`、`System.Object`或者`System.IConvertible`、`System.IFormattable`、`System.IComparable`。\n\n[关于枚举的种种 C#, IL, BCL(博客地址)](https://blog.csdn.net/superbirds/article/details/4434133)\n\n## Flag特性\n\n位标志可以用来组合. 虽然枚举类型和位标志相似,但它们语义不尽相同.\n- 枚举类型表示单个数值\n- 位标志表示位集合\n  - 一些位处于On状态(代表1),一些处于off状态 (代表0)\n- **强烈建议向枚举类型应用定制特性类型[Flag]**\n\n```csharp\npublic static void Main(string[] args)\n{\n    // 现在数值为0x0005\n    Actions actions = Actions.Read | Actions.Delete;\n    // 输出: Read, Delete\n    Console.WriteLine(actions.ToString());\n}\n\n// 加上特性类型[Flag],ToString方法会试图转换为对应的符号,\n// 但是0x0005没有对应的值,不过方法检测到[Flag]标志,不会把他视为单独的值\n// 会视为一组位标志 0x0005由0x0001和0x0004组合而成,会输出Read, Delete字符串\n[Flags]\ninternal enum Actions\n{\n    None      = 0b0,\n    Read      = 0b1,\n    Write     = 0b10,  // 0x2\n    ReadWrite = Actions.Read | Actions.Write, //0x5\n    Delete    = 0b100, // 0x4\n    Query     = 0b1000,// 0x8\n    Sync      = 0b10000//0x10\n}\n```\n\n加上特性类型[Flag],ToString方法会试图转换为对应的符号,但是0x0005没有对应的值,不过 **方法检测到[Flag]标志,不会把他视为单独的值,会视为一组位标志** 0x0005由0x0001和0x0004组合而成,会输出Read, Delete字符串,去掉[flag]特性,则输出5.\n\n枚举的ToString()允许三种方式格式化输出:\n1. \"G\" 常规\n  1. 首先会检测类型,是否应用了[Flags]这个特性\n  2. 没有应用就查找与该数值匹配的符号,返回 **符号**\n2. \"D\" 十进制\n3. \"X\" 十六进制\n4. \"F\" 获得正确的字符串\n\n如果应用了[Flags]这个特性,ToString的工作流程如下:\n- 获取枚举类型定义的集合,降序排列这些数值\n- 每个数值都和枚举实例中的值进行`按位与`计算\n- 结果等于数值,与该数值关联的字符串就附加到输出字符串上. 对应的位会被关闭(设为0),认为已经考虑过了.\n- 重复上一步,直到检查完所有的值(或者所有位都为0)\n- 检查完数值后,如果枚举实例仍有不为0,表示处于On位的位不对应任何已经定义的符号.这种情况下,ToString返回枚举实例中的 **原始数值作为字符串返回.**\n- 如果实例不为0,就返回符号之间以逗号分隔的字符串.例如:`Read, Delete`\n- 如果实例原始值是0,并且有对应0值的符号. 返回这个符号\n- 到达这一步就返回\"0\".\n\n**永远不要对位`标志枚举`使用IsDefined方法**.\n- 向方法传递`字符串`,它不会把字符串拆分为单独的token来进行查找,而是查找整个字符串, 把它看成是一个包含逗号的更大的符号.由 **于不能再枚举中定义包含逗号的符号**,所以永远找不到.\n- 向方法传递`数值`,它会检查枚举类型是否定义了其数值和传入的数值匹配,位标志不能简单的这样匹配,所以不要用这个方法.\n\n# 向枚举类型添加方法\n\n利用C#的扩展方法 **模拟** 向枚举类型添加方法.\n\n```csharp\nclass Program\n{\n    public static void Main(string[] args)\n    {\n        FileAttributes fa = FileAttributes.System;\n        fa = fa.Set(FileAttributes.ReadOnly);\n        fa = fa.Clear(FileAttributes.System);\n        // 输出: ReadOnly\n        fa.ForEach(f=>Console.WriteLine(f));\n\n    }\n}\n\n// 先定义一个包含了扩展方法的静态类\ninternal static class FileAttributesExtensionMethod\n{\n    public static Boolean IsSet(this FileAttributes flags, FileAttributes flagToTest)\n    {\n        if (flagToTest == 0)\n        {\n            throw new ArgumentOutOfRangeException(\"flagToTest\",\"值不能为0.\");\n        }\n        return (flags & flagToTest) == flagToTest;\n    }\n\n    public static Boolean IsClear(this FileAttributes flags, FileAttributes flagToTest)\n    {\n        if (flagToTest == 0)\n        {\n            throw new ArgumentOutOfRangeException(\"flagToTest\",\"值不能为0.\");\n        }\n        return  ! IsSet(flags,flagToTest);\n    }\n\n    public static Boolean AnyFlagSet(this FileAttributes flags, FileAttributes testFlag)\n    {\n        return ((flags & testFlag) != 0);\n    }\n\n    public static FileAttributes Set(this FileAttributes flags, FileAttributes setFlag)\n    {\n        return flags | setFlag;\n    }\n\n    public static FileAttributes Clear(this FileAttributes flags, FileAttributes clearFlag)\n    {\n        return flags & ~clearFlag;\n    }\n\n    public static void ForEach(this FileAttributes flags, Action<FileAttributes> processFlag)\n    {\n        if (processFlag == null)\n        {\n            throw new ArgumentNullException(\"processFlag\");\n        }\n\n        for (UInt32 bit = 1; bit != 0; bit <<= 1)\n        {\n            UInt32 temp = ((UInt32) flags) & bit;\n            if (temp!=0)\n            {\n                processFlag((FileAttributes) temp);\n            }\n        }\n    }\n}\n```\n","tags":["CLR读书笔记"]},{"title":"14字符字符串和文本处理2","url":"/2019/08/15/14字符字符串和文本处理2/","content":"# 获取对象的字符串表示 ToStirng\n\nSystem.Object定义了一个pulic,virtual,无参的ToString方法.\n\nSystem.Object的ToStirng实现的只是返回对象所属类型的全名,这对于许多不能提供有意义的字符串的类型来说,这是一个合理的默认值.\n\n想要提供合理的方式获取对象当前值的字符串表示,就应重写ToString方法. 定义类时应该总是重写ToString方法,以提供良好的调试支持.\n\n## 指定具体的格式和语言文化\n\n无参的ToString方法有两个问题:\n- 无法控制字符串的格式\n- 不能选择一种特定的语言文化来格式化字符串\n\n为了解决这个,类型应该实现`System.IFormattable`接口:\n```csharp\n// FCL的所有基类型都实现了这个接口, 另一些类型(Guid)也实现了它\npublic interface IFormattable\n{\n  String ToString(String format, IFormatProvider formatprovider);\n}\n```\n\nIFormattable方法获取两个参数,\n- `String format`: 告诉方法如何格式化字符串\n- `formatprovider`: 是一个实现了IFormatProvider接口的实例类型,提供具体的语言文化信息.\n\nFCL中定义的许多类型都能同时识别几种格式, 例如,\n- DateTime\n  - d 表示短日期\n  - D 表示长日期\n  - g 表示常规\n  - M 表示月/日\n  - s 表示可排序\n  - T 表示长时间\n  - u 表示ISO8601格式的协调世界时\n  - U 表示长日期格式的协调世界时\n  - Y 表示年/月\n- 所有枚举\n  - G 表示常规\n  - F 表示标志\n  - D 表示十进制\n  - X 表示十六进制\n- 所有内建数值类型\n  - C 表示货币格式\n  - D 表示十进制格式\n  - E 表示科学计数法\n  - F 表示定点(fix-point)格式\n  - G 表示常规格式\n  - N 表示数字格式\n  - P 表示百分比格式\n  - R 表示往返行程(round-trip)格式\n    - 保证转换为字符串的数值再次被分析为相同的数值\n    - 此格式仅有浮点型(Single,Double)支持\n  - X 表示十六进制\n- 数值类型还支持 picture数值格式字符串###,###可以显示千分位分隔符. (详情参考自定义数字格式字符串)\n\n![](14字符字符串和文本处理2/R说明符.png)\n\n大多数类型,调用ToStirng传递null完全等价于传递格式字符串`G`.\n\n关于语言文化,默认无参ToString方法默认使用与调用线程关联的语言文化信息进行格式化.如果formatprovider传null,IFormattable的ToString也这么做.\n\n\n格式化数组(货币,整数,浮点数,百分比,日期和时间)适合应用对语言文化敏感的信息.\n\n```csharp\n// 一下代码将以越南地区适用的货币格式来获取一个Decimal数值的字符串表示.\nDecimal price = 123.54M;\nString s = price.ToStirng(\"C\",new CultureInfo(\"vi-VN\"));\nMessageBox.Show(s);\n```\n\n![](14字符字符串和文本处理2/越南货币显示.png)\n\n```csharp\n// 这个版本调用ToString(null,null);\n// 采用常规数值格式,采用线程的语言文化信息\npublic override String ToString();\n\n// 是ToString的真正实现\n// 采用由调用者指定的格式和语言文化信息\npublic String ToString(String format, IFormatProvider formatprovider);\n\n// 简单的调用ToString(null,formatprovider);\n// 实现了IConvertible的ToString方法\npublic String ToString(IFormatProvider formatprovider);\n```\n\n## 将多个对象格式化成一个字符串\n\n```csharp\nString s = String.Format(\"On {0:D}, {1} is {2:E} years old.\", new DateTime(2019, 8, 15), \"AA\", 9);\n// 输出: On 2019年8月15日, AA is 9.000000E+000 years old.\nConsole.WriteLine(s);\n```\n\n在Format中,解析字符串时, 发现可替换`参数0`应该调用它的IFormattable接口的ToString方法,并为方法传递\"D\",null参数.\n\n但是如果使用StringBulider而不是String来构造字符串,可以调用StringBulider的AppendFormat方法.AppendFormat原理与String的Format相似.\n\nConsole的Write/WriteLine要格式化符合特定语言文化的字符串必须要调用String的Format方法.\n\n## 提供定制格式化器\n\n可以定义一个方法,在任何对象需要格式化字符串的时候由`StringBuilder`的`AppendFormat`方法调用该方法,按照我们希望的任何方式格式化对象. (也适用于String的Format方法)\n\n也就是说,`AppendFormat`不是为每个对象调用ToString方法,而是调用自定义的方法.\n\n以下代码为了将所有的Int32值在HTML中加粗显示.\n\n```csharp\n/// <summary>\n/// 格式化定制器\n/// 将所有的Int32值在HTML中加粗显示.用<B></B>加粗显示\n/// </summary>\nnamespace FormatController\n{\n    class Program\n    {\n        public static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n            // 传入定制类BoldInt32s为参数\n            sb.AppendFormat(new BoldInt32s(), \"{0} {1} {2:M}\", \"AAA\", 23, DateTime.Now);\n            //输出 AAA <b>23</b> 8月15日\n            Console.WriteLine(sb);         \n            Console.ReadKey(true);\n        }\n    }\n    // 需要实现IFormatProvider和ICustomFormatter接口\n    internal sealed class BoldInt32s : IFormatProvider, ICustomFormatter\n    {\n        public object GetFormat(Type formatType)\n        {\n            if(formatType == typeof(ICustomFormatter))\n            {\n                return this;\n            }       \n            return Thread.CurrentThread.CurrentCulture.GetFormat(formatType);\n        }       \n        public string Format(string format, object arg, IFormatProvider formatProvider)\n        {\n            string s;       \n            IFormattable formattable = arg as IFormattable;         \n            if(formattable == null)\n            {\n                s = arg.ToString();\n            }\n            else\n            {\n                s = formattable.ToString(format, formatProvider);\n            }         \n            if(arg.GetType() == typeof(Int32))\n            {\n                return \"<b>\" + s + \"</b>\";\n            }       \n            return s;\n        }     \n    }         \n}\n```\n\nAppendFormat的工作方式:\n1. 需要格式化一个可替换参数时,会调用ICustomFormatter的Format方法\n2. 如果不支持就调用简单的无参的ToString方法\n3. 如果对象支持IFormattable就调用支持富格式化的ToString,向它传递字符串和格式提供器.\n4. 最后核实类型是否是需求的类型,处理自定义操作.\n\n\n# 解析字符串来获取对象 : Parse\n\n从某种意义上来说,Parse扮演了一个工厂的角色. 能解析字符串的任何类型都提供了`公共静态方法Parse`.\n\n以Int32类型的Parse方法为例(其他数值类型的Parse方法与此相似):\n\n```csharp\n\npublic static Int32 Parse(String s,NumberStyles style, IFormatProvider provider);\n```\n\n- `NumberStyles` 参数是标志集合,标识了Parse应在字符串查找的字符,也就是s中允许的样式,不允许的会抛出异常.(也就是说 string中不能出现不对应类型的字符)\n- `IFormatProvider` 获取语言文化特有的信息\n```csharp\n// 会抛出FormatException\n// 字符串包含了前导空白符\n// Int32 x = Int32.Parse(\" 123\",NumberStyles.None, null);\n\n// 这样修改,能跳过前导空白符\nInt32 x = Int32.Parse(\" 123\",NumberStyles.AllowLeadingWhite, null);\n\n// 解析16进制数\nInt32 x = Int32.Parse(\"1A\",NumberStyles.HexNumber, null); // x : 26\n\n// 上述方法需要传递3个参数,为了简化编程,还提供了Parse方法的4个重载版本.\n```\n\n[数字NumberStyles的详细文档.](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.numberstyles?redirectedfrom=MSDN&view=netframework-4.8)\n\n[日期的DateTimeStyles的详细文档](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.datetimestyles?redirectedfrom=MSDN&view=netframework-4.8)\n\n对日期和事件的解析比较复杂, DateTime类型的Parse方法过于宽松,还提供`ParseExact`方法,接收一个picture参数,能准确描述应该如何格式化日期/时间字符串,以及如何解析.\n\n[参考DateTimeFormatInfo的详细文档](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.datetimeformatinfo.-ctor?redirectedfrom=MSDN&view=netframework-4.7.2)\n\n## 关于Parse性能上的问题\n\n如果应用程序频繁调用Parse,而且Parse频繁抛出异常(用户无效输入),应用程序性能会显著下降.\n\n为此, Microsoft为所有的`数值数据类型`,`DateTime类型`,`TimeSpan类型`,`IPAddress类型`中加入`TryParse`方法.\n\n```csharp\n// 方法返回bool, 指出传递的字符串是否能解析成功,以传引用的方式传给result\npublic static bool TryParse(string s,NumberStyles style,IFormatProvider provider,\n  out int result);\n```\n\n\n# 编码: 字符和字节的相互转换\n\n用`System.IO.BinaryWriter`或者`System.IO.StreamWriter`类型将字符串发送给文件或网络流时，通常要进行编码。对应地，`System.IO.BinaryReader`或者`System.IO.StreamReader`类型从文件或网络流中读取字符串时，通常要进行解码。不显式指定一种编码方案，所有这些类型都默认使用UTF-8。\n\nFCL提供了一些类型来简化字符编码和解码. 两种最常用的编码方案是UTF-16和UTF-8.\n\n- `UTF-16`: 将每个16位字符编码成2个字节。不会对字符产生任何影响，也不发生压缩---性能非常出色。UTF-16编码也称为Unicode编码。(可以从`低位优先`转换成`高位优先`,或者`高位优先`转换成`低位优先`)\n\n- `UTF-8`: 将部分字符编码成1个字节，部分编码成2个字节，部分编码成3个字节或4个字节。值在0x0080之下的字符压缩成1个字节，适合表示美国使用字符。0x00800~0x07FF的字符转换成2个字节，适合欧洲和中东语言。0x0800以及之上的字符转换成3个字节，适合东亚语言。最后代理项对表示成4个字节。0x0080编码方法非常流行，但如果要编码的许多字符都具有0x0800或者之上的值，效率不如UTF-16\n\n- `ASCII`: 编码方案将16位字符编码从ASCII字符：也就是说，值小于0x0080的16位字符被转换成单字节。值超过0x007F的任何字符都不能被转换，否则字符的值会丢失。\n\n> 应该总是选择UTF-16 UTF-8编码\n\n```csharp\nString s = \"Hi there.\";\n\n// 它知道怎么使用UTF-8来进行编码和解码\nEncoding encodingUTF8 = Encoding.UTF8;\n\n// 将字符串编码成字节数组\nByte[] encodingBytes = encodingUTF8.GetBytes(s);\n\n// 显式编译好的字节值\n// 输出:48-69-20-74-68-65-72-65-2E\nConsole.WriteLine(BitConverter.ToString(encodingBytes));\n\n// 将字节数组解码回字符串\nString decodeString = encodingUTF8.GetString(encodingBytes);\n\n// 显式解码的字符串\n// 输出: Hi there.\nConsole.WriteLine(decodeString);\n```\n\n**不建议使用Encoding类的静态属性Defult,它返回的是对象使用用户当前的代码页来进行编码和解码(在用户控制面板的区域和语言选项中指定),也就有是说应用程序的行为会随着机器的设置而变.**\n\n**`UnicodeEncoding`**,**`UTF8Encoding`**,**`UTF32Encoding`**,`UTF7Encoding`提供了多个构造器, 允许对编码和前导码进行更多的控制. 前3个类还提供了特殊的构造器,允许在对一个无效的字节序列进行解码时抛出异常,**应该使用这些能抛出异常的类.**\n\n前导码: 也称`字节顺序标记`(BOM,Byte Order Mark).\n\n![](14字符字符串和文本处理2/Encoding的派生类常用的方法.png)\n\n## 字符和字节流的编码和解码\n\n字节流通常以数据块data chunk的形式传输, 可能先从流中读5个字节,然后再7个字节,因为UTF-16每个字符都是2个字节,那么调用Encoding的GetString方法传递一个5字节的数组返回的字符串只包含2个字符,后面的7个字节返回3个,显然会造成数据损坏.\n\n\n字节块解码首先要获取一个Encoding对象,在调用其`GetDecoder`方法.\n- 返回一个新构造对象的引用,从抽象类`System.Text.Decoder`派生.\n- Decoder提供了2个重要方法\n  - GetChars和GetCharCount.\n  - 它会尽可能多的解码字节数组. 如果剩余一个字节,\n  - **则会保存到Decoder对象内部,下次调用时取出,和新的字节数组合并.**\n  - 这样就能正确解码.\n\n> 从流中读取字节时,Decoder对象的作用很大.\n\n每次调用从Encoder派生的对象都会维护余下数据的状态信息,以便成块的方式对数据进行编码.\n\n## Base-64字符串编码和解码\n\n除了UTF-16和UTF-8,另一个流行方案是将`字节序列`编码成`Base-64字符串`.\n\n例外的是,Base-64编码和解码不是用Encoding派生类型来完成,而是用`Convert`的`静态方法ToBase64String或ToBase64CharArray方法`.\n\n```csharp\n// 获取10个随机生成的字节\nByte[] bytes = new Byte[10];\nnew Random().NextBytes(bytes);\n\n// 将字节解码成Base-64字节串,并显示字符串\nString s = Convert.ToBase64String(bytes);\n// 输出: usLVdVlIgAgfsw==\nConsole.WriteLine(s);\n\n// 将Base-64字符串编码回字节,并显示\nbytes = Convert.FromBase64String(s);\n// 错误用法, 显示的是类名 System.Byte[]\n// Console.WriteLine(bytes.ToString());\n// 输出: BA-C2-D5-75-59-48-80-08-1F-B3\nConsole.WriteLine(BitConverter.ToString(bytes));\n```\n\n\n# 安全字符串\n\nString对象可能包含敏感数据,比如信用卡资料,密码. String对象会在内存中包含一个字符数组. 执行不安全代码或者非托管代码就可以扫描进程的地址空间,找到包含敏感数据的字符串.\n\n即使String对象只用一小段时间就进行垃圾回收, CLR也可能无法立即重用String对象的内存, 致使String的字符长时间保留在进程的内存中. 由于字符串不可变,处理它们的时候,旧的副本会逗留在内存中,最终造成多个不同版本的字符串散布在整个内存空间中.\n\nFCL增加了一个更安全的字符串类:`System.Security.SecureString`\n\n构造`SecureString`对象时,会在内部分配一个非托管内存块,其中包含一个字符数组.\n- 使用非托管内存块是为了避开垃圾回收器的魔爪.\n- 这些字符串是经过加密的,能防范任何恶意的非安全/非托管代码获取机密信息.\n\n`SecureString`类的操作方法:\n1. `AppendChar` 附加\n2. `InsertAt` 插入\n3. `RemoveAt` 删除\n4. `SetAt` 设置一个字符\n\n但是调用这些方法时,方法内部会进行 **解密** ,执行完指定的操作再 **重新加密** 字符串.**这说明有一段时间是处于未加密的状态.** 并且这些操作性能会比较一般.\n\n`SecureString`类实现了`IDisposable`接口. 用简单的方式 **确定性** 地摧毁字符串中的安全内容. 只需要调用`SecureString`的`Dispose`方法. 在方法内部,Dispose会对内存缓冲区的内容进行清零.然后释放缓冲区.\n\nSecureString对象内部有一个SafeBuffer派生的对象负责维护字符串,SafeBuffer类最终从CriticalFinalizerObject类派生,所以在垃圾回收时,内容保证清零,缓冲区被释放.\n\n`SecureString`对象被垃圾回收后,加密的字符串的内容将不再存于内存中.\n\nFCL限制了对`SecureString类`的支持. 只有少数方法才能接受`SecureString参数`.\n\n要使用的话可以创建自己的方法来接收SecureString对象参数,方法内部必须先让SecureString对象创建一个非托管内存缓冲区,它将用于包含解密过的字符,然后才能让该方法使用缓冲区.为了最大程度降低恶意代码获取敏感数据的风险,你的代码在访问解密过的字符串时,时间应尽可能短,结束使用后,代码尽快清零并释放缓冲区. **不要将SecureString内容放到一个String中. String会在堆中保持未加密的状态.** 并且SecureString没有重写ToString方法,就是为了避免这个.\n\n```csharp\npublic static void Main(string[] args)\n{\n    // using代码块之后,SecureString被dispose,内存中无敏感数据\n    using (SecureString ss = new SecureString())\n    {\n        Console.WriteLine(\"请输入密码:\");\n        while (true)\n        {\n            // 参数true意思是,拦截输入,不显示在控制台上\n            ConsoleKeyInfo cki = Console.ReadKey(true);\n            // 回车表示输入完成\n            if (cki.Key == ConsoleKey.Enter) break;\n\n            // 将密码附加到SecureString中\n            ss.AppendChar(cki.KeyChar);\n            Console.Write(\"*\");\n        }\n\n        Console.WriteLine();\n        // 密码已经输入,出于演示的目的显示它\n        DisplaySecureString(ss);\n    }\n}\n\n// 这个代码是unsafe,要访问非托管内存\nprivate unsafe static void DisplaySecureString(SecureString ss)\n{\n    Char* pc = null;\n    try\n    {\n        // 将SecureString解密到一个非托管内存缓冲区\n        pc = (char*) Marshal.SecureStringToCoTaskMemUnicode(ss);\n\n        // 访问包含已经解密SecureString字符的非托管内存缓冲区\n        for (int i = 0; pc[i] != 0; i++)\n        {\n            Console.Write(pc[i]);\n        }\n    }\n    finally\n    {\n        // 确定清零并释放包含已解锁SecureString字符的非托管内存缓冲区\n        if (pc != null)\n        {\n            Marshal.ZeroFreeCoTaskMemUnicode((IntPtr) pc);\n        }\n    }\n}\n```\n\n### 什么情况下用SecureString?\n\n如果以下情况下，`SecureString`非常有用：\n- 您可以逐字符构建它(例如从控制台输入)，或者从非托管API获得它。\n- 您可以通过将它传递给非托管API(SecureStringToBSTR)来使用它。\n**如果您曾经将其转换为托管字符串，则您已经放弃了它的用途。**\n\n我会看到的主要用例是在客户端应用程序中，它要求用户输入高度敏感的代码或密码。用户输入可以逐字符用于构建SecureString，然后将其传递给非托管API，该API对它使用后接收的BSTR进行零。任何后续内存转储都不会包含敏感字符串。\n在服务器应用程序中，很难看出它在哪里有用。\n\n\n## Marshal类提供用于操纵安全字符串的方法\n\n`System.Runtime.InteropServices.Marshal类`提供5个方法来将一个`SecureString`的字符 **解密到非托管** 内存缓冲区. 所有方法都是静态方法.所有方法都接受一个SecureString参数,并返回IntPtr.\n\n每个方法都有一个配对方法来清零并释放内部缓冲区.\n\n![](14字符字符串和文本处理2/Marshal提供操作安全字符串的方法.png)\n","tags":["CLR读书笔记"]},{"title":"14字符字符串和文本处理","url":"/2019/08/12/14字符字符串和文本处理/","content":"\n# 字符,字符串和文本处理\n\nMicorsoft .Net Framework中处理字符和字符串的机制.\n\n- `System.Char`结构以及处理字符的多种方式.\n- `System.String` 处理不可变(immutable)字符串(一旦创建,字符串便不能以任何方式修改).\n- `System.Text.StringBuilder` 高效的动态构造字符串.\n- 如何将对象格式化成字符串, 以及如何使用各种编码方案高效率的持久化或传输字符串.\n- `System.Security.SecureString` 保护密码等敏感字符串.\n\n\n# 字符\n\n在`.Net Framework`中字符总是表示成 **16位的Unicode代码值**.\n\n每个字符都是一个`System.Char`结构(值类型)的实例. 并提供了两个公共只读常量字段:\n- `MinValue` : `'\\0'`\n- `MaxValue` : `'\\ufff'`\n\nUnicode标准定义了控制字符,货币字符,小写字母,大写字母,标点符号,数学符号还有其他符号. `System.Globalization.UnicodeCateGory枚举`定义了这些枚举类型. `Char`的实例调用静态方法`GetUnicodeCategory`方法返回这些枚举中的一个值. 反应这个字符是什么种类的.\n\nChar类型其他几个静态方法,大多数都在内部调用`GetUnicodeCategory`方法,并简单的返回true/false.\n\n> 这些方法要么获取当字符作为参数,要么获取String以及目标字符在这个String中的索引作为参数.\n\n> 关于语言文化culture, 有些方法比如ToLowerInvariant会以忽略语言文化的方式将字符转换为小写.\n> 比如土耳其语中,字母U+0069(小写拉丁字母i)转换成大写是U+0130(大写拉丁字母I上加一点).\n\nChar类型自己的实例方法:\n1. `Equals`: 两个Char实例代表同一个16位Unicode码位的前提下返回true. (ASCII码包含128个码位)\n2. `CompareTo`: 返回两个Char实例忽略语言文化的比较结果.\n3. `ConvertFromUtf32`:  从UTF-32字符生成包含1个或2个UTF-16字符的字符串\n4. `ConvertToUtf32`:  从字符串生成一个UTF-32字符\n5. `ToString`: 返回单个字符的一个String, 相反的是`Parse/TryParse`,它们获取单字符的String,返回该字符的UTF-16码位.\n6. `GetNumericValue`: 返回字符的数值形式.\n\n```csharp\n// 返回字符的数值形式\nDouble d = Char.GetNumericValue('\\u0033'); // \\u0033 是数字3\nConsole.WriteLine(d.ToString()); // 输出: 3\nd = Char.GetNumericValue('\\u00bc'); // \\u00bc 是普通分数的1/4\nConsole.WriteLine(d.ToString()); // 输出: 0.25\nd = Char.GetNumericValue('A');\nConsole.WriteLine(d.ToString()); // 输出: -1\n```\n\n三种技术实现`数值类型`与`Char实例`的互相转换. 按照优先顺序列出:\n\n1. 转型(强制类型转换)\n  1. 比如将Char转换成数值Int32最简单的办法就是强制转换. 这是三种技术中 **效率最高的,因为编译器会生成中间语言IL指令执行转换,而且不必调用方法.** 需要考虑转换时是否使用`checked`还是`unchecked`(对基元类型执行的许多算术运算符都可能造成溢出).\n2. 使用`Convert类型`\n  1. `System.Convert`类型提供了几个静态方法实现Char和数值类型的相互转换,所有这些转换都以`checked`方式执行,发现转换将造成数据丢失就抛出`OverflowException`异常.\n3. 使用`IConvertible接口`\n  1. `Char类型`和FCL中的`所有数值类型`都实现了`IConvertible`接口. 这个接口定义了像ToUInt16和ToChar这样的方法. 这种效率最差,因为值类型调用接口方法会产生装箱, **Char和所有数值类型都是值类型.** 所以许多类型(包括FCL的Char和数值类型)都将IConvertble的方法实现了 **EIMI显式接口方法成员**.  这就意味着为了调用接口的任何方法,都必须将实例显式转型为一个`IConvertible`接口变量, 转换时,大多数时候都可以忽略语言文化,为`IFormatProvider`这个参数传递null值.\n\n```csharp\npublic static void Main()\n{\n    Char  c;\n    Int32 n;\n\n    // 使用C#转型技术实现，强制类型转换\n    // 效率最高,直接编译生成中间语言IL指令执行转换\n    // 需要考虑是否会溢出,对基元类型执行的许多算术运算符都可能造成溢出\n    // 转换时是否使用`checked`还是`unchecked`\n    c = (Char)65;\n    Console.WriteLine(c); // 显示 \"A\"\n    n = (Int32)c;\n    Console.WriteLine(n); // 显示 \"65\"\n    c = unchecked((Char)(65536 + 65));\n    Console.WriteLine(c); // 显示 \"A\"\n\n\n    // 使用Convert进行转换\n    // 这些转换方法都以checked方式执行\n    // 转换出现数据丢失会抛出异常\n    c = Convert.ToChar(65);\n    Console.WriteLine(c); // 显示 \"A\"\n    n = Convert.ToInt32(c);\n    Console.WriteLine(n); // Displays \"65\"\n    // 显示Convert的范围检查\n    try {\n        // 2^16 = 65535\n        c = Convert.ToChar(70000); // 对 16-bits 来说过大,转换丢失精度\n        Console.WriteLine(c);      // !!!不执行\n    }\n    catch (OverflowException) {\n        Console.WriteLine(\"Can't convert 70000 to a Char.\");\n    }\n\n\n    // 使用IConvertible进行转换\n    // 效率最差,因为值类型调用接口方法会产生装箱(Char和所有数值类型都是值类型)\n    // IConvertble的方法实现了 EIMI显式接口方法成员,所以要转换成接口类型变量才能调用接口方法\n    // 传递参数IFormatProvider为null 是忽略语言文化\n    c = ((IConvertible)65).ToChar(null);\n    Console.WriteLine(c); // 显示 \"A\"\n    n = ((IConvertible)c).ToInt32(null);\n    Console.WriteLine(n); // 显示 \"65\"\n}\n```\n\n\n# System.String类型\n\n一个System.String代表一个不可变(immutable)的顺序字符集.\n\nString是引用类型, 对象总是存在于`堆`上,永远不会到线程`栈`.\n\n## 构造字符串\n\nC#将String视为基元类型, 编译器允许在源代码中直接使用字面值(literal)字符串, 编译器将这些字符串放到模块的元数据中,并在运行时加载和引用它们.\n\n1. 不允许用new操作符从字面值字符串构造String对象.\n\n```csharp\n// 不能使用 new + 字面值(literal)字符串 构造.\nString s = new String(\"Error\");// 错误\n\n// 必须使用简化语法\nString s = \"Hi there.\";\n```\n\n![](14字符字符串和文本处理/StringIL代码.png)\n\n用于构造对象新实例的IL指令时`newobj`. 但是上述IL代码中并没出现这个指令, 出现的是`ldstr`(load string)指令, 它使用从元数据获得的字面值literal字符串构造String对象.这证明了CLR实际用一种特殊的方式构造字面值String对象.\n\n如果使用`不安全的unsafe代码`,可以从一个`Char*`或`Sbyte*`构造一个String. 这时要使用到new操作符,调用对应参数的构造器.\n\nC#提供了一些特殊语法来帮助开发人员在源代码中输入字面值字符串. 对于`换行符`,`回车符`和`退格符`这样的特殊字符,采用如下转义机制:\n\n```csharp\n// 这是硬编码了回车符和换行符,一般不建议这样做\n// 不同底层平台使用的不一定相同\n// \\r 回车符 \\n 换行符\nString s = \"Hi\\r\\nthere.\";\n\n// 正确定义上述字符串的方式\n// Environment.NewLines属性对平台敏感, 会根据平台返回恰当的字符串\nString s = \"Hi\" + Environment.NewLine + \"there.\";\n```\n\n使用`+操作符`可以将几个字符串连接成一个, 如果都是字面值,C#编译器在编译时就能连接它们,最终将一整个字符串放到模块的元数据中, 如果存在非字面值,则会在运行时进行.\n\n**运行时连接不建议使用+操作符, 这样会在堆上创建多个字符串对象,而堆是需要垃圾回收的,对性能有影响. 应该使用StringBuilder类型.**\n\n## 逐字字符串声明(@ 操作符)\n\n采用这种方法,引号之间的所有字符都会视为字符串的一部分, 也就是不转义`\\`,视为字符串, 通常用于指定文件和目录的路径,或者与正则表达式配合使用.\n\n```csharp\n// 不使用@逐字字符串声明方式\nString s = \"C:\\\\Window\\\\System32\\\\Notepad.exe\";\n// 使用@方式\nString s = @\"C:\\Window\\System32\\Notepad.exe\";\n```\n\n两种写法在程序集的元数据中生成完全一样的字符串,但是后者可读性更好.\n\n## 字符串是不可变的\n\nString对象最重要的一点就是不可变,并且只能是密封类. 一经创建便不能更改(变长,变短,修改任何字符).\n\n好处有:\n1. 在字符串上执行各种操作,而不实际地更改字符串. 返回修改后的新建的字符串地址.\n2. 在操作字符串时不会发生线程同步问题.\n  1. `字符串留用`:CLR通过一个String对象共享多个完全一致的String内容,减少系统中的字符串数量,从而节省内存.\n\n\n## 比较字符串\n\n判断相等性或者排序. 建议调用String类定义的一下方法:\n\n```csharp\n// 建议使用以下版本, 不建议使用没有列出的重载版本\nbool Equals (string value, StringComparison comparisonType);\nstatic bool Equals (string a, string b, StringComparison comparisonType);\n\nstatic int Compare (string strA, string strB, StringComparison comparisonType);\nstatic int Compare (String strA, String strB, bool ignoreCase, CultureInfo culture);\nstatic int Compare (string strA, string strB, CultureInfo culture, CompareOptions options);\nstatic int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);\nstatic int Compare (string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);\nstatic int Compare (String strA, int indexA, String strB, int indexB, int length, bool ignoreCase, CultureInfo culture);\n\n```\n\n **比较时应该区分大小写, 原因是两个大小写不同的字符串会被视为相等.**\n\n**建议避免使用** String实现IComparable接口的`CompareTo方法`, `CompareOrdinal方法`, `==操作符`, `!=操作符`. 这是因为调用者不显式指出以什么方式执行字符串比较, 比如`CompareTo方法`默认执行语言文化敏感的比较, 而`Equals方法`执行 **不考虑语言文化的序号(ordinal)比较**.\n\n> Ordinal: 序号比较, 就是不考虑语言文化信息, 只比较字符串中每个Char的Unicode码位.\n\n\n- `comparisonType`参数,要求获取`StringComparison`枚举定义的某个值:\n\n```csharp\n// 要求传递显式传递语言文化\npublic enum StringComparison\n{\n    // 为了向用户显式一些字符串,要以语言文化正确的方式,就应该使用如下两个,\n    //使用区域敏感排序规则和当前区域比较字符串。\n    CurrentCulture,\n    //使用区域敏感排序规则、当前区域来比较字符串，同时忽略被比较字符串的大小写。\n    CurrentCultureIgnoreCase,\n    // ----------------------\n\n    // 平时不建议使用,所花的时间远超Ordinal\n    //使用区域敏感排序规则和固定区域比较字符串。\n    InvariantCulture,//固定语言文化  --- 其实就是不使用任何具体的语言文化.\n    //使用区域敏感排序规则、固定区域来比较字符串，同时忽略被比较字符串的大小写。\n    InvariantCultureIgnoreCase,\n    // ----------------------\n\n\n    // 以下选项会忽略语言文化(常用)\n    // 特别是在程序内部使用的字符串, 比如文件名,URL,注册表值,环境变量,反射,XML标记,特性等.\n    // 忽略语言文化是字符串比较最快的方式\n    //使用序号排序规则比较字符串。\n    Ordinal,\n    //使用序号排序规则并忽略被比较字符串的大小写，对字符串进行比较。\n    OrdinalIgnoreCase\n}\n```\n\n要在比较前更改字符串中的字符的大小写, 应该使用:\n1. `String.ToUpperInvariant`, **强烈建议使用此方法对字符串进行正规化(normalizing),不使用转小写**\n2. `String.ToLowerInvariant`, 建议使用.\n\n**因为Microsoft对执行`大写比较`的代码进行了优化.** , 事实上,执行不区分大小写的比较之前, FCL会自动将字符串`正规化为大写形式`.\n\n之所以使用`ToUpperInvariant`和`ToLowerInvariant`,是因为String类没有提供`ToUpperOrdinal`和`ToLowerDordinal`方法, 不使用以下2个方法是因为以下方法`对语言文化敏感`.\n\n3. `String.ToUpper` (不建议使用,因为对语言文化敏感)\n4. `String.ToLower` (不建议使用,因为对语言文化敏感)\n\n\n- `CompareOptions`参数。这个参数要获取有`CompareOptions`枚举类型定义的一个值：\n\n```csharp\npublic enum CompareOptions\n{\n    None = 0,\n\n    //指示字符串比较必须忽略大小写。\n    IgnoreCase = 1,\n\n    //指示字符串比较必须忽略不占空间的组合字符，比如音调符号。\n    IgnoreNonSpace = 2,\n\n    //指示字符串比较必须忽略符号，如空白字符、标点符号、货币符号、百分号、数学符号、“&”符等等\n    IgnoreSymbols = 4,\n\n    //指示字符串比较必须忽略 Kana 类型\n    IgnoreKanaType = 8,\n\n    //指示字符串比较必须忽略字符宽度\n    IgnoreWidth = 16,\n\n    //指示字符串比较必须使用字符串排序算法。\n    StringSort = 0x20000000,\n\n    //指示必须使用字符串的连续 Unicode UTF-16 编码值进行字符串比较（使用代码单元进行代码单元比较），这样可以提高比较速度，但不能区分区域性\n    Ordinal = 0x40000000,\n\n    //字符串比较必须忽略大小写，然后执行序号比较。\n    OrdinalIgnoreCase = 0x10000000\n}\n```\n\n## 执行语言文化正确的比较\n\n.Net Framework 使用 System.Globalization.CultureInfo 类型表示一个\"语言/国家\".\n\n- en-US 美国英语\n- en-AU 澳大利亚英语\n- de-DE 德国德语\n\n在CLR中,每个线程都关联了两个特殊属性, 每个属性都应用一个CultureInfo对象:\n- `CurrentUICulture`: 该属性获取要向用户显示的资源. 在GUI或web窗体应用程序中特别有用.\n- `CurrentCulture`:不适合CurrentUICulture属性的场合就用该属性.通过控制面板的区域和语言对话框来修改这个值.\n\n![](14字符字符串和文本处理/设置语言文化.png)\n\n如果不是序号比较(不考虑语言文化),就会进行`字符展开`,也就是将一个字符展开成忽视语言文化的多个字符. 这样比较字符串就\n\n![](14字符字符串和文本处理/展开字符.png)\n\n```csharp\nString s1 = \"Strasse\";\nString s2 = \"Straße\"; // ß 等同于ss\n\n// 忽略语言文化\nConsole.WriteLine(String.Compare(s1,s2,StringComparison.Ordinal)); // 两个字符串不同 输出 -108\n\nCultureInfo ci = new CultureInfo(\"de-DE\");\n// 设置德语文化\nConsole.WriteLine(String.Compare(s1,s2,true,ci)); // 两个字符串相同 输出 0\n```\n\n> 关于法语,日语,一些比较参考书中代码. P289页\n\n> 源代码不要用ANSI格式保存,否则日语字符会丢失,要保存的话选择另存为-并选择Unicode(UTF-8带签名)-代码页65001 , 这样C#编译器就能成功解析这个源文件代码了.\n\n\n## 字符串留用\n\n检查字符串相等性的操作,也可能是损害性能的操作,\n\n- 执行`序号(ordinal 语言文化不敏感)相等性检查`时\n  - CLR快速检测两个字符串是否包含相同数量的字符\n    - 不相同则肯定不等.\n    - 若相同,CLR必须比较每个单独的字符才能最终确认\n- 执行`语言文化敏感的比较`时:\n  - CLR必须比较所有单独的字符(因为两个字符串长度不同也可能相等)\n\n**在内存中复制一个字符串的多个实例纯属浪费. 浪费内存,只需要保留一个实例,将引用字符串的所有变量执行单独一个字符串对象.**\n\n如果应用程序经常对字符串进行区分大小写的序号比较,或者事先知道许多字符串对象都有相同的值, 既可以用CLR的`字符串留用(intering)`机制来显著提升性能.\n\n- CLR初始化会创建一个`内部哈希表`.key:字符串  value:堆中对String对象的引用\n- String提供了两个方法,访问这个内部哈希表\n  - `pulic static String Intern(String str);`  \n    - 在内部哈希表中检查是否有匹配的,\n    - 如果存在,就返回对现有String对象的引用\n    - 如果不存在,**就创建字符串副本,返回副本的引用**\n  - `pulic static String IsInterned(String str);`\n    - 和上述方法一样,不同的是如果没有找到匹配的字符串\n    - **就会返回`null`,不会将字符串添加到哈希表中.**\n\n垃圾回收器不能回收被`内部哈希表`所引用的字符串. 除非卸载AppDomain或进程终止.否则内部哈希表引用的String对象不能被释放.\n\n(**不要依赖这个行为**)CLR在程序集加载时,默认留用程序集的元数据中描述的所有字面值字符串.\n\n1. CLR的4.5版本上,会忽略编译器的CompilationRelaxations和NoStirngInterning特性和标志.\n2. 以至于CLR会对字面值字符创进行留用.(事实上用NGen.exe编译,CLR4.5版本确实会使用这些特性)\n3. **所以不要依赖这个行为.**\n\n```csharp\n// 不要以字符留用为前提来写代码\n// 即使指定了特性和标志,也可能进行字段留用,\nString s1 = \"Hello\";\nString s2 = \"Hello\";\n// 没进行留用,则2个字符串是不同的堆对象\nConsole.WriteLine(Object.ReferenceEquals(s1,s2)); // 一些特定版本,不进行字段留用,这边就会返回false\n\ns1 = String.Intern(\"Hello\");\ns2 = String.Intern(\"Hello\");\n// 显式调用字段留用之后, 以下输出就保证为true\nConsole.WriteLine(Object.ReferenceEquals(s1,s2));// 显式留用此字符串\n```\n\n## 字符串留用提升性能并减少内存消耗\n\n```csharp\n// 方式一:\n// 不利用字符串留用, 使用Equals忽略语言文化进行比较\n// 将word和String数组中的字符串比较\nprivate static Int32 NumTimesWordApperasEquals(String word, String[] wordlist)\n{\n    Int32 count = 0;\n\n    for (int wordnum = 0; wordnum < wordlist.Length; wordnum++)\n    {\n        // Ordinal序号比较(忽略语言文化)\n        // 比较字符串内的各个单独字符,这个比较可能很慢\n        // wordlist可能含有多个元素引用了含有相同内容的不同String对象,并且不会被垃圾回收掉重复的\n        if (word.Equals(wordlist[wordnum], StringComparison.Ordinal))\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\n// 方式二:\n// 利用字符串留用的机制,使用ReferenceEquals比较\n// 这个方法假定wordlist中的所有数组元素都引用已留用的字符串\nprivate static Int32 NumTimesWordApperasIntern(String word, String[] wordlist)\n{\n    word = String.Intern(word);\n    Int32 count = 0;\n\n    for (int wordnum = 0; wordnum < wordlist.Length; wordnum++)\n    {\n        if (Object.ReferenceEquals(word,wordlist[wordnum]))\n        {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n方式二假定wordlist包含对已留用字符串的引用. 如果字符串出现多次,堆中只有一个String对象. 比较指针就能知道指定单词是否在数组中.\n\n方式二的前提,是对需要留用的字符串进行留用(花费一些时间性能),应用程序总体性能是可能变慢的. 在多次要调用比较wordlist的情况下, **字符串留用是很有用的,但是使用需要谨慎. 这也是C#编译器默认不想启用字符串留用的原因.(虽然编译器应用特性并设置了不进行字符串留用的标志,但是CLR选择忽略这些设置你也没办法.)**\n\n## 字符串池\n\n编译源代码时, 编译器会处理每个字面值字符串, 并在托管模块的元数据中嵌入.\n\n如果同一个字符串在源代码中多次出现,都嵌入元数据会使生成的文件无谓地增大.\n\n为了解决这个,C#编译器只在模块的元数据中只将字符串写入一次,引用该字符串的代码都被修改成引用元数据中的同一个字符串. **编译器能将单个字符的多个实例合并成一个实例,能显著减少模块的大小.**\n\n## 检查字符串中的字符和文本元素\n\n检查字符串中的字符,String类型为此提供了几个属性和方法, 包括Length,Chars(有参属性,C#索引器),IndexOf,Contains,LastIndexOf...\n\n文本元素(抽象字符): 有的抽象Unicode字符是两个码值的组合.\n\n有的Unicode文本元素要求用两个16位值表示,\n- 第一个称为`高位代理项(high surrogate)` U+D800到U+DBFF之间\n- 第二个称为`低位代理项(low surrogate)` U+DC00到U+DFFF之间\n\n**有了代理项,Unicode就能表示100万个以上不同的字符.**\n\n为了正确处理文本元素,应当使用`System.Globalization,StringInfo`类型,\n- 向此类的构造器传递一个字符串\n- 查询`StringInfo`的`LengthTextElements`属性来了解有多少个文本元素.\n- 接着使用`StringInfo`的`SubstringByTextElements`方法来提取所有的文本元素.\n\n`StringInfo`的静态方法`GetTextElementEnumerator`返回`TextElementEnumerator`对象,允许枚举字符串中包含的所有抽象Unicode字符.\n\n`StringInfo`的静态方法`ParseCombiningCharacers`来返回一个Int32数组.从数组长度就能知道字符串包含多少个文本元素,每个数组元素都是一个文本元素的起始码值索引.\n\n\n![](14字符字符串和文本处理/StringInfo类的使用方式.png)\n\n![](14字符字符串和文本处理/StringInfo类例子输出.png)\n\n## 其他字符串操作\n\n![](14字符字符串和文本处理/复制字符串的方法.png)\n\nClone返回同一个对象(this)的引用.\n\nCopy返回指定字符串的新副本.引用(指针不同).\n\nSubstring返回代表原始字符串一部分的新字符串.\n\nToString返回对同一个对象(this)的引用.\n\n因为字符串你是不可变的,所以返回的都是新字符串的引用.(除非使用不安全代码)\n\n# 高效率构造字符串\n\n可将`StringBuilder`看成是创建String对象的特殊构造器.\n\n从逻辑上看, `StringBuilder对象`包含一个字段, 该字段引用了由`Char结构`构成的数组.可利用`StringBuilder`的各个成员来操纵该字符数组, 高效率地缩短字符串或更改字符串中的字符.\n\n如果字符串变大了,超过了事先分配的 **数组大小** , StringBuilder会自动分配一个新的,更大的数组, 复制字符,并开始使用新数组. 前一个数组被垃圾回收.\n\n用StringBuilder构造好字符串后, 调用ToString方法既可以将StringBuilder的 **字符数组** 转换成String. 这样会在堆上新建String对象,堆上还有StringBuilder中的字符数组,可以继续处理StringBuilder种的字符数组,再次调用ToString把它转换成另一个String对象.\n\n## 构造StringBuilder对象\n\n大多数语言都不将StringBuilder视为基元类型. 要像构造其他任何非基元类型那样构造StringBuilder对象.\n\nStringBuilder提供了许多构造器. 一些关键概念如下:\n1. **最大容量**\n  1. 一个Int32值,指定了能放到字符串中的最大字符数,默认是Int32.MaxValue(约20亿). 一般不用更改这个值. 有时需要指定较小的最大容量以确保不会创建超出特定长度的字符串,**构造好之后就固定下来了,不能再变.**\n2. **容量**\n  1. 一个Int32值, 指定了StringBuilder维护的字符数组的长度,默认16, 如果事先知道要放入多少,则应该在构造StringBuilder对象时自己设置容量.\n  2. 在向字符数组追加字符时, StringBuilder会检测数组会不会超过设定的容量.如果会,StringBuilder会自动 **倍增容量字段(翻倍).**  旧的数组字符数组复制到新的数组中,随后`原始数组可以被垃圾回收`. **数组动态扩展会损害性能,可以在构造时就设置一个合适的初始容量.**\n3. **字符数组**\n  1. 一个由Char结构构成的数组, 负责维护字符串的字符内容.\n  2. 可以用`StringBuilder的Length属性`来获取已经使用的字符数.\n  3. 在构造时传递一个String来初始化数组.\n  4. 不传递任何字符串,数组中就不包含任何字符,Length为0.\n\n\n## StringBuilder成员\n\nStringBuilder代表可变字符串, 大多数成员都能更改字符数组的内容, 同时不会造成在托管堆上分配新对象.\n\n**分配新对象** 只会在以下两种情况:\n1. 动态构造字符串,其长度超过了设置的容量.\n2. 调用StringBuilder的ToString方法.\n\n![](14字符字符串和文本处理/StringBuilder成员1.png)\n\n![](14字符字符串和文本处理/StringBuilder成员2.png)\n\n\n```csharp\n// 有参属性,索引器\n// IL代码 StringBuilder::get_Chars(int32)\n[IndexerName(\"Chars\")] // 不加这个,默认是 get_Item\npublic char this[int index]\n\n// 用法如同使用数组\nStringBuilder sb = new StringBuilder(\"1234567\");\nConsole.WriteLine(sb[1]);\n```\n\n- `Length` 属性设为0等同于内容重置为空字符串, 还等同于Clear方法.\n- `Append` 在字符数组 **后追加** 一个对象,有必要会进行扩充.\n- `Insert` 在字符数组 **中插入** 一个对象,有必要会进行扩充.\n- `AppendFormat` 在字符数组末尾追加0个或多个对象.\n- `AppendLine` 追加一行中止符或者一个带有中止符的字符串.\n\n>  ’\\0’字符在C#中意味着字符串结束, 后面的字符不显示. `string.Replace('\\0','*')`\n\n- `Equals` **两个StringBuilder对象具有相同最大容量,字符数组容量和字符内存才返回true.**\n\n大多数方法返回的都是对同一个StringBuilder对象的引用.\n\nString类提供的一些方法,StringBuilder类并没有提供对应的方法.\n- ToLower\n- ToUpper\n- EndsWith\n- PadLeft\n- PadRight\n- Trim\n\nStringBuilder提供了更全面的Replace方法,允许替换一部分字符串而不是整个.\n\n```csharp\n\n// 因为StringBuilder提供转换大写的方法,需要用String的方法来中转一下\nStringBuilder sb = new StringBuilder();\n\nsb.AppendFormat(\"Jeffrey Richter\").Replace(\" \", \"-\");\n\n// 推荐使用忽视语言文化的转换\n// 将StringBuilder转成string以便将所有字符串转换成大写\nString s = sb.ToString().ToUpperInvariant();\n\n// 清空StringBuilder,分配新的char数组\nsb.Length = 0;\n\n// 将全部大写的String加载到StringBuilder中执行其他操作\nsb.Append(s).Insert(8, \"Marc-\");\n\n// 再转回String ,向用户显式\ns = sb.ToString();\n\n// 输出: JEFFREY-Marc-RICHTER\nConsole.WriteLine(s);\n```\n\n因为StringBuilder提供转换大写的方法,需要用String的方法来中转一下.\n","tags":["CLR读书笔记"]},{"title":"13接口","url":"/2019/08/08/13接口/","content":"\n# 接口\n\nCLR通过`接口`提供了'缩水版'的多继承.\n\n**`接口`是引用类型**. 实际是对一组方法签名进行统一命名. 这些方法不提供任何实现.类通过指定接口名称来继承接口. **必须显式实现接口方法.**\n\n凡是能使用`具体名称接口类型的实例`的地方, 都能使用`实现了接口的类型的实例`.\n\n# 定义接口\n\n接口对一组方法签名进行了统一命名.\n\n接口能定义:\n- 方法\n- 事件\n- 无参属性\n- 有参属性(索引器)\n\n以上东西本质上都是方法,只是语法上的简化.\n\n但是接口不能定义:\n- 任何构造器方法\n- 任何实例字段\n- 静态方法\n- 静态字段\n- 常量\n- 静态构造器\n\n接口定义可以从另一个或多个接口\"继承\",但这不是严格意义上的继承, 是将其他接口的协定包括到新接口中.\n\n```csharp\n// 接口\"继承\"接口\n// 1. 继承接口ICollection<T>的任何类必须实现 ICollection<T> ,IEnumerable<T>,IEnumerable这3个接口所定义的方法\n// 2. 任何代码在引用对象时,如果实现了ICollection<T>接口,可以认为也实现了IEnumerable<T>,IEnumerable接口\npublic interface ICollection<T> : IEnumerable<T>,IEnumerable\n{...}\n```\n\n\n# 继承接口\n\nC#编译器要求:实现接口的方法标记为`public`\n\nCLR要求:将接口方法标记`virtual`\n- 如果显式标记为`virtual`,编译器就会将该方法标记为`virtual`(保持它的非密封状态),使派生类能重写它.\n- 如果不显式标记为`virtual`,编译器就会标记为`virtual`和`sealed`, 这会阻止派生类重写接口方法.\n\n派生类不能重写`sealed`的接口方法. 但派生类可以重新继承同一个接口,并为接口方法提供自己的实现.\n\n```csharp\ninternal static class InterfaceReimplementation\n{\n    public static void Go()\n    {\n        /************************* 第一个例子 *************************/\n        Base b = new Base();\n        // 结果显示: \"Base's Dispose\"\n        b.Dispose();\n\n        // 接口类型的变量  IDisposable b; 调用接口方法\n        // 用b的对象的类型来调用Dispose，结果显示: \"Base's Dispose\"\n        ((IDisposable)b).Dispose();\n\n        /************************* 第二个例子 ************************/\n        Derived d = new Derived();\n        // 结果显示: \"Derived's Dispose\"\n        d.Dispose();\n\n        // 用d的对象的类型来调用Dispose，结果显示: \"Derived's Dispose\"\n        ((IDisposable)d).Dispose();\n\n        /************************* 第三个例子 *************************/\n        b = new Derived();\n        // 用b的类型来调用Dispose，结果显示: \"Base's Dispose\"\n        // 因为子类是自己new覆盖父类的方法,并不会修改父类方法的功能\n        // 所以用Base类型的对象去调用dispose会输出Base类的方法\n        b.Dispose();\n        // 用b的对象的类型来调用Dispose，显示: \"Derived's Dispose\"\n        // 转成接口类型后, 基类的方法被隐藏,只有子类的方法\n        // 只要子类实现了接口方法,就会调用实际类型的实现\n        ((IDisposable)b).Dispose();\n\n        /************************* new和override **********************/\n\n        // Base b;\n        b.Test();\n        // 如果 子类实现Test 用new关键字, 则输出: Base Test!\n        // 如果 子类重写Test 用override关键字, 则输出: Dervied Test!\n\n    }\n}\n// 这个类型派生自 Object 并且实现了 IDisposable\ninternal class Base : IDisposable\n{\n    // 这个方法是隐式密封的，不能被重写\n    // 没标记virtual实现接口方法,是不能被子类重写的\n    public void Dispose()\n    {\n        Console.WriteLine(\"Base's Dispose\");\n    }\n    // 基类的方法\n    public virtual void Test()\n    {\n        Console.WriteLine(\"Base Test!\");\n    }\n}\n// 这个类继承了Base并且实现了IDisposable接口\n// 派生类可以重新继承同一个接口,并为接口方法提供自己的实现.  \n// new 是覆盖,不会改变父类方法的功能\ninternal class Derived : Base, IDisposable\n{\n    // 这个方法不能重写 Base's Dispose.\n    // 'new' 关键字表明重新实现了IDisposable的Dispose\n    new public void Dispose()\n    {\n        Console.WriteLine(\"Derived's Dispose\");\n\n        // 注意: 下一行展示了如何让调用基类的方法\n        // base.Dispose();\n    }\n\n    public new void Test()\n    {\n        Console.WriteLine(\"Dervied Test!\");\n    }\n}\n```\n\n> override: 重写:会重写基类的方法,如果子类转基类,用基类对象去调用也会执行子类的实现\n> new: 覆盖(隐藏):不会改变父类方法的功能,并隐藏基类的方法,如果子类转基类,用基类对象去调用会执行基类的实现.(不会判断实际的类型,只会从当前对象类型去调用)\n\n**转型`接口变量`调用接口方法和用`类的实例`调用接口方法是不同的.**\n\n1. 基类继承接口, 子类如果要实现接口方法需要加`new`.\n2. 用`类的实例`去调用(new)接口方法时,会执行`当前类型`的接口方法,不会去判断`实际类型`.\n3. 转成`接口变量`,去调用接口方法,会根据`实际类型`,如果`实际类型(子类)实现了接口方法`,就会`隐藏基类实现的接口方法`.调用`实际(子类)类型`的实现.\n\n\n# 关于调用接口方法的更多探讨\n\nCLR允许定义`接口类型`的`字段`,`参数`或`局部变量`.\n\n使用接口类型的变量可以调用该接口定义的方法.并且还可以调用Object定义的方法.\n\n但是 **不能** 用接口变量调用类本身定义的公共方法.\n\n> 值类型可实现0个或多个接口,但是值类型的实例转换为接口类型时必须装箱.因为接口变量是引用.\n\n\n# 隐式和显式接口方法实现(幕后发生的事情)\n\n\n  类型加载到CLR中时，会为该类型创建并初始化一个方法表。在这个方法表中，类型引入的每个新方法都有对应的记录项；另外，还为该类型继承的所有虚方法添加了记录项目。继承的虚方法既有继承层次结构中的各个基类型定义的，也有接口类型定义的。\n\n```csharp\ninterter sealed class SimpleType : IDisposable {\n    public void Dispose() { console.WriteLine(\"Dispose\"); }\n}\n```\n\n**接口方法签名和新增方法签名(相同的参数和返回类型)一致, 如果标记为`virtual`,C#编译器仍然会认为该方法匹配接口方法.**\n\nC#编译器将新方法和接口方法匹配起来之后,会生成元数据,指明SimpleType类型的方法表中的两个记录项应该引用同一个实现.\n\n下面的代码演示了如果调用类的`公共Dispose方法`以及如何调用`IDisposable的Dispose方法`在类中的实现：\n\n```csharp\npublic static void Main()\n{\n    SimpleType st = new SimpleType();\n\n    // 调用公共的 Dispose 方法实现\n    st.Dispose();\n\n    // 调用 IDisposable 的 Dispose 方法实现\n    IDisposable d = st;\n    d.Dispose();\n}\n// 输出:\n// Dispose\n// Dispose\n```\n\n- 在第一个dispose方法调用中，调用的是SimpleType定义的dispose方法。\n- 然后定义IDisposable接口类型的变量d，它引用SimpleType对象。\n- 调用SimpleType时，调用的是IDisposable接口的dispose方法。\n- 由于`公共dispose方法`是`IDisposable的Dispose方法`的实现，所以会执行相同的代码。\n\n\n为了看出区别\n```csharp\npublic sealed class SimpleType : IDisposable\n{\n     public void Dispose() { Console.WriteLine(\"public Dispose\"); }\n     // 显示接口方法实现 EIMI\n     // 不允许显示指定可访问性,会正在编译时自动设为private,防止其他类型直接调用\n     // 派生类也不可以调用\n     // 只能由接口类型变量才能调用\n     void IDisposable.Dispose() { Console.WriteLine(\"IDisposable Dispose\"); }\n}\n\n// 这样一下代码就会输出\nst.Dispose();\nIDisposable d = st;\nd.Dispose();\n// public Dispose\n// IDisposable Dispose\n```\n\n**显示接口方法实现EIMI**,\n1. 不能显式指定可访问性, 编译时生成private\n2. 派生类也无法调用\n3. 只有接口类型变量才能调用接口方法\n4. 不能标记virtual,所以不能被重写(这是因为EIMI方法并不是真的是类型的对象模型的一部分),只是将接口和类型连接起来,同时避免公开行为/方法.\n\n\n\n# 泛型接口\n\n泛型接口提供了出色的编译时安全性. 非泛型接口是Object参数,值类型会产生装箱,并且缺少类型安全.\n\n```csharp\nprivate static void SomeMethod1()\n{\n    Int32 x = 1, y = 2;\n    IComparable c = x;\n\n    // CompareTo 期望接口一个 Object 类型; 传递 y (一个 Int32 类型) 允许\n    c.CompareTo(y);     // y在这里装箱\n\n    // CompareTo期望接口一个 Object 类型; 传递 \"2\" (一个 String 类型) 允许\n    // 但运行是抛出 ArgumentException 异常   \n    c.CompareTo(\"2\");\n}\n\n// 修改后\n\nprivate static void SomeMethod2()\n{\n    Int32 x = 1, y = 2;\n    IComparable<Int32> c = x;\n\n    // CompareTo 期望接口一个 Int32 类型; 传递 y (一个 Int32 类型) 允许\n    c.CompareTo(y);     // y在这里不装箱\n\n    // CompareTo 期望接口一个 Int32 类型; 传递 \"2\" (一个 String 类型) 编译不通过\n    // 指出 String 不能被隐式转型为 Int32\n    // c.CompareTo(\"2\");\n}\n```\n\nFCL中有些泛型接口并未实现,而且继承了非泛型接口,如果接口的任何翻翻获取或返回Object,就会失去编译时的类型安全性,而且值类型将发生装箱, 所以利用显示接口方法EIMI实现来增强编译时类型安全性.\n\n泛型接口的好处还有,类可以实现同一个接口若干次,只要每次使用的类型参数不同.\n\n```csharp\npublic static void Go()\n{\n    Number n = new Number();\n\n    // n 与 一个 Int32类型 5 作比较\n    IComparable<Int32> cInt32 = n;\n    Int32 result = cInt32.CompareTo(5);\n\n    //  n 与一个 String类型 \"5\" 作比较\n    IComparable<String> cString = n;\n    result = cString.CompareTo(\"5\");\n}\n\n// 该类实现了 IComparable<T> 接口两次\npublic sealed class Number : IComparable<Int32>, IComparable<String>\n{\n    private Int32 m_val = 5;\n\n    // 该方法实现了 IComparable<Int32>’s CompareTo\n    public Int32 CompareTo(Int32 n)\n    {\n        return m_val.CompareTo(n);\n    }\n\n    // 该方法实现了 IComparable<String>’s CompareTo\n    public Int32 CompareTo(String s)\n    {\n        return m_val.CompareTo(Int32.Parse(s));\n    }\n}\n```\n\n泛型接口还可以标记为`逆变in`和`协变out`,为泛型接口使用提供了更大的灵活性.\n\n> 逆变in: 允许传入参数使用T的基类\n> 协变out:允许输出类型使用T的派生类\n> 逆变参数基类,协变返回子类\n>`Object Method(FileStream fs); // 允许协变和逆变的转换`\n>`String Method2(Stream s); `\n\n# 泛型和接口约束\n\n泛型类型参数约束为多个接口,这样传递的参数必须要实现全部接口约束.\n\n```csharp\npublic sealed class SomeType\n{\n    private static void Test()\n    {\n        Int32 x = 5;\n        Guid g = new Guid();\n        // 对M的调用能通过编译，因为Int32实现了IComparable 和 IConvertible\n        // 不会发生装箱\n        M(x);\n        // 对M的调用能不通过编译，因为Guid实现了IComparable，但没实现了 IConvertible\n        // M(g);\n    }\n\n    // M类型参数T被约束为需要支持同时实现IComparable 和 IConvertible interfaces接口的类型\n    private static Int32 M<T>(T t) where T : IComparable, IConvertible\n    {\n        // ...\n        return 0;\n    }\n\n    // 如果这样声明,x传给M就必须装箱, 接口是引用类型.\n    private static Int32 M<IComparable t>{..}\n}\n```\n\n这很有用,, 如果参数的类型是接口, 那么实参可以是任意类类型,只要该类实现了此接口.\n\n使用多个接口约束,实际上是表示向方法传递的实参必须实现多个接口.\n\n**接口约束还可以减少传递值类型实例时的装箱**,`M(x);`上述代码向M方法传递了x（值类型int实例）。x传给M方法时不会发生装箱。M内部的代码调用t.CompareTo(..),这个调用本身也不会引发装箱,但传给CompareTo的实参可能发生装箱.\n\n**C#编译器为接口约束生成特殊的IL指令,导致直接在值类型上调用接口方法而不装箱,不用接口约束就没办法生成特殊指令. 在值类型调用接口时总是装箱,例外是这个值类型实现了一个接口方法.在值类型的实例上调用这个方法不会造成值类型的实例装箱.**\n\n\n# 实现多个具有相同方法名和签名的接口\n\n\n要定义一个实现了这两个接口的类型，必须使用`显示接口方法实现`来实现这个类型的成员.\n\n```csharp\npublic interface IWindow\n{\n     Object GetMenu();\n}\npublic interface IRestaurant\n{\n     Object GetMenu();\n}\n\n// 这个类型派生自 System.Object and\n// 并不实现 IWindow 和 IRestaurant 接口.\npublic class MarioPizzeria : IWindow, IRestaurant\n{\n    // 这是IWindow 的 GetMenu 方法.\n    Object IWindow.GetMenu()\n    {\n        // ...\n        return null;\n    }\n\n    // 这是 IRestaurant 的 GetMenu 方法.\n    Object IRestaurant.GetMenu()\n    {\n        // ...\n        return null;\n    }\n\n    // 这个GetMenu方法是可选的，与接口无关\n    public Object GetMenu()\n    {\n        // ...\n        return null;\n    }\n}\n```\n\n这个类要实现多个接口的GetMenu方法,所以要告诉编译器每个GetMenu对应的是哪个接口的实现.**在使用使用必须将对象转换为具体的接口才能调用所需的方法.**\n\n```csharp\npublic static void Go()\n{\n    MarioPizzeria mp = new MarioPizzeria();\n\n    // 这行调用 MarioPizzeria 的公共 GetMenu 方法\n    mp.GetMenu();\n\n    // 这行调用 MarioPizzeria 的 IWindow.GetMenu 方法\n    IWindow window = mp;\n    window.GetMenu();\n\n    // 这行调用 MarioPizzeria 的 IRestaurant.GetMenu 方法\n    IRestaurant restaurant = mp;\n    restaurant.GetMenu();\n}\n```\n\n# 用显式接口方法实现EIMI来增强编译时类型安全性\n\n因为有些接口不存在泛型版本,或者泛型版本是继承非泛型版本,所以仍需实现非泛型接口.\n\n非泛型接口接收任何System.Object类型的参数或返回System.Object类型的值,这样就会失去编译时的类型安全性,装箱也会发生.\n\n```csharp\n// 这个接口定义了一个方法，该方法接受一个System.Object类型的参数。\n// 可像下面一样实现该接口的一个类型：\npublic interface IComparable {\n      Int32 CompareTo(Objetc other);\n }\n\n// 值类型实现接口\ninternal struct SomeValueType : IComparable\n{\n    private Int32 m_x;\n    public SomeValueType(Int32 x) { m_x = x; }\n    public Int32 CompareTo(Object other)\n    {\n        return (m_x - ((SomeValueType)other).m_x);\n    }\n}\n\n\npublic static void Go()\n{\n   SomeValueType v = new SomeValueType(0);\n   Object o = new Object();\n   Int32 n = v.CompareTo(v);  // 出现装箱,因为参数是Object,V是值类型\n   n = v.CompareTo(o);        // 能通过编译,会InvaidCastException抛出转换异常\n}\n```\n\n为了解决上述代码的装箱问题和类型安全性问题(编译期就能报错,而不是运行时)\n\n```csharp\ninternal struct SomeValueType : IComparable\n{\n     private Int32 m_x;\n     public SomeValueType(Int32 x) { m_x = x; }\n     // 改动: 参数类型换成了SomeValueType,这样就不会发生值类型转Object时发生装箱操作\n     public Int32 CompareTo(SomeValueType other)\n     {\n         // 也不需要强制类型转换的操作\n         return (m_x - other.m_x);\n     }\n     // 因为修改了上面的CompareTo方法, 所以还需要实现接口的公共CompareTo方法来满足接口协定,这就是IComparable.CompareTo方法的作用\n     // 注意: 这个是显示实现接口EIMI  没有指定public或者private的可访问性\n     Int32 IComparable.CompareTo(Object other)\n     {\n        return CompareTo((SomeValueType)other);\n     }\n}\n```\n\n经过这样修改之后, 就不存在装箱问题,编译时期就能报错,不用在运行时才报,有了类型安全性.\n\n但如果定义接口类型的变量会再次失去编译时的类型安全性,也会发生装箱.(发生2次)\n\n```csharp\npublic static void Go()\n{\n    SomeValueType v = new SomeValueType(0);\n    // 接口类型是引用类型, 值类型赋值会装箱\n    IComparable c = v;              //第一次装箱\n\n    Object o = new Object();\n    // 这里使用的是接口类型变量去调用接口方法IComparable.CompareTo(Object other)\n    // 接口类型变量只能调用接口定义的方法,\n    Int32  n = c.CompareTo(v);       // 第二次发生装箱操作\n    // n = c.CompareTo(o);           // 运行时InvalidCastException异常           \n}\n```\n\n**实现IConvertible， ICollection，IList和IDictionary等接口时，可利用EIMI为这些接口的方法创建类型安全的版本，并减少值类型的装箱。**\n\n# 谨慎使用显式接口方法实现\n\n使用EIMI也可能造成一些严重后果，所以应该尽量避免使用EIMI。幸好，泛型接口可帮助我们在大多数时候避免使用EIMI。但有时，比如实现具有相同名称和签名的两个接口方法时，仍需要它们。\n\nEIMI最主要的问题如下：\n- 没有文档解释一个类型具体如何实现一个EIMI方法，也没有vs的智能感知。\n- 值类型的实例在转型为接口时装箱\n- EIMI不能由派生类调用\n\n\n```csharp\n// 问题1,2\n// 不能直接从一个Int32上调用一个IConvertible接口方法\n// 错误说明:int不包含ToSingle的定义,但是实际上是定义了\n// 必须先转换为IConvertible接口变量,才能调用, 还会装箱,并损害性能\npublic static void Main()\n{\n     int x=5;\n     // 无法编译此句\n     // Single s=x.ToSingle(null);\n\n     // 修改成这样才能编译\n     // 但是这又会发生装箱,浪费内存又损害性能\n     Single s=((IConvertible) x).ToSingle(null);\n\n}\n```\n\n```csharp\n// 问题3\n// 不能由派生类调用\ninternal class Base : IComparable\n{\n    // EIMI 显示接口方法实现\n    // 此方法只能通过IComparable接口类型变量来调用\n    int IComparable.CompareTo(object obj)\n    {\n        Console.WriteLine(\"Base's CompareTo\");\n        return 0;\n    }\n}\n\ninternal sealed class Derived : Base, IComparable\n{\n    public int CompareTo(object obj)\n    {\n        Console.WriteLine(\"Derived's CompareTo\");\n\n        // 情况一\n        // 试图调用基类的EIMI导致编译错误\n        // error CS0117: Base不包含CompareTo的定义\n        // base.CompareTo(obj);\n\n        // 情况二, 修改情况一\n        // 试图调用基类的EIMI导致无穷递归\n        // 通过接口变量调用接口方法, 会根据实际类型,调用到Derived的CompareTo\n        // 就产生无限递归\n        // 解决的方法是 internal sealed class Derived : Base { } 去掉IComparable接口定义\n        IComparable c = this;\n        c.CompareTo(obj);\n\n        return 0;\n    }\n}\n```\n为了解决问题3中情况二,这样的解决方式有时不能因为想在派生类中实现接口方法就将接口从类型中删除,正确定义Base类和Derived类的代码如下:\n\n```csharp\n// 用于解决 调用基类的接口方法\n// 在基类中定义个用于派生类的虚方法,\n// 这样 如果用接口类型变量就能访问到 基类的CompareTo方法,并且不会产生无限递归\ninternal static class Program\n{\n    public static void Main()\n    {\n        Base b = new Base();\n        Derived d = new Derived();\n\n        IComparable c = d;\n        // 输出\n        // Derived's CompareTo\n        // Base's virtual CompareTo\n        d.CompareTo(b);\n    }\n}\n\n\ninternal class Base : IComparable\n{\n    // EIMI 显示接口方法实现\n    Int32 IComparable.CompareTo(object obj)\n    {\n        Console.WriteLine(\"Base's CompareTo\");\n        // 调用虚方法\n        return CompareTo(obj);\n    }\n\n    // 用于派生类的虚方法(名字可以任意)\n    public virtual Int32 CompareTo(Object o)\n    {\n        Console.WriteLine(\"Base's virtual CompareTo\");\n        return 0;\n    }\n}\n\ninternal sealed class Derived : Base, IComparable\n{\n    // 公共方法,也是接口的实现\n    public override Int32 CompareTo(object obj)\n    {\n        Console.WriteLine(\"Derived's CompareTo\");\n        // 现在可以调用基类的虚接口方法\n        return base.CompareTo(obj);\n    }\n}\n```\n\nEIMI在某些情况下确实有用,但是应该 **尽量避免使用**,这样导致类型变得很不好用.\n\n# 设计:基类还是接口\n\n\n选择基类还是接口的指导性原则:\n\n- **`IS-A` vs. `CAN-DO`关系**\n\n类型 **只能继承一个实现**。如果派生类型和基类型不能建立起`is–a`关系，就不用基类而用接口。接口意味着`Can-do`关系。如果多种对象类型都能做某事，就为它们创建接口。\n\n例如，一个类型能将自己的实例转换为另一个类型（IConvertible），一个类型能序列化自己的实例(ISerializable)。注意，值类型必须从system.valueType派生，所以不能从一个任意的基类派生。这时必须使用`can-do`关系并定义接口。\n\n- **易用性**\n\n对于开发人员，定义从基类派生的新类型通常比实现接口的所有方法容易得多。基类可提供大量功能，所以派生类型可能只需要稍微改动。而提供接口的话，新类型必须实现所有成员。\n\n- **一致性的实现**\n\n无论接口协定订立得有多好，都无法保证所有人百分之百正确实现它。事实上，com颇受该问题之累。而如果为基类型提供良好的默认实现，那么一开始得到的就是能正常工作并经过良好测试的类型。以后根据需要修改就可以了。\n\n- **版本控制**\n\n向基类型添加一个方法，派生类将继承新方法。一开始使用就是一个能正常工作的类型，用户的源代码甚至不需要编译。向接口添加一个新成员，会强迫接口的实现者更改其源代码。\n\n最后要指出的是，这两件事情实际上是可以同时做：**定义一个接口，同时提供一个实现了这个接口的基类。**\n\n\nFCL中涉及数据流处理的类采用的是实现继承方法。system.IO.Stream是抽象基类，提供了包括read和write在内的一组方法。其他类（filestream，memoryStream和NetWorkStream等）都从stream派生。在这三个类中，每一个和stream类都是`is–a`关系，这使得具体类的实现变得更容易。\n\n相反，Microsoft采用基于接口的方式设计FCL中的集合。 FCL定义了`IComparer<in T>接口`,还提供了`抽象基类Compare<T>`,它实现了该接口,同时为非泛型`IComparer`的`Compare方法`提供了默认实现. 接口定义和基类同时存在带来了很大的灵活性.\n","tags":["CLR读书笔记"]},{"title":"12泛型","url":"/2019/08/05/12泛型/","content":"\n# 泛型\n\n**泛型** 支持另一种形式的代码重用,即 **算法重用**.\n\n定义算法的开发人员不设定该算法要`操作的数据类型`, 该算法可广泛的应用于不同类型的对象.\n\n## 泛型有两种表现形式:泛型类型和泛型方法。\n\n\n\nCLR允许创建:\n- 泛型引用类型\n- 泛型值类型\n- 泛型接口\n- 泛型委托\n\n不允许创建`泛型枚举类型`.\n\nCLR也允许在引用类型,值类型和接口中`定义泛型方法`.\n\n# 泛型的写法\n\n例如泛型类`List`类, 在类名后添加一个`<T>`, 表名它操作的是一个未指定的数据类型.\n\n定义泛型类或方法时, 为类型指定的任何变量(比如T),都称为`类型参数`. T是变量名,源代码能使用数据类型的任何地方都能使用T.\n\n> 命名规则: 泛型参数变量要么称为T, 要么以大写T开头(TKey,TValue) , 类似I代表接口一样.T代表类型Type.\n\n## 使用泛型\n\n```csharp\nprivate static void SomeMethod()\n{\n  // 构造一个List来操作DateTime对象\n  List<DateTime> dtList = new List<DateTime>();\n\n  dtList.Add(DateTime.Now); //不进行装箱, 值类型\n\n  dtList.Add(\"1/1/2004\");   // 编译时错误,检查类型\n\n  DateTime dt = dtList[0];  // 不需要转型\n}\n```\n\n# 使用泛型的优势\n\n1. 源代码保护\n  1. 不需要使用泛型算法的开发人员访问算法的源代码\n2. 类型安全\n  1. 将泛型算法应用于具体的类型时,编译器和CLR能保证只有与指定类型兼容的对象才能用于算法.否则编译时报错.\n3. 更清晰的代码\n  1. 由于编译器强制类型安全, 所以减少了类型强制转换次数.`DateTime dt = dtList[0];`\n4. 更佳的性能\n  1. 值类型能以传值的形式传递,不需要执行任何装箱操作.CLR无需验证这种转型是否类型安全,提高了代码的运行速度.\n\n# 比较泛型和非泛型算法的性能\n\n```csharp\npublic static class Generics\n{\n    public static void Main()\n    {\n        Performance.ValueTypePerfTest();\n        Performance.ReferenceTypePerfTest();\n    }\n}\ninternal static class Performance\n{\n    // 值类型的泛型类和非泛型类性能测试\n    public static void ValueTypePerfTest()\n    {\n        const Int32 count = 100000000;\n\n        // 泛型类List<Int32>性能测试\n        // 运行性能计时器, 在using代码块结束后会DisPose停止计时\n        using (new OperationTimer(\"List<Int32>\"))\n        {\n            List<Int32> l = new List<Int32>();\n            for (Int32 n = 0; n < count; n++)\n            {\n                l.Add(n);       // 不发生装箱\n                Int32 x = l[n]; // 不发生拆箱\n            }\n            l = null; // 使引用为null,确保进行垃圾回收\n        }\n        // 非泛型类ArrayList<Int32>性能测试\n        // 运行性能计时器, 在using代码块结束后会DisPose停止计时\n        using (new OperationTimer(\"ArrayList of Int32\"))\n        {\n            ArrayList a = new ArrayList();\n            for (Int32 n = 0; n < count; n++)\n            {\n                a.Add(n);               // 装箱\n                Int32 x = (Int32) a[n]; // 拆箱\n            }\n            a = null; // 使引用为null,确保进行垃圾回收\n        }\n    }\n    // 引用类型的非泛型和泛型性能测试\n    public static void ReferenceTypePerfTest()\n    {\n        const Int32 count = 100000000;\n\n        using (new OperationTimer(\"List<String>\"))\n        {\n            List<String> l = new List<String>();\n            for (Int32 n = 0; n < count; n++)\n            {\n                // 字符串\n                l.Add(\"X\");      // Reference copy\n                String x = l[n]; // Reference copy\n            }\n            l = null; // Make sure this gets GC'd\n        }\n\n        using (new OperationTimer(\"ArrayList of String\"))\n        {\n            ArrayList a = new ArrayList();\n            for (Int32 n = 0; n < count; n++)\n            {\n                // 字符串\n                a.Add(\"X\");               // Reference copy\n                String x = (String) a[n]; // Cast check & reference copy\n            }\n            a = null; // Make sure this gets GC'd\n        }\n    }\n\n    // 用于运行时性能计时\n    private sealed class OperationTimer : IDisposable\n    {\n        private Stopwatch m_stopwatch;\n        private String    m_text;\n        private Int32     m_collectionCount;\n\n        public OperationTimer(String text)\n        {\n            PrepareForOperation();\n\n            m_text            = text;\n            m_collectionCount = GC.CollectionCount(0);\n\n            // This should be the last statement in this\n            // method to keep timing as accurate as possible\n            m_stopwatch = Stopwatch.StartNew();\n        }\n\n        // 在using代码块结束后会Dispose会执行\n        public void Dispose()\n        {\n            Console.WriteLine(\"{0} (GCs={1,3}) {2}\",\n                (m_stopwatch.Elapsed),\n                GC.CollectionCount(0) - m_collectionCount, m_text);\n        }\n\n        // 强制垃圾回收器执行\n        private static void PrepareForOperation()\n        {\n            // 首先 GC.Collect(); 并不会立即去回收 只是告诉回收器 去回收\n            // 垃圾收集器在一次垃圾收集过程中,垃圾收集器的逻辑不能保证所有未引用的对象都从堆中删除\n\n            // 我们可以显式调用 GC.Collect();GC.WaitForPendingFinalizers();\n            // 这两行代码进行强制回收的执行\n            GC.Collect();\n            // 挂起当前线程，直到处理终结器队列的线程清空该队列为止。\n            GC.WaitForPendingFinalizers();\n            GC.Collect();\n        }\n    }\n}\n// 00:00:00.6625861 (GCs=  6) List<Int32>\n// 00:00:05.5150908 (GCs=388) ArrayList of Int32\n// 00:00:01.1244509 (GCs=  1) List<String>\n// 00:00:01.2407716 (GCs=  0) ArrayList of String\n```\n\n\n\n结果表明:\n1. 泛型List算法比非泛型ArrayList算法快得多.\n2. ArrayList会造成大量装箱,要进行频繁的垃圾回收\n3. 引用类型则区别不大\n\n> 首次为特定的数据类型调用方法时,CLR都会为这个方法生成本机代码.\n\n\n# FCL中的泛型\n\n泛型最明显的应用是集合类. Microsoft建议使用泛型集合类,不建议使用非泛型集合类.常用的接口包含在Sysytem.Collections.Generic命名空间中。\n\n`System.Array`类(即所有数组的基类)提供了大量静态泛型方法，比如，AsReadonly、FindAll、Find、FindIndex等。\n\n集合类实现了许多接口,放入集合中的对象`可实现接口`来执行排序和搜索等操作.\n\n# 泛型基础结构\n\n## CLR内部如何处理泛型\n\nCLR会为应用程序的各种类型创建称为`类型对象`的内部数据结构. 泛型类型参数仍然是类型,CLR同样会创建内部数据结构.(包括 引用类型(类),值类型(结构), 接口类型和委托类型).\n\n具有`泛型参数`的类型称为`开放类型`. **CLR禁止构造开放类型的任何实例.** 类似于禁止构造接口类型实例.\n\n代码`引用泛型类型`时,为所有类型参数传递了实际的数据类型,类型就成为`封闭类型`, CLR允许创建封闭类型的实例.如果在引用泛型类型时,留下一些泛型类型 **实参未指定**,CLR就会创建开放类型对象,而且不能创建该类型的实例.\n\n```csharp\n// 定义一个部分指定的开放类型\ninternal sealed class DictonaryStringKey<TValue> : Dictionary<String, TValue>\n{\n}\n\nstatic void Main(string[] args)\n{\n    Object o = null;\n\n    // Dictionary<,>有2个泛型参数,是开放类型,不允许创建实例\n    Type t = typeof(Dictionary<,>);\n    // 在运行时抛出异常, 创建失败\n    o = CreateInstance(t);\n\n    // DictonaryStringKey<>,有一个泛型参数没指定,所以是开放类型\n    t = typeof(DictonaryStringKey<>);\n    // 在运行时抛出异常, 创建失败\n    o = CreateInstance(t);\n\n    // 传入了确定的类型,就是封闭类型\n    t = typeof(DictonaryStringKey<Guid>);\n    // 创建成功\n    o = CreateInstance(t);\n\n    Console.WriteLine(o.GetType());\n}\n\nprivate static Object CreateInstance(Type t)\n{\n    Object o = null;\n    try\n    {\n        o = Activator.CreateInstance(t);\n        Console.WriteLine($\"已创建{t.ToString()}的实例.\");\n    }\n    catch (ArgumentException e)\n    {\n        Console.WriteLine(e.Message);\n    }\n    return o;\n}\n// 输出:\n// Cannot create an instance of System.Collections.Generic.Dictionary`2[TKey,TValue] because Type.ContainsGenericParameters is true.\n// Cannot create an instance of DictonaryStringKey`1[TValue] because Type.ContainsGenericParameters is true.\n// 已创建DictonaryStringKey`1[System.Guid]的实例.\n// DictonaryStringKey`1[System.Guid]\n```\n\n如上代码, Activator.CreateInstance在运行时试图构造开放类型的实例时,会抛出ArgumentException异常,并指明泛型参数.\n\n类型名以 `单引号+数字 `结尾, 数字代表类型的元数,也就是要求的参数个数,Dictionary类的元数是2, 要求`[TKey,TValue]` . `DictonaryStringKey`要求一个`[TValue]`, 指定元数的具体类型.\n\n- CLR会在类型对象内部分配`类型的静态字段`( 非静态的字段是实例的,这里是类型字段,回顾第四章 )\n- 每个封闭类型都有自己的静态字段\n  - 换言之:`List<T>`中定义了任何静态字段,不会在`List<A>`和`List<B>`之间共享.\n- 如果定义了泛型类的`静态构造器`,那针对每个封闭类类,构造器都会执行一次.\n  - **泛型静态构造器目的是保证传递的类型参数满足特定条件**.\n\n```csharp\ninternal sealed class MyClass<T>\n{\n    // 静态类型构造器\n    static MyClass()\n    {\n        // 这样定义只能处理枚举类型的泛型类型\n        // CLR提供了约束的功能, 可以更好的指定有效的类型实参,\n        // 但是约束无法将类型实参限制为仅枚举类型. 由于这个原因,\n        // 所以需要用静态构构造器来保证类型是一个枚举类型\n        if (!typeof(T).IsEnum)\n        {\n            throw new ArgumentException(\"T must be an Enum \");\n        }\n    }\n    // 实例构造器\n    public MyClass()\n    {\n    }\n}\n```\n\n\n## 泛型类型和继承\n\n使用泛型类型并指定类型的实参时,实际是在CLR中定义一个`新的类型对象`, `新的类型对象`从泛型类型派生自的那个类型派生.\n- `List<T>`从`Object`派生,`List<String>`和`List<Guid>`也从`Objcet`派生.\n- `DictonaryStringKey<TValue>`从`Dictionary<String, TValue>`派生, 那么`DictonaryStringKey<Guid>`是从`Dictonary<String, Guid>`派生.\n\n**指定类型实参不影响继承层次结构.** 需要判断强制类型转换是否是允许的.\n\n定义一个如下链表节点类:\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 传入构造函数需要的参数\n    Node<Char> head = new Node<Char>('C');\n    head = new Node<char>('B',head);\n    head = new Node<char>('A',head);\n    Console.WriteLine(head.ToString());// 输出ABC\n}\n// 链表节点类\ninternal sealed class Node<T>\n{\n    public T m_data;\n    public Node<T>  m_next;\n\n    public Node(T mData, Node<T> mNext)\n    {\n        m_data = mData;\n        m_next = mNext;\n    }\n    // 单参数构造函数,会通过this指针调用Node(T mData, Node<T> mNext)构造函数\n    public Node(T mData) : this(mData,null)\n    {\n    }\n    public override string ToString()\n    {\n        return m_data.ToString() + ((m_next != null) ? m_next.ToString() : String.Empty);\n    }\n}\n```\n\n在这个Node类中,对于m_next字段引用的另一个节点来说, m_data字段必须包含相同的数据类型, 例如不能一个包含Char,一个包含String,一个包含DataTime.  如果全部用`Node<Object>`,会失去编译时的类型安全性,值类型会被装箱.  \n\n很好的办法是定义`非泛型Node基类.` 再定义`泛型TypedNode类`(用`Node类`作为基类). 这样就可以创建一个链表,每个节点都可以是一种具体的数据类型(不能是Object),并防止了值类型装箱.\n\n```csharp\nstatic void Main(string[] args)\n{\n    // 传入构造函数需要的参数\n    Node head = new TypeNode<Char>('.');\n    head = new TypeNode<DateTime>(DateTime.Now,head);\n    head = new TypeNode<String>(\"Today is \",head);\n    Console.WriteLine(head.ToString());// Today is 2019/8/5 18:06:43.\n}\n\n// 非泛型Node基类\ninternal class Node\n{\n    protected Node m_next;\n\n    public Node(Node mNext)\n    {\n        m_next = mNext;\n    }\n}\n\n// 链表节点类\ninternal sealed class TypeNode<T> : Node\n{\n    public T m_data;\n\n    // 基类没有无参构造函数,派生类要显式调用基类的\n    public TypeNode(T mData, Node mNext) : base(mNext)\n    {\n        m_data = mData;\n    }\n    // 使用单个参数构造函数用this调用TypeNode(T mData, Node mNext),\n    public TypeNode(T mData) : this(mData,null)\n    {\n    }\n    public override string ToString()\n    {\n        return m_data.ToString() + ((m_next != null) ? m_next.ToString() : String.Empty);\n    }\n}\n```\n\n## 泛型类型的同一性\n\n有些开发人员为了简化如下代码:\n\n```csharp\n// 因为源代码中大量<>符号有损可读性\nList<DateTime> dt1 = new ListList<DateTime>();\n\n// 定义个新的非泛型类,从泛型类型派生\n// 这样就只是为了简化代码没有了<>符号\ninternal sealed class DateTimeList : List<DateTime>\n{\n  //这里不用写任何代码\n}\n\n// false\nBoolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));\n```\n\n上述代码会失去类型的`同一性`和`相等性`. 如果方法原型需要的是`DateTimeList`类型参数,那么`List<DateTime>`类型就不能传递给它\n\n\n所以C#允许使用简化语法来引用泛型封闭类型,同时不影响类型的相等性. 就是在源文件顶部使用传统的`using`指令.\n\n```csharp\n// 用using指令定义DateTimeList符号.\n// 代码编译时, 所有DateTimeList替换成System.Collections.Generic.List<System.DateTime>\nusing DateTimeList = System.Collections.Generic.List<System.DateTime>;\n\n// true\nBoolean sameType = (typeof(List<DateTime>) == typeof(DateTimeList));\n\n// 还可以用var\nvar dt1 =new List<DateTime>();\n```\n\n## 代码爆炸\n\n使用泛型类型参数的方法进行JIT编译时,CLR获取方法的IL, 用指定的类型实参替换, 然后创建恰当的本机代码(这些代码是为指定数据类型量身定制). 这样CLR要为`每种不同的方法/类型组合`生成`本机代码`. 称为 **代码爆炸**.\n\nCLR的优化措施:\n\n1. **假如特性的类型实参调用了一个方法, 以后再用相同的类型实参调用这个方法,CLR只会为这`个方法/类型组合`编译一次代码.** 例如:一个程序集中使用`List<DateTime>`,另一个程序集加载到同一个AppDomain也使用`List<DateTime>`,CLR只编译一次`List<DateTime>`.\n\n2. **CLR认为所有引用类型实参都完全相同,所以代码能够共享.** 因为任何引用类型的实参或变量实际上只是指向堆上对象的指针(32位系统是32位指针,64位系统是64位指针). 所有的对象指针都以相同方式操作. 例如 List<String>编译的代码可直接用于List<Stream>的方法.\n\n3. 值类型就不能,CLR必须专门为那个值类型生成本机代码. 因为值类型的大小不定.即使值类型大小一样,仍然无法共享(Int32和UInt32都是32位). 要用不同的本机CPU指令来操纵这些值.\n\n\n# 泛型接口\n\n泛型的主要作用是定义泛型的引用类型和值类型.\n\n但是,对泛型接口的支持对CLR也很重要. 没有泛型接口,每次用非泛型接口(如`IComparable`)来操纵值类型都会发生装箱.\n\n```csharp\n// 这个泛型接口定义是FCL的一部分\npublic interface IEnumerator<T> : IDisposable, IEnumerator\n{\n  // 实现接口的需要有此属性\n  T Current {get {...}}\n}\n// 实现了泛型接口, 保持类型实参的未指定状态\ninternal sealed class ArrayEnumrator<T> : IEnumerator<T>\n{\n  private T[] m_array;\n  // IEnumerator<T>的Current是T类型.\n  public T Current { get { ... }  }\n}\n```\n\n# 泛型委托\n\nCLR支持泛型委托, 目的是保证任何类型的对象都能以类型安全的方式传给回调方法.\n\n泛型委托运行值类型实例在传给回调方法时不进行任何装箱.\n\n委托实际只是提供了4个方法的一个类定义.\n1. 构造器\n2. Invoke方法\n3. BeginInvoke方法\n4. EndInvoke方法\n\n**尽量使用FCL预定义的泛型Action和Func委托.**\n\n\n# 委托和接口的逆变和协变泛型类型实参\n\n协变性: 指定`返回类型`的兼容性.\n\n逆变性: 指定`参数`的兼容性.\n\n委托的每个泛型类型参数都可标记为协变量和逆变量.\n\n泛型类型参数形式:\n1. `不变量`: 泛型类型参数不能更改.\n2. `逆变量`: 泛型类型参数可以从一个类更改为它的某个`派生类`.  在C#中用`in`关键字标记.\n  1. 逆变量泛型类型参数只出现在输入位置,比如方法的参数.\n3. `协变量`: 泛型类参数可以从一个类更改为它的某个`基类`.  在C#中用`out`关键字标记.\n  1. 协变量泛型类型参数只能出现在输出位置,比如作为方法的返回类型.\n\n> 方便记忆: in(里面,内部,子类) 参数类型允许它的子类; out(外面,外部,基类) 返回类型允许它的基类.\n\n```csharp\n// 委托定义\n// in T 逆变量, out TResult协变量\npublic delegate TResult Func<in T, out TResult>(T arg);\n\n// 如果像这样声明一个变量\nFunc<Object, ArgumentException> fn1 = null;\n//    子类       基类\n//     ↓          ↓\n// 可以转型为另一个泛型类型参数不同的Func类型\nFunc<String, Exception> fn2 = fn1; // 不需要显式转型\nException e = fn2(\"\");\n```\n\nfn1 变量引用了一个方法, 获取一个Object, 返回一个ArgumentException.\n\nfn2 变量引用另一个方法, 获取String, 返回Exception\n\n因为`in逆变量`,`String`是从`Object`派生, 并且 `out协变量`, `Exception` 是`ArgumentException`的基类,上述代码能正确编译, 而且编译时能维持类型的安全性.\n\n由于需要装箱,所以值类型不具有这种可变性,\n\n```csharp\n// 不能再调用它时传递List<Datetime>\n// 虽然Datetime派生自Object\n// 但是Datetime值类型和Object之间不存在引用转换\n// 此外, 此方法最大的好处,JIT编译得到的代码只有一个版本\nvoid Test(IEnumerable<Object> collection) { ... }\n\n// 为了解决上面问题,可以这样声明\n// 这样写,只有在T类型是引用类型的前提下,才能共享同一个版本的JIT编译代码\n// 每个值类型都有一份不同的JIT编译代码\n// 起码能传递值类型\nvoid Test<T>(IEnumerable<T> collection) { ... }\n\n// 编译不通过, 无效的可变性,T 必须是不变量, 当前T为逆变.\n// delegate void SomeDelegate<in T>(ref T t);\n\n```\n\n**注意: 不能将`可变性(in/out)`泛型类型参数传给使用了out/ref关键字的方法. 必须是不变量**\n\n使用 要 **获取泛型参数和返回值** 的`委托`时, 尽量为逆变性参数和协变性返回值指定in和out关键字,这样做不会有不良反应,使委托能在更多的情形中使用.\n\n要使用 具有 **泛型类型参数** 的`接口`也尽量为逆变性参数和协变性返回值指定in和out关键字.\n\n```csharp\n// T可接受\npublic interface IEnumerator<in T> : IEnumerator\n{\n  Boolean MoveNext();\n  T Current{ get; }\n}\n\n// 定义一个方法,接受任意引用类型的一个IEnumerator\nInt32 Count(IEnumerator<Object> col) { ... }\n\n// 以下调用Count,传递IEnumerator<String>\n// 因为T是逆变量,String是Object的子类,所以编译没问题,可以顺利运行\nInt32 c = Count(new[] {\"Grant\"});\n\n```\n\n\n**在声明泛型类型参数时,必须由你显式使用`in/out`来标记可变性.** 这样防止以后修改类型参数时,用法与声明不符的地方编译器就会报错,提醒你违反了自己订立的协定.\n\n# 泛型方法\n\n定义泛型类,结构和接口时, 类型中定义的任何方法都可引用类型指定的类型参数. 类型参数可作为方法参数,方法返回值或方法内部定义的局部变量的类型使用.\n\nCLR还允许方法指定它自己的类型参数.\n\n```csharp\nstatic void Main(string[] args)\n{\n\n    GenericType<String> gt = new GenericType<string>(\"123\");\n    // 123 : System.Int32\n    Console.WriteLine($\"{gt.Converter<Int32>()} : {gt.Converter<Int32>().GetType()}\");\n\n}\n\n// 定义了类型参数T\ninternal sealed class GenericType<T>\n{\n    private T m_value;\n\n    public GenericType(T mValue)\n    {\n        m_value = mValue;\n    }\n    // 定义了自己的类型参数TOutput\n    // Converter方法能将m_value字段引用的对象转换成任意类型(TOutput).取决于调用时传递的TOutput参数\n    public TOutput Converter<TOutput>()\n    {\n        TOutput result = (TOutput) Convert.ChangeType(m_value, typeof(TOutput));\n        // 返回类型转换之后的结果\n        return result;\n    }\n}\n```\n\nConverter方法能将m_value字段引用的对象转换成任意类型(TOutput).取决于调用时传递的TOutput参数.\n\n```csharp\n// ref关键字标记参数,o1,o2必须先初始化,方法内能读写\n// out关键字标记 则不必需初始化,不能读取,在返回前必须写入\nprivate static void Swap<T>(ref T o1, ref T o2)\n{\n    T temp = o1;\n    o1 = o2;\n    o2 = o1;\n}\n\n// 这样调用Swap\nInt32 n1 = 1, n2 = 2l;\nSwap<Int32>(ref n1,ref n2);\n```\n\n**有ref/out参数的泛型方法, 实参传递的变量必须和方法参数相同的类型** , 不允许用可变性来标识参数,以防损害类型安全性.\n\n## 泛型方法和类型推断\n\nC#编译器支持在调用泛型方法时进行`类型推断`.(就是省略<>).\n\n```csharp\nprivate static vod Test()\n{\n  Int32 n1 = 1, n2 = 2;\n  // 编译器会推断n1,n2的类型,最后调用Swap<Int32>\n  Swap(ref n1, ref n2);\n\n  // 重要说明: C#使用的是变量的数据类型, 而不是变量引用对象的实际类型\n  String s1 = \"A\";\n  Object s2 = \"B\";\n  // 编译出错, 因为编译器无法推断用哪个传递的类型\n  // 编译器发现s1是String , s2是Object(不是String )\n  // Swap(ref s1, ref s2);\n}\n```\n\n类型可以定义多个方法,一个接受具体类型,另一个接受泛型类型.\n\n```csharp\nprivate static void Display(String s)\n{\n  Console.WriteLine(s);\n}\nprivate static void Display<T>(T t)\n{\n  // 调用Display(String)\n  Display(t.ToString());\n}\n\n// 调用的方式\n// 2个方法都可以被调用,\n// 但是C#编译器优先考虑明确的匹配, 再考虑泛型匹配\nDisplay(\"Jeff\");    // 调用Display(String)\nDisplay(123);       // 调用Display<T>(T)\n// 明确指定了泛型类型实参,告诉编译器不要尝试推断类型实参\n// 所以编译器会毫不犹豫的代用泛型方法\nDisplay<String>(\"AAA\"); // 调用Display<T>(T)\n\n```\n\n**C#编译器优先考虑参数明确的匹配, 再考虑泛型匹配, 如果指定了`<String>`,就调用泛型方法.**\n\n\n# 泛型和其他成员\n\nC#中, 属性,索引器(有参属性),事件,操作符方法,构造器,终结器本身不能有类型参数. 但他们能在泛型类型中定义,这些成员中的代码能使用类型的类型参数.\n\n# 可验证性和约束\n\nCLR支持称为`约束`的机制.\n\n```csharp\nprivate static T Min<T>(T o1,T o2)\n{\n  // 编译错误, 因为不是所有类型都能有ComparableTo方法\n  //if (o1.ComparableTo(o2))\n  {\n    return o1;\n  }\n  return o2;\n}\n\n// 通过限制类型, 可以对那些类型进行更多的操作\n// where关键字告诉编译器,为T指定的任何类型都必须实现IComparable<T>接口\nprivate static T Min<T>(T o1,T o2) where T : IComparable<T>\n{\n  if (o1.ComparableTo(o2))\n  {\n    return o1;\n  }\n  return o2;\n}\n```\n\n约束可以应用于泛型类型的类型参数,也可以用于泛型方法的类型参数(如上面的Min方法).\n\n**CLR不允许基于类型参数名称和约束来进行重载.**\n\n```csharp\n\ninternal sealed class Test<T>{}\n\n// 错误与Test<T>{}类定义冲突\n//internal sealed class Test<T> where T : IComparable<T>{}\n\nprivate static void M<T>();\n\n// 错误与M<T>方法定义冲突\n// private static void M<T> where T : IComparable<T>();\n```\n\n重写虚泛型方法时, 重写的方法必须指定相同数量的类型参数,这些类型参数会 **继承在基类方法上指定的约束**.\n\n**事实上根本不允许为重写方法的类型指定任何约束. 但是类型名称可以更改(T可以改为T1,T2之类),不能指定约束.**\n\n## 主要约束\n\n`T : Class`\n\n类型参数可以指定 **0个或1个** `主要约束` , 主要约束可是代表非密封类的一个引用类型.\n\n不能指定以下特殊类型:\n1. System.Object\n2. System.Array\n3. System.Delegate\n4. System.MulticastDelegate\n5. System.ValueType\n6. System.Enum\n7. System.Void\n\n指定引用类型约束时, 相当于向编译器承诺: **一个指定的类型实参要么是与约束类型相同,要么是从约束类型派生的类型. 如果类型参数没有指定主要约束,就默认为System.Object ,并且不能显式指定.**\n\n### 两个特殊的主要约束 class 和struct\n\n`T : class`\n\n`T : struct`\n\nclass约束是承诺类型实参是`引用类型`.\n  - 任何类,接口类型,委托类型或者数组类型都满足这个约束.\nstruct约束是承诺类型实参是`值类型`.\n  - 包括枚举在内的任何值类型都满足这个约束.\n  - CLR和编译器将任何`System.Nullable<T>`值视为`特殊类型`, 不满足这个struct约束.\n  - 原因是`Nullable<T>`类型将它的类型参数约束为struct,而CLR希望禁止这样的递归类型.\n```csharp\ninternal sealed class Test<T> where T : class\n{\n  public void M()\n  {\n    // 引用类型的变量都能设为null\n    // 值类型的变量不能设置为null\n    T temp = null; //允许,因为T约束为引用类型\n  }\n}\n\ninternal sealed class Test<T> where T : struct\n{\n  public static T Factory()\n  {\n    // 允许,因为所有值类型都隐式有一个公共无参构造器\n    // 如果约束为class, 无法通过编译,因为有的引用类型没有公共的无参构造器.\n    return new T();\n  }\n}\n\n```\n\n> 值类型都有公共的无参构造器. 不允许设置为null\n> 引用类型不一定都有无参构造器,不允许设置为null\n\n## 次要约束\n\n`T : interface`\n\n类型参数可以指定 **0个或多个** `次要约束`, 次要约束代表`接口类型`. 向编译器承诺类型实参实现了接口. 由于能指定多个接口约束,所以类型实参必须实现了所有接口约束.\n\n> 在第13章详细讲 接口约束.\n\n`T : TBase`\n\n还有一种次要约束称为 `类型参数约束`, 也称为 `裸类型约束`. 它允许一个泛型类型或方法规定: 指定的类型实参要么就是约束类型,要么是约束的类型的派生类.  一个类型参数可指定 **0个或多个** `裸类型约束`.\n\n> 意思就是: T 由 TBase 约束, 由类型参数决定约束.  List<T,TBase> where T:TBase\n\n```csharp\n// 指定了两个类型参数\n// T参数 由TBase类型参数约束, T必须兼容于TBase指定的类实参\nprivate static List<TBase> ConvertIList<T, TBase>(IList<T> list) where T : TBase\n{\n    List<TBase> baseList = new List<TBase>(list.Count);\n\n    for (int index = 0; index < list.Count; index++)\n    {\n        baseList.Add(list[index]);\n    }\n    return baseList;\n}\nstatic void Main(string[] args)\n{\n    // 初始化一个List<String> , 它实现了IList<String>\n    List<String> ls = new List<string>();\n    ls.Add(\"A String\");\n\n    // 将IList<String>转成IList<Object>\n    // 编译器检查String是否兼容于Object,由于是派生关系,所以满足约束 T(string) : TBase(Object)\n    IList<Object> lo = ConvertIList<String, Object>(ls);\n\n    // 将IList<String> 转成IList<IComparable>\n    // 编译器检查Strings是否实现了IComparable接口,由于String实现了,所以也满足约束.\n    IList<IComparable> lc = ConvertIList<String, IComparable>(ls);\n\n    // 将IList<String> 转成IList<IComparable<String>>\n    // 由于String实现了接口,所以也满足约束.\n    IList<IComparable<String>> lcs = ConvertIList<String, IComparable<String>>(ls);\n\n    //  IList<String>转成 IList<String>\n    IList<String> ls2 = ConvertIList<String, String>(ls);\n\n    // 错误,不能将IList<String>转 IList<Exception>\n    // String没有隐式引用转换到Exception\n    // IList<Exception> le = ConvertIList<String, Exception>(ls);\n}\n```\n\n\n## 构造器约束\n\n`T : new()`\n\n类型参数可以指定 **0个或1个** `构造器约束`.  它向编译器承诺类型实参是 **实现了公共无参构造器的非抽象类型**. 如果同时和struct约束一起使用,C#编译器会认为这是一个错误,因为是多余的; 所有值类型都隐式提供了公共无参构造器.\n\n```csharp\ninternal sealed class Test<T> where T : new()\n{\n  public static T Factory()\n  {\n    // 允许,因为所有值类型都隐式有一个公共无参构造器\n    // 如果约束为class, 约束也要求它提供公共无参构造器\n    return new T();\n  }\n}\n```\n\n## 其他可验证性问题\n\n几个特殊的代码构造和泛型共同使用时,可能产生不可预期的行为.\n\n1. 泛型类型变量的转型\n\n**不允许将泛型类型转型为其他类型, 除非转型为与约束兼容的类型.**\n\n```csharp\nprivate static void CastGenericType<T>(T obj)\n{\n  // T是任意类型无法保证成功转型\n  // Int32 x = (Int32) obj;   // 错误\n  // String s = (String) obj; // 错误\n\n  // 虽然能通过编译, 但是CLR仍有可能在运行时抛出InvalidCastException异常\n  Int32 x = (Int32) (Object) obj;    // 可能报异常\n  String s1 = (String) (Object) obj; // 可能报异常\n\n  // 转型为引用类型时还可以使用C# as操作符\n  // 使用了as就不会报异常\n  // 值类型不能用as\n  String s2 = obj as String; // 无错误\n}\n\n```\n\n2. 将泛型类型变量设为默认值\n\n`default(T)`\n\n**不允许将泛型类型变量设为`null`, 除非将泛型类型约束成引用类型.**\n\n由于未对T进行约束,所以可能是值类型.\n\n```csharp\nprivate static void SettingDefault<T>()\n{\n  // 编译错误,因为可能是不可以为null的值类型, 考虑改用default(T)\n  // T temp = null;\n\n  // default告诉编译器和CLR的JIT编译器,如果T是引用类型,就将temp设为null\n  // 如果temp是值类型,就将temp的所有位设为0\n  T temp = default(T);\n}\n```\n\n3. 将泛型类型变量与null进行比较\n\n不论泛型类型是否被约束,使用`==`或`!=`操作符将泛型类型与null进行比较都是可以的.\n\n```csharp\n// 由于T类型未进行约束, 所以可能是值类型或引用类型\n// 如果是值类型,obj永远不会为null\n// 如果被约束为struct, C# 编译器会报错,\n// 因为值类型的变量不能与null比较,因为结果始终一样\nprivate static void Compare<T>(T obj)\n{\n  if (obj == null)\n  {\n    // 如果obj是值类型, 这里的代码永远不会执行\n    // JIT编译器不会为此处的代码生成本机代码\n    // 如果 换成!=操作符\n    // 则不会为if (obj != null) 生成本机代码,因为永远为true\n    // 但是大括号内还是会生成\n  }\n}\n```\n\n如果是值类型,obj永远不会为null. 如果被约束为struct, C# 编译器会报错,因为值类型的变量不能与null比较,因为结果始终一样.\n\n4. 两个泛型类型变量比较\n\n如果泛型参数不限定为引用类型,对两个变量进行比较就是非法的.\n\n因为两个值类型的变量互相比较是非法的, 除非值类型重载了`==`操作符.\n\n```csharp\nprivate static void Compare<T>(T o1, T o2)\n{\n  if(o1 == o2) {} // 编译错误\n}\n\n// 对于非`基元值类型的值类型`,C#不知道如何比较,所以编译器会报错.\n//private static void Compare<T>(T o1, T o2) where T : struct\n\n\nprivate static void Compare<T>(T o1, T o2) where T : class\n{\n  if(o1 == o2) {} // 编译成功\n}\n\n```\n\n上述代码如果T约束成class,就能编译通过.\n1. 如果引用相同的对象, `==`操作符就返回`true`.\n2. 如果引用类型重载了`==`, 编译器会生成对`operator==`方法的调用代码\n\n写代码来比较基元值类型,C#编译器能知道生成正确的代码.如果约束为`struct`, 对于非`基元值类型的值类型`,C#不知道如何比较,所以编译器会报错.\n\n\n**不允许将类型参数约束成具体的值类型**, 因为值类型隐式密封,不可能存在从值类型派生的类型.如果支持,那就好比只支持该具体类型, 泛型参数的意义就不存在了.\n\nOnly class or interface could be specified as constraint 只有类或接口可以指定为约束.\n\n`private static void Test<T>(T t) where  T : Int32 // 编译错误`.\n\n\n## 泛型类型变量作为操作数使用\n\n将`操作符`用于`泛型类型的操作数`会出现大量问题. C# 知道如何解释应用于基元类型的操作符(加减乘除), **但是不能将这些操作符应用于泛型类型的变量.**\n\n编译器在编译时确定不了类型, 所以不能向泛型类型的变量应用任何操作符.\n\n因此不可能写出一个能处理任何数值数据类型的算法.\n\n```csharp\n// 尝试写一个能处理任何数据类型的算法\nprivate static T Sum<T>(T num) where T : struct\n{\n    T sum = default(T);\n    // 报错. 运算符< ++ += 无法应用于\"T\"和\"T\"类型的操作数\n    for (T n = default(T); n < num; n++)\n    {\n        // 报错. 运算符< ++ += 无法应用于\"T\"和\"T\"类型的操作数\n        sum += n;\n    }\n    return sum;\n}\n```\n\n这是CLR的泛型支持体系的一个严重限制, 许多开发人员(科学,金融,数学领域)对这个限制失望. 通过别的技术来避开这个以限制, `反射`,`dynamic基元类型`和`操作符重载`等. 但是这些技术会严重损害性能和代码的可读性.\n","tags":["CLR读书笔记"]},{"title":"11事件","url":"/2019/08/02/11事件/","content":"# 事件\n\n定义了`事件成员`的类型允许 **类型或类型实例** 通知其他对象发生了特定事情.\n\n例如: Button按钮类提供了Click事件.应用程序中的其他对象可以接收关于该事件的通知,以便在Button被点击之后采取特定的操作.\n\n定义了事件成员的`类型`能提供一下功能:\n- 方法能登记它对事件的关注.\n- 方法能注销它对时间的关注.\n- 事件发生时,登记了的方法将收到通知.\n\n`类型`之所以能提供事件通知功能,是因为类型维护了一个`已登记方法的列表`.事件发生后通知列表中的所有已登记方法.\n\nCLR事件模型是以`委托`为基础. 委托是调用`回调方法`的一种类型安全的方式.对象凭借回调方法接收它们订阅的通知.\n\n**我们可以通过为事件定义事件访问器,来控制事件运算符+=、-=运算符的行为,有两个访问器:add和remove,声明事件的访问器看上去和声明一个属性差不多.**\n\n```csharp\npublic event EventHandler Elapsed\n{\n    add\n    {\n        //... 执行+=运算符的代码\n    }\n     remove\n     {\n        //... 执行-=运算符的代码\n     }\n}\n```\n\n\n# 举例用到事件的场景\n\n设计电子邮件应用程序:\n\n功能:电子邮件到达时,将该邮件转发给传真机,将该邮件转给寻呼机.\n\n![](11事件/设计电子邮件程序.png)\n\n0) 先构建一个MailManager的一个实例. MailManager提供了NewMail事件.\n1) `构造`Fax和Pager对象时,它们向MailManager的NewMail事件`登记`它们自己的一个`实例方法`.\n2) MailManager收到新邮件时,会引发NewMail事件,使所有已登记的方法都能用自己的方式处理邮件.\n\n\n## 第一步:定义类型来容纳所有需要发送给事件通知接收者的附加信息\n\n事件引发时,引发事件的对象可能希望向接收事件通知的对象传递一些`附加信息`,这些附加信息要封装到它自己的类中, 这种类应该从`EventArgs`派生,并且类名以EventArgs结尾.\n\n```csharp\npublic  class NewMaillEventArgs : EventArgs\n{\n       // 私有只读字段\n       // 发件人\n       private readonly string _m_from;\n       // 收件人\n       private readonly string _m_to;\n       // 主题\n       private readonly string _m_subject;\n       public NewMaillEventArgs(string from,string to,string subject)\n       {\n           _m_from = from;\n           _m_to = to;\n           _m_subject = subject;\n       }\n       // 公开的只读属性(只有get访问器)\n       public string From { get { return _m_from; } }\n       public string To { get { return _m_to; } }\n       public string Subject { get { return _m_subject; } }\n}\n```\n\n### EventArgs类的定义实现\n\n实现非常简单,就是一个让其他类型继承的基类型.\n\n如果事件不需要传递附加信息,则可以直接使用EventArgs.Empty,不用构造新的EventArgs对象.  例如:Button点击事件,调用回调方法就可以了,不需要传递附加信息.\n\n```csharp\n[Serializable]\npublic class EventArgs\n{\n  public static readonly EventArgs Empty = new EventArgs();\n}\n```\n\n## 第二步:定义事件成员\n\n事件成员使用C#`关键字event`来定义。\n\n每个事件成员都要指定以下内容:\n- 一个可访问性标识符(几乎肯定是Public，这样其他代码才能访问该事件成员)；\n- 另一个委托类型，它指出要`调用的方法的原型`，以及一个名称(可以是任意有效的标识符)。\n\n\n```csharp\n//定义成员变量 NewMaill是事件名称\npublic event EventHandler<NewMaillEventArgs> NewMaill;\n```\n\n事件成员类型是`EventHandler<NewMaillEventArgs>`, 意味着所有接收者都必须提供一个原型和`EventHandler<NewMaillEventArgs>`匹配的`回调方法`.\n\n由于`泛型System.EventHandler`的委托定义如下:\n```csharp\npublic delegate void EventHandler<TEventArgs>(Object sender, TEventArgs e);\n```\n\n**所以方法的原型必须具有以下形式:**\n```csharp\nvoid MethodName(Object sender, NewMaillEventArgs e);\n```\n> 事件模式要求所有事件处理程序(方法)的返回类型都是void;\n> 因为引发事件后可能要调用好几个回调方法,但是没办法获得所有方法的返回值,将返回类型void,就不允许回调方法返回值.\n> 但是ResloveEventHandle事件没有遵循这个要求,返回了Assembly类型的对象.\n\n\n### 为什么要求sender参数是Object类型\n\n只有`MailManager对象`才会引发传递`NewMaillEventArgs对象`的事件,似乎以下回调方法更适合原型:\n```csharp\n// Object sender 改为 MailManager sender\nvoid MethodName(MailManager sender, NewMaillEventArgs e);\n```\n\n原因是:\n1. 要求Object主要是因为继承.\n\n假设: MailManager成为SmtpMailManager的基类`SmtpMailManager : MailManager` ,`SmtpMailManager`从基类继承了`事件NewMail`, 那参数类型需要由`MailManager`转换为`SmtpMailManager`,反正都是需要转换的,不如定义成`Object`.\n\n2. 另一个原因是灵活性,使委托能由多个类型使用.\n\n只要`类型`提供一个会传递`NewMaillEventArgs对象`的事件,即使`PopMailManager`类不从`MailManager`类派生,也能使用这个委托.\n\n\n## 第三步:定义负责引发事件的方法来通知事件的登记对象\n\n事件主要是在单线程情形中使用,所以线程安全不是问题.\n\n```csharp\n//如果类是密封的，该方法要声明为私有和非虚\nprotected virtual void OnNewMaill(NewMaillEventArgs e)\n{\n    //出于线程安全的考虑，现在将对委托字段的引用复制到一个临时变量时\n    // EventHandler<NewMaillEventArgs> temp = NewMaill; 也是可以的\n    // 事件主要是在单线程的情形中使用,所以线程安全不是问题\n    // (NewMaill != null) 在多线程中会出现竞态问题\n    // 以下写法是技术正确的版本.\n    EventHandler<NewMaillEventArgs> temp = Volatile.Read(ref NewMaill);\n    //任何方法登记了事件的关注,就通知它们\n    if (temp != null)\n    {\n        temp(this, e);\n    }\n}\n```\n\n> (NewMaill != null) 在多线程中会出现竞态问题,调用NewMaill之前,在另外一个线程中可能移除一个委托,使NewMaill成了null. 许多开发者就像EventHandler<NewMaillEventArgs> temp = NewMaill;这样写, 将NewMail引用复制到变量中,引用的是赋值时发生的委托链. 委托是不可变的.\n\n将MailManager作为基类,派生类可以自由重写OnNewMaill方法,一般情况下,派生类会调用基类的OnNewMaill方法,使登记的方法都能收到通知,但是派生类也可以不允许事件转发.\n\n### 定义如下扩展方法来封装这个线程安全逻辑\n\n```csharp\npublic static class EventArgExtensions\n{\n    public static void Raise<TEventargs>(this TEventargs e, Object sender, ref EventHandler<TEventargs> eventHandler)\n    {\n        EventHandler<TEventargs> temp = Volatile.Read(ref eventHandler);\n\n        if (temp != null)\n        {\n            temp(sender, e);\n        }\n    }\n}\n```\n\n为了方便起见,就可以如下重写OnNewMail方法\n\n```csharp\nprotected virtual void OnNewMaill(NewMaillEventArgs e)\n{\n  e.Raise(this, ref m_NewMail);\n}\n```\n\n## 第四步:定义方法将输入转化为期望事件\n\n```csharp\npublic void SimulateNewMaill(String from, String to, String subject)\n{\n    // 构造对象来容纳想附加给接收者的信息\n    NewMaillEventArgs e =new NewMaillEventArgs(from,to,subject);\n\n    // 调用虚方法通知事件已经发生\n    // 如果没有类型重写该方法,我们的对象将通知事件的所有登记对象\n    OnNewMaill(e);\n}\n```\n\n# 事件是什么? 是如何工作的?\n\n```csharp\n// 事件成员\npublic EventHandler<NewMaillEventArgs> NewMail = null;\n```\n\nC#编译器编译时把它转换为3个构造:\n1. 一个被初始化为null的`私有委托字段`;\n  1. **是对委托列表头部的引用.**\n2. 一个公共的`add_Xxx方法`(Xxx是事件名,例如add_NewMail)\n  1. 生成的代码总是调用`System.Delgate的静态Combine方法`,将`委托实例添加到委托列表`中,返回`新的列表头地址`, 将这个地址存回字段.\n3. 一个公共的`remove_Xxx`(Xxx是事件名,例如remove_NewMail)\n  1. 生成的代码总是调用`System.Delgate的静态Remove方法`,将`委托实例从委托列表中删除`中,返回`新的列表头地址`, 将这个地址存回字段.\n\n如果试图删除从未添加过的方法, `Delgate`内部不做任何事情,也不会抛出异常, 事件的集合保持不变.\n\n> add和remove以线程安全的一种模式更新值.\n\n事件的可访问性决定了什么代码能登记和注销对事件的关注.**无论如何只有类本身可以访问委托字段**.\n\n\n# 设计侦听事件的类型\n\n1. 在Fax类中的构造函数传入MailManager,并将对该对象的引用保存到变量中,\n2. 在构造函数中登记它对MailManager的事件的关注\n  1. `mm.NewMail += FaxMsg;`\n  2. C#编译器对`+=`操作符翻译成以下代码来添加对象对事件的关注.`mm.add_NewMail(new EventHandler<NewMaillEventArgs>(this.Msg));`\n  3. C#编译器调用了`MailManager`类的`add_NewMail`方法,传递新的委托对象(Msg).\n3. MailManager对象引发事件时, Fax对象的FaxMsg方法会被调用.\n  1. 调用时,传递的第一个参数时MailManager对象引用,`sender`.  可以用来访问MailManager对象的成员.\n  2. NewMaillEventArgs附带了信息.\n4. 类型实现了IDisposable的Dispose方法,就应该在其中注销对所有事件的关注. 用`-=`操作符(会调用remove方法).\n\n> C#要求代码使用+=和-=操作符在列表中增删委托.\n\n# 什么情况需要显式实现事件?\n\n在一个类型中定义了很多事件,也就是要很多个委托字段,但是用到的只是少数事件, 这样从这个类派生创建的对象都要浪费大量内存.\n\n因此需要开发人员显式实现一个事件,使开发人员能够`控制add和remove方法`处理回调委托.\n\n1. 高效率存储事件委托, 公开了事件的每个对象都要维护一个集合(通常是字典)\n  1. `事件标识符作`为key, `委托列表`作为值value\n  2. 新对象构造时, 集合是空白的, 登记事件时会查找集合中的键(事件标识符),如果已经有了,就将新委托和委托列表合并. 不存在就新添加.\n2. 所以这个设计,需要定义事件的那个类型开发人员去完成.\n\n\n## EventKey和EventSet设计\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Threading;\n\n// 此类目的:提供多一点的类型安全性和代码的可维护性\n// 用于 字典的key键存放每个事件标识符类的哈希码,以便查找这个事件的委托链表\npublic sealed class EventKey : Object\n{\n}\n\n// 用于显示实现事件的字典集合\npublic sealed class EventSet\n{\n    // 定义私有只读字典,用于维护EventKey->Delegate(委托链表)映射\n    private readonly Dictionary<EventKey, Delegate> m_events =\n        new Dictionary<EventKey, Delegate>();\n\n    // Adds an EventKey -> Delegate mapping if it doesn't exist or\n    // combines a delegate to an existing EventKey\n    public void Add(EventKey eventKey, Delegate handler)\n    {\n        // 线程安全的方式\n        Monitor.Enter(m_events);\n        Delegate d;\n        m_events.TryGetValue(eventKey, out d);\n        // 合并新的委托到委托链表中\n        // Delegate.Combine将`委托实例添加到委托列表`中,返回`新的列表头地址`, 将这个地址存回字段.\n        m_events[eventKey] = Delegate.Combine(d, handler);\n        Monitor.Exit(m_events);\n    }\n\n    // Removes a delegate from an EventKey (if it exists) and\n    // removes the EventKey -> Delegate mapping the last delegate is removed\n    public void Remove(EventKey eventKey, Delegate handler)\n    {\n        Monitor.Enter(m_events);\n        // Call TryGetValue to ensure that an exception is not thrown if\n        // attempting to remove a delegate from an EventKey not in the set\n        Delegate d;\n        // 确保从集合中删除不存在的EventKey时不会抛出异常.\n        if (m_events.TryGetValue(eventKey, out d))\n        {\n            d = Delegate.Remove(d, handler);\n\n            // 如果委托链表还存在委托,则重新设置头部的地址.\n            if (d != null) m_events[eventKey] = d;\n            // 链表为空,则移除这个键值对.\n            else m_events.Remove(eventKey);\n        }\n\n        Monitor.Exit(m_events);\n    }\n\n    // 为指定的EventKey引发事件\n    public void Raise(EventKey eventKey, Object sender, EventArgs e)\n    {\n        // 如果EventKey不在集合中,不会抛出异常\n        Delegate d;\n        Monitor.Enter(m_events);\n        m_events.TryGetValue(eventKey, out d);\n        Monitor.Exit(m_events);\n\n        if (d != null)\n        {\n            // 由于字典可能包含几个不同的类型委托\n            // 所以无法再编译时构造一个类型安全的委托调用\n            // 调用Delegate的DynamicInvoke方法,以一个对象数组的形式传递回调方法的参数\n            // 在内部,DynamicInvoke会向调用的回调方法查证参数的类型安全性.\n            // 如果类型不匹配,会抛出异常\n            d.DynamicInvoke(new Object[] {sender, e});\n        }\n    }\n}\n```\n\n## 使用EventSet类在TypeWithLotsOfEvents类中\n\nTypeWithLotsOfEvents类(使用了大量时间的类):\n\n```csharp\nusing System;\n\n// 为事件定义从EventArgs派生的附加信息类\npublic class FooEventArgs : EventArgs\n{\n}\n\n// Define the EventArgs-derived type for this event.\npublic class BarEventArgs : EventArgs\n{\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\ninternal class TypeWithLotsOfEvents\n{\n    // 定义私有只读字段来引用集合类\n    // 用于管理维护一组EventKey->Delegate(事件/委托)对.\n    private readonly EventSet m_eventSet = new EventSet();\n\n    // protected只能派生类型能访问集合\n    protected EventSet EventSet\n    {\n        get { return m_eventSet; }\n    }\n\n    // 定义Foo事件的键\n    // 2a. 构造静态只读对象来作为标识符表示这个事件\n    // 每个对象都有自己的哈希码,可以方便在对象的集合中查找这个事件的委托链表\n    protected static readonly EventKey s_fooEventKey = new EventKey();\n\n    // 2d. 定义事件的访问器, 用于在集合中增删委托\n    public event EventHandler<FooEventArgs> Foo\n    {\n        // 操作EventSet集合来 增加/删除 键值对\n        add { m_eventSet.Add(s_fooEventKey, value); }\n        remove { m_eventSet.Remove(s_fooEventKey, value); }\n    }\n\n    // 2e. 定义虚方法,用来触发事件\n    protected virtual void OnFoo(FooEventArgs e)\n    {\n        m_eventSet.Raise(s_fooEventKey, this, e);\n    }\n\n    // 2f. 定义将输入转成这个事件的方法\n    public void SimulateFoo()\n    {\n        OnFoo(new FooEventArgs());\n    }\n}\n```\n\n## 使用TypeWithLotsOfEvents类型\n\n```csharp\npublic static void Main()\n{\n  TypeWithLotsOfEvents twle = new TypeWithLotsOfEvents();\n  // 添加一个回调\n  twle.Foo += HandleFooEvent;\n  // 证明确实可行\n  twle.SimulateFoo();\n}\n\nprivate static void HandleFooEvent(object sender, FooEventArgs e)\n{\n  Console.WriteLine(\"Handling Foo Event here..\");\n}\n\n```\n","tags":["CLR读书笔记"]},{"title":"10属性","url":"/2019/08/01/10属性/","content":"\n# 属性\n\nCLR支持两种属性:\n1. 无参属性\n2. 索引器\n\n# 无参属性\n\n## 属性是用来干嘛的?解决了什么问题?\n\n1. 面向数对象设计重要原则之一,数据封装. 意味着类型的字段永远不应该公开.否则很容易因为不恰当的使用而破坏对象的状态.\n  1. 例如 `e.Age = -1; //年龄不可能为负数` ;\n2. 设置为私有字段private后,要修改字段添加`访问器(accessor)方法`,这样就要编写额外的方法\n3. 调用方法不能直接引用字段名,需要调用方法名\n  1. 例如 `e.SetAge(2);`\n\n为了解决以上问题,C#提供了`属性property`机制.\n\n```csharp\nprivate string name;\nprivate int age;\npublic string Name\n{\n    get { return name; }\n    set { name = value; }\n}\npublic int Age\n{\n    get { return age; }\n    set\n    {\n        if (age < 0 && age > 200)\n            throw new ArgumentOutOfRangeException(\"age不在正常范围\", value.ToString());\n        age = value;\n    }\n}\n\n/// 调用时,可以直接引用字段名\ne.Name = \"aaaa\";\n```\n\n## 属性的用法\n\n1. 支持静态,实例,抽象,虚属性.\n2. 可以用任意`可访问性`来修饰`get/set`.\n3. 属性不能重载,即不能定义名称相同,类型不同的属性.\n4. `只读属性`: 只写get标识; `只写属性`:只写set标识\n5. set方法中包含隐藏参数叫做`value`，表示赋给属性的值。\n\n> 私有字段 通常被称为支持字段.\n\n\n## 自动实现的属性(AIP)\n\n如果只为一个私有字段而创建属性,C#提供了更简洁的语法.称为`AIP(Automatiocally Implemented Property)`.\n\n```csharp\n// 声明属性不需要提供get/set的实现, C#会自动声明一个私有字段\npublic string Name{set;get;}\n```\n\n### 自动实现的属性(AIP)不建议使用的理由:\n\n1. 没有简单的语法初始化AIP,要在构造器中显式初始化每个AIP\n2. AIP的私有字段名称有编译器决定,每次重新编译都可能会更改这个名称.因此,**任何类型只要含有AIP就没办法对该类型进行反序列化**. 所以在想要序列化的类中不要使用AIP功能.\n3. 调用时不能再get/set上设置断点.手动实现属性方法可以设置.\n4. AIP属性必然是可读可写的.\n5. get或set方法,如果要显式实现,那么两个方法都要显式实现,不能一个自动一个显式.\n\n## 属性字段差别列表\n\n1. 属性索引器不得作为out或ref参数传递,字段可以.\n2. 属性看起来和字段相似,但是本质上是方法.\n3. 属性方法可能抛出异常;字段访问永远不会.\n4. **线程同步不要使用属性,要使用方法.** 属性方法可能花较长时间执行,字段访问总是立即完成.\n5. 属性可以只读或者只写, 字段访问总是可读或可写(一个例外是readonly字段仅在构造器中可写).\n\n**属性的唯一好处是提供了简化的语法.**\n\n## 对象和集合初始化器\n\n构造对象并设置对象的一些公共属性,为了简化这个常见的编程模式,使用下面这个语法:\n\n`Employee e = new Employee(){ Name = \"Jeff\", Age = 45 };`\n\n等同于\n\n```csharp\nEmployee e = new Employee();\ne.Name = \"Jeff\";\ne.Age = 45;\n```\n\n允许组合多个函数,增强了可读性.(函数的组合使用:扩展方法)\n\n`Employee e = new Employee(){ Name = \"Jeff\", Age = 45 }.ToString.ToUpper();`\n\n> 要用无参构造函数,可以省略大括号前的圆括号,`new Employee { Name = \"Jeff\", Age = 45 }`\n\n**如果类型的属性实现了IEnumerable或IEnumerable<T>接口, 属性就被认为是集合.**\n\n集合的初始化是一种`相加(additive)`操作,而不是`替换(replacement)`操作.\n- 编译器会假定属性类型提供了Add方法,然后生成代码来`调用Add方法`.\n- 如果属性类型`未提供Add方法`,则不允许使用集合初始化语法.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        MyClass mc = new MyClass()\n        {\n            MStudent =\n            {\n                \"A\",\n                \"B\",\n                \"C\"\n            }\n        };\n\n        foreach (var student in mc.MStudent)\n        {\n            Console.WriteLine(student);\n        }\n    }\n}\n\npublic sealed class MyClass\n{\n    // 私有字段\n    private List<String> m_Student = new List<string>();\n    // 只读属性\n    public List<string> MStudent\n    {\n        // C#7 方法体表达式\n        // constructors, finalizers, get, set\n        // get只读\n        get => m_Student;\n    }\n    public MyClass() { }\n}\n```\n\n# 匿名类型\n\n利用C#的匿名类功能,可以用很简洁的语法来自动声明不可变的元组类型.\n- `元组类型`:是含有`一组属性`的类型.\n\n```csharp\n// 没有在new后指定类型名称,编译器会自动创建类型名称\n// 因为不知道类型名称,也就不知道o1声明的是什么类型\n// 可以像var\nvar o1 = new { Name = \"aa\", Year = 1989};\n\n// Nameaa,Year1989.\nConsole.WriteLine(\"Name{0},Year{1}.\",o1.Name,o1.Year);\n\nString Name = \"B\";\nDateTime dt = DateTime.Now;\n// 还可以这么写\nvar o2 = new { Name, dt.Year };\n```\n\n1. 编译器会推断每个`表达式`的类型.\n2. 创建推断类型的`私有字段`.\n3. 为每个字段创建`公共只读属性`.\n4. 创建一个`构造器`来接受所有这些表达式.\n  1. 在构造器代码中, 会用传给它的`表达式的求值结果来初始化私有只读字段`.\n5. 编译器还会重写Object的Equals,GetHashCode和ToString方法.\n  1. 任何字段不匹配就返回false,否则true.\n  2. 返回根据每个字段的哈希码生成的一个哈希码.\n  3. 返回\"属性名=值\"对的以逗号分隔的列表.\n6. 匿名类的属性是只读的. 防止对象的哈希码发生改变.如果以哈希码为键,更改了哈希码,这就造成再也找不到它.\n\n编译器在定义匿名类型时, 如果定义了多个匿名类型,而且这些类型具有相同的结构,那么它只会创建一个匿名类型定义.\n\n## 匿名类经常与LINQ(语言集成查询)配合使用\n\n可以用LINQ执行查询,从而生成由一组对象构成的集合. 这些对象都是相同的匿名类型.\n\n- 匿名类型不能泄露到方法外部.\n- 方法也不能返回对匿名类的引用,\n  - 虽然可以将匿名类视为Object,但是没法将Object类的变量转型回匿名类.因为不知道匿名类在编译时的名称.\n\n# Tuple类型\n\n和匿名类型相似,\n- `Tuple`创建好之后就`不可变`了,\n- `所有属性只读`.\n- 提供了CompareTo,Equals,GetHashCode和ToString方法,以及Size属性,\n- 可以比较两个Tuple对象,对他们的字段进行比对.\n\n```csharp\nclass CLRTuple\n {\n     private static Tuple<int, int> MinMax(int a, int b) {\n         return new Tuple<int, int>(Math.Min(a, b), Math.Max(a, b));\n     }\n     private static void TupleTypes()\n     {\n         var minmax = MinMax(6, 2);\n         // Tuple类型,属性一律被称为Item#,无法进行改变\n         // 应该在自己的代码中添加详细的注释,说明每个Item#代表着是什么\n         Console.WriteLine(\"Min{0}Max{1}\", minmax.Item1, minmax.Item2);\n     }\n }\n\n// 当需要创建多于8个元素的一个Tuple时，可以将Rest参数传递到下一个Tuple如下\nvar t=Tuple.Create(0,1,2,3,4,5,6,Tuple.Create(7,8));\n\nConsole.WriteLine(\"{0}{1}{2}{3}{4}{5}{6}{7}{8}\",\n    t.Item1, t.Item2, t.Item3, t.Item4, t.Item5, t.Item6, t.Item7,\n    t.Rest.Item1.Item1, t.Rest.Item1.Item2);\n)\n```\n\n## 除了匿名类型和Tuple类型,ExpandoObject类和dynamic配合使用\n\n可以用另一种方式将一系列属性(键值对)组合到一起.\n\n![](10属性/ExpandoObject&dynamic.png)\n\n\n# 有参属性(索引器)\n\n可以看成是对`[]`操作符的重载.\n\n属性的get访问器方法 **不接受参数**,所以称为 **无参属性**.\n\nC#称有参属性为 **索引器**.\n- `get访问器`:接受一个或多个参数.\n- `set访问器`:接受两个或多个参数.\n\n\n**索引器使得对象可按照与数组相似的方法进行索引。**\n\n> CLR是以相同方式对待有参属性和无参属性.\n\n```csharp\nstatic void Main(string[] args)\n{\n    TestIndex<String> str= new TestIndex<string>();\n    // 定义了索引器之后可以像数组的方式一样访问类\n    str[0] = \"A\";\n    str[2] = \"B\";\n}\n\nclass TestIndex<T>\n{\n    T[] arr = new T[100];\n\n    // 定义[]索引器\n    public T this[int i]\n    {\n        get { return arr[i]; }\n        set { arr[i] = value; }\n    }\n}\n```\n\n![](10属性/索引器.png)\n\n**提示:查看文档,留意类型是否提供了名为Item的属性,从而判断该类型是否提供了索引器.**\n\n> 例如System.Collections.Generic.List类型提供了名为Item的公共实例属性,它就是List的索引器.\n\n## 如果会有其他语言的代码访问索引器,可能需要更改get/set方法名称\n\nC#编程中永远看不到 Item这个名称,所以一般不需要关心这个.\n\n```csharp\nclass TestIndex<T>\n{\n    T[] arr = new T[100];\n\n    // 定义[]索引器\n    [IndexerName(\"Method\")]\n    public T this[int i]\n    {\n        get { return arr[i]; }\n        set { arr[i] = value; }\n    }\n}\n```\n\n![](10属性/索引器2.png)\n\nSystem.String类型是改变了索引器名称的一个例子.String的索引器名称是Chars,而不是Item. 这个只读属性允许从字符串中获得一个单独的字符,对于不用[]操作符语法来访问这个属性的编程语言,Chars是更有意义的名称.\n\n## 索引器注意事项\n\n- C#用`this[...]`作为索引器的语法.\n  - 索引器语法不允许开发人员指定名称,编译器默认生成get_Item和set_Item方法名.\n  - Item方法名可以用`[IndexerName(\"..\")]`特性修改\n- 只允许在对象的实例上定义索引器.\n- 不支持静态索引器属性.\n- 索引器可以被重载.一个类可以有多个索引器,只要参数集不同即可.\n- 索引器可以多个参数,可以像二维数组.\n\n```csharp\nclass TestIndex<T>\n    {\n        T[] arr = new T[100];\n        T[,] arr1 = new T[10,10];\n        // 定义索引器\n        public T this[int i]\n        {\n            get { return arr[i]; }\n            set { arr[i] = value; }\n        }\n\n        // 定义两个形参的索引器\n        public T this[int i,int j]\n        {\n            get { return arr1[i,j]; }\n            set { arr1[i,j] = value; }\n        }\n    }\n```\n\n- 对于CLR来说有参和无参属性是无区别的,可以用相同的`System.Reflection.PropertyInfo类`来发现`有参属性`和`它的访问器方法`之间的关联.\n\n## 调用访问器方法时的性能\n\n对于简单的get/set方法 ,JIT编译器会将代码内联(嵌入到调用它的方法中去),这样使用属性就没有性能上的损失,避免了在运行时发出调用所产生的开销,会使编译好的方法变得更大.\n\n由于属性访问器包含的代码很少,所以内联所生成的本机代码很小,执行的也会更快.\n\n- JIT编译器在 **调试代码时不会内联属性方法**. 内联代码会难以调试.\n- 发行版本中,访问属性时的性能可能比较快.\n- 字段访问在调试和发布版中,速度都很快.\n\n## 属性访问器的可访问性\n\n如果2个访问器需要不同的可访问性,\n1. C#要求必须为属性本身指定限制最小的(比访问器访问性限制小),\n2. 两个访问器只能选择一个访问器来使用限制较大的.(不能两个都用)\n\n```csharp\n// 限制最小的可访问性public\npublic String Name\n{\n  get{ return m_name; }\n  // 限制较大的protected(相对于Public)\n  protected set { m_name = value; }\n}\n\n// 例子二\nprotected string A\n{\n    // private get => a; // 会报错\n    get => a;\n    private set => a = value;\n}\n```\n\n## 泛型属性访问器方法\n\nC#不允许属性引入它自己的泛型类型参数.  属性不应该和行为沾边,公开对象的行为,无论是不是泛型都应该定义方法,而不是用属性.\n","tags":["CLR读书笔记"]},{"title":"9参数","url":"/2019/07/30/9参数/","content":"\n# 参数\n\n# 可选参数和命名参数\n\n1. 设计方法参数时,可以为部分或全部参数分配默认值.\n\n```csharp\nclass CLR可选参数\n{\n    private static int s_n = 0;\n\n    private static void M(int x = 9, string s = \"A\", DateTime dt = default(DateTime), Guid guid = new Guid())\n    {\n        Console.WriteLine($\"x={x},s={s},dt={dt},guid={guid}\");\n    }\n\n    public static void Main()\n    {\n        //等同于M(9, \"A\", default(DateTime), new Guid())\n        M();\n        //等同于M(8, \"X\", default(DateTime), new Guid())\n        M(8, \"X\");\n        //等同于M(5, \"A\", DateTime.Now, Guid.NewGuid()))\n        M(5, guid: Guid.NewGuid(), dt: DateTime.Now);\n\n        M(s_n++,s_n++.ToString());\n\n        //等同于string t1=0,t2=1;\n        //M(t2,t1,default(DateTime), new Guid())\n        M(s: (s_n++).ToString(), x: s_n++);\n    }\n}\n//输出\n//x=9,s=A,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=8,s=X,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=5,s=A,dt=2019/7/31 11:03:00,guid=afb6f487-dc69-4ae4-ba58-588982d1e68a\n//x=0,s=1,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n//x=3,s=2,dt=0001/1/1 0:00:00,guid=00000000-0000-0000-0000-000000000000\n```\n\n## 部分参数指定默认值的规则和原则\n\n1. 可以为方法,构造器方法,有参属性(C#索引器)的参数指定默认值.\n2. **有默认值的参数必须放在没有默认值的所有参数之后.**\n3. **\"参数数组\"必须放到所有参数之后(包括有默认值的这些),而数组本身不能由默认值.**\n4. 默认值必须是编译时能确定的常量值.\n  1. 值类型参数可将默认值设为值类型的实例. default()关键字和new关键字会生成完全一致的IL代码.`DateTime dt = default(DateTime), Guid guid = new Guid()`\n5. 不要重命名参数变量,不然之后的指定赋值时变量名就需要修改.`s: (s_n++).ToString(), x: s_n++`就会报错.\n6. 更改参数的默认值具有潜在危险性. call site在它的调用中嵌入`默认值`, **建议将默认值0/null作为哨兵值使用**.\n  1. 如果方法被模块外部调用,外部使用默认值,如果以后修改方法的默认值,没有重新编译call site外部的代码.那它在调用方法时,传递的还是旧的默认值.\n\n```csharp\n// 不要这样做\nprivate static String MakePath(String filename = \"Untitled\")\n// 参数中的默认值会被直接嵌入到方法调用中的IL代码里\n// 如果修改默认参数后,call site代码没有重新编译,仍旧会使用旧默认值\n{\n  return String.Format($\"C:\\{filename}.txt\");\n}\n\n// 建议这样做\n// 默认值用0/null作为哨兵值使用\nprivate static String MakePath(String filename = null)\n{\n  // 在语句中就不会出现这样的问题\n  return String.Format(\"C:\\{0}.txt\", filename ?? \"Untitled\");\n}\n```\n\n7. 如果参数用ref或out关键字进行标识,就不能设置默认值. 没办法为这些参数传递有意义的默认值.\n\n使用可选或命名参数调用方法时,\n1. 实参可按任意顺序传递,命名实参只能出现在实参列表的尾部.( `x: s_n++` 命名实参:值)\n2. C#不允许省略逗号之间的实参.(如果想省略, 就用要以传递`参数名:`的方式传递实参就可以)\n3. 如果参数要求ref/out, 为了以传参数名的方式传递实参,使用以下语法\n\n```csharp\n// 方法声明\nprivate static void M(ref Int32 x){ ... }\n\n// 方法调用\nInt32 a = 5;\nM(x: ref a);\n```\n\n\n# 隐式类型( var )的局部变量\n\n1. 不能用var声明参数,因为编译器必须根据在call site传递的实参来推断类型,但是call site可能一处没有,也可能有很多处.\n2. 不能用var声明字段. 应该显式陈述.\n\n\n> 不要混淆dynamic和var\n> 用var声明局部变量只是一种简化语法.\n\n# 以传引用的方式向方法传递参数\n\nCLR默认所有方法参数都传值. 传递引用类型的对象时, 引用(或指针)本身是传值的.\n\n- 引用类型: 方法能修改对象,而调用者能看到这些修改\n- 值类型:传给方法的是实例的一个副本,调用者的实例不受影响.\n\n## ref和out关键字\n\nCLR运行以传引用而非传值的方式传递参数. C#用关键字`out/ref`来支持这个功能. 两个关键字都告诉C#编译器生成元数据来指明该参数时传引用的. **编译器会生成代码来传递参数的地址,而不是传递参数本身.**\n\nCLR不区分关键字`out/ref`,都会生成相同的IL代码,元数据几乎完全一致,只有一个bit除外,记录指定的是out还是ref.\n\nC#编译器则是区别对待`out/ref`的.\n- `out标记`:被传入调用方法的参数 **不必要初始化**, 被调用的方法 **不能读取参数值**, 在返回前\n**必须向这个值写入**.\n- `ref标记`:调用方法前 **必须先初始化被ref标记的参数**, 被调用的方法 **可以读写** 这个参数值.\n\n\n## 值类型使用ref和out关键字\n\n```csharp\npublic static void Main()\n{\n    int x;                //x没有初始化\n    GetVal(out x);        //x不必初始化\n    Console.WriteLine(x); //显示10\n}\n\nprivate static void GetVal(out int v)\n{\n    // 访问前必须先赋值v\n    // Console.WriteLine(v); 这句话编译时会报错\n    v = 10; //该方法必须初始化v\n}\n```\n1. x在Main的栈帧(当前线程的调用栈中的一个方法调用)\n2. x的地址传递给GetVal, GetVal的参数v是一个指针,指向Main栈帧中的Int32值.\n3. 在GetVal方法内部,v指向的那个Int32值被更改为10.\n\n> 栈帧: 在执行线程的过程中进行的每个方法调用都会在调用栈中创建并压入一个StackFrame\n\n **用处: 为 `大的值类型`使用out, 可以避免在进行方法调用时复制值类型实例的字段.**\n\n```csharp\npublic static void Main()\n{\n    int x = 5;            //已经初始化\n    AddVal(ref x);        //x必须初始化\n    Console.WriteLine(x); //显示15\n}\n\nprivate static void AddVal(ref int v)\n{\n    v += 10; //该方法可使用v的已初始化的值\n}\n```\n1. 和out不同的是,在AddVal内部,v指向的那个Int32值必须是已经初始化的.\n2. AddVal可以对v进行读写\n\n\n综上所述:\n1. 从IL和CLR角度看,out和ref是同一回事: **都传递指向实例的一个指针.**\n2. 从编译器角度看,两者的区别在于:**会按不同的标准验证你写的代码是否正确,是否已赋值.**\n3. 为值类型使用out/ref,效果等同于以传值的方式传递引用类型.\n\n## 为什么C#要求必须在调用方法时指定out或ref\n\nC#语言设计者认为调用者应该显式表明意图,只有这样,在`call site(调用位置)`那里,才能清楚地知道被调用的方法`是否需要对传递的变量值`进行更改.\n\nC#允许 使用out/ref参数对方法进行重载.但是两个不能同时出现,因为2个签名的元数据形式完全相同.\n\n```csharp\npublic sealed class Point\n{\n  static void Add(Point p){ ... }\n  static void Add(ref Point p){ ... }\n  // Add不能定义仅在ref和out上有差别的重载方法\n  // 因为这两个方法签名生成的元数据形式完全相同\n  // static void Add(out Point p) { ... }\n}\n```\n\n## 引用类型使用ref和out关键字\n\n和值类型使用out/ref参数的区别:\n1. `值类型`:调用者必须 **为实例分配内存**. 被调用者则操作该内存中的内容.\n2. `引用类型`:调用代码 **为一个指针分配内存**,指针指向引用类型的对象. 被调用者操纵这个指针.\n\n```csharp\npublic static void Main()\n{\n    FileStream fs = null; // 初始化为null (必要操作)\n\n    // 打开第一个待处理的文件\n    for(; fs != null; ProcessFiles(ref fs))\n    {\n      //处理文件\n      fs.Read(...);\n    }\n}\n\nprivate static void ProcessFiles(ref FileStream fs)\n{\n    // 如果先前的文件是打开的,就将其关闭\n    if (fs!=null) fs.Close();\n\n    // 打开下一个文件,如果没有,就返回null\n    if (noMoreFilesToProcess) fs = null;\n    else\n    {\n        fs = new FileStream(...);\n    }\n}\n```\n\n### 是ref关键字实现一个用于交换两个引用类型\n\n```csharp\npublic static void Main()\n{\n    String s1 = \"111\";\n    String s2 = \"222\";\n    // 无法通过编译,参数类型不匹配\n    // 它的类型必须与签名中声明的类型相同\n    // Swap需要的是两个Object的引用,而不是String\n    // Swap(ref s1,ref s2);\n\n\n    // 需要进行转型\n    Object o1 = s1, o2 = s2;\n    Swap(ref o1,ref o2);\n    // 完事后,再将Object转型为String\n    s1 = (String) o1;\n    s2 = (String) o2;\n\n}\n\npublic static void Swap(ref Object a,ref Object b)\n{\n    Object t = b;\n    b = a;\n    a = t;\n}\n\n// 泛型版本\n// 这样之前就不需要再转型了,能直接通过编译完美运行\npublic static void Swap<T>(ref T a,ref T b)\n{\n    T t = b;\n    b = a;\n    a = t;\n}\n```\n**传递参数的类型必须与签名中声明的类型相同.**\n\n# 向方法传递可变数量的参数（params）\n\n```csharp\n// 用params关键字\nstatic int Add(params int[] values)\n{\n    int sum = 0;\n    if (values != null)\n    {\n        for (int x = 0; x < values.Length; x++)\n            sum += values[x];\n    }\n\n    return sum;\n}\n\n//调用方法1\nAdd(new int[]{1,2,3,4,5,6});\n//调用方法2，\nAdd(1,2,3,4,5,6);\n```\n\nparams关键字告诉编译器向参数定制特性System.ParamArrayAttribute的一个实例.\n\nC#编译器检测方法调用时,会先检查所有具有指定名称,同时参数没有应用ParamArray的方法.如果没有找到,就检查应用了ParamArray特性的方法,生成代码来构造数组,填充它的元素,再生成代码来调用所选的方法.\n\n\n1. 只有方法的`最后一个参数`才可以用`params关键字`(ParamArrayAttribute)标记.\n2. **只能标识一维数组(任意类型)**.\n3. 可为这个参数传递null值. `Console.WriteLine(Add(null));//生成的结果是0,不会分配数组`\n\n## 获取任意数量,任意类型的参数方法\n\n只需要修改方法原型,让它获取`Object[]`而不是`Int32[]`;\n\n```csharp\nstatic void Main(string[] args)\n{\n    DisplayTypes(new object(),new Random(),\"Jeff\",5);\n}\n\nprivate static void DisplayTypes(params Object[] objects)\n{\n    if (objects!=null)\n    {\n        foreach (object o in objects)\n        {\n            Console.WriteLine(o.GetType());\n        }\n    }\n}\n// System.Object\n// System.Random\n// System.String\n// System.Int32\n```\n\n使用params会对性能有所影响\n1. 数组必须在堆上分配\n2. 数组元素必须初始化\n3. 数组内存最终需要垃圾回收\n\n# 参数和返回类型的设计规范\n\n这里例子讨论的是集合,是用接口体系结构来设计的.\n1. 声明方法的参数类型时, **应尽量指定最弱的类型,宁愿要接口也不要基类.** 最好是使用接口声明参数比如`IEnumerable<T>`\n\n```csharp\n// 好: 方法使用弱参数类型\n// 参数的类型只要实现了IEnumerable<T>接口就可以\n// 方法更灵活,适合更广泛的情形\npublic void MainpulateItems<T>(IEnumerable<T> collection) { ... }\n\n// 不好: 方法使用强参数类型\n// 参数不接受数组或String对象\npublic void MainpulateItems<T>(List<T> collection) { ... }\n```\n\n2. 如果方法需要的是列表,就应该将参数类型声明为`IList<T>` ,避免声明为`List<T>`\n3. 强参数类型和弱参数类型,`参数类型`最好是弱类型\n4. `返回类型`最好是声明为最强的类型\n\n```csharp\n// 好: 方法使用弱参数类型\n// 能处理任何流包括FileStream,NetworkStream,MemoryStream等\npublic void ProcessBytes(Stream someStream){ ... }\n\n// 不好: 方法使用强参数类型\n// 只能处理FileStream\npublic void ProcessBytes(FileStream someStream){ ... }\n\n// 好: 方法使用强返回类型\npublic FileStream OpenFile(){ ... }\n// 不好: 方法使用弱返回类型\npublic Stream OpenFile(){ ... }\n```\n\n\n# 常量性\n\n1. 不能将方法或参数声明为常量.\n2. CLR也没提供对常量对象/实参的支持.\n\n> String类就没有提供任何能更改String对象的方法,所以字符串是不可变的(immutable).\n","tags":["CLR读书笔记"]},{"title":"8方法","url":"/2019/07/28/8方法/","content":"# 方法\n\n# 实例构造器和类(引用类型)\n\n构造器方法在`方法定义元数据表`中始终叫做`.ctor`(constructor简称).\n\n创建引用类型的实例时\n- 首先,为实例的数据字段分配内存\n- 初始化对象的附加字段(`类型对象指针`和`同步索引块`)\n  - 这些附加字段称为`overhead fields`,创建对象时必须的开销.\n- 最后调用类型的`实例构造器`,来设置对象的初始状态.\n\n构造引用类型对象时,在调用类型的实例构造器之前,为对象分配的内存总是先被归零,**没有被构造器显示重写的字段都保证获得0或null值.**\n\n- 实例构造器不能使用以下修饰符: `virtual`,`new`,`override`,`sealed`,`abstract`.\n- 没有显示定义任何构造器时,C#编译器将定义一个默认的`无参构造器`.\n- 如果是抽象类(abstract),那么编译器生成的默认构造器可访问性是`protected`,否则就是`public`.\n- 如果基类没有提供 **无参构造器**,那么派生类必须 **显式调用一个基类构造器**.\n- 如果是静态类(static),编译器不会再定义中生成默认构造器.\n\n```csharp\npublic class SomeType {}\n// 等价于\npublic class SomeType\n{\n  public SomeType() : base() {}\n}\n```\n\n- 类的实例构造器在访问从基类继承的任何字段之前,都必须先调用基类的构造器.\n- 如果派生类的构造器没有显式调用一个基类构造器,C#编译器会自动生成对默认的基类构造器的调用.(System.Object的无参构造器会得到调用,直接返回什么都不做)\n- 极少数情况可以在不调用构造器的前提下创建类型的实例.\n  - 一个典型的例子是Object的`MemberwiseClone`方法.该方法的作用是分配内存,初始化对的额外开销成员,然后将源对象的字节数据复制到新对象中.(不需要构造器去初始化成员)\n  - 另外`运行时序列化器`反序列化对象时也不需要调用构造器.反序列化代码使用`System.Runtime.Serialization.FormatterServices`类型的`GetUninitializedObject`或者`GetSafeUninitializedObject`方法为对象分配内存. 期间不会调用一个构造器.\n\n## 不要在构造器中调用虚方法\n\n- 假如基类构造器中调用了虚方法,派生类重写了虚方法, 派生类被实例化时,会先调用基类的构造器,但是基类构造器中的虚方法会使用派生类重写后的虚方法,但是派生类构造器还没运行,所以会导致无法预测的行为.\n- 尚未完成对继承层次结构中所有字段的初始化.\n\n归根到底,这是由于调用虚方法时,直到运行之前都不会选择执行该方法实际的类型.\n\n```csharp\ninternal sealed class SomeType\n{\n  // C# 编译器允许嵌入方式初始化实例字段\n  // 但是在幕后,它会将语法转换成构造器方法中的代码来初始化. <----代码膨胀效应\n  private Int32 m_x = 5;\n}\n```\n这段代码在IL代码如下工作:\n1. SomeType的构造器把值5存储到m_x.\n2. 再调用基类构造器`System.Object::.cotr()`.\n\n```csharp\ninternal sealed class SomeType\n{\n  // 内联方式初始化实例字段   等同于嵌入代码的形式\n  // 会将此种语法转换成代码在构造器方法中来执行初始化\n  // 所以有多少个构造器,都会生成多少次所有字段初始化的代码\n  private Int32  m_x = 5;\n  private String m_s = \"Hi there\";\n  private Double m_d = 3.1415;\n  private Byte   m_b;\n\n  public SomeType(){...}\n  public SomeType(Int32 x){...}\n  // 此构造器的执行过程\n  // 1. 编译器生成代码 初始化m_x,m_s和 m_d(没有显示初始化也保证会被初始化为0)\n  // 2. 调用基类构造器 base()  基类的无参构造器调用\n  // 3. 再调用SomeType(String s) 类型自己的构造器\n  // 4. 用10覆盖掉m_d值\n  public SomeType(String s){...; m_d=10;}\n}\n\n.method public hidebysig specialname rtspecialname\n        instance void  .ctor(string s) cil managed\n{\n  // 代码大小       64 (0x40)\n  .maxstack  2\n  //////////////////////////////////////////////////////////////////\n  IL_0000:  ldarg.0\n  IL_0001:  ldc.i4.5\n  IL_0002:  stfld      int32 ConsoleApp1.SomeType::m_x\n  IL_0007:  ldarg.0\n  IL_0008:  ldstr      \"Hi there\"\n  IL_000d:  stfld      string ConsoleApp1.SomeType::m_s\n  IL_0012:  ldarg.0\n  IL_0013:  ldc.r8     3.1415000000000002\n  IL_001c:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_0021:  ldarg.0\n  ////////////////////以上就是每个构造器都要生成的初始化m_x,m_s和 m_d代码\n  // 调用基类构造器\n  IL_0022:  call       instance void [System.Runtime]System.Object::.ctor()\n  IL_0027:  nop\n  IL_0028:  nop\n  // 调用自己的构造器\n  IL_0029:  ldarg.0\n  IL_002a:  ldarg.1\n  IL_002b:  stfld      string ConsoleApp1.SomeType::m_s\n  // m_d=10;用10覆盖掉m_d值\n  IL_0030:  ldarg.0\n  IL_0031:  ldc.r8     10.\n  IL_003a:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_003f:  ret\n} // end of method SomeType::.ctor\n```\n\n1. **编译器为这3个构造器方法生成代码时,在每个方法的开始位置,都会包含用于初始化m_x,m_s和m_d的代码.**\n2. **在这些初始化代码之后,编译器会插入对基类构造器的调用.**\n3. **再然后,会插入构造器自己的代码.**\n\n\n_**编译器在调用基类构造器前使用简化语法对所有字段初始化.**_\n\n因此上述3个构造器就要生成3次这样相同的代码(初始化m_x,m_s和 m_d代码).\n\n## 优化构造器代码膨胀效应的方法\n\n如果有几个已初始化的实例字段和许多重载构造器方法,可以创建单个构造器来执行公共的初始化. 让其他构造器都显示调用这个公共初始化构造器.  不显示初始化字段(不在定义时赋值初始化).\n\n```csharp\n    public sealed class SomeType\n    {\n        // 不要显示初始化下面的字段,减少生成相同的代码\n        // 不然会在没个构造器中生成相同的初始化代码,\n        private Int32  m_x;\n        private String m_s;\n        private Double m_d;\n        private Byte   m_b;\n\n        public SomeType()\n        {\n            m_x = 5;\n            m_s = \"ssss\";\n            m_d = 3.1415;\n            m_b = 0xff;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        public SomeType(Int32 x) : this()\n        {\n            m_x = x;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        // 用10覆盖m_d\n        public SomeType(String s) : this()\n        {\n            m_s = s;\n            m_d = 10;\n        }\n        // 先调用基类System.Object的无参构造器\n        // 调用自己的无参构造器初始化\n        public SomeType(Byte b) : this()\n        {\n            m_b = b;\n        }\n    }\n\n.method public hidebysig specialname rtspecialname\n        instance void  .ctor(string s) cil managed\n{\n  // 代码大小       31 (0x1f)\n  .maxstack  8\n  IL_0000:  ldarg.0\n  IL_0001:  call       instance void ConsoleApp1.SomeType::.ctor()\n  IL_0006:  nop\n  IL_0007:  nop\n  IL_0008:  ldarg.0\n  IL_0009:  ldarg.1\n  IL_000a:  stfld      string ConsoleApp1.SomeType::m_s\n  IL_000f:  ldarg.0\n  IL_0010:  ldc.r8     10.\n  IL_0019:  stfld      float64 ConsoleApp1.SomeType::m_d\n  IL_001e:  ret\n} // end of method SomeType::.ctor\n```\n\n> 如果还在字段定义时赋值, 其他构造器使用:this(),则不会在这些构造器中生成字段初始化的代码,而会在无参构造器中生成. 关键在于:this()\n\n\n# 实例构造器和结构(值类型)\n\n值类型(struct)构造器的工作方式与引用类型(class)的构造器截然不同. CLR总是允许创建值类型的实例,并且没有办法阻止类型的实例化.\n\n- 值类型构造器需要显示调用才会执行.\n- 不显式调用构造器都将初始化为0或null\n- C#编译器不允许结构包含显式的无参构造器.\n- 由于不能定义无参构造器,所以编译器永远不会生成自动调用它的代码\n\n> **引用类型中的字段** 保证初始化为0或null, C#是能生成\"可验证\"代码的编译器,可以保证所以 **基于栈的值类型字段** 对它们进行\"置零\".\n\n## 关于值类型的实例构造器\n\n1. C#不允许 值类型带有无参构造器\n2. 也就不允许值类型使用内联实例字段的初始化语法\n  1. `private Int32 m_x =5;` 在结构中会编译出错.\n3. 值类型的任何构造器都必须初始化值类型的全部字段. 否则编译出错.\n\n```csharp\npublic SomeType(Int32 x)\n{\n  // 值类型结构中,this代表值类型本身的一个实例, 可以赋值(引用类型this是只读的)\n  // 显示调用无参值类型构造函数, 所有值类型字段初始化为0或null\n  this = new SomeType();\n\n  // 覆盖原始的0\n  m_x = x;\n  // m_y已经初始化,所以不会编译出错.\n}\n```\n\n# 类型构造器\n\n除了实例构造器,CLR还支持类型构造器.也称为静态构造器,类构造器,类型初始化器.\n\n- 类型构造器的作用是`设置类型`的初始状态.\n  - 实例构造器作用是`设置类型实例`的初始状态.\n- 类型构造器永远没有参数\n- 类型构造器必须标static,且默认不可更改,访问性是private\n\n类型默认没有定义类型构造器, 如果定义也只能定义一个.\n\n```csharp\ninternal sealed class SomeRefType\n{\n    // 类型构造器必须标static,且默认不可更改访问性是private\n    static SomeRefType()\n    {\n        // SomeRefType被首次访问时,执行这里的代码\n    }\n}\n\n/// 永远不要定义值类型类型构造器, CLR有时不会调用值类型的静态类型构造器\ninternal struct SomeValType\n{\n    // C#允许值类型定义无参的构造类型\n    // 类型构造器必须标static,且默认不可更改访问性是private\n    static SomeValType()\n    {\n        // SomeValType被首次访问时,执行这里的代码\n    }\n}\n```\n之所以是私有,是为了防止任何开发人员写代码去调用它,**对它(类型构造器)的调用总是由CLR负责.**\n\n\n\n1. 不要在静态构造函数中执行复杂的逻辑、它只是为了对静态字段进行初始化而设置的,并且只能访问静态字段.\n2. 不要出现两个或者多个类的静态构造函数相互调用的情况，因为它是线程安全的，是要加锁的，如果出现相互调用，可能导致死锁。\n3. 不要在类的静态构造函数中写你期望按照某个顺序执行的代码逻辑，因为静态构造函数的调用时由CLR控制的，程序员不能准确把握运行时机。\n4. **永远不要定义值类型类型构造器, CLR有时不会调用值类型的静态类型构造器**\n5. 如果在类型构造器中抛出未处理的异常,CLR会认为类型不可用,访问该类型的字段或方法都会抛出`System.TypeInitializationException`异常.\n\n\n> CLR并不支持静态的Finalize方法, 就是在类型卸载时执行一些代码,类型只有在AppDomain卸载时才会卸载,AppDomain卸载时,用于标识类型的对象将成为不可达的对象,垃圾回收期会回收类型对象的内存.\n> 要实现这样的需求,要在AppDomain卸载时执行一些代码,可向System.AppDomain类型的DomainUnload啥时间登记一个回调方法.\n\n\n# 操作符重载方法\n\nCLR对操作符重载一无所知.甚至不知道什么是操作符.\n\n- 操作符重载必须是 public static\n- 操作符重载方法的参数类型至少有一个和当前定义这个方法的类型相同.(能在合理的时间内找到要绑定的操作符重载方法)\n- 编译器会为名为op_Addition的方法生成元数据方法定义项,还会设置一个specialname标志.表明这是一个特殊的方法.\n\n\n```csharp\npublic sealed class Complex\n{\n  public static Complex operator+(Complex c1, Complex c2){...}\n}\n```\n\n\n> FCL的System.Decimal类型很好地演示了如何重载操作符并根据Microsoft的设计规范定义友好的方法名.\n\n## 操作符方法的友好名称方法\n\n![](8方法/操作符.png)\n\n```csharp\npublic sealed class Complex\n{\n  // 重载操作符方法\n  public static Complex operator+(Complex c1, Complex c2){...}\n  // 定义友好方法,内部调用操作符重载方法\n  public static Complex Add(Complex c1, Complex c2){ return c1+c2;}\n}\n```\n\n> 作者认为这种额外的复杂性没必要,调用它们导致额外的性能损失.\n\n# 转换操作符方法\n\n将对象从一种类型转换为另一种类型.\n- 如果源类型和目标类型都是编译器识别的基元类型,编译器自己就知道如何生成转换对象所需的代码.\n- 如果不是,编译器会生成代码,要求CLR执行强制转型.\n- 转换操作符重载方法必须是 public static\n\n```csharp\ninternal sealed class Rational\n{\n    public Rational(Int32 num)\n    {...}\n\n    public Rational(Single num)\n    {...}\n\n    public Int32 ToInt32()\n    {...}\n\n    public Single ToSingle()\n    {...}\n\n    // implicit关键字告诉编译器为了生成代码来调用方法. 不需要在源代码中进行显示转换.\n    // 由一个Int32隐式构造并返回一个Rational\n    public static implicit operator Rational(Int32 num)\n    {\n        return new Rational(num);\n    }\n\n    // 由一个Single隐式构造并返回一个Single\n    public static implicit operator Rational(Single num)\n    {\n        return new Rational(num);\n    }\n\n    // explicit关键字告诉编译器只有在发现了显示转型时,才调用方法.\n    // 由一个Rational 显式返回一个Int32\n    public static explicit operator Int32(Rational r)\n    {\n        return r.ToInt32();\n    }\n\n    // 由一个Rational 显式返回一个Single\n    public static explicit operator Single(Rational r)\n    {\n        return r.ToSingle();\n    }\n}\n```\n\n- `implicit关键字`\n  - 该关键字告诉编译器为了生成代码来调用方法. 不需要在源代码中进行显示转换.\n- `explicit关键字`\n  - 该关键字告诉编译器只有在发现了显示转型时,才调用方法.\n\n关键字之后要指定operator关键字告诉编译器该方法是一个转换操作符, 在operator之后,指定对象要转换成什么类型,圆括号内指定要从什么类型转换.\n`public static explicit/implicit operator 目标类型(源类型 r)`\n\n定义完转换操作符之后,就可以写出像下面这样的C#代码:\n```csharp\nRational r1 = 5; // Int32隐式转型为Rational\nRational r2 = 2.5f;// Single隐式转型为Rational\n\nInt32 x = (Int32) r1; // Rational 显示转型为Int32\nSingle s = (Single) r2;// Rational显示转型为Single\n```\n\n**使用强制类型转换表达式时,C#生成代码来调用显示转换操作符方法, 使用C#的as或is操作符时,则永远不会调用这些方法.**\n\n要理解操作符重载和转换操作符方法. 建议用`System.Decimal`类型作为典型来研究.\n\n\n# 扩展方法\n\n理解C#扩展方法最好是从例子中学习.\n\n允许定义一个静态方法,并用实例方法的语法来调用. 只需要在第一个参数前添加this关键字.\n\n```csharp\npublic static class StringBuilderExtensions\n{\n    public static Int32 IndexOf(this StringBuilder sb, Char value)\n    {\n        ....\n    }\n}\n```\n\n这样就可以通过`Int32 index = sb.IndexOf('X');`方式去调用.\n\n编译这句话的过程:\n1. 首先检查`StringBuilder`类或者它的任何基类是否提供了参数为Char,名为IndexOf的一个实例方法.\n2. 如果有,就生成IL代码来调用它.\n3. 如果没有找到匹配的实例方法,就继续检查是否有任何静态类定义了名为IndexOf的静态方法,方法的第一个参数和类型和当前调用方法的表达式类型匹配,必须用this关键字标识.\n4. 编辑器就会找到`IndexOf(this StringBuilder sb, Char value)`方法,生成对应的IL代码来调用这个静态方法.\n\n\n## 扩展方法的规则和原则\n\n- C#**只支持扩展方法**,不支持扩展属性,扩展事件,扩展操作符等等.\n- 扩展方法(第一个参数前面有this的方法)必须在 **非泛型的静态类** 中声明.\n- 类名没有限制.\n- 至少要有一个参数,而且第一个参数能用 **this关键字标记**.\n- 扩展方法必须在 **顶级静态类** 中定义.具有 **整个文件的作用域** (不能嵌套在另一个类中而只有该类的作用域).\n- C#要求导入扩展方法所在的命名空间. 例如:在`Wintellect`命名空间下定义了一个扩展方法,那么别人访问这个扩展方法就需要添加`using Wintellect;`语句.\n- 如果多个静态类存在相同的扩展方法,就必须显示指定静态类(扩展方法所在类)的名称,明确指定.\n- 同时也会扩展派生类型.\n- 如果`StringBuilder`未来提供了`IndexOf`方法,则程序不会调用我的静态扩展方法,而是绑定微软提供的`IndexOf`方法.\n- 由于扩展方法实际是一个静态方法的调用.**CLR不会对调用的表达式进行null值检查(不保证非空)**.\n\n```csharp\nStringBuilder sb = null;\n// 调用扩展方法: NullReferenceException异常不会在调用IndexOf时抛出\n// 而会在,IndexOf内部的for循环中抛出\nsb.IndexOf('x');\n// 调用实例方法,NullReferenceException异常在调用Replace时抛出\nsb.Replace('x','!');\n```\n\n\n## 为接口类型定义扩展方法\n\n\n```csharp\nclass Program\n{\n\n    static void Main(string[] args)\n    {\n        // 每个char在控制台上单独显示一行\n        \"Grant\".ShowItems();\n\n        // 每个String在控制在单独显示一行\n        new[]{\"Jeff\",\"Kristin\"}.ShowItems();\n\n        // 每个Int32在控制台上单独显示一行\n        new List<Int32>(){1,2,3}.ShowItems();\n    }\n}\n\nstatic class ExClass\n{\n    // // 任何表达式只要它最终的类型实现了IEnumerable<T>接口,就能此调用扩展方法\n    public static void ShowItems<T>(this IEnumerable<T> collection)\n    {\n        foreach (var item in collection)\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n```\n\n任何表达式只要它最终的类型实现了`IEnumerable<T>`接口,就能调用此扩展方法.\n\n### LINQ (Language Integrated Query) 语言集成查询\n\n想要仔细研究提供了许多扩展方法的一个典型类, System.LinQ.Enumerable及其所有静态扩展方法.这个类中每个扩展方法.\n\n\n##  为委托类型定义扩展方法\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 抛出NullReferenceException\n        Action<Object> action = o => Console.WriteLine(o.GetType());\n        // 吞噬NullReferenceException\n        action.InvokeAndCatch<NullReferenceException>(null);\n    }\n}\n\nstatic class ExClass\n{\n    public static void InvokeAndCatch<TException>(this Action<Object> d, Object o) where TException : Exception\n    {\n        try { d(o); }\n        catch (TException) { }\n    }\n}\n```\n\n## 向枚举类型添加扩展方法\n\n在15.3节有例子.\n\n## 创建委托来引用对象上的扩展方法\n\n```csharp\nAction a = \"Jeff\".ShowItems;\n\n// 调用(Invoke)委托,后者调用(call)ShowItems\n// 并向它传递对字符串\"Jeff\"的引用\na();\n```\n\n1. 编译器生成IL代码来构造一个Action委托.\n2. 创建委托时,会向构造器传递应调用的方法,同时传递一个对象引用,这个引用传给方法的隐藏this阐述.\n3. 正常情况下,创建引用静态方法的委托时,对象引用为null,因为静态方法没有this参数\n4. 这个例子中,C#编译器生成特殊代码创建一个委托来引用静态方法(ShowItems),而静态方法的目标对象是\"Jeff\"字符串的引用.\n5. 这个委托被调用时,CLR会调用静态方法,并向其传递对\"Jeff\"字符串的引用.\n\n\n\n### 关于invoke和call的翻译区别\n调用:\n- `invoke`:理解为`唤出`更为恰当,  需要先唤出某个东西帮你调用一个信息不明的方法时,用invoke比较恰当.\n- `call`:调用, 在执行一个所有信息都已知的方法时,用call比较恰当.\n\n## ExtensionAttribute特性类\n\n1. 一旦用this关键字标记了某个静态方法的第一个参数\n2. 编辑器就会在内部向该方法应用一个定制特性\n3. 此特性会在最终生成的文件的元数据中持久性的存储下来.\n4. 任何静态类只要包含扩展方法,它的元数据也会应用这个特效.\n\n\n# 分部方法\n\n假设用某个工具生成了C#源代码文件,并且这个类会让你定制类型的行为.\n一般做法:\n1. 定义个虚方法\n2. 从这个类派生并定义自己的类\n3. 重写虚方法,实现定制的行为\n\n```csharp\n//工具生成的代码，存储在某个代码文件中\ninternal class Base\n{\n    private String m_name;    \n    // 虚方法定义\n    protected virtual void OnNameChanging(String value){}\n\n    public String Name\n    {\n        get{return m_name;}\n        set{\n            OnNameChanging(value.ToUpper());\n            m_name=value;\n        }\n    }\n}\n//开发人员生成的代码。存储在另一个源代码文件中\ninternal class Derived:Base\n{\n    protected override void OnNameChanging(string value)\n    {\n        if(String.IsNullOrEmpty(value))\n            throw new ArgumentNullException(\"value\");\n    }\n}\n```\n\n这个做法有几个问题:\n1. 因为用到继承,所以基类不能是密封类,也不能用于值类型(值类型隐式密封).\n2. 不能用于静态方法,静态方法不能重写.\n3. 效率问题,如果派生类不重写方法,也会生成对ToUpper()进行调用的IL代码\n\n以下用 **分部方法** 功能来解决,并且在一些情况下能提升运行时性能:\n\n```csharp\n//工具生成的代码，存储在某个代码文件中\ninternal sealed partial class Base\n{\n    private String m_name;\n\n    // 分部方法的声明\n    partial virtual void OnNameChanging(String value);\n    public String Name\n    {\n        get{return m_name;}\n        set{\n            OnNameChanging(value.ToUpper());\n            m_name=value;\n        }\n    }\n}\n//开发人员生成的代码。存储在另一个源代码文件中\ninternal sealed partial class Base\n{\n    partial void OnNameChanging(string value)\n    {\n        if(String.IsNullOrEmpty(value))\n            throw new ArgumentNullException(\"value\");\n    }\n}\n```\n1. 类可以是密封类,静态类,值类型.\n2. 工具生成的代码包含分部方法的声明,要用partial关键字标记,无主体.\n3. 开发者生成的代码实现这个声明. 该方法也要用partial关键字标记,有主题.\n\n> 输入partial按空格能智能感知列出当前类型定义的还没有匹配实现的所有分部方法声明.\n\n**如果不提供自己的源文件(不需要修改工具生成的类型的行为),编译器编译工具生成的代码就不会包含任何代表分部方法的元数据,也不会生成任何调用分部方法的IL指令. 而且, 编译器不会生成对本该传给分部方法的实参进行求值的IL指令.** 在此例中,编译器不会生成调用ToUpper方法的代码. 使运行时的性能得到了提升.\n\n## 分部方法的规则和原则\n\n1. 只能在分部类或结构中声明.\n2. 分部方法的返回类型始终是void, 任何蚕食都不能用out修饰符来标记.\n  1. 是因为运行时,方法可能不存在(之前说过,可以不提供自己的实现代码),不能进行初始化(out参数必须进行初始化)\n3. 分部方法可以有ref参数,可以是泛型方法,可以使实例或静态方法,而且可以标记为unsafe.\n4. 分部方法的声明和实现必须有完全一致的签名.\n5. 分部方法总是被视为private方法,但C#编译器禁止在分部方法声明之前添加private关键字.\n6. 如果没有对应的实现部分,便不能在代码中创建一个委托来引用这个分部方法.\n","tags":["CLR读书笔记"]},{"title":"7常量和字段","url":"/2019/07/27/7常量和字段/","content":"\n# 常量\n\n`常量`是从不变化的符号. 它的值必须能在编译时确定. 编译器将常量值保存到程序集的元数据中. 这意味着只能定义编译器识别的基元类型常量.\n- Boolean\n- Char\n- Byte\n- SByte\n- Int16\n- UInt16\n- Int32\n- UInt32\n- Int64\n- UInt64\n- Single (float)\n- Double\n- Decimal\n- String\n\n特殊的是: C#允许定义非基元类型的常量变量,但是必须为null;\n\n`public const SomeType Empty = null;`\n\n定义常量将导致创建元数据,总是被视为静态成员,而不是实例成员.\n\n>  C#不允许为常量指定static关键字,因为常量是总是隐式的static.\n\n## 常量是怎么保存的?\n\n1. 代码引用常量符号时, 编译器在定义常量的程序集的元数据中查找符号,提取常量的值,将值嵌入生成的IL代码中.\n2. 由于常量的值直接嵌入代码,所以运行时不需要为常量分配任何内存.\n3. 不能获取常量的地址,也不能以传引用的方式传递常量\n4. 不能很好的支持跨程序集的版本控制\n\n## 常量的跨程序集问题\n\n```csharp\n// 程序集A 类TypeA\npublic const A = 50;\n```\n\n```csharp\n// 程序集B,引用了程序集A\nConsole.WriteLine(TypeA.A);\n```\n\n程序集B生成应用程序B之后, 用IL代码看出, **常量值直接嵌入IL代码**.\n\n如果程序集A,开发人员改变常量值为1000,只重新生成程序集A,应用程序B不会被影响,常量值还是50. 只有重新编译程序集B并生成才可以.\n\n如果希望在运行时从一个程序集中提取另一个程序集的值,不应该使用常量,而应该使用`readonly`字段.\n\n# 字段\n\n`字段`是一种数据成员,其中容纳了一个值类型的实例或者对一个引用类型的引用.\n\n\n![](7常量和字段/字段修饰符.png)\n\n> volatile 翻译为可变的, 其实它是短暂存在,易变的意思,因为可能有多个线程都想对这个字段进行修改. \"易变/易失\" 翻译更佳.\n\nCLR支持\n- 类型字段.(**静态**)\n  - 容纳字段数据所需的动态内存是在`类型对象`中创建时分配的. `类型对象`是在类型加载到`AppDomain`时创建的.\n\n> 类型对象通常是在引用了 **该类型的任何方法首次进行JIT编译** 的时候,将该类型加载到AppDomain中.\n\n- 实例字段.(**非静态**)\n  - 容纳字段数据所需的动态内存是在 **构造类型的实例时分配** 的.\n\n\n字段存储在动态内存中,它们的值在运行时才能获取.(字段还解决了常量存在版本控制问题). 此外字段可以使任何数据类型,不像常量仅仅局限于编译器内置的基元类型.\n\nCLR支持`readonly字段`和`read/write字段`.\n- `readonly字段`\n  - 只能在构造器方法中写入.(构造器方法只调用一次,即对象首次创建的时.)\n  - 编译器和验证机制确保readonly字段不会被构造器以外的任何方法写入.\n  - **可以利用反射来修改readonly字段(非常规手段反射,操作内存)**.\n\n更改上一段代码,程序集B的代码不需要改,这样如果修改程序集A的值为1000,程序集B不需要重新编译就能获取到新值.\n```csharp\n// 程序集A 类TypeA\n// 字段和类型关联需要用static关键字\npublic static readonly A = 50;\n```\n\n**当某个字段是引用类型,并且该字段被标记为readonly时,`不可变的是引用`,而不是`字段引用的对象`.**\n\n```csharp\n\npublic static readonly Char[] cc = new Char[]{'a','b','c'};\n...\n// 合法的,可以通过编译\ncc[0] = 'A';\n\n// 非法的,无法通过编译,因为不能让cc引用别的东西\ncc = new Char[]{'x','y','z'};\n```\n\n\n## 如何定义一个与类型本身关联的字段\n\n```csharp\n// 这是一个静态的readonly字段; 在运行时对它初始化\n// 它的值会被计算并存储到内存中\npublic static readonly Random s_random = new Random();\n\n// 静态的可读可写字段\nprivate static Int32 s_numberOfWrites = 0;\n\n// 实例只读的字段\npublic readonly String Pathname = \"Untitled\";\n\n// 实例可读可写的字段\nprivate System.IO.FileStream m_fs;\n\npublic SomeType(String pathname)\n{\n    // 修改只读字段Pathname\n    // 在构造器中可以这样做\n    this.Pathname = pathname;\n}\n```\n\n上述代码许多字段都是`内联初始化`的. C#允许使用这种内联初始化语法来初始化类的`常量`,`可读可写字段`和`readonly字段`.\n\nc#其实是在构造器对字段进行初始化的, 字段的内联初始化只是一种语法上的简化.(有些情况用内联语法需要考虑性能问题)\n\n> 内联初始化: 代码中直接赋值来初始化,而不是将对构造器的调用写出来.\n","tags":["CLR读书笔记"]},{"title":"6类型和成员基础","url":"/2019/07/23/6类型和成员基础/","content":"\n# 类型的各种成员\n\n- **常量**\n  - 是指出`数据值恒定不变`的符号, 总与类型关联,不与类型实例关联. 逻辑上总是静态成员.\n- **字段**\n  - 表示只读或可读/可写的数据值.\n  - 字段可以是静态的,这种被认为是`类型`状态的一部分.\n  - 字段也可以是实例非静态,这种被认为是`对象`状态的一部分.\n- **实例构造器**\n  - 将`新对象的实例字段`初始化的特殊方法.\n- **类型构造器**\n  - 将`类型的静态字段`初始化的特殊方法.\n- **方法**\n  - 是更改或查询类型或对象状态的函数.\n  - 作用于类型称为静态方法.\n  - 作用于对象称为实例方法.\n- **操作符重载**\n  - 实际上是方法.定义了操作符用于对象时应该如何操作该对象. 不是所有编程语言都支持,所以不属于CLS.\n- **转换操作符**\n  - 定义如何隐式或显示将对象从一种类型转换为另一种类型的方法.不是所有编程语言都支持,所以不属于CLS.\n- **属性**\n  - 允许用简单的字段风格的语法设置或查询类型或对象的逻辑状态,同时保证状态不被破坏.\n  - 作用于类型的称为静态属性.\n  - 作用于对象的称为实例属性.\n  - 属性可以无参(非常普遍)\n  - 多个参数(集合类用得多)\n- **事件**\n  - 静态事件允许`类型`向一个或多个`静态或实例方法`发送通知.\n  - 非静态(实例)事件允许`对象`向一个或多个静态或实例方法发送通知.\n  - 事件包含两个方法:允许静态或实例方法`登记`或`注销`对该事件的关注.\n  - 通常还用一个`委托字段`来维护`已登记`的方法集\n- **类型**\n  - 可以定义其他嵌套`类型` (`内/外部类`).\n\n > 元数据是整个Microsoft .Net Framework开发的关键 .元数据实现了编程语言,类型和对象的无缝集成.\n\n源代码中定义的所有成员都造成编译器生成元数据.有些数据还造成编译器生成额外的成员和额外的元数据.\n\n```csharp\n   public sealed class SomeType                              // 1\n   {\n       // 嵌套类\n       private class SomeNestedType { }                      // 2\n\n       // 常量\n       private const Int32 c_SomeConstant = 1;               // 3\n       // 只读\n       private readonly String m_SomeReadOnlyField = \"2\";    //4\n       // 静态可读/可写字段\n       private static Int32 s_SomeReadWriteField = 3;        // 5\n\n       // 类型构造器\n       static SomeType(){}                                    // 6\n\n       // 实例构造器\n       public SomeType(Int32 x){}                             // 7\n       public SomeType(){}                                    // 8\n\n       // 实例方法和静态方法\n       private String InstanceMethod(){ return null; }        // 9\n       public static void Main(){}                            // 10\n\n       // 实例属性\n       public Int32 SomeProp                                  // 11\n       {\n           get { return 0;}                                   // 12\n           set {  }                                           // 13\n       }\n\n       // 实例有参属性\n       public Int32 this[String s]                            // 14\n       {\n           get { return 0; }                                  // 15\n           set { }                                            // 16\n       }\n\n       // 实例事件\n       public event EventHandler SomeEvent;                   // 17\n```\n![](6类型和成员基础/IL成员代码.png)\n\n![](6类型和成员基础/IL图示.png)\n\n例如: 事件成员(17)造成编译器生成\n- 一个字段\n- 两个方法\n- 事件(一些额外的元数据)\n\n\n# 类型的可见性\n\n- **public** 类型:不仅对`定义程序集`中的所有代码可见,还对`其他程序集`中的代码可见.\n- **internal** 类型: 仅对`定义程序集`中的所有代码可见. 对其他程序集代码不可见.\n\n定义类型时如果不显示指定可见性,C#编译器会指定为`internal`.\n\n\n## 什么情况下要友元程序集?\n\n假设下述情形:\n一个公司有A团队和B团队, A团队定义了一组工具类,并希望团队使用这些类型. 但是他们不能将所有类型都生成到一个程序集中,而都要生成自己的程序集.\n\n为了使B团队使用A的工具类,A团队必须将工具类定义为`public`. 这样意味着工具类对所有程序集公开,连C团队也能使用. 这不是A团队所希望的.\n\n为了做到用`internal`定义工具类,同时B团队也能访问,C#可以通过`友元程序集`功能实现.\n\n### 示例做法\n\n1. 生成程序集时,用System.Runtime.CompilerServices命名空间下的InternalsVisibleTo特性,**标明它认为是友元的其他程序集**.\n2. 传入标识 **友元程序集名称** 和 **公钥的字符串参数**(不能包含版本,语言文化和处理器架构)\n3. 之后被标注的程序集能访问该程序集的 **所有internal类型**,以及 **这些类型的internal成员**.\n\n\n```csharp\nusing System.Runtime.CompilerServices;\n\n// 这里指定Wintellect和Microsoft是友元程序集\n[Assembly:InternalsVisibleTo(\"Wintellect, Publickey=12314..sbasd\")]\n[Assembly:InternalsVisibleTo(\"Microsoft, Publickey=asdas...basd\")]\n\ninternal sealed class SomeInternalType{...}\ninternal sealed class AnotherSomeInternalType{...}\n```\n\n\n> C#编译器在编译友元程序集(不含InternalsVisibleTo特性的程序集)要求使用/out:<file>开关, 因为编译器要知道准备编译的程序集的名称,从而判断生成的程序集是不是友元程序集.(意思是编译Wintellect和Microsoft程序集时,在代码编译结束前,C#编译器是不知道输出文件名的,因此使用/out:<file>能极大增强编译性能.)\n\n> 使用/t:module开关来编译模块,而且该模块还是友元程序集的一部分,那就需要C#编译器使用/moduleassemblyname:<string>开关来编译该模块.\n\n\n# 成员的可访问性\n\n每种编程语言都有自己的一组术语以及相应的语法. CLR自己定义了一组可访问性修饰符.\n\n例如:\n- CLR使用`Assembly`表明成员对同一程序集内的所有代码可见.\n- C#对应的术语是 `internal`\n\n![](6类型和成员基础/成员可访问性.png)\n\n表中总结了6个应用于成员的可访问性修饰符. 从第一行到最后一行按照限制最大到限制最小的顺序排列.\n\n- `private`:只能由`定义类型`和`任何嵌套类型`中的方法访问\n- `protected`: 能被`定义类型的方法`,`任何嵌套类型中的方法` 和`无论在什么程序集中`的`派生类型中的方法`访问.\n- `internal`: 只能被`当前定义的程序集中`的方法访问. (比public限制高,限制了程序集)\n- `protected internal`:能被`任何内/外部类(嵌套类)`, `无论在什么程序集中的派生类型`,`当前程序集中的任何方法`访问.\n- `public`: 能被`任何程序集中的任何方法`访问.\n\n\n在C#中,如果没有显示声明成员的可访问性,编译器通常默认选择private.\n\n> CLR 要求接口类型的所有成员都具有public可访问性. C#编译器因此禁止开发人员显示指定接口成员的可访问性.自动设为public.\n\nC#限制派生类重写基类方法需要具有相同的可访问性.\n\nCLR允许`放宽限制`,但不允许`收紧限制`(基类protected,派生类可以public,但不可以是private). 否则就无法派生类转为基类时,获取不到基类方法的访问权.\n\n\n# 静态类\n\n例如Console,Math,Environment,ThreadPool类,永远不需要实例化的类,只有static成员.\n\n`static`关键字定义不可以实例化的类. 只能应用于类,不能应用于结构(值类型). CLR总是允许值类型实例化.\n\n## C#编译器对静态类做了如下限制\n\n1. 静态类必须直接从基类System.Object派生. 继承只适用于对象,静态类不能创建实例.因此从其他任何积累下派生都没有意义.\n2. 静态类不能实现任何接口. 只有使用类的实例时,才能调用类的接口方法.\n3. 静态类只能定义静态成员(字段,方法,属性和事件).\n4. 静态类不能作为字段,方法参数或局部变量使用. 因为它们都代表引用实例的变量.\n\n> IL会将static定义类标记为absrtact和sealed. 并且不生成实例构造器方法.\n\n\n# 分部类,结构和接口\n\n`partial` 关键字告诉C#编译器: 类,结构或接口的定义源代码可能要分散到一个或多个源代码文件中.\n\n1. 源代码控制\n  - 多个程序员修改一个类,使用`partial`为多个文件后,每个文件可以单独签出,多个程序员能同时编辑类型.\n2. 在同一个文件中将类或结构分解不同的逻辑单元\n  - 有时会创建一个类型提供多个功能,为简化实现,会在源代码中重复声明一个分部类型,分部类型的每个部分都实现一个功能.也可以完整的删除一个功能.\n3. 代码拆分\n\n\n**要将`partial`关键字应用于所有文件中的类型. 编译到一起时, 编译器会合并代码. 分部类功能完全由C#编译器实现. CLR对此一无所知.**\n\n# C#关键字及其对组件版本控制的影响\n\n![](6类型和成员基础/C#关键字及其对组件版本控制的影响.png)\n\n这些关键字直接对应CLR用于支持组件版本控制的功能.\n\n# CLR如何调用虚方法,属性和事件\n\n> 属性和事件实际作为方法实现.\n\n## 方法是什么?\n\n方法代表类型或类型上的实例上执行某些操作的代码. 在类型上操作是静态方法,在实例上操作是非静态方法.\n\n## CLR允许定义多个同名方法,根据返回类型不同或者参数不同\n\n**除了IL语言,包括C#大多数语言在判断方法的唯一性时,除了方法名之外,都只以参数为准,方法返回类型会被忽略.**\n\n- 非虚实例方法 `public Int32 MethodA()`\n- 虚方法`public virtual String MethodB()`\n- 静态方法`public static Int32 MethodC()`\n\n 编译这些方法,编译器会在程序集的方法定义表中写入记录项,每个记录项都用一组`flag标志`指明方法的类型.\n\n 调用这些方法时, 生成调用代码的编译器会检查方法定义的`标志flag`,来生成对应的IL代码来调用.\n\n## callvirt和call指令调用非虚方法,虚方法,静态方法\n\n CLR提供两个方法调用指令:\n 1. call\n   - 用call指令调用静态方法,必须指定定义此静态方法的类型.\n   - 用call指令调用实例方法或虚方法,必须指定引用了对象的变量(就是调用方法的变量的定义类型).\n     - 如果调用方法的变量没有定义此方法,就会检查基类来查找匹配方法.\n   - 常用于以非虚方式调用虚方法.\n 2. callvirt\n   - 用callvirt可调用实例方法和虚方法,不能调用静态方法.\n   - 必须指定引用了对象的变量.\n   - 用callvirt调用非虚方法,变量的类型指明了方法的定义类型.\n   - 用callvirt调用虚实例方法,CLR会调查发出的调用对象的实际类型,然后以多态方式调用方法.\n   - 为了确定类型,发出调用的变量不能为null. JIT编译器会生成代码来验证变量的值是不是null.(抛出NUllReferenceException异常)\n   - 用callvirt调用非虚实例方法也会执行这种null检查. 所以用callvirt指令执行速度比call指令稍慢.\n\n\n```csharp\n// 调用静态方法\nConsole.WriteLine();\n\nObject o = new Object();\n// 调用虚方法\no.GetHashCode();\n// 调用非虚方法\no.GetType();\n```\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       28 (0x1c)\n  .maxstack  1\n  .locals init (object V_0)\n  IL_0000:  nop\n  // 静态方法会使用call指令\n  IL_0001:  call       void [System.Console]System.Console::WriteLine()\n  IL_0006:  nop\n  IL_0007:  newobj     instance void [System.Runtime]System.Object::.ctor()\n  IL_000c:  stloc.0\n  IL_000d:  ldloc.0\n  // 这里用callvirt 是因为GetHashCode是虚方法\n  IL_000e:  callvirt   instance int32 [System.Runtime]System.Object::GetHashCode()\n  IL_0013:  pop\n  IL_0014:  ldloc.0\n  // 这里用callvirt , Type是非虚方法,在JIT编译好的代码中会以非虚方式调用\n  // 为什么不用直接用call指令呢? 因为C#团队认为JIT编译器应生成代码来验证发出调用的对象不为null\n  IL_0015:  callvirt   instance class [System.Runtime]System.Type [System.Runtime]System.Object::GetType()\n  IL_001a:  pop\n  IL_001b:  ret\n} // end of method Program::Main\n\n```\n\n如果调用非虚方法时, C#编译器生成的是callvirt指令,那么发出调用的对象如果为null就会抛出异常.\n\nC#用`callvirt`指令调用所有 **实例方法**. 用`call`指令调用 **静态方法**.\n\n> 不建议把非虚方法改为虚方法. 这是因为某些编译器会用call而不是callvirt指令调用非虚方法. 并且引用此方法的代码没有重新编译,就会造成应用程序行为无法预料. 用C#写的引用代码不会出问题,因为C#用callvirt指令调用所有实例方法.\n\n## 编译器有时用call而不是callvirt调用虚方法.\n\n特殊的语句:`base.ToString();`\n\n```csharp\npublic override String ToString()\n{\n  // 编译器使用IL指令call\n  // 以非虚方式调用Object的ToString方法\n\n  // 如果编译器用callvirt而不是call\n  // 那么该方法将递归调用自身,直至栈溢出\n  return base.ToString();\n}\n// 如果编译器生成的是callvirt,那么是以虚方式(多态方式)调用, base.ToString还是会调用到重写的当前方法中\n// 再次执行base.ToString导致循环\n// call则是以非虚的方式调用,不会调用到重写的方法中,而是基类自己的ToString方法.\n```\n\n因为callvirt是以虚方式调用, 会导致base.ToString递归执行,直至线程栈溢出.\n\n**编译器调用值类型定义的方法时倾向于使用call指令,因为值类型时密封的,即使有虚方法也不用考虑多态性. 值类型的实例的本质保证它永不为null. 所以永远不抛出NullReferenceException异常.**\n\n如果以虚方式调用值类型的虚方法,CLR要获取对值类型的对象的引用,以便引用方法表.需要装箱.\n\n## call和callvirt的区别\ncall的callvirt的区别主要有两点：\n\n- `call`可以调用 **静态方法**，`实例方法和虚方法`\n- `call`一般是以 **非虚的方式** 来调用函数的.\n\n- `callvirt`不能调用 **静态方法**,只能调用`实例方法和虚方法`，\n- `callvirt`是以 **已多态(虚方式)的方式** 来调用函数的.\n\n## 设计类型时要注意\n\n1. 虚方法的调用速度比调用非虚方法慢.\n2. JIT编译器不能内嵌虚方法. 进一步影响性能\n3. 使最复杂(参数最多)的方法成为虚方法,使所有重载的简便方法成为非虚方法.\n\n\n```csharp\nprivate Int32 m_lenth = 0;\n\n// 重载的简便方法是非虚的\npublic Int32 Find(Object value)\n{\n    return Find(value,0,m_lenth);\n}\n\n// 重载的简便方法是非虚的\npublic Int32 Find(Object value, Int32 startIndex)\n{\n    return Find(value,0,m_lenth -startIndex);\n}\n\n// 功能最丰富的方法是虚方法,可以被重写\npublic virtual Int32 Find(Object value, Int32 startIndex, Int32 endIndex)\n{\n    // 可被重写的实现写这里..\n    //.....\n}\n```\n\n\n# 合理使用类型的可见性和成员的可访问性\n\n默认生成的类是非密封里, 允许使用关键字`sealed`将类型显示标记为密封.\n\n- 性能更好\n  - **如果调用的是密封类的虚方法(C#编译器在生成callvirt指令), JIT会优化并生成代码用非虚方式调用.**\n\n调用虚方法在性能上不及调用非虚方法, 因为CLR必须在运行时查找对象的类型,判断要调用的方法由哪个类型定义.\n\n如果JIT编译器看到使用的是密封类型的虚方法调用, 密封类不会有派生类,就可以采用非虚的方式调用虚方法(call指令),从而生成更高效的代码.\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Point p = new Point(3,4);\n        // C#编译器在此生成callvirt调用虚方法\n        // 但是JIT编译器会优化这个调用,并生成\n        // 代码来非虚地调用ToString,是因为Point是密封类\n        Console.WriteLine(p.ToString());\n    }\n}\npublic sealed class Point\n{\n    private Int32 m_x, m_y;\n\n    public Point(int mX, int mY)\n    {\n        m_x = mX;\n        m_y = mY;\n    }\n    public override string ToString()\n    {\n        return String.Format($\"{m_x},{m_y}\");\n    }\n}\n```\n\n开发人员希望从现有类型派生出一个类,在其中添加额外字段或状态信息. 还希望在派生类中定义`帮助方法(helper method)`或`简便方法(convenience method)`来操作这些额外的字段. 如果是密封类就不合适,可以利用C#的扩展方法来模拟`帮助方法`, 还可以利用`ConditionalWeakTable类`模拟跟踪状态.\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型3","url":"/2019/07/19/5基元类型引用类型和值类型3/","content":"# 回顾总结\n\n2019年8月23日\n\n1. 需要装箱的情况\n\t- 值类型重写的虚方法如果要调用基类的实现,就需要装箱传this指针引用给基方法\n\t- 如果重写基类的虚方法(不需要调用基类实现)就不需要装箱\n\t- 要调用非虚的,继承的方法(GetType)无论如何都要对值类型进行装箱\n\t- 将值类型转型为接口时,进行装箱. 因为接口变量是引用类型\n\n2. 使用接口方法修改已装箱值类型中的字段,在C#中,不用接口方法便无法做到.\n\t- `((IChangeBoxedPoint) o).Change(5,5); // 修改已装箱对象中的值`\n\t- `((Point) o).Change(3, 3); // 值复制到栈上,只在栈上修改`\n\n3. 值类型应该是不可变的,不应该定义任何会修改实例字段的成员,建议标记成`readonly`\n\n4. dynamic(动态绑定)基元类型\n\t- C#编译器允许将表达式/变量的类型标记为`dynamic`\n\t- 对于CLR, `dynamic`与`Object`完全一致.\n\t- C#编译器会生成`payload有效载荷`代码,在运行时检查`var`的实际类型,调用对应的重载版本.\n\t- 编译器 **不允许** 写代码将表达式从Object隐式转成其他类型. 必须显示转型.\n\t- 编译器 **允许** 使用隐式转型语法将表达式从dynamic转型为其他类型.\n\t\t- 运行时,dynamic类型不兼容要转型的类型,则会抛出`InvalidCastException`.\n\t\t- 返回值result具有dynamic类型. 如果运行时调用M方法.返回类型是void,将抛出RuntimeBinderException异常.\n\t- 变量/表达式用dynamic会生成 payload代码,进行动态调度.\n\t- 不能定义对dynamic进行扩展的扩展方法.\n\t- 不能将lanmbda表达式和匿名方法作为实参传给dynamic方法调用. 因为编译器推断不了类型.\n\t- 在foreach或者using语句中的资源被指定了dynamic表达式, 编译器分别将表达式转型为非泛型System.IEnumerable接口或System.IDispose接口.\n\t\t- 转型失败会抛出`RuntimeBinderException`异常.\n\n5. var和dynamic\n\t- var只能用在方法内部声明局部变量,必须显式初始化此变量\n\t- 表达式不能转型为var,但是能转型dynamic,也无需初始化用dynamic声明的变量.\n\n6. dynamic可以显著简化一些反射的代码\n\t- 但是会对性能产生影响\n\t- 如果只是一两个地方需要动态行为,反射做法或许更高效\n\t- dynamic的一个限制是只能访问对象的实例成员,因为dynamic变量必须引用对象\n\n\n# 什么时候需要装箱\n\n- 第一种情况: 将`值类型的实例`传给需要`获取引用类型`的方法.\n\n要获取`值类型`的引用,实例就必须`装箱`.\n\n未装箱值类型比引用类型更\"轻\",归结于\n1. 不在托管堆上分配\n2. 没有堆上的每个对象都有的额外成员:`类型对象指针`和`同步块索引`\n\n其中,由于未装箱值类型没有`同步块索引`,所以不能使用`System.Threading.Monitor(提供同步访问对象的机制)`类型的方法(或C#lock语句),让多个线程同步对实例的访问.\n\n- 第二种情况: 值类型如果`重写的虚方法`(例如Equals,ToString...)方法要`调用基类的实现`时,会`装箱`,通过this指针将`引用`传给基方法.\n\n虽然未装箱的值类型没有`类型对象指针`,但仍可以调用由类型`继承或重写的虚方法`.(比如Equals,GetHashCode,ToString).\n\n值类型可以重写Equals, GetHashCode或者ToString的虚方法，CLR可以非虚地调用该方法，因为值类型是隐式密封的（即不存在多态性），没有任何类型能够从它们派生。如果你重写的虚方法要`调用方法在基类中的实现`，那么在调用基类的实现时，`值类型实例就会装箱`，以便通过`this指针`将对一个堆对象的`引用`传给基方法。\n\n- 第三种情况:\n\n调用非虚的,继承的方法时(比如`GetType`或者`MemberwiseClone`),**无论如何都要对值类型进行装箱**, 因为这些方法由`System.Object`定义,要求this实参是指向`堆对象`的指针.\n\n- 第四种情况:\n\n将值类型的未装箱实例 **转型为某个接口时** 要对实例进行装箱. 是因为接口变量必须包含对堆对象的引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point : IComparable\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        // 重写从System.ValueType继承的ToString方法.\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n        // 实现类型安全的CompareTo方法\n        public Int32 CompareTo(Point other)\n        {\n            // Math.sign方法用来判断一个数到底是正数、负数、还是零。\n            // 利用勾股定理计算哪个Point离(0,0)更远\n            return Math.Sign(\n                Math.Sqrt(m_x * m_x + m_y * m_y) - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));\n        }\n        // 实现IComparable接口的CompareTo方法\n        public int CompareTo(object obj)\n        {\n            if (GetType() != obj.GetType()) throw new ArgumentException(\"obj is not a point\");\n            // 调用类型安全的CompareTo方法\n            return CompareTo((Point) obj);\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p1 = new Point(10,10);\n            Point p2 = new Point(20,20);\n\n            // 调用Point重写的ToString(虚方法)方法,不装箱p1\n            Console.WriteLine(p1.ToString());\n\n            // 调用GetType(非虚方法)时, 要对p1进行装箱\n            // 调用非虚的,继承的方法时, 无论如何都要对值类型进行装箱\n            // 因为这些方法由System.Object定义,要求this实参是指向堆对象的指针.\n            Console.WriteLine(p1.GetType()); // 显示ConsoleApp1.Point\n\n            // p1调用的是CompareTo(Point other),所以p2不需要装箱\n            Console.WriteLine(p1.CompareTo(p2)); // 显示 -1\n\n            // 装箱p1, 引用放到c中\n            // 将值类型的未装箱实例 转型为某个接口时 要对实例进行装箱\n            IComparable c = p1;\n            Console.WriteLine(c.GetType()); // 显示ConsoleApp1.Point\n\n            // 由于向CompareTo传递的不是Point变量,\n            // 所以调用的是CompareTo(object obj),c不需要装箱,\n            // 因为已经是引用了已装箱的Point\n            Console.WriteLine(p1.CompareTo(c)); // 显示0\n\n            // c是引用类型,不需要装箱\n            // c调用的是IComparable的CompareTo(object obj)方法\n            // 所以p2要装箱\n            Console.WriteLine(c.CompareTo(p2)); // 显示-1\n\n            // 对c拆箱, 字段复制到p2中\n            p2 = (Point) c;\n            Console.WriteLine(p2.ToString()); // 显示(10,10)  证明已经复制到栈\n        }\n    }\n}\n```\n\n上述代码演示了涉及装箱和拆箱的几种情形\n1. 调用ToString\n  - p1.ToString()时, p1不必装箱,**因为ToString是从基类System.ValueType继承的虚方法.**\n\n> 通常,为了调用虚方法,CLR需要判断对象的类型来定位类型的方法表,由于p1是未装箱的值类型,,所以不存在 **类型对象指针** 这个成员. 但是JIT编译器发现Point重写了ToString方法,所以会 **直接生产代码来直接(非虚地)调用重写的这个ToString方法** . 这里不存在多态性,没有类型能从它派生以提供虚方法的另一个实现. **但是如果Point.ToString方法内部调用了base.ToString() ,那么调会调用System.ValueType的ToString方法,值类型实例就会装箱.**\n\n2. 调用GetType\n  - 调用非虚方法GetType时,p1必须装箱.  因为Point的`GetType`方法从`System.Object`继承的,**CLR必须使用指向类型的指针,这个指针只能通过装箱p1来获得.**\n3. 调用CompareTo第一次\n  - p1.CompareTo(p2)时,p1不用装箱,因为Point实现了CompareTo(Point other)方法,编译器直接调用它,并且传递的是值类型对象,不需要装箱.\n4. 转型为IComparable\n  - p1转型为接口类型c时必须装箱. **因为接口被定义为引用类型.**\n5. 调用CompareTo第二次\n  - p1.CompareTo(c)时,传递的是接口变量c,所以编译器调用的是重载版本的CompareTo(object obj),要传递引用指针, c是引用了一个已装箱的Point,所以无序额外装箱.\n6. 调用CompareTo第三次\n  - c.CompareTo(p2)时,c是引用堆上的已装箱Point对象,还是IComparable接口类型,只能调用接口的CompareTo(object obj)方法, 因此p2需要装箱.\n7. 转型为Point\n  - 将c引用的堆上对象拆箱成Point复制到栈上的p2.\n\n\n## 使用接口更改已装箱值类型中的字段(不应该这样做)\n\n来看看你的理解程度,答出控制台输出什么.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point\n    {\n        private Int32 m_x, m_y;\n\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p);\n\n            p.Change(2, 2);\n            Console.WriteLine(p);\n\n            Object o = p;\n            Console.WriteLine(o);\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o);\n        }\n    }\n}\n```\n答案:\n1,1\n2,2\n2,2\n2,2\n\n解析:\n重点说下`((Point) o).Change(3, 3);`\n\n`Object o`对象对于`Change`方法一无所知, 所以需要`拆箱转型到Point`.\n  - 拆箱转型过程\n    - 将已装箱的Point中的字段 **复制到线程栈** 上的一个 **临时Point** 中.\n    - 这个栈上的Point的m_x和m_y字段会变成3,3\n    - 但是在堆上已装箱的Point里的值不受这个Change调用的影响.所以最后输出的Object o是堆上的2,2\n\n\n有的语言(比如C/C++)允许更改已装箱值中的字段,但是C#不允许. 不过,可以用接口欺骗C#,让它允许这个操作.代码如下:\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal interface IChangeBoxedPoint\n    {\n        void Change(Int32 x, Int32 y);\n    }\n    internal struct Point : IChangeBoxedPoint\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }    \n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p); // 1,1\n\n            p.Change(2, 2);\n            Console.WriteLine(p); // 2,2\n\n            Object o = p;\n            Console.WriteLine(o); // 2,2\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o); // 2,2\n\n            // 将P转型接口,装箱\n            // 在已装箱的值上调用Change, 堆上已装箱的值就变为4,4\n            // 并没有引用指向这个已装箱值,即将被垃圾回收掉\n            // 未装箱的Point p仍然是2,2\n            ((IChangeBoxedPoint) p).Change(4,4);\n            Console.WriteLine(p);// 2,2\n\n            // 将引用类型o转成IChangeBoxedPoint,才能使用Change方法\n            // 不需要装箱,因为o本来就是已装箱的Point\n            // Change(5,5);正确修改了已装箱的值\n            ((IChangeBoxedPoint) o).Change(5,5);\n            Console.WriteLine(o); //  5,5\n        }\n    }\n}\n```\n**演示接口方法如何修改已装箱值类型中的字段,在C#中,不用接口方法便无法做到.**\n\n**值类型应该是\"不可变\"(immutable). 也就是说我们不应该定义任何会修改实例字段的成员.建议将值类型字段都标记为readonly.** 否则容易写出一个试图更改字段的方法,就会产生非预期的行为. 标记readonly后,编译时就会报错.前面的例子清楚的揭示了为什么这样做.\n\n**FCL的核心值类型(Byte,Int32,UInt32,Int64,UInt64,Single,Double,Decimal,BigInteger,Complex以及所有枚举)都是`不可变`的.**\n\n> 不可变(immutable)： 即对象一旦被创建初始化后，它们的值就不能被改变，之后的每次改变都会产生一个新对象。\n\n所以，对于不变对象来说，调用对象自身的任意方法，也`不会改变该对象自身的内容`。相反，这些方法会创建`新的对象`并返回，这样，就保证了不可变对象本身永远是不可变的。\n\n\n# dynamic(动态绑定)基元类型\n\nC#是类型安全的编程语言. 意味着所有表达式都解析成类型的实例,编译器生成的代码只执行对该类型有效的操作.\n\n类型安全的优势:\n1. 许多错误能在编译时检测到\n2. 能编译出更小,更快的代码. 是因为能在编译时进行更多预设,并在生成的IL和元数据中落实预设.\n\n\n为了方便开发人员使用`反射`或者与其他组件通信.C#编译器允许将`表达式/变量的类型`标记为`dynamic`.\n\n**对于CLR, dynamic与Object完全一致.**\n\n\n## dynamic 变量/表达式\n\n**变量/表达式 使用dynamic的话,编译器会生成`payload有效载荷代码`根据运行时具体的类型来决定执行的操作.**\n\n> 编译器生成特殊IL代码来描述所需操作,这种特殊的代码称为payload有效载荷.\n\n在运行时,`payload有效载荷`代码根据dynamic`表达式/变量`引用的对象的实际类型来决定具体执行的操作.\n\n\n```csharp\nstatic void Main(string[] args)\n{\n    // dynamic 局部变量:编译器会将dynamic转成System.Object.\n    // 值类型会装箱.\n    dynamic val;\n    for (Int32 demo = 0;  demo<2 ;demo ++)\n    {\n        // dynamic 表达式 : 编译器会生成payload代码\n        val = (demo == 0) ? (dynamic) 5 : (dynamic) \"A\";\n        // 两个操作数的类型是dynamic\n        val = val + val;\n        // 传入dynamic类型参数, C#编译器会生成payload代码\n        // 在运行时检查val的实际类型.\n        // 调用对应的重载版本.\n        M(val);\n    }\n}\nprivate static void M(Int32 n)\n{\n    Console.WriteLine($\"M(Int32):{n}\");\n}\n\nprivate static void M(String s)\n{\n    Console.WriteLine($\"M(String):{s}\");\n}\n```\n输出:\nM(Int32):10\nM(String):AA\n\n由于val是dynamic类型,C#编译器生成payload代码在`运行时`检查value的实际类型,然后决定`+`操作符实际要做什么.\n1. 第一个循环中: val = 5(Int32值),结果是10 .\n2. `M(val);`传入dynamic类型参数, C#编译器会生成`payload有效载荷代码`,在`运行时`检查val的实际类型,调用对应的重载版本.\n\n**所有表达式都能隐式转型为dynamic,因为所有表达式最终都生成从Object派生的类型(值类型需要装箱).**\n\n正常情况下:\n1. 编译器 **不允许** 写代码将`表达式`从`Object`隐式转成其他类型. 必须显示转型.\n2. 但是,编译器 **允许** 使用隐式转型语法将`表达式`从`dynamic`转型为其他类型.\n  - 虽然编译器允许省略显示转型,但CLR会在运行时验证来确保类型的安全性.\n  - 运行时,dynamic类型不兼容要转型的类型,则会抛出InvalidCastException.\n\n```csharp\nObject o1 = 123;    // OK: 从值类型隐式转型为Object,装箱\n//Int32 n1 = o1;    // Error: 不允许从Object隐式转型到Int32\n\nInt32 n2 = (Int32) o1; // OK: 显示转型, 拆箱\n\ndynamic d1 = 123;    // OK: 从值类型隐式转为dynamic,装箱\nInt32 n3 = d1;       // OK: 从dynamic隐式转为值类型,拆箱\n```\n\n```csharp\n// 编译出的IL代码会对值类型123进行装箱\ndynamic d = 123;\n// d引用了已装箱的Int32\nvar result = M(d); // var result 等同于 dynamic result\n```\n上述代码之所以能通过编译,是因为编译器不知道调用哪个方法,也不知道返回的类型,所以编译器假定result具有dynamic类型. 如果运行时调用M方法.返回类型是void,将抛出`Microsoft.CSharp.RuntimeBinder.RuntimeBinderException`异常.\n\n> var声明局部变量是一种简化语法,要求编译器根据表达式推断具体数据类型. 只能用在方法内部声明局部变量,必须显式初始化用var声明的变量.\n\n表达式不能转型为var,但是能转型dynamic,也无需初始化用dynamic声明的变量.\n\n\n\n## dynamic 字段/方法参数/方法返回值\n\n**字段/方法参数/方法返回值 是dynamic类型, 编译器会将dynamic转成System.Object.**\n\nC#编译器会将该类型转换为`System.Object`,并在元数据中向`字段/参数/返回类型`应用`System.Runtime.CompilerServices.DynamicAttribute`的实例.\n\n如果指定`局部变量`被指定为dynamic, 则变量类型也会成为Object,局部变量不会应用`DynamicAttribute`,因为限制在方法内部使用.\n\n**由于dynamic其实就是Object,所以方法签名不能仅靠dynamic和Object来区分.**\n\n## dynamic 泛型类(引用类型),结构(值类型),接口,委托,方法的泛型类型实参\n\n**泛型类(引用类型),结构(值类型),接口,委托,方法** 的`泛型类型实参`也可以是dynamic,编译器将dynamic转为Object. 向必要的元数据应用`DynamicAttribute`.\n\n> 泛型方法是已经编译好的,会将类型视为Object,**编译器不在泛型代码中生成`payload`代码.所以不会执行动态调度.**\n\n\n重要提示:\n1. **对于CLR, dynamic与Object完全一致.**\n2. `变量/表达式`用dynamic会生成 payload代码,进行动态调度.\n3. 不能定义对dynamic进行扩展的扩展方法.\n4. 不能将`lanmbda表达式`和`匿名方法`作为实参传给dynamic方法调用. 因为编译器推断不了类型.\n5. 在`foreach`或者`using语句中的资源`被指定了`dynamic表达式`, 编译器分别将表达式转型为非泛型System.IEnumerable接口或System.IDispose接口.\n  - 转型成功,就是用表达式,代码正常运行.\n  - 失败就抛出Microsoft.CSharp.RuntimeBinderException异常.\n\n\n\n\n# dynamic 具体用法\n\n什么是动态化(dynamification)?\n- 在为COM对象生成可由\"运行时\"调用的包装(warpper)程序集是,COM方法中使用任何`VARIANT`实际都转换成`dynamic`.\n\n```csharp\n// 如果没有dynamic类型,就需要转型成Range类型,才能访问Value属性\n((Range)execel.Cells[1,1]).Value = \"Text\";\n\n// 由于excel.Cells[1,1]是dynamic类型,所以不需要显示转型.\nexecel.Cells[1,1].Value = \"Text\";\n```\n\n## 利用反射和dynamic的例子\n\n```csharp\nObject target = \"ABC\";\nObject arg    = \"ff\";\n\n// 在目标上查找和希望的实参类型匹配的方法.\n// 从目标target的String类型上查找 方法名MethodA,参数的类型String的方法信息\nType[]     argTypes = new Type[] {arg.GetType()};\nMethodInfo method   = target.GetType().GetMethod(\"MethodA\", argTypes);\n\n// 在目标上调用方法,传递实参\"ff\"\nObject[] arguments = new Object[] {arg};\nBoolean  result    = Convert.ToBoolean(method.Invoke(target, arguments));\n\n\n// 利用dynamic简化上述代码写法\ndynamic target1 = \"ABC\";\ndynamic arg1    = \"ff\";\nresult = target1.MethodA(arg1);\n```\n\n可以看到显著简化的语法.\n\n## payload代码\n\nC#编译器会生成payload代码,在运行时根据对象的实际类型判断要持续什么操作.\n\n这些payload代码使用了称为`运行时绑定器(RuntimeBinder)`的类.\n\nC# `运行时绑定器(RuntimeBinder)`的代码在Microsoft.CSharp.dll程序集中. 生成使用dynamic关键字就必须引用该程序集(默认的csc.rsp中已经引用了该程序集).\n\n> 是这个程序集中的代码知道在运行时生成代码,在+操作符2个Int32执行加法,+操作符两个string时执行连接.\n> 运行时绑定器(RuntimeBinder) 首先检查类型是否实现了IDynamicMetaObjectProvider接口. 如果是就调用接口的GetMetaObject方法, 返回的类型`DynamicMetaObject的派生类型`能处理对象的多有成员,方法和操作符绑定.\n\n\npayload代码执行时,会在运行时生成动态代码; 这些代码进入驻留于内存的程序集,即\"匿名寄宿的DynamicMethods程序集(Anonymously Housted DynamicMethods Assembly)\",作用是当特定的`call site(发生调用处)`使用具有相同运行时类型的动态参数发出大量调用时增强动态调度的性能.\n\n### C#内建的动态功能所产生的额外开销不容忽视\n\n虽然动态功能能简化语法,但也要加载这些程序集以及额外的内存消耗,会对内存造成额外的影响.\n- Microsoft.CSharp.dll\n- System.dll\n- System.Core.dll\n- System.Dynamic.dll (如果使用dynamic与COM组件互操作)\n\n## 什么时候使用dynamic\n\n1. 如果程序只是 一两个地方需要动态行为,传统(反射)做法或许更高效. 托管对象则调用反射方法,COM对象则进行手动类型转换.\n2. 如果在动态表达式中使用的对公对象未实现IDynamicMetaObjectProvider接口,C#编译器会将对象视为C#定义的普通类型的实例,利用反射在对象上执行操作.\n\n## dynamic的限制\n\ndynamic的一个限制是只能访问对象的实例成员,因为dynamic变量必须引用对象.但有时需要动态调用运行时才能确定一个类型的静态成员.\n\n## 实现动态调用类型的静态成员方法\n\n作者实现的`StaticMemberDynamicWrapper`从`DynamicObject`派生,实现了接口`IDynamicMetaObjectProvider`.\n```csharp\n        /// <summary>\n        /// 构造一个 'dynamic' 的实例派生类，来动态调用类型的静态成员\n        /// </summary>\n        internal sealed class StaticMemberDynamicWrapper : DynamicObject //P(132)\n        {\n            private readonly TypeInfo m_type;\n            public StaticMemberDynamicWrapper(Type type) { m_type = type.GetTypeInfo(); }\n\n            public override IEnumerable<String> GetDynamicMemberNames()\n            {\n                return m_type.DeclaredMembers.Select(mi => mi.Name);\n            }\n\n            public override bool TryGetMember(GetMemberBinder binder, out object result)\n            {\n                result = null;\n                var field = FindField(binder.Name);\n                if (field != null) { result = field.GetValue(null); return true; }\n\n                var prop = FindProperty(binder.Name, true);\n                if (prop != null) { result = prop.GetValue(null, null); return true; }\n                return false;\n            }\n\n            public override bool TrySetMember(SetMemberBinder binder, object value)\n            {\n                var field = FindField(binder.Name);\n                if (field != null) { field.SetValue(null, value); return true; }\n\n                var prop = FindProperty(binder.Name, false);\n                if (prop != null) { prop.SetValue(null, value, null); return true; }\n                return false;\n            }\n\n            public override Boolean TryInvokeMember(InvokeMemberBinder binder, Object[] args, out Object result)\n            {\n                MethodInfo method = FindMethod(binder.Name, args.Select(a => a.GetType()).ToArray());\n                if (method == null) { result = null; return false; }\n                result = method.Invoke(null, args);\n                return true;\n            }\n\n            private MethodInfo FindMethod(String name, Type[] paramTypes)\n            {\n                return m_type.DeclaredMethods.FirstOrDefault(mi => mi.IsPublic && mi.IsStatic && mi.Name == name && ParametersMatch(mi.GetParameters(), paramTypes));\n            }\n\n            private Boolean ParametersMatch(ParameterInfo[] parameters, Type[] paramTypes)\n            {\n                if (parameters.Length != paramTypes.Length) return false;\n                for (Int32 i = 0; i < parameters.Length; i++)\n                    if (parameters[i].ParameterType != paramTypes[i]) return false;\n                return true;\n            }\n\n            private FieldInfo FindField(String name)\n            {\n                return m_type.DeclaredFields.FirstOrDefault(fi => fi.IsPublic && fi.IsStatic && fi.Name == name);\n            }\n\n            private PropertyInfo FindProperty(String name, Boolean get)\n            {\n                if (get)\n                    return m_type.DeclaredProperties.FirstOrDefault(\n                       pi => pi.Name == name && pi.GetMethod != null &&\n                       pi.GetMethod.IsPublic && pi.GetMethod.IsStatic);\n\n                return m_type.DeclaredProperties.FirstOrDefault(\n                   pi => pi.Name == name && pi.SetMethod != null &&\n                      pi.SetMethod.IsPublic && pi.SetMethod.IsStatic);\n            }\n        }\n```\n\n为了调用静态成员,传递想要操作的Type来构建上述类的实例, 将引用放到dynamic变量中, 再用实例成员语法调用所需静态成员.\n\n```csharp\ndynamic stringType = new StaticMemberDynamicWrapper(typeof(String));\nvar r = stringType.Concat(\"A\",\"B\");// 动态调用String 的静态Concat方法\nConsole.WriteLine(r); // 显示AB\n```\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型2","url":"/2019/07/16/5基元类型引用类型和值类型2/","content":"# 回顾总结\n\n2019年8月22日\n\n1. 值类型一般在线程栈上分配\n\t- 值类型不受垃圾回收器控制\n\t- 随着变量生命周期结束而被栈释放\n\t- 所有值类型都是隐式密封的\n\t- 值类型称为结构或枚举.\n\t- `System.ValueType`的后代不全是值类型,`System.Enum`就是唯一的特例.\n\t- 它直接继承自System.ValueType，`System.Enum`和`System.ValueType`本身是引用类型。\n\n2. new操作符,编译器会判断类型是值类型和引用类型\n\t- 会生成正确的IL代码分配在线程栈 或者 堆中.\n\n3. 值类型对象有 未装箱和已装箱两种形式. 引用类型总是处于已装箱形式.\n\n4. 值类型如果不与非托管代码互操作,就应该覆盖C#编译器的默认设定改为[StructLayout(LayoutKind.Auto)]\n\t- 不覆盖默认是LayoutKind.Sequential\n\n5. 拆箱就是获取指针的过程\n\t- 拆箱不要求在内存中复制任何字节,指针指向的是已装箱实例中的未装箱部分\n\t- 然后进行一次字段复制到线程栈过程.\n\t- 已装箱对象在拆箱过程时,如果引用对象不是所需的值类型,会抛InvalidCastException\n\t- 先拆箱为正确类型,再转型,`Int16 y = (Int16)(Int32)o;// o里存放的是Object->Int32的已装箱对象 `\n\n6. ToString方法 代替 直接使用值类型传递给object参数的方法, 可以减少一个装箱操作.\n\t- 例如:Console.WriteLine编辑器选择Concat的重载版本去实现3个参数的合并\n\t- `Concat(object,object,object)`\n\t- 不建议使用 `Console.WriteLine(v + \",\" + o );` 建议使用`Console.WriteLine(v.ToString() + \",\" + (Int32) o );` 减少装箱操作.\n\n7. 大多数方法重载的目的是减少常用的值类型装箱次数.\n\t- 可以将方法定义为泛型,通过约束限制为值类型,这样获取任何值类型而不必装箱.\n\t- 如果要对一个值类型反复装箱, 建议手动写代码装箱`Object o = v;` 减少装箱次数\n\n\n# 引用类型和值类型\n\nCLR支持两种类型: 引用类型和值类型.\n\n引用类型总是从`托管堆`分配. C#的`new`操作符返回对象内存地址----指向对象数据的内存地址.\n\n**使用引用类型必须留意性能问题.**\n\n1. 内存必须从托管堆分配.\n2. 堆上分配的每个对象都有一些额外成员,这些额外成员必须初始化.\n3. 对象中的其他字节(为字段设置的字节)总是设为0.\n4. 从对管堆分配对象时,可能强制执行一次垃圾回收.\n\n为了提高性能,CLR提供了名为\"值类型\"的轻量级类型.\n\n**值类型** 的实例一般在线程栈上分配.\n\n1. 可以作为字段嵌入引用类型的对象中\n2. 在代表值类型实例的变量中 **不包含指向实例的指针**.\n3. 实例中包含了实例本身的字段(值). 所以操作实例中的字段(值)不需要提领指针.\n4. 值类型不受垃圾回收器的控制.\n5. 所有值类型都是隐式密封,防止用作其他应用类型或值类型的基类.\n\n\n**值类型缓解了使用托管堆的压力,并减少了应用程序生存期内的垃圾回收次数.**\n\n> 在非托管环境(C/C++)中声明类型后, 使用该类型的代码会决定是在线程栈上还是应用程序的堆中分配该类型的实例.\n> 托管代码中,要由定义类型的开发人员决定在什么地方分配类型实例,使用此类型的人对此没有控制权.\n\n# 查看文档区分引用类型和值类型\n\n1. 在文档中查看类型时, 任何称为 **类** 的类型都是引用类型. 例如System.Exception类...\n2. 所有值类型都称为 **结构** 或 **枚举**. 例如:System.Int32结构...\n\n\n## 结构&枚举\n\n所有`结构`都是抽象类型`System.ValueType`的直接派生类.`System.ValueType`本身又直接从`System.Object`派生.\n\n1. 根据定义, 所有值类型都必须从`System.ValueType`派生.\n2. 所有枚举都从`System.Enum`抽象类型派生,`System.Enum`从`System.ValueType`派生.\n\n> CLR和所有编程语言都会给予枚举特殊待遇(直接支持各种强大的操作,非托管环境中就不这样了.)\n\n# 引用类型和值类型的区别\n\n```csharp\n// 引用类型,因为class\nclass SomeRef { public Int32 x; }\n// 值类型\nstruct SomeVal{ public Int32 x; }\n\nstatic void ValueTypeDemo()\n{\n    // 图示左边部分\n    SomeRef r1 = new SomeRef();    // 在堆上分配\n    // 使用new看似是要在托管堆上分配实例,实际是C#编译器知道SomeVal是值类型\n    // 所以会正确的生成IL代码,在线程栈上分配,\n    // C#还会确保值类型中的所有字段都初始化为零.\n    // SomeVal v1; 还可以这么写. 但是C#认为此处v1没有初始化.\n    // 如果直接使用Int32 a = v1.x;将不能通过编译\n    SomeVal v1 = new SomeVal();    // 在栈上分配. 使用new操作符,C#会认为已经初始化.\n    r1.x = 5;                      // 提领指针\n    v1.x = 5;                      // 在栈上修改\n\n    // 图示右边部分\n    SomeRef r2 = r1;               // 只复制引用(指针)\n    SomeVal v2 = v1;               // 在栈上分配并复制成员\n    r1.x = 8;                      // r1.x和r2.x都会更改\n    v1.x = 9;                      // v1.x会更改,v2.x不变,为5\n}\n\n```\n\n![](5基元类型引用类型和值类型2/5-2.png)\n\n在代码中使用类型时, 必须注意是引用类型还是值类型,这会极大的影响在代码中表达自己意图的方式.\n\n# 设计类型时,满足什么条件才声明为值类型?\n\n1. 类型具有基元类型的行为. 是十分简单的类型,没有成员会修改类型的任何实例字段.\n  - 如果类型没有提供会更改字段的成员,就说该类型不可变(immutable).\n2. 类型不需要从其他任何类继承.\n3. 类型也不派生出其他任何类型\n\n类型实例大小也应该在考虑范围内,因为`实参`默认以`值方式传递`,造成对值类型实例中的字段进行复制,影响性能.\n1. 类型的实例较小(16字节或更小)\n2. 类型的实例较大(大于16字节),但不作为方法实参传递,也不从方法返回\n\n# 值类型的主要优势以及自身的局限\n\n1. `值类型`主要的优势是**不作为对象在托管堆上分配**.\n2. `值类型`对象有两种表示形式: `未装箱`和`已装箱`.  引用类型总是处于`已装箱`形式.\n3. `值类型`从`System.ValueType`派生. 该类型提供了与`System.Object`相同的方法,但重写了`Equals`方法,能在两个对象的字段值完全匹配的前提下返回true.还重写了GetHashCode方法.会将字段中的值都考虑在内.但是这个实现存在性能问题.所以定义自己的值类型时应该重写Equals和GetHashCode方法,并提供显式实现.\n4. 由于不能将`值类型`作为基类或新的引用类型,所以不应当在值类型中引入任何新的虚方法,所有方法不能是抽象的,并且隐式密封不可重写.\n5. `引用类型`的变量包含堆中对象的地址.引用类型的变量创建时默认初始化为`null`(表示当前不指向任何有效对象). 试图使用null引用时会报`NullReferenceException`异常.`值类型`的变量总是包含其基础类型的一个值.而`值类型`的初始化都为0. 值类型变量不是指针,不会报`NullReferenceException`异常.CLR允许为值类型添加`可空`标识.\n6. 将`值类型`变量赋给另一个`值类型`变量,会执行`逐字段复制`. `引用类型`的变量赋给另一个`引用类型`的变量值`只复制内存地址`.\n7. 两个或多个`引用类型`变量能引用堆中的同一对象,所以对一个变量操作可能会影响到另一个变量引用的对象.`值类型`则不会影响另一个值类型变量.\n8. 由于`未装箱的值类型`不在堆上分配, 定义了该类型的实例的方法不再活动(变量的生命周期结束),为它们分配的栈存储就会被释放.\n\n# CLR如何控制类型中的字段布局?\n\n为了提高性能,CLR能按照它所选择的任何方式排列`类型的字段`. 例如:CLR可以在内存中重新安排`字段的顺序`,将对象引用分为一组,同时正确排列和填充数据字段.\n\n定义类型时,针对类型的各个字段,你可以告诉CLR按照指定的顺序排列,还是按照CLR自己认为合适的方式重新排列.\n\n## 如何告诉CLR怎么排列?\n\n1. 要为自己定义的类或结构应用`System.Runtime.InteropServices.StructLayoutAttribute`特性.\n  - 向该特性的构造器传递`LayoutKind.Auto`          : 让CLR自动排列字段.  \n  - 顺序布局:传递`LayoutKind.Sequential`         : 让CLR保持你的字段布局.\n  - 精确布局:传递`LayoutKind.Explicit`           : 指定每个字段的偏移量,利用偏移量在内存中显示排列字段.\n2. 如果不指定`StructLayoutAttribute`,则CLR按照自己的方式.\n3. **注意:C#编译器有默认设定:**\n  - 默认`引用类型`选择`LayoutKind.Auto`\n  - 默认`值类型`选择`LayoutKind.Sequential`\n  - 这是因为C#编译器团队认为和`非托管代码`互操作时会经常用到`结构`.为此,字段必须保持程序员定义的顺序.\n  - 假如创建的值类型不与`非托管代码`互操作,就应该覆盖C#编译器的默认设定.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\n// 让CLR自动排列字段以增强这个值类型的性能\n// 覆盖掉C#编译器默认的`LayoutKind.Sequential`设置\n[StructLayout(LayoutKind.Auto)]\ninternal struct SomeValType\n{\n    private readonly Byte m_b;\n    ....\n}\n```\n\n### LayoutKind.Explicit说明\n\n构造器传递了`LayoutKind.Explicit`之后, 要向值类型中的每个字段都应用`System.Runtime.InteropServices.FieldOffsetAttribute`特性的实例.并且向该特性传递Int32值来指出字段第一个字节距离实例起始处的偏移量(以字节为单位).  \n\n显示布局常用来模拟非托管C/C++中的`union`,因为多个字段可起始于内存的相同偏移位置.\n\n注意在类型中:一个引用类型和一个值类型互相重叠是不合法的.多个值类型相互重叠则是合法的.为了是这样的类型能够验证,所有重叠字节都必须能通过公共字段访问.\n\n\n> union是特殊类,union中的数据成员在内存中的存储是相互重叠.每个数据成员都从相同的内存地址开始.\n> 分配给union的存储区数量是包含它最大数据成员所需的内存数, 同一时刻只有一个成员可以被赋值.\n> （1）同一个内存段可以用来存放几种不同类型的成员，但在每一个时刻只能存在其中一种，而不能同时存放几种，即每一瞬间只有一个成员起作用，其它的成员不起作用，不能同时都存在和起作用；\n> （2）共用体变量中起作用的成员是最后一个存放的成员，在存入一个新的成员后，原有的成员就会失去作用，即所有的数据成员具有相同的起始地址。\n> （3）union和struct都是由多个不同的数据成员组成，但是union所有成员共享一段内存地址，只存放最后一次赋值的成员值，而struct可以存放所以有成员的值。\n> （4）union的大小是所有成员中所占内存最大的成员的大小，struct是所有成员的大小的“和”。\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n// 让开发人员显示排列这个值类型的字段\n[StructLayout(LayoutKind.Explicit)]\ninternal struct SomeValType\n{\n    [FieldOffset(0)]\n    private readonly Byte m_b;// m_b和m_x字段在该类型的实例中相互重叠\n\n    [FieldOffset(0)]\n    private readonly Int16 m_x; // m_b和m_x字段在该类型的实例中相互重叠\n}\n```\n\n\n# 值类型的装箱和拆箱\n\n值类型不作为对象在托管堆中分配,不被垃圾回收,也不通过指针进行引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    struct Point{public Int32 x, y;}\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ArrayList a = new ArrayList();\n            Point p;                        // 分配一个Point,不在堆中分配\n            // 每次迭代都初始化一个`Point值类型字段`, 并将该Point存储到ArrayList中.\n            for (int i = 0; i < 10; i++)\n            {\n                p.x = p.y = i;     // 初始化值类型中的成员\n                a.Add(p);          // 对值类型进行装箱,将引用添加到ArrayList中\n            }\n        }\n    }\n}\n```\n\n## ArrayList中究竟存储了什么? 是Point结构还是Point结构的地址?\n\n想要知道答案需要研究ArrayList的Add方法.\n\nAdd方法原型:`public virtual Int32 Add(object value);`\n\n1. 参数是`object`,也就是说Add获取对托管堆上的一个对象的引用(指针)来作为参数.\n2. a.Add(p); 之前的代码传递的是Point,是值类型.\n3. 为了使代码正确工作,Point值类型必须转换成真正的,在堆中托管的对象,而且必须获取对该对象的引用\n4. 对`值类型`转成`引用类型`要使用`装箱机制`.\n\n## 装箱机制发生的事情\n\n1. 在托管`堆`中分配内存. 分配的内存是值类型各字段所需的内存量(还要加上托管堆所有对象都有的两个额外成员:类型对象指针和同步块索引所需的内存量).\n2. **值类型的字段复制到新分配的堆内存.**\n3. 返回对象地址, 现在该地址是对象引用:值类型成了引用类型.\n\n在托管堆中分配相应的内存.  \n\n**C#编译器自动生成对值类型实例进行装箱所需的IL代码.** 但是仍需要理解内部的工作机制才能体会到代码的大小和性能问题.\n\n在运行时,当前存在于`Point值类型实例p`中的字段复制到`新分配的Point对象`中. 已装箱`Point对象`(现在是引用类型)的地址传给Add方法. `Point对象`一直存在于堆中,直至被垃圾回收.\n\n> FCL现在包含一组新的泛型集合类, 非泛型集合类已经是过时的东西.\n> 例如:应该使用`System.Collections.Generic.List<T>`类而不是`System.Collections.ArrayList`类.\n> `泛型集合类`对`非泛型集合类`进行了大量改进.\n> 1. API得到简化和增强,性能也得到显著提升\n> 2. 允许开发人员在操作`值类型的集合`时不需要对`集合中的项`进行`装箱/拆箱`\n> 3. 开发人员还获得编译时的类型安全性, 减少强制类型转换次数.\n\n## 拆箱机制\n\n要从上面代码中的`ArrayList a`取第一个元素.\n\n```csharp\nPoint p = (Point)a[0];\n```\n\n1. 它获取ArrayList的元素0包含的引用(指针), 试图放到`Point值类型`的实例p中.\n2. 为此,`已装箱Point对象`中的所有字段都必须复制到`值类型变量`p中. 后者在`线程栈`上.\n3. CLR分两步完成复制\n  - 第一步: 获取`已装箱Point对象`的`各个Point字段`的地址.  **← 此过程称为拆箱.**\n  - 第二步: 将字段包含的值从`堆`复制到`栈`的值类型实例中.\n\n拆箱不是直接将装箱过程倒过来, **装箱的代价被拆箱高得多.**\n1. 拆箱就是获取指针的过程.\n2. **拆箱不要求在内存中复制任何字节. 指针指向的是已装箱实例中的未装箱部分.**\n3. 拆箱操作后紧接着一次字段复制.\n\n\n### 已装箱值类型在拆箱时的过程\n\n1. 如果包含\"对已装箱值类型实例的引用\"的变量为null,抛出NullReferenceException.\n  - `Point p = (Point)a[0];// a为null时`\n2. 如果引用的对象不是所需值类型的已装箱实例,抛出InvalidCastException.\n\n```csharp\npublic static void Main()\n{\n  Int32 x = 5;\n  object o = x;              // 对x装箱,o引用已装箱对象\n  // 在对对象进行拆箱时,只能转型为最初未装箱的值类型(本例是Int32)\n  // 所以以下写法会抛出异常\n  Int16 y = (Int16)o;        // 抛出InvalidCastException.\n\n  // 正确写法\n  Int16 y = (Int16)(Int32)o; // 先拆箱为正确类型,再转型\n}\n```\n\n#### 拆箱和复制例子\n```csharp\npublic static void Main()\n{\n  Point p;\n  p.x = p.y = 1;\n  Object o = p;   // 对p装箱;  o引用已装箱实例\n\n  // 将Point的x字段变成2\n  p = (Point)o;   // 对o拆箱, 将字段从已装箱的实例复制到[栈]变量中 (复制所有字段)\n  p.x = 2;        // 更新[栈]变量的状态\n  o = p;          // 对p装箱;o引用新的已装箱实例 (复制所有字段)\n}\n```\n\n首先进行一次拆箱,再执行一次字段复制(到栈变量中),最后再执行一次装箱(在托管堆上创建全新的已装箱实例).\n\n这个过程对应用程序性能影响较大.\n\n> 此段代码用C++/CLI来写,效率会高很多,因为它允许在不复制字段的前提下,对已装箱的值类型进行拆箱,拆箱返回的是已装箱对象中的未装箱部分的地址(忽略对象的类型对象指针和同步索引块这两个额外成员),接着可以用这个指针来操作未装箱实例的字段(这些字段恰好在堆上的已装箱对象中).\n> C++/CLI直接在已装箱Point实例中修改Point的x字段的值. 就这避免了在堆上分配新对象和复制字段两次.\n\n### 从IL代码查看编译器隐式生成的装箱代码\n\n\n如果关心特定算法的性能,可以用ILDasm.exe这样的工具查看方法的IL代码,观察IL指令box都在哪些地方出现.\n\n#### 例子一\n\n```csharp\n// 以下代码发生了3次装箱\npublic static void Main()\n{\n  Int32 v = 5; // 值类型变量\n  object o = v; // 一次装箱\n  v = 123; // 将未装箱的值修改为123\n\n  Console.WriteLine(v + \",\" + (Int32) o );// 显示123,5\n}\n```\n\n解析:\n1. 首先在栈上创建一个Int32未装箱值类型实例`v` , 将其初始化为5.\n2. 创建Object类型的变量`o`, 让它指向`v`.\n  - 因为`引用类型的变量`始终是指向`堆`中的对象,所以C#生成正确的IL代码对`v`进行装箱,(复制所有字段到堆中)\n  - 让`v`的已装箱拷贝的地址存储到`o`中.\n3. 接着,值123被放到`未装箱值类型`实例`v`中, 但这个操作不会影响已装箱的Int32,后者值依然是5.\n4. 接着调用WriteLine方法, 由于方法需要string对象作为参数,编辑器选择Concat的重载版本去实现3个参数的合并\n5. `Concat(object,object,object)`\n  - 第一个参数传递v(未装箱的值参数),需要进行装箱操作\n  - 第二个参数\",\",作为string对象,引用传递.\n  - 第三个参数,`(Int32) o`, 先进行拆箱(但不紧接着执行复制),获取到在已装箱Int32中的未装箱Int32的地址.这个未装箱的Int32实例必须再次装箱. 将实例的内存地址传给arg2参数\n6. Concat方法调用每个对象的ToString方法,将每个对象的字符串连接起来.返给给WriteLine方法以最终显示.\n\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       47 (0x2f)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop       // nop:没有什么意义；\n\n  // Int32 v = 5;\n  IL_0001:  ldc.i4.5  // Ldc.I4 将所提供的 int32 类型的值作为 int32 推送到计算堆栈上。\n  IL_0002:  stloc.0   //从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。\n\n  // object o = v;\n  // 局部变量object o,位置设定为索引0\n  IL_0003:  ldloc.0   //将索引 0 处的局部变量加载到计算堆栈上。\n  IL_0004:  box        [System.Runtime]System.Int32  // 将值类转换为对象引用（O 类型）。\n  IL_0009:  stloc.1   //从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。\n\n  // v = 123;\n  IL_000a:  ldc.i4.s   123  // 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。\n  IL_000c:  stloc.0\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // 在WriteLine方法参数(object引用类型)中, 会对值类型的v产生装箱操作\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"    // 推送对元数据中存储的字符串的新对象引用。\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // (Int32) o 拆箱操作,拆成原始的Int32值类型.\n  IL_0018:  ldloc.1\n  IL_0019:  unbox.any  [System.Runtime]System.Int32\n  // 由于被作为WriteLine方法参数(object引用类型), 再进行装箱操作\n  IL_001e:  box        [System.Runtime]System.Int32\n  // 调用string的Concat方法连接字符串\n  IL_0023:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  // 将Concat返回的string 传给WriteLine方法\n  IL_0028:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_002d:  nop\n\n  // 从Main返回,终止应用程序\n  IL_002e:  ret\n} // end of method Program::Main\n\n```\n\n如果改进一下,如下:\n```csharp\n// 此处如果修改成如下代码,效率更高,避免了2次操作:一次装箱一次拆箱\nConsole.WriteLine(v + \",\" + o );// 显示123,5\n```\n对比一下IL代码\n1. 比之前版本小了10个字节. 第一个版本`额外的拆箱/装箱`显然会产生更多的代码. 额外的装箱操作步骤会从托管堆中分配一个额外的对象, 将来对其进行垃圾回收.\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       37 (0x25)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop\n  IL_0001:  ldc.i4.5\n  IL_0002:  stloc.0\n  IL_0003:  ldloc.0\n  IL_0004:  box        [System.Runtime]System.Int32\n  IL_0009:  stloc.1\n  IL_000a:  ldc.i4.s   123\n  IL_000c:  stloc.0\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"\n  IL_0018:  ldloc.1\n  IL_0019:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  IL_001e:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_0023:  nop\n  IL_0024:  ret\n} // end of method Program::Main\n```\n\n进一步提升代码的性能:\n\n**v.ToString(),返回是的String,是引用类型,不需要装箱,减少一个装箱操作.**\n\n`Console.WriteLine(v.ToString() + \",\" + (Int32) o );`\n\n对应的IL代码则是: `IL_000f:  call       instance string [System.Runtime]System.Int32::ToString()`\n\n#### 例子二\n\n```csharp\n// 以下代码只发生了一次装箱.\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // 装箱\n    Object o = v;\n    // 修改栈, 不影响已装箱的o\n    v = 123;\n    // public static void WriteLine(int value)\n    // 方法WriteLine是传值的方式,不需要装箱\n    Console.WriteLine(v); // 123\n    // 拆箱\n    v = (Int32) o;\n    Console.WriteLine(v); // 5\n}\n```\n\n### FCL重载了很多常用值类型的方法,减少常用值类型的装箱次数\n```csharp\npublic static void WriteLine(double value);\npublic static void WriteLine(float value);\npublic static void WriteLine(int value);\n...\n```\n\n**大多数方法进行重载唯一的目的就是减少常用值类型的装箱次数.**\n\n但是FCL不可能接受你自己定义的值类型. 也可能FCL没有提供对应的重载版本,那调用方法传递值类型参数时,就是调用Object参数的重载版本. 将值类型实例作为Object传递会造成装箱.\n\n定义自己的类时, 可将类中的方法定义为泛型(通过泛型约束将类型参数限制为值类型), 这样方法就可以获取任何值类型而不必装箱.\n\n#### 例子三(如果要反复对一个值类型装箱,请改为手动方式)\n\n```csharp\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // v会被装箱3次,浪费时间和内存\n    Console.WriteLine($\"{v}+{v}+{v}\");\n\n    // 对v手动装箱一次\n    Object o = v;\n    // 编译下一行不会发生装箱行为\n    // 内存利用还是执行速度都比上一段代码更胜一筹\n    Console.WriteLine($\"{o}+{o}+{o}\");\n}\n```\n","tags":["CLR读书笔记"]},{"title":"5基元类型引用类型和值类型","url":"/2019/07/15/5基元类型引用类型和值类型/","content":"# 回顾总结\n\n2019年8月22日\n\n1. 允许转换安全的隐式转换.\n\t- 转换安全: 不发生数据丢失的情况.比如从`Int32`转换为`Int64`.\n\t- 隐式转换: 不用写 (类型) 的方式\n\t- 显示转型: 用()注明类型\n\n2. 丢失精度时, 会向下取整.\n\t- 在转型时,`float` 6.8 放入`int`中会截断小数点后的数,放入6\n\n3. 字面值会在编译期就完成表达式求值.\n\t- `String s = \"a \" + \"bc\";// 生成的代码将s设为\"a bc\" `\n\n4. 算术运算符溢出处理\n\t- checked / unchecked\n\t- 将有溢出风险的计算语句放入块中, 如果块中调用方法不会有任何作用.\n\t- 捕捉`OverflowException`异常\n\n5. Decimal是特殊的基元类型,CLR不会为此生成特殊的指令\n\t- 编译器会生成代码来调用Decimal的成员方法,处理速度慢于其他基元类型\n\t- 溢出检查操作符无效\n\n6. BigInteger\n\t- `UInt32`数组来表示任意大的整数\n\t- 没有上限和下限\n\t- 不会抛`OverflowException`可能会抛`OutOfMemoryException`\n\n\n\n\n\n# 编程语言的基元类型\n\n## 什么是基元类型\n\n编译器直接支持的数据类型称为`基元类型(primitive type)`.\n\n基元类型直接映射到Framework类库FCL中存在的类型.例如C#中的`int`直接映射到的`System.Int32`类型.\n\n> MSDN文档将primitive type翻译成\"基元类型\",而不是容易混淆的\"基本类型\".\n\n以下四行代码都能正确编译,并能生成完全相同的`IL代码`.\n```csharp\n// 最方便的语法\nint a = 0;\n// 方便的语法\nSystem.Int32 a = 0;\n// 不方便的语法\nint a = new int();\n// 最不方便的语法\nSystem.Int32 a = new System.Int32();\n\n// 从另外一个角度可以认为C#编译器自动假定所有源代码都添加了一下using指令(取别名作用)\nusing sbyte = System.SByte;\nusing byte = System.Byte;\nusing short = System.Int16;\nusing ushort = System.UInt16;\nusing int = System.Int32;\nusing uint = System.UInt32;\n...\n```\n\n## 基元类型对应的FCL类型\n\n是要是符合CLS公共语言规范的类型,其他语言都提供了类似的基元类型. 不符合的就不一定支持了.\n\n![](5基元类型引用类型和值类型/5-1.png)\n\n## 关于关键字和完整的系统类型名称\n\nC#语言规范:\"从风格上说,最好使用关键字,而不是使用完整的系统类型名称.\"\n作者认为: 更好的是使用FCL类型名称,完全不用基元类型名称.\n\n事实上,作者希望编译器根本不提供`基元类型名称`, 而是强迫开发人员使用`FCL类型名称`.理由如下:\n\n1. 有些程序员纠结用`string`还是`String` . 由于C#的`string`(这是关键字)直接映射到`System.String`类型(这是FCL库中的类型). 所以两者没有区别.\n\n> 误区: 有些开发人员说32位系统上int代表32位整数,64位系统上int代表64位整数,这个说法是错误的.\n> 因为c#的`int`始终映射到`System.Int32`类型. 所以不管在什么操作系统上运行,代表的都是32位整数.\n> 如果用Int32,这样的误解就没有了.\n\n2. C#的`long`类型映射到的是`System.Int64`,而其他编程语言中可能映射到Int16或Int32. 例如C++/CLI就将long视为Int32. 事实上大多数语言不将long当做关键字.根本不编译使用了它的代码.\n\n3. FCL的许多方法都将类型名作为方法名的一部分.例如BinaryReader类型的方法包括ReadBoolean,ReadInt32,ReadSingle等, 而System.Convert类型的方法包括ToBoolean,ToInt32,ToSingle等.\n\n```csharp\n// 虽然语法上没问题, 但float的那一行无法一下子判断该行的正确性.\nBinaryReader br = new BinaryReader(...);\n// 使用float C#关键字\nfloat val = br.ReadSingle(); // 正确,但感觉别扭\n// 使用Single FCL类型名称\nSingle val = br.ReadSingle();// 正确,感觉自然\n\n```\n\n4. 平时只用C#的许多程序员逐渐忘了还可以用其他语言写面向CLR的代码.`C#主义逐渐入侵类库代码`.例如:FCL几乎完全是用C#写的,FCL团队向库中引入了`Array`的`GetLongLength`这样的方法,该方法返回的是`Int64`值.这种值在C#中确实是long,但是在其他语言比如C++/CLI中不是. 另一个例子是:`System.Linq.Enumerable`的`LongCount`方法.\n\n**考虑到以上原因,本书坚持使用FCL类型名称.**\n\n## System.Int32 为什么能转 System.Int64?\n\n在许多编程语言中,一下代码都能正确编译并运行:\n\n```csharp\nInt32 i = 5;//32位值\nInt64 i = i;//隐形转型为64位值\n```\n但是根据上一章内容,对类型转换的讨论,你或许认为上述代码无法编译. 毕竟`System.Int32`和`System.Int64`是不同的类型.互相不存在派生关系. 但是能正确编译上述代码,运行起来也没有问题.\n\n原因是: C#编译器非常熟悉基元类型,会在编译代码时应用自己的特殊规则.\n1. 具体的说,C#编译器支持与`类型转换`,`字面值(直接量或文字常量)`以及`操作符`有关的模式.\n\n### 转型\n\n编译器能执行`基元类型之间`的隐式或显示转型.\n```csharp\nInt32 i = 5; //从Int32隐式转型为Int32\nInt64 l = i; //从Int32隐式转型为Int64\nSingle s =i; //从Int32隐式转型为Single\nByte b = (Byte)i;// 从Int32显示转型为Byte\nInt16 v = (Int16)s;//从Single显示转型为Int16\n```\n\n只有在转换`安全`的时候,C#才允许隐式转型.\n- 什么是转换`安全`的时候?\n  - 是指不会发生数据丢失的情况. 比如从`Int32`转换为`Int64`.\n\n- 如果可能`不安全`,C#就要求显示转型.\n  - 对于数值类型,`不安全`意味着转换后丢失精度或数量级.\n  - 例如`Single(float IEEE32位浮点值)`,转换为`Int16(short 有符号16位)`也要求显示转型.因为Single能表示比Int16更大数量级的数字(会丢失精度).\n\n#### C#编译器总是对转型结果进行截断\n\n比如 6.8的`Single(float IEEE32位浮点值)`转型为`Int32`,\n**C#总是对结果进行截断(向下取整)**, 结果是将6放入`Int32`类型中.\n\n> 有些编译器可能会将结果向上取整为7.\n\n### 字面值\n\n`字面值`可被看成是类型本身的实例.\n\n```csharp\n// 实例 调用 实例方法\nConsole.WriteLine(123.ToString() + 456.ToString()); // 123456\n\n// 如果表达式由字面值构成, 编译器在编译时就能完成表达式求值.从而增强应用程序性能.\nBoolean found = false;// 生成的代码将found设为0\nInt32 x = 100 + 20 + 3;// 生成的代码将x设为123\nString s = \"a \" + \"bc\";// 生成的代码将s设为\"a bc\"\n```\n\n## checked 和 unchecked 基元类型操作\n\n对基元类型执行的许多算术运算符都可能造成溢出:\n\n```csharp\n// byte 2^8 = 256\nByte b = 100;\n// 100 +200 = 300\n// 执行此处算术运算符时, 要求所有的操作数扩大到32位(64位,如果有操作数需要超过32位来表示的话)\n// b 和 200 都不超过32位,则先转换成32位值,然后加到一起,结果是一个32位的十进制300.\n// 然后该值存回b变量前**必须转型为Byte, C#不隐式执行此操作.**\nb = (Byte)(b + 200); // b 现在为 44\n```\n\n## 溢出处理\n\n1. 溢出大多数时候是不希望出现的,会导致应用程序行为失常.但是极少数时候计算哈希值和校验和,这种溢出可以接受.\n2. 不同语言处理溢出的方式不同, C/C++不将溢出视为错误,允许值回滚.VB则视为错误,并抛出异常.\n\n> 回滚:一个值超出允许的最大值时,回滚到一个非常小的,负的或者未定义的值.\n\nCLR提供了一些特殊的IL指令. 允许程序员自己决定如何处理溢出. CLR有一个add指令,作用是将两个值相加,但不执行溢出检查,还有一个add.ovf指令,会在溢出时抛System.OverfolwException异常.\n\n1. `溢出检查`默认是关闭的. 编译器生成IL代码时,将自动使用加减乘和转换指令的无溢出检查版本.代码能更快的运行.\n2. `/checked+`编译器开关在生成代码时使用溢出检查版本.这样CLR会检查这些运算,判断是否发生溢出,并抛出异常.\n3. 除了全局性的打开和关闭溢出检查, 程序员可以在代码的特定区域控制.\n   - unchecked 操作符\n   - checked 操作符\n\n```csharp\nUInt32 invalid = unchecked( (UInt32) (-1)); // OK\n\nByte b = 100;\n// 会抛出OverflowException异常\n// 这个过程中,b和200会转成32位值,\n// 300 转成 Byte就会抛出异常\nb = checked((Byte)(b + 200));\n\n// b包含44, 不会抛出异常.\nb = (Byte)checked(b + 200);\n```\n\nC#还支持checked和unchecked语句. 可以是语句块中的代码都进行或不进行溢出检查.\n\n> checked和unchecked语句 唯一作用就是决定生成哪个版本的加减乘和数据转换的IL指令.\n> **所以在checked操作符或语句中 调用方法,不会对该方法造成任何影响.**\n\n```csharp\nchecked\n{\n  Byte b = 100;\n  //简化 b = (Byte)(b + 200)\n  b += 200;\n}\n\nchecked\n{\n  // 假定SomeMethod试图把400加载到一个Byte中\n  SomeMethod(400);\n  // SomeMethod 可能会,也可能不会抛出OverflowException异常\n  // 如果SomeMethod使用checked指令编译,就可能会抛出异常.\n  // 但这和当前的checked语句无关.\n}\n```\n\n## 应对无效输入的建议\n\n1. 尽量使用有`符号数值类型`比如:Int32和Int64,而不是`无符号数值类型`UInt32和UInt64.\n  - 这允许编译器检测更多的上溢/下溢的错误.\n  - 类库的多个部分,比如Array和String的Length属性 被硬编码为返回有符号的值.\n  - 减少强制类型转换,无符号数值类型不符合CLS.\n\n2. 写代码时,如果代码可能发生你想不到的溢出(可能是无效的输入,使用用户或客户机提供的数据), 就把这些代码放到`checked块`中. 同时捕捉`OverflowException`异常.\n\n3. 将允许发生溢出的代码显示放到`unchecked块`中,比如在计算校验和时.\n\n4. 对于没有使用`unchecked`和`checked`的语句,都假定发生溢出时抛出异常.\n\n![](5基元类型引用类型和值类型/5-1-1.png)\n\n勾选 `检查运算上溢/下溢` 相当于打开了编译器的`/checked+开关`进行调试性生成.应用程序运行起来会慢一点.可以进行比较完整的溢出检查.\n\n## System.Decimal是非常特殊的类型\n\n1. C#和VB视为基元类型. 但是CLR不这样. CLR没有知道如何处理Decimal值的IL指令.\n2. Decimal类型自己定义一系列方法,包括Add,Subtract,Multiply,Divide. 还为`+-*/`等提供了操作符重载方法.\n3. 编译使用了Decimal值的代码时,**编译器会生成代码来调用Decimal的成员方法**,并**通过这些成员方法来进行实际的运算**. 这也意味着Decimal值的处理速度慢于CLR基元类型的值.\n4. 由于没有相应的IL指令来处理Decimal值, 所以checked和unchecked操作符,编译器开关都失去作用.\n\n## System.Numerics.BigInteger类型\n\n1. 类似的,BigInteger类型也在内部使用了`UInt32`数组来表示任意大的整数,它的值没有上限和下限.\n2. 因此对于BigInteger类型执行运算永远不会造成OverflowException异常\n3. 如果值太大,没有足够的内存来改变数组大小,BigInteger的运算可能会抛出`OutOfMemoryException`异常.\n","tags":["CLR读书笔记"]},{"title":"4类型基础","url":"/2019/07/08/4类型基础/","content":"\n# 所有类型都从System.Object派生\n\n**`运行时`要求每个类型都从`System.Object`派生**.\n\n```csharp\n//隐式派生自Object\nclass Employee｛\n  ...\n｝\n//显式派生自Object\nclass Employee: System.Object{\n  ...\n}\n```\n\n## System.Object的公共方法Equals\n| 公共方法 | 说明 |\n| :------| ------ |\n| Equals  | 如果两个对象具有`相同的值`就返回true  |\n\n### 对象的相等性和同一性\n\n#### 同一性\n\n```csharp\n// 此虚方法实现的是同一性,而非相等性.\n// 因为obj引用的对象如果不是引用相同对象,那就无法比较值是否相等.\npublic virtual Boolean Equals(Object obj)\n{\n  // 如果两个引用指向同一个对象,它们肯定包含相同的值\n  if (this == obj) return true;\n  // 假定对象包含不同的值\n  return false;\n}\n```\n\n| 静态方法 | 说明 |\n| :------| ------ |\n| ReferenceEquals  | 检查两个引用是否指向同一对象  |\n\n> 检查同一性务必调用ReferenceEquals,不应该使用C#的== 操作符 (除非都转成Object), 因为某个操作数可能重载了==操作符.\n\n```csharp\n// 上述方法是不合理的,因此Microsft提供了检查同一性的方法\npublic static bool ReferenceEquals (Object objA, Object objB) {\n    return objA == objB;\n}\n```\n#### 重写Equals方法\n\n1. Equals 必须自反: x.Equals(x)肯定返回true\n2. Equals 必须对称:  x.Equals(y)和y.Equals(x)返回相同\n3. Equals 必须可传递:  x.Equals(y)返回true,  y.Equals(z)返回true,那么 x.Equals(z)肯定是true\n4. Equals 必须一致:比较的两个值不变,返回值也不能变.\n\n### 值类型的基类ValueType重写了Equals方法\n\n```csharp\npublic override bool Equals(object obj)\n{\n  // 1.判断实参obj是否为null\n  if (obj == null)\n    return false;\n  RuntimeType type = (RuntimeType) this.GetType();\n  // 2.this和obj实参引用不同类型的对象,返回false\n  if ((RuntimeType) obj.GetType() != type)\n    return false;\n  object a = (object) this;\n\n  // 3. 如果对象的成員中存在对于堆上的引用，那么返回false，\n  // 如果不存在，返回true。例如按照ValPoint的定义，它仅包含一个int类型的字段x，自然不存在对堆上其他对象的引用，所以返回了true\n  if (ValueType.CanCompareBits((object) this))\n    return ValueType.FastEqualsCheck(a, obj);\n\n  // 4.利用反射获取值的所有字段\n  FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n  for (int index = 0; index < fields.Length; ++index)\n  {\n    object obj1 = ((RtFieldInfo) fields[index]).UnsafeGetValue(a);\n    object obj2 = ((RtFieldInfo) fields[index]).UnsafeGetValue(obj);\n    // 5. 判断是否为null\n    if (obj1 == null)\n    {\n      if (obj2 != null)\n        return false;\n    }\n    // 6. 通过调用字段的Equals方法进行比较\n    else if (!obj1.Equals(obj2))\n      return false;\n  }\n  return true;\n}\n```\n由于CLR反射机制慢,定义自己的值类型时应重写`Equals`方法来提供自己的实现.从而提高用自己类型的实例进行值相等性比较的性能. **当然,自己的实现不调用 `base.Equals`**.\n\n### 重写Equals方法还需要做的事\n\n1. 让类型实现`System.IEquatable<T>`接口的`Equals`方法\n  - 泛型接口,定义类型安全的`Equals`方法` bool Equals(T other)`;\n2. 重载==和!=操作符方法( 这些方法内部调用了类型安全的`CompareTo`方法. )\n3. 如果需要排序,类型还应该实现`System.IComparable`的`CompareTo`方法和泛型接口`System.IComparable<T>`的类型安全的`CompareTo`方法.\n4. 重载比较操作符方法<,<=,>,>= ( 这些方法内部调用了类型安全的`CompareTo`方法.)\n\n\n\n## System.Object的公共方法GetHashCode\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetHashCode  | 返回对象值的哈希码.如果某个类型的对象要在哈希表集合(比如`Dictionary`)中作为键使用,类型应重写该方法.  |\n\n### 对象哈希码\n\nFCL的设计者认为,如果能将任何对象的任何实例放到`哈希集合`中,能带来很多好处。为此`System.Object`提供了虚方法`GetHashCode`,它能获取任意对象的Int32哈希码.\n\n如果你定义的类型重写了Equals方法,还应该重写GetHashCode方法. 这是因为`System.Collections.Hashtable`类型,`System.Collections.Generic.Dictionary`类型以及一些其他的集合中,要求两个对象必须具有**相同哈希码才能被视为相等**. 确保相等性算法和对象哈希码算法一致.\n\n- 添加\n  - 向集合添加`键/值对`,首先要获取`键`对象的哈希码, 该哈希码指出这个`键/值对`要存储到哪个`哈希桶bucket`中.\n- 查找\n  - 集合需要查找`键`时候, 会获取`键`对象的哈希码, 此哈希码标识了现在要以顺序的方式搜索的哈希桶. 在这个哈希桶中查找哈希码相同的`键`对象,以及对应的`值`对象.\n- 修改\n  - **错误的方式: 直接修改集合中的`键`对象,修改后的键对象的哈希码与原来不同,就会去搜索错误的哈希桶,找不到对应的值对象.**\n  - 正确做法: 从集合中移除原来的`键/值对`, 修改键对象, 重新将新的键值对添加回哈希表.\n\n### 自己实现哈希算法\n自定义GetHashCode方法,取决于数据类型和数据分布情况, 需要设计出能返回良好分布值的哈希算法.\n\n要遵循的规则:\n1. 算法要提供良好的随机分布,使哈希表获得最佳性能.\n2. 一般不要调用Object或ValueType的GetHashCode方法, 因为两者的实现与高性能哈希算法不沾边.\n3. 算法至少使用一个实例字段.\n4. 理想情况下, 算法使用的字段值应该不可变,也就是说,字段在对象构造时初始化,在对象的生存期永不言变.\n5. 算法执行速度尽量快.\n6. 包含相同值的不同对象应返回相同的哈希码.\n\n> System.Object实现的GetHashCode方法对派生类型和其中的字段一无所知,所以返回一个在对象生存期保证不变的编号.\n\n> 最好不要将哈希码持久化, 因为生成哈希码的算法可能会发生改变. 例如:CLR版本升级后,String的GetHashCode方法发生了改变. 之前如果存储的是string的哈希码,则导致全部不对应了.\n\n\n## System.Object的公共方法ToString\n| 公共方法 | 说明 |\n| :------| ------ |\n| ToString  | 默认返回类型的完整名称`this.GetType().FullName` . 经常用于调试的目的重写该方法,返回一些值的字符串表示. |\n\n## System.Object的公共方法GetType\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetType  | 返回从Type派生的一个类型的实例,指出调用GetType的对象是什么类型. |\n\n### GetType是非虚方法.\n\n目的是`不允许重写`. 防止类重写该方法,隐瞒其类型,进而破坏类型安全性.(用new关键字告诉编译器定义一个新方法`new public void F()`)\n\n\n> 返回的Type对象可以和反射类配合,获取与对象的类型有关的元数据信息.\n\n\n## System.Object的受保护方法MemberwiseClone\n| 受保护方法 | 说明 |\n| :------| ------ |\n| MemberwiseClone  | 就是创建一个浅表副本的新对象，然后将当前对象的非静态字段复制到该新对象. |\n\n`MemberwiseClone` 方法创建一个`浅表副本`，。如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则**复制引用但不复制引用的对象**；因此，原始对象及其复本引用同一对象。\n\n```csharp\npublic DemoClass Clone1() //浅CLONE\n{\n    return this.MemberwiseClone() as DemoClass;\n}\n\npublic DemoClass Clone2() //深clone\n{\n    MemoryStream stream = new MemoryStream();\n    BinaryFormatter formatter = new BinaryFormatter();\n    formatter.Serialize(stream, this);\n    stream.Position = 0;\n    return formatter.Deserialize(stream) as DemoClass;\n}\n```\n\n\n### 什么是浅表副本?\n- 浅度拷贝( **浅表副本** )\n  - 一个集合的浅度拷贝意味着只拷贝集合中的元素，不管他们是引用类型或者是值类型，但是它`不拷贝引用所指的对象`。这就是说新集合中的引用和原始集合中的`引用所指的对象是同一个对象`。\n- 深度拷贝( **深表副本** )\n  - 深度拷贝不仅拷贝集合中的元素，而且还拷贝了这些元素直接或者间接引用的所有内容。这也就意味着，新集合中的引用和原始集合中的`引用所指的对象是不同的`.\n\n### 深度复制原理\n为了实现`深度复制`，我们就必须遍历有相互引用的对象构成的图，并需要处理其中的循环引用结构。这无疑是十分复杂的。幸好借助.Net的`序列化和反序列化机制`，可以十分简单的深度Clone一个对象。原理很简单，首先将对象序列化到内存流中，此时对象和对象引用的所用对象的状态都被保存到内存中。.Net的序列化机制会自动处理循环引用的情况。然后将内存流中的状态信息反序列化到一个新的对象中。这样一个对象的深度复制就完成了。在原型设计模式中CLONE技术非常关键。\n\n### 深拷贝的帮助类\n```csharp\npublic static class ObjectCopier\n{\n    /// <summary>\n    /// Perform a deep Copy of the object.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of object being copied.</typeparam>\n    /// <param name=\"source\">The object instance to copy.</param>\n    /// <returns>The copied object.</returns>\n    public static T Clone<T>(T source)\n    {\n        // 判断泛型T是否能序列化\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(\"The type must be serializable.\", \"source\");\n        }\n\n        // Don't serialize a null object, simply return the default for that object\n        // 不能序列化一个null对象\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n\n        // 流操作\n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n    }\n}  \n```\n\n\n## System.Object的受保护方法Finalize\n| 受保护方法 | 说明 |\n| :------| ------ |\n| Finalize  | 在垃圾回收器判断此对象作为垃圾被回收之后,在对象的内存被实际回收之前,调用此虚方法. |\n\n需要在回收之前执行清理工作的类型应重写此方法.\n\n\n# 所有对象都要用new操作符\n\n> 实例字段(实例成员)是非静态字段  --- 属于类的对象\n> 静态成员----------------------- 属于类\n\n\n**new 操作符所做的事情**\n1. 计算类型及其所有基类(一直到System.Object)中定义的所有实例字段需要的字节数. (计算需要的字节数 )\n  - `堆`上的每个对象都需要有`开销成员overhead`,包括 `类型对象指针(type object pointer)`和`同步块索引sync block index`.\n  - CLR利用这些`开销成员`管理对象. `开销成员`的字节数要计入对象的大小.\n2. 从`托管堆`中分配类型要求的字节数, 从而分配对象的`内存`, 分配的所有字节都设置为`零(0)`.\n3. 初始化对象的`开销成员`:`类型对象指针(type object pointer)`和`同步块索引sync block index`.\n4. 调用类型的实例化`构造器`,传递在new调用中指定的`实参`.\n  - 每个类型的构造器都负责初始化该类型定义的实例字段. 最终调用System.Object的构造器,该构造器什么都不做,简单地返回.\n5. 返回新建对象的一个引用(或指针).\n\n\n> 没有delete操作符用来显示释放为对象分配的内存, CLR采用垃圾回收机制.\n\n# 类型转换及类型安全性\n\n> CLR最重要的特性就是类型安全. 在运行时,CLR总是知道对象的类型是什么.\n> 调用GetType方法即可知道对象的确切类型.\n> 由于它是非虚方法,所以不可能伪装成别的类型.\n\nCLR运行将对象转换为`它的(实际)类型`或者`它的任何基类型`.\n\n- `对象类型` --转换成--> `该对象的基类型`\n  - C#中, `向基类型的转换`是一种安全的**隐式转换** .\n- 而将`对象类型` --转换成--> `该对象的某个派生类型`\n  - C#要求开发人员只能进行 **显示转换(强制类型转换)** .\n\n\n```csharp\n// Employee的基类是Object\n// 不需要转换, 派生类对象转基类对象是类型安全的隐式转换\nObject o = new Employee();\n\n// Employee是Object的派生类,需要进行转型\n// 必须用强制类型转换\nEmployee e = (Employee)o;\n```\n\n> 为了方便记忆,打个比方\n>- `公交汽车(派生类)` 可以认为是 `汽车(基类)` , 因为包含`汽车(基类)`都存在的东西.\n>- 但是, `汽车(基类)` 并不只有`公交汽车(派生类)`,还有其他类型的汽车.\n\n这样才能让编译器顺利编译这些代码.\n\n运行时做的事:\n1. CLR检查转型操作, 确保总是转换为对象的实际类型或者它的任何基类.\n\n```csharp\n// 在运行时, CLR会检查转换,判断o的实际类型是否是Employee类型或者它的派生类.\nEmployee e = (Employee) o;\n```\n( `A` ) >= `A/A的派生类`.\n\n因此,类型安全是CLR及其重要的一个特点.\n```csharp\nclass A{..}\n\nclass B:A{..}\n\nMain()\n{\n  B b = new B();\n  test(b);\n\n  DateTime t = new DateTime(...);\n  // 编译期 t的基类也是object,能通过编译\n  test(t);\n}\n\nstatic test(Object o)\n{\n  // 运行期会CLR会进行类型检查,\n  // 传进来的参数t类型基类不是A,也不是A的派生类,\n  // 会报System.InvalidCastException异常\n  A a = (A)o;\n}\n```\n给方法合适的参数能在编译期就能发现错误,而非运行期报错.例如改为`test(A a){}`而不是`Object`参数类型.\n\n\n# 使用C#的is和as操作符来转型\n\n> 相较于is操作符,使用as操作符来简化写法和提升性能.\n\n相较于之前的`()`强转语法,C#还有另外一方式进行类型转换. 是使用`is`操作符,区别如下\n1. 返回Boolean值true或false;\n2. 并且永远不会抛出异常.\n3. 如果对象引用null,is操作符总是返回false.\n\n通常使用方法:\n```csharp\n// 这种用法有个缺点,\n// CLR实际检查两次对象类型.\n// 1. is操作符首先核实o是否兼容于A类型,\n// 2. 如果是,在if内部转型时,CLR再次核实o是否引用一个A类型.\n// 这样对性能造成了一定的影响\nif(o is A)\n{\n  A a = (A)o;\n  // 在if剩余语句使用a\n}\n```\n\n**这种写法对性能造成影响,是因为CLR必须遍历继承层次结构,用每个基类型去核对指定的类型(上述例子中的A类型).**\n\nC#专门提供了as操作符,目的就是简化这种写法,同时提升性能.\n1. `as`操作符返回对同一个对象的`非null引用`.\n2. 工作方式与强制转换一样,并且不会抛出异常.\n3. 如果对象不能转型,则返回`null`.\n4. `as`操作符造成CLR值校验一次对象类型\n\n```csharp\n// as操作符造成CLR值校验一次对象类型\n// 从而提高性能\nA a = o as A;\nif (a != null)\n{\n  // 在if语句中使用a\n}\n\n```\n\n> 编译时错误 Complier Time Error 运行时错误Run Time Error\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 向基类型的转换是一种安全的隐式转换\n        Base b2 = new Dervied();\n\n        // CTE 编译时错误\n\n        // Base派生自object,不能由new基类创建子类. new子类可以创建基类\n        // Base b3 = new Object(); // CTE\n        Object o2 = new Base();\n\n        // Dervied d3 = new Object(); // CTE\n        Object o3 = new Dervied();\n\n        // new Dervied()隐式转为Base类. b2要转成原本的Dervied类型需要显示转换\n        // Dervied d3 = b2; // Base b2 = new Dervied();  // CTE\n        Dervied d3 = (Dervied)b2;\n\n        // RTE 运行时错误\n\n        // 不能由new基类转换子类,CLR会在运行期检查类型,判断 (Dervied) >= new Base()\n        Dervied d6 = (Dervied) new Base(); // RTE\n        Base b5 = (Base) new Object(); //RTE\n    }\n}\n\nclass Base{}\nclass Dervied : Base{}\n```\n\n**注意: C#允许类型定义`转换操作符`方法, 只有在使用转型表达式时才调用这些方法,使用C# `as/is操作符`永远不会调用它们.**\n\n\n\n# 命名空间和程序集\n\n1. 命名空间和程序集不一定相关, 同一个命名空间中的类型可能在不同程序集中实现.同一程序集也可能包含不同命名空间中的类型.\n2. 使用命名空间用`using`指令\n  - 引用类库,标记命名, 少写代码.\n  - 为类型和命名空间创建别名, 消除歧义.\n\n```csharp\nusing Microsoft; // 可以少写Microsoft.前缀\nusing Wintellect;// 可以少写Wintellect.前缀\n\nusing WintellectWidget = Wintellect.Widget; //\n\npublic class Program\n{\n  // 这样写会有歧义,不明确引用. 两个命名空间中都包含Widget类\n  // Widget w = new Widget();\n\n  // 消除了歧义, 需要多打一点字\n  Wintellect.Widget w = new Wintellect.Widget();\n\n  // 使用using别名方式\n  WintellectWidget w = new WintellectWidget();\n}\n```\n3. `外部别名extren alias` 用于更精细的消除歧义\n  - 公司Axxxx Bxxxx Cxxxxx和Ayyyy Byyyy Cyyyyy公司都发布一个`BuyProduct`类型\n  - 如果他们都用ABC作为命名空间, 那同时引用这2个公司的dll就会出现一个问题\n    - `ABC.BuyProduct`方法会报不明确引用.\n\n![](4类型基础/外部别名.png)\n\n\n> 为此,为了降低冲突发生的概率,应该使用全称来作为自己的顶级命名空间名称.\n\n# 运行时的相互关系\n\n- C#中`栈` 是**编译期间就分配好的内存空间**，因此你的代码中必须就`栈的大小`有明确的定义；\n- `堆` 是**程序运行期间动态分配的内存空间**，你可以根据程序的运行情况确定要分配的堆内存的大小.\n\n## 创建线程栈\n\n已加载CLR的一个Windows进程，进程中可能有多个线程。\n\n**线程创建时会分到1MB的栈。**\n- 栈空间用于向方法`传递实参`\n- 方法内部定义的`局部变量`也在栈上。\n- 栈从高位内存地址向地位地址构建。\n\n## 开始调用一个方法M1\n\n在开始调用之前,\n- `序幕(prologue)代码`对其进行初始化.\n\n在方法做完工作后\n- `尾声(epilogue)代码`对其进行清理,以便返回至调用者.\n\n![](4类型基础/4-2.png)\n\n1. 假定线程执行的代码要调用M1方法\n2. M1方法开始执行时,它的`序幕代码`在线程栈上分配`局部变量name`的内存,如4-3图示.\n\n![](4类型基础/4-3.png)\n\n3. 然后M1调用M2方法, 将`局部变量name`作为`实参`传递,将这个实参也`压入栈`,并且将`返回地址`压栈.\n  - `返回地址`:被调用的方法在结束之后应该回至该位置.如4-4图示.\n\n![](4类型基础/4-4.png)\n\n4. M2方法开始执行时, 它的`序幕代码`在线程栈上分配`局部变量length和tally`的内存. 如4-5所示.\n\n![](4类型基础/4-5.png)\n\n5. M2方法内部开始执行,最终达到`return`语句,CPU的指令指针被设置成`返回地址`. M2的`栈帧展开(unwind)`.恢复成4-3所示.\n\n> `栈帧展开(unwind)` : 这个翻译来源自生活,把线缠到线圈上称为wind,从线圈上搜开称为unwind.同样的调用方法时压入栈帧称为wind,方法执行完毕弹出栈帧称为unwind.\n\n6. 最终M1会返回到它的调用者. 这同样通过将CPU的指令指针设置成返回地址来实现.\n\n\n# 围绕CLR来观察,来演示CLR如何工作的\n\n```csharp\ninternal class Employee {\n    public               int32         GetYearsEmployed()       { ... }\n    public    virtual    String        GenProgressReport()      { ... }\n    public    static     Employee      Lookup(String name)      { ... }    \n}\ninternal sealed class Manager : Employee {\n    public    override   String         GenProgressReport()    { ... }\n}   \n```\n\n1. Window进程已经启动,CLR已经加载到其中,托管堆已经初始化,而且创建了一个线程(连同它的1MB栈空间).\n2. 准备要调用M3方法.\n\n![](4类型基础/4-6.png)\n\n3. **JIT编译器** 将M3的`IL代码`转换成`本机CPU指令`时, CLR需要确认定义了这些类的类型都已加载.\n  - `Employee`,`Int32`,`Manager`,以及`String`(因为存在一个\"Joe\"的字符串).\n4. 然后利用程序集的`元数据`,CLR提取与这些类型有关的信息. 并创`建一些数据结构`来表示类型本身.\n  - 图4-7展示了`Employee`和`Manager`类型对象使用的`数据结构`.\n  - 至于`Int32`,`String`的`数据结构`可以认为之前已经定义好了.因为它们都是很常用的类型.所以图中没显示它们.\n\n![](4类型基础/4-7.png)\n\n- 堆上所有对象都包含两个额外成员:\n  - `类型对象指针(type object pointer)`\n  - `同步索引块(sync block index)`\n- 静态数据字段.\n- 方法表: 定义的所有方法都有一个对应的记录项.\n\n5. 当CLR确认方法需要的所有类型对象都已创建,M3的代码编译之后,就允许线程执行M3的`本机代码`.\n  - M3的`序幕代码`执行时必须在线程栈中为局部变量分配内存.\n  - 在调用类型构造器之前,CLR会先初始化同步块索引,将对象的所有实例字段设为null或者0.\n  - CLR自动将所有局部变量初始化为`null`或者`0`.\n  - Manager只定义了1个方法(GetProgressReport的重写)\n\n![](4类型基础/4-8-9.png)\n\n6. 任何时候在堆上新建对象,CLR都自动初始化内部的`类型对象指针`成员来引用和对象对应的类型对象.\n7. new 操作符返回Manager对象的内存地址. 该地址保存到变量e中,(e在线程栈上).\n8. M3下一行代码调用Employee的`静态方法Lookup`.\n  - CLR定位类型对象\n  - JIT编译器查找类型对象的方法表中对应的记录项, 对方法进行JIT(如果需要的话).\n  - 再调用JIT编译好的代码.\n9. 假定`静态方法Lookup`会从数据库找出一名经理Joe.\n  - 在方法内会在堆上构造一个新的Manager对象, 用Joe的对象初始化它.返回该对象的地址.\n  - 该地址保存到变量e中\n  - 这里e不再引用第一个Manager对象, 第一个对象会被垃圾回收.\n10. M3的下一行代码调用Employee的非虚实例方法GetYearsEmployed\n  - JIT编译器会找到 **发出调用的那个变量(e)的类型 对应的类型对象(Employee)**.\n  - 此时e的类型定义为`Employee`类型\n    - 如果此类型中没有定义被调用的方法\n    - JIT编译器会**回溯类层次结构**(一直到Object),并沿途的每个类型中查找该方法.\n\n> 之所以能`回溯`,是因为每个类型对象都有一个字段引用了它的`基类型`.\n\n![](4类型基础/4-10.png)\n\n11. JIT编译器找到了被调用方法的记录项, 进行JIT编译,再调用JIT编译好的代码,将返回的数据放到临时变量中保存.\n\n12. M3的下一行代码调用了Employee的`虚实例方法(虚方法,重写过的)`GetProgressReport.\n  - `调用虚方法`时,JIT编译器要在方法中生成一些额外的代码.\n  - 方法每次调用都会执行这些代码, 这些代码首先\n    - 检查`发出调用的变量`, 并跟随地址来到`发出调用的对象`\n    - 变量e当前引用的是代表\"Joe\"的Manager对象.\n    - 代码检查对象内部的`类型对象指针`成员, 该成员指向对象的实际类型.\n    - 代码在类型对象的方法表中查找对应调用方法的`记录项`,对方法进行JIT编译\n    - 再调用编译好的代码.\n    - 由于目前e引用的是一个Manager对象,所以会调用Manager的GetProgressReport实现\n\n![](4类型基础/4-11-12.png)\n\n\n> 注意:  如果Employee对象的`Lookup方法`发现\"Joe\"是`Employee`而不是`Manager`,则Lookup会在内部构造一个Employee对象,它的类型对象指针将引用Employee类型, 最终执行的则是Employee的GetProgressReport实现,而不是Manager的.\n\n\n# CLR内部发生的事情\n\nEmployee和Manager类型对象都包含\"类型对象指针\"成员. 这是由于类型对象本质上也是对象.\n\nCLR创建类型对象时, 必须初始化这些成员.\n\n## 初始化什么呢?\n\n1. CLR开始在一个进程中运行时, 会立即为MSCorLib.dll中定义的`System.Type`类型创建一个特殊的类型对象.\n2. Employee和Manager类型对象都是该类型的\"`实例`\"``\n3. System.Object的`GetType方法`返回存储在指定对象的`类型对象指针`成员中的地址.\n  - 也就是说,GetType方法返回`指向对象的类型对象`的指针.\n  - 这样就可以判断系统中任何对象的真实类型.\n\n![](4类型基础/4-13.png)\n","tags":["CLR读书笔记"]},{"title":"3CLR基础4","url":"/2019/07/07/3CLR基础4/","content":"# 程序集种类和部署方式\n\n本章将解释 .Net Framework为了解决版本控制问题而建立的基础结构.\n\n## 为什么要有强命名程序集?\n\n因为只根据文件名来区分程序集明显不够, CLR必须支持对程序集进行唯一性标识的机制. 这就需要`强命名程序集`.\n\n## 私有部署 & 全局部署\n\n- 私有部署:程序集部署到应用程序`基目录`或者`某个子目录`.\n- 全局部署:部署到`公认位置`的程序集.\n\n## 强命名程序集 & 弱命名程序集\n\n- 强命名程序集\n  - 使用了发布者的公钥/私钥进行了`签名`.\n  - 这对秘钥允许对程序集进行唯一性的标识.\n  - 私有部署和全局部署都可以.\n- 弱命名程序集\n  - 只能以私有方式部署.\n\n### 在生成的程序集中引用强命名程序集\n\n1. CSC.exe编译器 /r 开关引用,如果不指定目录,按照以下顺序查找\n  - 工作目录\n  - CSC所在目录\n  - 使用/lib 编译器开关指定的目录\n  - 使用LIB环境变量指定的任何目录\n\n## 唯一性标识技术\n- GUID(Globally Unique Identifier) 全局唯一标识符\n- URL(Uniform Resource Locator) 统一资源定位符\n- URN(Uniform Resource Name)\n\n没有使用以上技术,使用了 `标准的公钥/私钥加密技术`\n\n![](3CLR基础4/公钥.png)\n\n`PublicKeyToken`:公钥标记, 如果没null,则是弱命名程序集.\n\n## 创建强命名程序集\n\n可以使用SN.exe(Strong Name)工具来生成公钥/私钥对。\n\n在VS中,新建`公钥/秘钥文件`,可显示项目属性,点击`签名`标签,勾选`为程序集签名`,然后从选择`强名称秘钥文件`中新建.\n\n\n# 全局程序集缓存\n\n1. 如果一个程序集要由多个应用程序访问，必须把它放到一个已知的目录中，而且clr在检测到对该程序集的一个引用时，必须知道自动检查该目录。这个已知的位置成为`全局程序集缓存(GAC,Global Assmbly Cache)`。\n2. GAC通常位于`%SystemRoot%\\Microsoft\\Assembly`\n3. GAC目录是结构化的：其中包含许多子目录，并用一个算法来生成这些子目录的名称。不要手动复制.要用工具完成.\n4. 可以使用GACUtil.exe在GAC中安装一个强命名程序集.\n5. 无法将弱命名程序集安装到GAC.\n\n\n# \"运行时\"如何解析类型引用\n\n1. 运行应用程序,CLR会加载并初始化自身\n2. 读取程序集的`CLR头`,查找标识了应用程序入口方法(Main)的`MethodDefToken`\n3. 检索`MethodDef元数据表`,找到方法的的IL代码在文件中的偏移量\n4. 将IL代码JIT编译成本机代码.\n5. 最后执行本机代码.\n\n\n解析引用的类型时候,CLR可以在三个地方找到类型：\n- 同一个文件（早期绑定）\n- 不同的文件但同一个程序集（当前程序集清单目录）\n- 不同的文件不同的程序集（其他程序集清单目录）。　　\n\n\n- `早期绑定early binding`: 编译时便能发现对相同文件中的类型的访问.\n- `晚期绑定late binding`: 在运行时通过反射机制绑定到类型并调用方法.\n\n1. 对于CLR来说，所有程序集都是根据名称、版本、语言文化和公钥来标识的。\n2. GAC根据名称、版本、语言文化和`cpu架构`来标识程序集。\n","tags":["CLR读书笔记"]},{"title":"2CLR基础3","url":"/2019/07/07/2CLR基础3/","content":"# .Net Framework部署目标\n\n## 什么是DLL Hell?\n\n> Windows早期并没有很严谨的DLL版本管理机制，以致经常发生安装了某软件后，因为其覆盖了系统上原有的同一个DLL文件，而导致原有可运行的程序无法运行。但还原回原有的DLL文件之后，所新安装的软件就无法运行。若影响到系统所使用的重要DLL时也可能让系统容易死机甚至无法正常启动。\n\n[別再掉進DLL地獄的陷阱裡(DLL Hell)~.NET解決之道 資策會數位教育研究所講師 王芳芳](https://web.archive.org/web/20080208173943/http://www.iiiedu.org.tw/knowledge/knowledge20021130_1.htm)\n\n总结:\n\n1. The .NET Framework NET Assembly 自描述与版本管理功能让 zero-impact(零影响) 的部署安装成为可能，同時也终结了DLL Hell 。\n\n2. Application-Private Assemblies (or 被隔离的assembly) 只能被一个应用程式所使用- 它不会被其他的应用程式所影响。 隔离的assembly 让程式开发者对应用程式有着绝对的控制权，开发好的Application-Private Assemblies只要部署在和应用程式同一目录即可。\n\n3. 透过Side by side execution(并行执行)的技术，应用程式只要安装成功之后，就不用担心DLL更新版本，或规格的改变， 它允许一个assembly 的多个版本在一个机器上同时被安装并执行， 而且每一个应用程式都可以要求和不同的Assembly 版本系结。\n\n4. The .NET Framework 纪录应用程式版本资讯，并在执行应用程式时使用此资讯载入应用程式所需依赖的正确版本的Assemblies。\n\n# 将类型生成到模块中\n\n```csharp\npublic sealed class Program{\n        public static void Main()\n        {\n          // 由于引用了Console类的WriteLine方法\n          // 要顺利通过编译，必须向C#编译器提供一组程序集\n          // 使他能解析对外部类型的引用\n          System.Console.WriteLine(\"Hi\");\n        }\n}\n```\n>System.Console是Microsoft实现好的类型，用于实现这个类型的各个方法的IL代码存储在MSCorLib.dll\n\n> 此处”r“意为`reference`\n\n因此需要添加`r:MSCorLib.dll` 开关命令，完整编译命令行应如下：\n`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs `\n\n但由于其他命令均为默认命令，本例中的编译命令行可以简化为\n`csc.exe Program.cs `\n\n如果不想C#编译器自动引用`MSCorLib.dll`程序集，可以使用`/nostdlib`开关。\n\n## 生成三种应用程序的编译器开关\n\n> 此处”t“意为`target`\n\n- 生成控制台用户界面(Console User Interface, CUI)应用程序使用`/t:exe`开关；\n- 生成图形用户界面(Graphical User Interface, GUI)应用程序使用`/t:winexe`开关；\n- 生成Windows Store应用程序使用`/t:appcontainerexe`开关；\n\n## 集合开关命令的文件:响应文件\n\n编译时可以指定包含编译器设置命令的响应文件，例如：假定响应文件`MyProject.rsp`包含以下文本\n\n```csharp\n// MyProject.rsp\n/out:MyProject.exe\n/target:winexe\n```\n为了让CSC.exe使用该响应文件，可以像下面这样调用它\n\n`csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs`\n\nC#支持多个响应文件，其先后顺序服从就近原则，优先级为`控制台命令>本地>全局`。\n\n.NET Framework具有一个默认的全局CSC.rsp文件，在运行CSC.exe进行编译时会自动调用，全局CSC.rsp文件中列出了所有的程序集，就不必使用C#的/reference开关显式引用这些程序集，这会对编译速度有一些影响，但不会影响最终的程序集文件，以及执行性能，开发者也可以自己为全局CSC.rsp添加命令开关，但这可能为在其他机器上重现编译过程带来麻烦。\n\n另外，指定/noconfig开关后，编译器将忽略本地和全局CSC.rsp文件。\n\n# 什么是元数据? 元数据概述\n\n> 元数据（英语：metadata），又称诠释数据、中介数据、中继数据、后设数据等，为描述其他数据信息的数据.\n\n>元数据概述：元数据是一种二进制信息，用以对存储在公共语言运行库可移植可执行文件 (PE) 文件或存储在内存中的程序进行描述。将您的代码编译为 PE 文件时，便会将元数据插入到该文件的一部分中，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中。在模块或程序集中定义和引用的每个类型和成员都将在元数据中进行说明。当执行代码时，运行库将元数据加载到内存中，并引用它来发现有关代码的类、成员、继承等信息。\n\n首先回顾一下`托管模块(Managed Module)`。`托管模块`是一个需要`CLR`才能执行的`标准WindowsPE(Portable executable，简称PE)文件`。\n\n- `PE32(+)头` :PE 文件主要部分的索引和入口点的地址。运行库使用该信息确定该文件为 PE 文件并确定当将程序加载到内存时执行从何处开始。\n- `CLR表头`:是一个小的信息块，是托管模块特有的，包含生成时所面向的版本号、一些标志、和一个MethodDef token用来指定模块的入口方法，最后，CLR头还包含模块内部的一些元数据表的大小的偏移量\n- `中间语言(IL)代码` : 编译器在编译源代码时产生的指令。CLR在运行时会将IL代码编译成本地CPU指令\n- `元数据`: 元数据表和堆,是由三种表构成的二进制数据块，这三种表分别为`定义表(definiton talbe)`、`引用表(reference table)`和`清单表(mainfest table)`。运行库使用该部分记录您的代码中每个类型和成员的信息。本部分还包括自定义属性和安全性信息。\n\n## 元数据描述的信息\n\n元数据以非特定语言的方式描述在代码中定义的每一类型和成员。元数据存储以下信息：\n\n- 程序集的说明\n  - 标识（名称、版本、区域性、公钥）。\n  - 导出的类型\n  - 该程序集所依赖的其他程序集。\n  - 运行所需的安全权限。\n- 类型的说明\n  - 名称、可见性、基类和实现的接口。\n  - 成员（方法、字段、属性、事件、嵌套的类型）。\n- 属性\n  - 修饰类型和成员的其他说明性元素。\n\n### 定义表(definiton talbe)\n\n**代码中定义的任何东西都将在上表中的某个表创建一个记录项。**\n\n| `定义表`名称 | 说明 |\n| :------| ------ |\n| ModuleDef\t| 包含`模块`文件名,扩展名(不含路径),编辑器创建的GUID 的 记录项.|\n| TypeDef\t| 每个`类型`都在这个表中有一个记录项,包含类型的名称,基类,标志(public/private等),一些索引.这些索引指向MethodDef中属于该类型的方法、FieldDef表中该类的字段、PropertyDef表中该类型的属性以及EventDef表中该类型的时间.|\n| MetodDef  | 每个`方法`(包括入口方法)都在这个表中有一个记录项, 包含方法的名称,标志,签名,以及方法的IL代码在模块中的偏移量(位置),每个记录项还引用了ParamDef表中的一个记录项，后者包括与方法参数有关的更多信息。 |\n|FieldDef   |\t模块定义的每一个`字段`在这个表中都有一个记录项。每个记录项都包括标志、类型和名称。   |\n| ParamDef  |  关于`参数`的记录项 |\n| PropertyDef\t  |  模块定义的每个`属性`在这个表中都有一个记录项。每个记录项都包含标志、类型和名称。 |\n|EventDef\t   | 模块定义的每个事件在这个表中都有一个记录项。每个记录项都包含标志和名称。  |\n\n### 引用表(reference table)\n| `引用表`名称 | 说明 |\n| :------| ------ |\n| AssemblyRef  | `引用的每个程序集`的记录项,每个记录项都包含绑定(bind)该程序集所需的信息：程序集名称(不包含路径和扩展名)、版本号、语言文化及公钥Token(根据发布者的公钥生成一个小的哈希值，标识了所引用程序集的发布者)。  |\n| ModuleRef  | 实现该模块所引用的类型的`每个PE模块`在这个表中都有一个记录项。每个记录项都包含模块的文件名和扩展名(不含路径),如果存在别的模块实现了你需要的类型，这个表的作用便是同哪些类型建立绑定关系  |\n| TypeRef  | 模块引用的每一个`引用类型`.....  |\n| MemberRef   | 模块引用的`每个成员`（字段和方法，以及属性方法和事件方法）在这个表中都有一个记录项。每个记录项都包含成员的名称和签名，并指向对成员进行定义的那个类型的TypeRef记录项  |\n\n### 清单表(mainfest table)\n\n| `引用表`名称 | 说明 |\n| :------| ------ |\n|AssemblyDef   | 如果模块标识的是程序集，这个元数据表就包含`单一记录项来列出程序集名称`(不包含路径和扩展名)、版本(major，minor，build和revision)、语言文化、标志、哈希算法以及发布者公钥(可为null)  |\n|FileDef   | 每个`PE文件和资源文件`在这个表中都有一个记录项(清单本身所在的文件除外，该文件在AssemblyDef表的单一记录项中列出) 在每个记录项中，都包含文件名和扩展名(不含路径)、哈希值和一些标志。如果程序集只包含他的主模块，不包含其他非主模块和资源文件。FileDef将无记录 |\n|ManifestResourceDef   | 每个`资源`在这个表中都有一个记录项 .记录项中包含资源名称、一些标志(如果程序集外部可见，就为public，否则为private)以及FileDef表的一个索引(指出资源或流包含在哪个文件中)。如果资源不是独立文件(比如.jpg或者.gif文件)，那么资源就是包含在PE文件中的流。对于嵌入资源，记录项还包含一个偏移量，指出资源流在PE文件中的起始位置|\n|ExportedTypesDef   | 从程序集的所有PE模块中`导出的每个public类型`在这个表中都有一个记录项。  |\n\n\n# 将模块合并成程序集\n\n## Microsoft为何考虑要引入程序集这一概念?\n\n这是因为使用程序集，`可重用类型`的`逻辑表示`和`物理表示`就可以分开。\n- 物理上，可以将常用的类型放在一个文件中，不常用的程序放在另一些文件中，只在使用时加载，\n- 在逻辑上，这些程序仍然被组织于同一程序集中，不需要编写额外的代码显式进行链接。\n\n## 程序集(Assembly)是什么组成的?\n\n程序集(Assembly)是一个或多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了`清单(Manifest)`，如上一节一开始所述，`清单`也是`元数据`的组成部分之一，表中主要包含作为程序集组成部分的那些文件的名称。此外还描述程序集的版本、语言文化、发布者、公开导出类型以及构成程序集的所有文件。\n\n`CLR`操作的是程序集，对于程序集，有以下几点重要特性：\n- 程序集定义了可重用的类型。\n- 程序集用一个版本号标记。\n- 程序集可以关联安全信息。\n\n**程序集是进行重用、版本控制和应用安全性设置的基本单元。**\n\n对于一个程序集来说，除了包含清单元数据表的文件，程序集中的其他文件独立时不具备以上特点.\n\n## 编译生成含有清单元数据表的PE文件\n\nC#编译器都会生成程序集： `/t: exe`, `/t: winexe`, `/t: appcontainerexe`, `/t: library` 或者`/t: winmdobj`。这些开关会指示编译器生成含有清单元数据表的PE文件。\n\nC#编译器还支持`/t: module`开关。这个开关指示编译器生成一个不包含清单元数据表的PE文件。这样生成的肯定是一个DLL PE文件。CLR要想访问其中的任何类型，必须先将该文件添加到一个程序集中。使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\n\n例如:\n将不常用类型编译到一个单独模块，这样一来如果程序集的用户永远不使用不常用类型，就不需要部署这个模块。\n```csharp\n// 使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\ncsc /t:module 不常用类型.cs\n```\n\n`不常用类型.netmodule`这是一个标准的DLL PE文件，但是CLR不能但单独加载它。\n\n将输出的文件名改为MultiFileLibrary.dll, 目标是生成库文件,添加`不常用类型`的模块, 编译`FUI.cs`\n```csharp\n// 指定了/t: library开关，所以生成的是含有清单元数据表的DLL PE文件\n// /addmodule:不常用类型.netmodule 开关告诉编译器不`常用类型.netmodule`文件是程序集的一部分，从而将其添加到FileDef清单元数据表，并将`不常用类型.netmodule`的公开导出类型添加到ExportedTypesDef清单源数据表。\ncsc /out:NultiFileLibray.dll /t:library /addmodule:不常用类型.netmodule FUT.cs\n```\n\n## 使用程序集链接器(AL.exe)生成程序集\n\n除了使用C#编译器，还可以使用”程序集链接器“实用程序AL.exe来创建程序集。如果程序集要求包含由不同编译器生成的模块(而这些编译器不支持与C#编译器的/addmodule开关等家的几种机制)，程序集连接器就显得相当有用。\n\n**AL.exe能生成EXE文件，或者生成只包含清单的DLL PE文件。程序集链接器不能将多个文件合并成一个文件。**\n\n```csharp\ncsc /t:module RUT.cs\ncsc /t:module FUT.cs\nal /out:MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule\n```\n## 为程序集添加资源文件\n\n- 用AL.exe创建程序集时，可用`/enbed [resource]`开关将文件作为资源添加到程序集。该开关获取任意文件，并将文件内容嵌入最终的PE文件。也可用`/Link [resource]`开关获取资源文件，但只指出资源包含在程序集的哪个文件，并不嵌入到PE文件中；该资源文件独立，并必须与程序集文件一同被打包部署\n- C#编译器用`/resource`开关将资源嵌入PE文件，用`/linkresource`开关添加记录项引用资源文件。以上开关均会修改ManifestResourceDef清单表添加记录项，外部引用的开关还会修改FileDef表以指出资源包文件。\n\n\n\n# 程序集版本资源信息\n\n> Visual Studio新建C#项目时会在一个Properties文件夹中自动创建AssemblyInfo.cs文件。可直接打开该文件并修改自己的程序集特有信息。\n\n在应用程序代码中调用`System.Diagnostics.FileVersionInfo的`静态方法`GetVersionInfo`并传递程序集路径作为参数可以获取并检查这些信息。\n\n![](2CLR基础3/版本资源字段和对应的特性.png)\n\n```csharp\n// 有关程序集的一般信息由以下\n// 控制。更改这些特性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle(\"LentilToolbox\")]\n[assembly: AssemblyDescription(\"Licensed under the MIT license\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"LentilToolbox\")]\n[assembly: AssemblyCopyright(\"Copyright ©  2016 Lentil Sun\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n//将 ComVisible 设置为 false 将使此程序集中的类型\n//对 COM 组件不可见。  如果需要从 COM 访问此程序集中的类型，\n//请将此类型的 ComVisible 特性设置为 true。\n[assembly: ComVisible(false)]\n\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid(\"ac315d57-80ca-4e7a-b55c-064b94547552\")]\n\n// 程序集的版本信息由下列四个值组成:\n//\n//      主版本\n//      次版本\n//      生成号\n//      修订号\n//\n//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值，\n// 方法是按如下所示使用“*”: :\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.1.0.2\")]\n[assembly: AssemblyFileVersion(\"1.1.0.2\")]\n\n```\n\n| - | \tmajor（主版本号）|\tminor（次版本号）|\tbuild（内部版本号）|\trevision（修订号）|\n| :-----:| :-----: | :-----: | :-----: | :-----: |\n|示例  | 2  | 5  | 719  | 2  |\n\n\n注意：程序集有三个版本号，每个版本号都有不同的用途：\n- `AssemblyFileVersion`：这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号的作用是说明**该程序集的版本**。\n- `AssemblyInformationalVersion`：同上，这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号作用是说明**使用该程序集的产品的版本**。\n- `AssemblyVersion`：存储在AssemblyDef清单元数据表中，CLR在绑定到强命名程序集时会用到它。这个版本号很重要，它**唯一性地标识了程序集。**\n\n\n\n\n# 语言文化\n\n![](2CLR基础3/语言文化标记.png)\n\n未指定具体语言文化的程序集成为`语言文化中性(Culture neutral)`。\n\n```csharp\n// 将程序集的语言文化设为瑞士德语\n[assembly: AssemblyCulture(\"de-CH\")]\n```\n\n# CLR探测程序集文件会扫描的目录\n","tags":["CLR读书笔记"]},{"title":"1CLR基础2","url":"/2019/07/06/1CLR基础2/","content":"> 温故而知新\n\n# CLR功能\n\n## JIT(just-in-time 运行时编译技术)\n\n>通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。\n\n>`即时编译器`则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。\n\n>即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。\n\n为了执行方法，首先必须将方法的IL转换成本机(native)CPU指令。这是CLR的JIT编译器的职责。\n\n### 流程讲解\n\n![](1CLR基础2/方法的首次调用.png)\n\n1. 在Main方法执行之前,CLR会检测出Main的`代码引用`的所有类型.\n  - CLR分配一个`内部数据结构`来管理对引用类型的访问.\n  - 图中,Main方法引用了Console类型,CLR分配了一个`内部结构`.\n  - Console类型定义的每个方法都在`内部结构`中存在一个`记录项 entry`.\n  - 根据这个记录项可以找到方法的实现.\n  - 对这个`内部结构`进行初始化,每个方法都指向包含在CLR内部的一个`未编档函数`,称之为`JITCompiler`.\n2. 进入Main方法,首次调用`WriteLine方法`时, `JITCompiler函数`被调用.\n3. `JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的`IL代码`.\n4. 然后`JITCompiler`验证`IL代码`,将`WriteLine方法`的`IL代码`编译成`本机CPU指令`.\n5. `本机CPU指令`保存到动态分配的内存块中.`JITCompiler`将在CLR为类型创建的`内部数据结构`中,修改引用.\n6. 指向到刚才动态分配的内存块地址. 最后`JITCompiler`跳转到内存块中的代码(`WriteLine方法`的具体实现).\n7. 返回到Main中的代码.\n\n![](1CLR基础2/方法的第二次调用.png)\n8. 第二次调用`WriteLine方法`,由于已经进行了验证和编译,会直接跳转到已经编译好的`本机CPU指令`代码块中执行.\n\n方法仅在首次调用时才会有一些性能损失,之后调用全是以本机代码的形式全速运行.\n\n## JIT 编译技术特点\n\n1. JIT编译器将本机CPU指令存储到动态内存中.意味着一旦应用程序终止,编译好的代码也会被丢弃.\n2. JIT编译器会对`本机代码`进行优化.类似于C++编译器后端所做的事情. 可能花较多的时间生成优化代码.\n> 在Visual Studio中新建C#项目时，”调试“(Debug)配置指定的是/optimize-/debug:full，而”发布“(release)配置指定的是/optimize+/debug:pdbonly。\n\n3. JIT能够针对本机CPU为IL代码生成指令，以利用本机指定CPU的任何特殊指令进行编译。相反，非托管应用程序通常是针对具有最小功能集合的CPU编译的。\n\nJIT编译器能够判断一个特定的测试在它运行的机器上是否总是失败，例如，假定有一个方法包含以下代码\n```csharp\n// 如果主机只有一个CPU，JIT编译器不会为此代码生成任何CPU指令。\nif(numberofCPUs>1){\n    ...//Do something\n}\n```\n\n## 将IL代码编译成本机代码的验证过程\n\n将IL代码编译成本机代码的过程中,CLR会执行验证过程,根据元数据检查类型,返回值,返回语句,参数是否正确等等.\n\n\n## NGen.exe生成的本机代码与JIT生成的本机代码对比\n\n1. NGen生成的代码**不会**像JIT编译器生成的代码进行高度优化.较差的执行时性能.\n2. CLR加载程序集时,会检查是否存在一个对应的,由NGen生产的本机文件.\n3. NGen.exe生成的本机文件没有知识产权保护.\n4. NGen生成的文件可能失去同步.版本不匹配,系统升级过等,就无法使用.\n\n\n# 基类库支持功能\n\n> .Net Framework 包含 Framework类库(Framework Class Library,FCL).\n\n1. FCL是一组DLL程序集的统称.\n\n![](1CLR基础2/FLC部分常规命名空间.png)\n","tags":["CLR读书笔记"]},{"title":"1CLR基础","url":"/2019/07/05/1CLR基础/","content":"\n> 对真正的力量一无所知。\n\n# 程序执行基础概念\n- 代码\n- 翻译器\n  - 编译器\n  - 优化编译器\n- 中间语言\n- 执行\n  - 运行时系统\n    - 运行期\n  - 可执行文件\n  - 解释器\n  - 虚拟机\n\n---\n- 代码类型\n  - 源代码\n  - 目标代码\n  - 字节码\n  - 机器代码\n  - 微程序\n\n\n# CLR和 .Net Framework的关系\n\n>.NET框架 （.NET Framework） 是由微软开发，一个致力于敏捷软件开发（Agile software development）、快速应用开发（Rapid application development）、平台无关性和网络透明化的软件开发平台。.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、VB.NET、C++、Python等）的开发。\n\n由此可见，`.Net Framework`是一个支持多种开发语言的开发平台，而这种多语言支持的特性又要以CLR为基础。CLR是一个.Net产品的运行环境。`公共语言运行时(Common Language Runtime)`和 `.Net Framework Library(FCL)`是`.Net Framework`的两个主要组成部分。\n\n\n# 什么是CLR?\n\n> 通用语言运行平台（Common Language Runtime，简称CLR）是微软为他们的.NET的虚拟机所选用的名称。它是微软对通用语言架构（CLI）的实现版本，它定义了一个代码运行的环境。CLR运行一种称为通用中间语言的字节码，这个是微软的通用中间语言实现版本。\n\n1. `CLR`是一个类似`JVM`的虚拟机, 为.NET的程序提供运行的环境.\n2. `CLR`中运行的是一种字节码形态的` Microsoft Intermediate Language，简称MSIL \"微软中间语言\"`.\n3. 在.Net开发平台下，所有语言（C#、VB.NET、J#、C++/CLI）都会被编译为`MSIL`\n\n## CLR做了什么?\n\n1. 将`IL`代码在`运行时`编译成`本机代码Native Code`.(`JIT(just-in-time 运行时编译技术)`)\n> 本机代码Native Code,是面向特定CPU架构(x86,x64,ARM)的代码\n\n![](1CLR基础/1.png)\n\n## CLR有哪些功能?\n\n- 基类库支持 Base Class Library Support\n- 内存管理 Memory Management\n- 线程管理 Thread Management\n- 垃圾回收 Garbage Collection\n- 安全性 Security\n- 类型检查 Type Checker\n- 异常管理 Exception Manager\n- 调试管理 Debug Engine\n- 中间码(MSIL)到机器代码(Native)编译 (即时编译 (JIT just-in-time))\n- 类别装载 Class Loader\n\n\n# CIL是什么?如何生成?\n\n>字节码现在已经官方地成为了CIL (通用中间语言（Common Intermediate Language，简称CIL)\n\n1. 在编译.NET编程语言时，源代码被翻译成`CIL`,再由`CLR`负责运行\n2. `IL代码`有时又称为`托管代码(managed code)`.\n3. `IL代码`只是`面向CLR的编译器`生成的其中一部分.\n\n## IL代码\n\n1. `IL`是与CPU无关的面向对象的机器语言.\n\n## 非托管代码\n\n1. C++编译器默认生成包含`非托管代码`的EXE/DLL模块.\n2. 并且在运行时操纵非托管数据(`native 内存`).\n3. 不需要CLR就能运行.\n4. 只有C++编译器允许开发人员同时写`托管代码`和`非托管代码`,并生成到同一模块中.\n\n### 非托管代码和托管代码的互操作性\n\n- 托管代码能调用DLL中的非托管函数：托管代码通过`P/invoke机制`调用DLL中的函数\n- 托管代码可以使用现有的COM组件：详情可参考 .NET Framework SDK提供的TlbImp.exe\n- 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。详情可以参考 .NET Framework SDK提供的TlbExp.exe和RegAsm.exe工具。\n\n\n# 面向CLR的编译器生成了什么?\n\n> 微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。\n\n1. 不同语言的`编译器(Compiler)`就相当于一个这种语言的代码审查者(Checker),所做的工作就是检查源码语法是否正确，然后将源码编译成`CLR`所需要的`中间语言(IL)`.\n2. `C#语言编译器`编译C#源码文件之后生成`托管模块`.\n\n![](1CLR基础/将源代码编译成托管模块.png)\n\n## C#编译器做的工作\n\n1. C#编译器(CSC.exe)默认将生成的**托管模块转换成程序集**,也就是生成的是**含有清单的托管模块**.\n2. 生成的是PE32(+)文件.\n3. 这个PE32(+)文件包含一个名为`清单(manifest)`的数据块. `清单`也是`元数据表`的集合.\n\n![](1CLR基础/将托管模块合并成程序集.png)\n\n\n# 托管模块是什么?由哪些组成?\n\n1. 无论是什么编译器，最后都是生成`托管模块`。\n2. `托管模块`是标准的32位的可移植执行体（PE32）文件，或者是64位的（PE32+）\n3. 需要`CLR`才能运行。\n4. 其中托管模块中还包含完整的`元数据`.\n\n![](1CLR基础/托管模块的各个部分.png)\n- `CLR头`：包含使这个模块成为托管模块的信息。\n- `IL中间语言代码`：编译器编译源码的时候生成的代码。运行时，`CLR`将`IL`编译成`本机CPU指令`\n- `元数据`：面向CLR的每个编译器要在每个托管模块中生成完整的元数据。元数据是一个数据表的集合。一些数据描述了模块中定义了什么，另一些描述了模块中引用了什么。由于编译器同时生成元数据和代码，把他们绑在一起，并嵌入最终生成的托管模块。所以元数据和他描述的代码不会失去同步。\n-\n\n## 可移植执行体PE文件的结构\n\n![](1CLR基础/PE文件架构.png)\n\n# 元数据是什么?\n\n1. `元数据`简单的说是一个数据表的集合.\n2. 主要包含两种表:\n  - 描述源代码中定义的类型和成员\n  - 描述源代码`引用的`类型和成员\n3. 元数据有多种用途\n  - 避免了编译时对原生C/C++数据头和库文件的需求. 因为IL代码中已经包含了全部信息.编译器直接读取元数据.\n  - `智能感知IntelliSense`技术解析元数据,提示帮助写代码.\n  - CLR验证代码使用元数据确保只执行`类型安全`的操作.\n  - `元数据`允许将对象的字段序列化到内存块,发到另一台机器反序列化,重建对象状态.\n  - `元数据`允许垃圾回收器跟踪对象的生存期.\n\n\n\n# CTS通用类型系统是什么?\n\n> 通用类型系统 (Common Type System) 定义了运行期引擎如果使用程序中的数据类型，以及如何配置数据在存储器中的一种标准，依照此种标准所撰写的编程语言，都可以在同一个运行期引擎中使用，因此它是跨语言支持的重要部分，亦即匹配 CTS 规范的编程语言所撰写出的程序，都可以在 CLR 中使用。\n\n> CTS与CLI规格都是由微软所发展，当前已标准化为 ECMA 335 标准：“Common Language Infrastructure (CLI) Partitions I to VI.”，并且由 Microsoft 在 .NET Framework 中完全的实现。\n\n**由于类型是CLR的根本，微软专门为如何定义、使用和管理类型定义了一个正式的规范-- 通用类型系统(Common Type System)，即CTS。**\n\n事实上, 不根本不需要专门学习CTS规则本身,因为你选择的余元会采用你熟悉的方式公开它自己的`语言语法`与`类型规则`,通过编译来生成程序集时,会将语言特有的语法映射到IL---也就是CLR的`语言`.\n\n无论使用哪一种语言,类型的行为都完全一致,因为最终是由CLR的CTS来定义类型的行为.\n\n## 类型可见性和访问规则\n\n- `private`           : 成员只能由同一个类(class)类型中的其他成员访问.\n- `protected`         : 成员可以从派生类型访问,不管是不是在同一个程序集中.\n- `internal`          : 成员可以由同一个程序集中的任何代码访问.\n- `protected internal`: 可以由任何程序集中的派生类型访问.\n- `public`            : 成员可由任何程序集中的任何代码访问.\n\n\n\n# CLS通用语言规范是什么?\n\n > 定义了一个最小公共集，任何编译器只有支持这个功能集，生成的类型才能兼容其他符合CLS、面向CLR的语言生成的组件\n\n![](1CLR基础/CLS图示.png)\n\n在开发类型和方法的时候，如果希望它们对外“可见”，能够从符合 CLS 的任何一种编程语言中访问，就必须遵守由 CLS 定义的规则。注意， 假如代码只是从定义（这些代码的）程序集的内部访问，CLS 规则就不适用了。\n\n```csharp\nusing System\n\n//告诉编译器检查CLS相容性\n[assembly:CLSCompliant(true)]\n\nnamespace SomeLibrary\n{\n    //因为是public类，所以会显示警告\n    public sealed class SomeLibrarytype\n    {\n        //警告：SomeLibrary.SomeLibraryType.Abc()的返回类型不符合CLS\n        public UInt32 Abc(){return 0;}\n\n        //警告：仅大小写不同的标识符SomeLibrary.SomeLibraryType.abc()不符合CLS\n        public void abc(){ }\n\n        //不显示警告：该方法是私有的\n        private UInt32 ABC(){return 0;}\n    }\n}\n```\n- 第一个警告是因为Abc方法返回了无符号整数，一些语言是不能操作无符号整数值的\n- 第二个警告是因为该类型公开了两个public方法，这两个方法只是大小写和返回类型有别，VB和其他一些语言无法区分这两个方法。\n\n# 关于window32位和64位版本\n1. 如果程序集文件只包含`类型安全`的`托管代码`在32位和64位上都能运行.\n> 类型安全代码指访问被授权可以访问的内存位置.有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。(直接访问内存的其他位置)\n\n2. 如果要使用`不安全的代码`, 需要用到`/playform`命令行开关.如果指定了,则只能在对应平台上使用.默认`anycpu`.\n3. 可执行文件执行时,Windows会检查文件头,64位系统会通过`WoW64(Windows on Windows64)`技术运行32位应用程序.\n\n![](1CLR基础/platform对生成的模块的影响.png)\n\n4. Windows启动托管应用程序的流程.\n\n![](1CLR基础/Windows运行EXE流程.png)\n\n5. 可在代码中查询\n  - `Environment.Is64BitOperatingSystem`属性,判断是否在64位系统上运行.\n  - `Environment.Is64BitProcess`属性,判断是否在64位地址空间中运行\n\n# 不安全的代码\n\nC#编译器默认生成的是安全代码.\n\nC#允许开发人员通过`unsafe`关键字标记包含不安全代码的方法.\n\n# 保护IL代码\n\n1. 混淆器\n2. 在非托管模块中实现想保密的算法, 利用CLR的互操作功能实现应用程序的托管和非托管部分之间的通讯.\n\n# 一些微软提供的实用工具\n- CSC.exe C#编译器:将多个托管模块和资源文件合并成程序集的工具.\n- AL.exe 程序集链接器:将一组文件合并到程序集中.\n- CLRVer.exe 列出机器上安装的所有CLR版本\n  - `-all` 或者指定 `目标进程ID` 列出正在允许的进程使用的CLR版本号.\n- DumpBin.exe 和 CorFlags.exe:可以用来检查编译器生成的托管模块所嵌入的信息.\n- ILAsm.exe IL汇编器\n- ILDasm.exe IL反汇编器\n>用IL反编译工具查看生成的IL代码。这里使用的是ILDasm.exe，当然，你也可以使用一些其他的工具，例如.Net Reflector、ILSpy等。\n\n- NGen.exe 本机代码生成器: 将程序集的所有IL代码编译成本机代码.并将本机代码保存到一个磁盘文件中.\n- PEVerify.exe 检查一个程序集的所有方法,并报告其中含有不安全代码的方法.\n- MPGO.exe 分析客户端应用程序启动需要哪些东西,会写入一个profile并嵌入程序集中.NGen能根据这个更好的优化生成本机映像.\n- TlbImp.exe 托管代码可以使用现有的COM组件.\n- TlbExp.exe和RegAsm.exe 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。\n- FusLogVw.exe 帮助你了解CLR在运行时与程序集的绑定.\n- SN.exe 获取秘钥(生成公钥/私钥对),未提供显示私钥的功能.\n- GACUtil.exe在GAC中安装一个强命名程序集\n","tags":["CLR读书笔记"]},{"title":"HelloWorld","url":"/2019/07/05/HelloWorld/","content":"\n\n![](https://portablehexo.bitmoe.cn/hexopp/hexop.png)\n\n>**本版本仅适用于Win环境**\n>本文关键字： **Hexo绿色版**，**Hexo便携版**，**Hexo配置**，**Hexo**，**U盘**\n\n[Hexo](https://hexo.io/)是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。\n\n但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。\n\n所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。\n\n#### **版本介绍**\n那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。\n\n本便携版（Release 1.0.0）所包含的软件如下：\n>- Git: 2.7.4\n>- Nodejs: 6.10.1\n>- Npm: 4.4.1\n>- Hexo: 3.2.2\n\n# 用到的主题和插件\n\n1. 兼容Markdown图片语法和Hexo图片语法插件:https://github.com/7ym0n/hexo-asset-image\n2. 主题:https://github.com/aircloud/hexo-theme-aircloud\n3. Tag-Cloud插件 https://github.com/MikeCoder/hexo-tag-cloud\n4. 代码高亮插件:https://github.com/ele828/hexo-prism-plugin\n","tags":["HEXO"]},{"title":"ET入门小指南 v19.7.4","url":"/2019/07/04/ET入门小指南/","content":"\n![](ET入门小指南/1.jpg)\n\n# 了解ET\n\n[[Github]](https://github.com/egametang/ET)\n[[ET论坛]](https://bbs.honorworkroom.com/forum.php)\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端.\n\n[[具体介绍]](https://github.com/egametang/ET/blob/master/README.md)\n\n- [为什么使用C# .net core做服务端？](https://github.com/egametang/ET/blob/master/Book/1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.md)\n  - ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。\n- **为什么选择Unity作为客户端?**\n  - 当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。 客户端可以不使用Unity3d,需要自己对接协议.\n- [为什么后端选MongoBson序列化库?](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n- [为什么选MongoDB数据库?](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=183&extra=page%3D1)\n- [为什么选择ProtoBuf?](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 基于google官方3.4.1版本的protobuf c#-runtime以及3.4.0版本的protoc修改而来，还增加了0gc功能。仍然是标准的pb协议\n  - [ET使用精简过的PB库](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n- **为什么选择ILRuntime热更?**\n  - 因为ios的限制，之前unity热更新一般使用lua，导致unity3d开发人员要写两种代码，麻烦的要死。之后幸好出了ILRuntime库，利用ILRuntime库，unity3d可以利用C#语言加载热更新dll进行热更新。ILRuntime一个缺陷就是开发时候不支持VS debug，这有点不爽。ET框架使用了一个预编译指令ILRuntime，可以无缝切换。平常开发的时候不使用ILRuntime，而是使用Assembly.Load加载热更新动态库，这样可以方便用VS单步调试。在发布的时候，定义预编译指令ILRuntime就可以无缝切换成使用ILRuntime加载热更新动态库。这样开发起来及其方便，再也不用使用狗屎lua了\n- [什么是组件式设计?](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n\n\n# 运行Demo前的准备事项\n\n1. IDE选择\n  - **VS**\n    - ET 5.0(master)\n      - 建议使用VS2019 ( 用2017就自己去官网下 .net core 2.2)\n    - ET 4.0分支使用vs2017（更新到最新版）,并且要勾选\n      - a. .net 桌面开发\n      - visual studio tools for unity\n      -  .net core 2.1\n  - **Rider**\n    - 安装 .net core 2.2\n  - other.....\n\n2. Unity版本选择\n  - ET4.0请使用unity2017.4版\n  - ET5.0(master)需要unity2018.4版\n  - [为什么是.4版本](https://www.bilibili.com/video/av49789692)\n  - 别问怎么破解.问就是个人免费版.\n\n\n3. 安装MongoDB数据库(Demo中注释了数据库组件,只为了运行demo,就随意)\n\n\n# 准备运行Demo\n\n- [运行指南](https://github.com/egametang/ET/blob/master/Book/1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.md)\n\n- [常见的错误解决方法](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=203&extra=page%3D1)\n\n\n\n\n## 测试状态同步Demo\n\n打包一个客户端,unity开一个客户端.就会出现2个小人.点击鼠标右键即可移动人物.看到效果.\n\n## 帧同步Demo\n\n在4.0分支.\n\n# 学习ET\n\n\n\n\n你可能需要如下知识储备:\n- C# 语言基础 ([你渴望力量吗?](https://pan.baidu.com/s/1mqaaVIxOVo02pg8aXaQKXg)s1fz )\n- 设计模式    ([你渴望知识吗?](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 数据结构    ([那就看完吧](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 反射\n- 特性\n- 异步/协程\n- 了解ECS\n- 了解actor模型\n- 网络层TCP/UDP/KCP/ENET\n- MongoDB数据库\n- MongoBson\n- Protobuf\n- 服务器分布式相关\n- [网络同步模型的认识](https://www.gameres.com/849046.html?tdsourcetag=s_pcqq_aiomsg)\n\n客户端\n- Unity基础\n- UGUI\n- AssetBundle流程\n- 热更ILRuntime\n\n其余\n- AstarPathfinding\n- Behavior Designer\n- FGUI\n- NLog\n\n\n>猫大语录:\n应该先去提高下c#基础跟编程基础，再来看ET，碰到问题自己想办法解决，谷歌，打log。你现在好比初中基础却来做大学题目一样，到处碰壁，碰到问题自己不研究指望别人给你找问题，这样编程技术是无法提高的.\n群里能力有高有低，问问题也没什么。但是我是希望群里提问题前能够经过自己一番摸索，经过自己思考，经过谷歌，经过调试log等等再问。很多问题经过自己摸索查找资料能够增长很多知识。其实程序开发就是在不断找bug，在找bug中提升自己。\n\n# ET框架设计大纲\n\n- 公共部分\n  - ET的特色\n  - 什么是ECS\n- async await 协程\n\t- 什么是异步? 单线程？多线程？\n      - [ET/Book/2.1CSharp的协程](https://github.com/egametang/ET/blob/master/Book/2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n      - [ET/Book/2.2更好的协程](https://github.com/egametang/ET/blob/master/Book/2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n\t- 为什么需要async await，await是多线程吗？\n    \t- [ET/Book/2.3单线程异步](https://github.com/egametang/ET/blob/master/Book/2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md)\n\t- 更好的Task：ETTask\n    \t- [群内讨论/ETTask](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=204&extra=page%3D1)\n- [一切皆组件（Entity&Component）](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n  - [事件机制EventSystem](https://github.com/egametang/ET/blob/master/Book/3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.md)\n  - [强大的mongo bson](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n  - 设计一个双端网络库\n  - 协议格式的设计\n  - [protobuf](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 使用Kcp协议\n      - [kcp-bulild](https://github.com/egametang/kcp-bulild)\n  - 应用层循环缓冲区\n  - 消息打包解包\n  - 消息的分发处理\n  - 远程过程调用RPC\n  - 客户端无GC处理\n- 服务端\n\t- 服务端架构简介\n    \t- [服务器命名以及消息类的X2X代表意思](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=161&extra=page%3D1)\n\t- 组件式的服务器\n\t- [Actor模型](https://github.com/egametang/ET/blob/master/Book/5.4Actor%E6%A8%A1%E5%9E%8B.md)\n\t- [ActorLocation](https://github.com/egametang/ET/blob/master/Book/5.5Actor%20Location.md)\n\t- 设计一个计时器( TimerCompoent组件 )\n\t- 服务端热更\n    \t- [群内讨论/热更层和Model层/逻辑与数据相关](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=146&extra=page%3D1)\n\t- Config\n\t- [数值组件](https://github.com/egametang/ET/blob/master/Book/5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.md)\n    \t- [群内讨论/数值组件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=139&extra=page%3D1)\n\t- Repl\n    \t- [Nlog配置和Repl](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=151&extra=page%3D1)\n- 客户端\n\t- 客户端架构简介\n\t- 客户端资源管理\n\t- UI框架\n\t- 客户端热更 (ILRuntime)\n\t- 抛弃unity的协程，使用await\n\t- 组件可视化\n- Demo\n\t- demo的架构, 消息路径\n    \t- [Demo消息流转时序图](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=145&extra=page%3D2)\n\t- recast 3d寻路\n\n\n# ET的一些教学视频\n- [肉饼老师主讲](https://www.taikr.com/my/course/972) : ET3.0时期教程,可以学习如何分离客户端和服务器端,和一些开发思路\n- [初见主讲(B站)](https://www.bilibili.com/video/av33280463/?redirectFrom=h5) - [优酷](https://i.youku.com/i/UNTQ3MjU4MDEy?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DT~A):ET4.0教程,工具使用及demo运行,ET入门教程\n- [ET在Mac上运行指南-L主讲](http://www.liuocean.com/index.php/2018/07/25/et-kuang-jiamac-duan-gong-ju-zhi-chi/)百度云视频链接失效，参考文章吧\n\n\n# 群内大佬的Github\n- [C# 实现的十字链表的AOI算法](https://github.com/qq362946/AOI) by 初见\n  - [群内讨论/十字链表+快慢针方式的AOI算法可用于双端](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=174&extra=page%3D1)\n- [在初见的AOI（2D）的基础改成3D AOI](https://github.com/yhr28/3D_AOI) by yhr28\n- [ET-RPG-DEMO(基于ET框架的RPG游戏DEMO)](https://github.com/AnotherEnd15/ET-RPG-DEMO)   by AE\n  - [一种完全组合式的技能系统的设计思路](https://blog.csdn.net/qq_32270109/article/details/88551196?tdsourcetag=s_pcqq_aiomsg)\n- [RVO2](https://github.com/AnotherEnd15/RVO2) by AE\n- [Box2DSharp(BOX2D物理引擎C#版)](https://github.com/Zonciu/Box2DSharp)  by 白纸无字Zonciu\n- [Bullet版本(.netCore封装)](https://gitee.com/fengssy/ET-Platform-Bullet?tdsourcetag=s_pcqq_aiomsg) by 风恒\n- [FGUI/双端行为树](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n  - [群内讨论/Behavior Designer全热更行为树插件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=170&extra=page%3D1)\n- [NKGNMobaBasedOnET(基于ET框架的Moba游戏DEMO)](https://gitee.com/NKG_admin/MKGMobaBasedOnET) by 烟雨迷离半世殇\n- [ET斗地主Demo](https://github.com/Viagi/LandlordsCore)\n  - [斗地主架构图](https://pan.baidu.com/s/1wyv6ihefBjQmVynIUBumKA) o05k\n- [ET-MultiplyDemos小游戏集合](https://github.com/Acgmart/ET-MultiplyDemos) by 咲夜詩\n- [五星麻将](https://github.com/wufanjoin/fivestar) by 間 間 單 單\n\n# 群内大佬分享的一些工具/组件\n\n- [[Debug组件]DebuggerComponent.cs](https://pan.baidu.com/s/1bGJxNGu5P9KB8czCK1NRtw)  mcyz\n- [[Console插件]DebugCodeLocation.cs ](https://pan.baidu.com/s/1mptlsaf9L4w0x5pIRTvA9Q)\n  - log双击利用Console插件能够方便的跳到Hotfix代码中\n- [[AspNet组件]AspNetCoreComponent](https://pan.baidu.com/s/1q6KEgLY08pdht6IioVekVQ) z84o\n- [[Http请求帮助类]HttpRequestHelper](https://pan.baidu.com/s/15sf7KuMvN0NU_Dsx0frtiQ) 7mvr\n- [ET心跳组件2.0](https://pan.baidu.com/s/1oR8f9fSE91bsfmyPCjCTZg) 8p0b\n  - [这篇是初见早期写的心跳文章](http://www.tinkingli.com/?p=111) 不会心跳的可以看下原理\n- [增加工具封装模板github](https://github.com/swicksu/ET-Plus) by 苏伟涛\n  - [[AutoGenerateCodeEditor]](https://github.com/swicksu/ET-Plus/blob/master/Unity/Assets/Editor/PlusEditor/AutoGenerateCodeEditor.cs)\n  - Unity中创建新脚本自动生成ET模板代码\n  - [演示视频](https://pan.baidu.com/s/12F-K2pyab61VJ77bhAmqlw)\n  - ETConfig制作流程简化\n  - [演示视频](https://pan.baidu.com/s/1uG7Lb6JimEBukxBTsCudYw)\n  - 使用Scp同步ET热更资源到服务器\n  - [演示视频](https://pan.baidu.com/s/1-9AShPBswKNg5y3v3ynC2g)\n\n# ET学习笔记/博客/公众号\n\n- [ET Mac环境运行和iOS打包指南.pdf](https://pan.baidu.com/s/1LyDaeA3l3skySb3ECu3VvA ) 9bzj\n- [Tinkingli博客教程](http://www.tinkingli.com/?cat=8)\n- [ECS概要--ET游戏框架详解](https://mp.weixin.qq.com/s/tDgqE_Ah8PWfnAGfi_R-aQ)  by 122304518\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n- [咲夜詩的博客](https://acgmart.com/unity/)\n- [群内分享的一些ET笔记](https://pan.baidu.com/s/1KqtGWVbFBRtQ_RJZTMYFww) ho3e\n- [ET5.0学习思维导图](https://pan.baidu.com/s/14XLl0v9oDlA72VxkdPtnEQ)  by 小豆子\n- [ET网络消息流程(Send) & ET网络消息流程(Connect&Recive) & (DateFlow)](https://pan.baidu.com/s/1jz66RNsZmlUhvFDg6h5ZBQ) by 小豆子\n- [Atheos的笔记](https://www.processon.com/view/link/5cb935fae4b0bab9095ebbd0#map)\n\n# 相关技术的教学文章\n\n## 大学生学习资源表\n- [为大学生策划的资源列表A-to-Z-Resources-for-Students](https://github.com/dipakkr/A-to-Z-Resources-for-Students)\n\n\n\n## MongoDB\n- [官方Driver教程](https://mongodb.github.io/mongo-csharp-driver/2.7/getting_started/)\n- [官方API文档](http://api.mongodb.com/csharp/current/html/R_Project_CSharpDriverDocs.htm)\n- [菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [Working with MongoDB in .NET (Part 1): Driver Basics & Inserting Documents](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz)\n- [Working with MongoDB in .NET (Part 2): Retrieving Documents with Filter Clause](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-2-retrieving-mrlbeanm5)\n- [Working with MongoDB in .NET (Part 3): Skip, Sort, Limit, & Projections](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka)\n\n\n## ILRuntime\n\n- [官方主页](https://ourpalm.github.io/ILRuntime/public/v1/guide/index.html)\n- [Github-Demo](https://github.com/Ourpalm/ILRuntimeU3D/)\n- QQ群:512079820\n- [ILRuntime技术相关的总结](https://pan.baidu.com/s/1Re-mM-9KEoO3D7VXePdyIg) vz3q\n- [群内讨论/ILRuntime剪裁相关问题](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=195&extra=page%3D1)\n\n\n## FGUI\n\n- [官方主页](http://www.fairygui.com/guide/index.html)\n- [官方教程](http://www.sikiedu.com/course/139)\n- QQ群:614444599\n- [ET+FGUI+BD](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n","tags":["ET"]},{"title":"test","url":"/2019/07/04/test/","content":"# Test!!!!!!!!!!\n\n\n```csharp\nusing System;\nusing MongoDB.Driver;\n\nnamespace ETModel\n{\n\t[ObjectSystem]\n\tpublic class DBQueryTaskSystem : AwakeSystem<DBQueryTask, string, ETTaskCompletionSource<ComponentWithId>>\n\t{\n\t\tpublic override void Awake(DBQueryTask self, string collectionName, ETTaskCompletionSource<ComponentWithId> tcs)\n\t\t{\n\t\t\tself.CollectionName = collectionName;\n\t\t\tself.Tcs = tcs;\n\t\t}\n\t}\n\n\tpublic sealed class DBQueryTask : DBTask\n\t{\n\t\tpublic string CollectionName { get; set; }\n\n\t\tpublic ETTaskCompletionSource<ComponentWithId> Tcs { get; set; }\n\n\t\tpublic override async ETTask Run()\n\t\t{\n\t\t\tDBComponent dbComponent = Game.Scene.GetComponent<DBComponent>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// 执行查询数据库任务\n\t\t\t\tIAsyncCursor<ComponentWithId> cursor = await dbComponent.GetCollection(this.CollectionName).FindAsync((s) => s.Id == this.Id);\n\t\t\t\tComponentWithId component = await cursor.FirstOrDefaultAsync();\n\t\t\t\tthis.Tcs.SetResult(component);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthis.Tcs.SetException(new Exception($\"查询数据库异常! {CollectionName} {Id}\", e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","tags":["Test"]}]