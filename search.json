[{"title":"二基元类型引用类型和值类型3","url":"/2019/07/19/二基元类型引用类型和值类型3/","content":"# 什么时候需要装箱\n\n- 第一种情况: 将`值类型的实例`传给需要`获取引用类型`的方法.\n\n要获取`值类型`的引用,实例就必须`装箱`.\n\n未装箱值类型比引用类型更\"轻\",归结于\n1. 不在托管堆上分配\n2. 没有堆上的每个对象都有的额外成员:`类型对象指针`和`同步块索引`\n\n其中,由于未装箱值类型没有`同步块索引`,所以不能使用`System.Threading.Monitor(提供同步访问对象的机制)`类型的方法(或C#lock语句),让多个线程同步对实例的访问.\n\n- 第二种情况: 值类型如果`重写了虚方法`(例如Equals,ToString...)方法,`调用基类的实现`时,会`装箱`,通过this指针将`引用`传给基方法.\n\n虽然未装箱的值类型没有`类型对象指针`,但仍可以调用由类型`继承或重写的虚方法`.(比如Equals,GetHashCode,ToString).\n\n值类型可以重写Equals, GetHashCode或者ToString的虚方法，CLR可以非虚地调用该方法，因为值类型是隐式密封的（即不存在多态性），没有任何类型能够从它们派生。如果你重写的虚方法要`调用方法在基类中的实现`，那么在调用基类的实现时，`值类型实例就会装箱`，以便通过`this指针`将对一个堆对象的`引用`传给基方法。\n\n- 第三种情况:\n\n调用非虚的,继承的方法时(比如`GetType`或者`MemberwiseClone`),**无论如何都要对值类型进行装箱**, 因为这些方法由`System.Object`定义,要求this实参是指向`堆对象`的指针.\n\n- 第四种情况:\n\n将值类型的未装箱实例 **转型为某个接口时** 要对实例进行装箱. 是因为接口变量必须包含对堆对象的引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point : IComparable\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        // 重写从System.ValueType继承的ToString方法.\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n        // 实现类型安全的CompareTo方法\n        public Int32 CompareTo(Point other)\n        {\n            // Math.sign方法用来判断一个数到底是正数、负数、还是零。\n            // 利用勾股定理计算哪个Point离(0,0)更远\n            return Math.Sign(\n                Math.Sqrt(m_x * m_x + m_y * m_y) - Math.Sqrt(other.m_x * other.m_x + other.m_y * other.m_y));\n        }\n        // 实现IComparable接口的CompareTo方法\n        public int CompareTo(object obj)\n        {\n            if (GetType() != obj.GetType()) throw new ArgumentException(\"obj is not a point\");\n            // 调用类型安全的CompareTo方法\n            return CompareTo((Point) obj);\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p1 = new Point(10,10);\n            Point p2 = new Point(20,20);\n\n            // 调用Point重写的ToString(虚方法)方法,不装箱p1\n            Console.WriteLine(p1.ToString());\n\n            // 调用GetType(非虚方法)时, 要对p1进行装箱\n            // 调用非虚的,继承的方法时, 无论如何都要对值类型进行装箱\n            // 因为这些方法由System.Object定义,要求this实参是指向堆对象的指针.\n            Console.WriteLine(p1.GetType()); // 显示ConsoleApp1.Point\n\n            // p1调用的是CompareTo(Point other),所以p2不需要装箱\n            Console.WriteLine(p1.CompareTo(p2)); // 显示 -1\n\n            // 装箱p1, 引用放到c中\n            // 将值类型的未装箱实例 转型为某个接口时 要对实例进行装箱\n            IComparable c = p1;\n            Console.WriteLine(c.GetType()); // 显示ConsoleApp1.Point\n\n            // 由于向CompareTo传递的不是Point变量,\n            // 所以调用的是CompareTo(object obj),c不需要装箱,\n            // 因为已经是引用了已装箱的Point\n            Console.WriteLine(p1.CompareTo(c)); // 显示0\n\n            // c是引用类型,不需要装箱\n            // c调用的是IComparable的CompareTo(object obj)方法\n            // 所以p2要装箱\n            Console.WriteLine(c.CompareTo(p2)); // 显示-1\n\n            // 对c拆箱, 字段复制到p2中\n            p2 = (Point) c;\n            Console.WriteLine(p2.ToString()); // 显示(10,10)  证明已经复制到栈\n        }\n    }\n}\n```\n\n上述代码演示了涉及装箱和拆箱的几种情形\n1. 调用ToString\n  - p1.ToString()时, p1不必装箱,**因为ToString是从基类System.ValueType继承的虚方法.**\n\n> 通常,为了调用虚方法,CLR需要判断对象的类型来定位类型的方法表,由于p1是未装箱的值类型,,所以不存在 **类型对象指针** 这个成员. 但是JIT编译器发现Point重写了ToString方法,所以会 **直接生产代码来直接(非虚地)调用重写的这个ToString方法** . 这里不存在多态性,没有类型能从它派生以提供虚方法的另一个实现. **但是如果Point.ToString方法内部调用了base.ToString() ,那么调会调用System.ValueType的ToString方法,值类型实例就会装箱.**\n\n2. 调用GetType\n  - 调用非虚方法GetType时,p1必须装箱.  因为Point的`GetType`方法从`System.Object`继承的,**CLR必须使用指向类型的指针,这个指针只能通过装箱p1来获得.**\n3. 调用CompareTo第一次\n  - p1.CompareTo(p2)时,p1不用装箱,因为Point实现了CompareTo(Point other)方法,编译器直接调用它,并且传递的是值类型对象,不需要装箱.\n4. 转型为IComparable\n  - p1转型为接口类型c时必须装箱. **因为接口被定义为引用类型.**\n5. 调用CompareTo第二次\n  - p1.CompareTo(c)时,传递的是接口变量c,所以编译器调用的是重载版本的CompareTo(object obj),要传递引用指针, c是引用了一个已装箱的Point,所以无序额外装箱.\n6. 调用CompareTo第三次\n  - c.CompareTo(p2)时,c是引用堆上的已装箱Point对象,还是IComparable接口类型,只能调用接口的CompareTo(object obj)方法, 因此p2需要装箱.\n7. 转型为Point\n  - 将c引用的堆上对象拆箱成Point复制到栈上的p2.\n\n\n## 使用接口更改已装箱值类型中的字段(不应该这样做)\n\n来看看你的理解程度,答出控制台输出什么.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal struct Point\n    {\n        private Int32 m_x, m_y;\n\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p);\n\n            p.Change(2, 2);\n            Console.WriteLine(p);\n\n            Object o = p;\n            Console.WriteLine(o);\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o);\n        }\n    }\n}\n```\n答案:\n1,1\n2,2\n2,2\n2,2\n\n解析:\n重点说下`((Point) o).Change(3, 3);`\n\n`Object o`对象对于`Change`方法一无所知, 所以需要`拆箱转型到Point`.\n  - 拆箱转型过程\n    - 将已装箱的Point中的字段 **复制到线程栈** 上的一个 **临时Point** 中.\n    - 这个栈上的Point的m_x和m_y字段会变成3,3\n    - 但是在堆上已装箱的Point里的值不受这个Change调用的影响.所以最后输出的Object o是堆上的2,2\n\n\n有的语言(比如C/C++)允许更改已装箱值中的字段,但是C#不允许. 不过,可以用接口欺骗C#,让它允许这个操作.代码如下:\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    internal interface IChangeBoxedPoint\n    {\n        void Change(Int32 x, Int32 y);\n    }\n    internal struct Point : IChangeBoxedPoint\n    {\n        private Int32 m_x, m_y;\n        public Point(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }\n        public void Change(Int32 x, Int32 y)\n        {\n            m_x = x;\n            m_y = y;\n        }    \n        public override string ToString()\n        {\n            // 将Point作为字符串返回. 调用ToString避免装箱\n            return string.Format($\"{m_x.ToString()}, {m_y.ToString()}\");\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Point p = new Point(1, 1);\n            Console.WriteLine(p); // 1,1\n\n            p.Change(2, 2);\n            Console.WriteLine(p); // 2,2\n\n            Object o = p;\n            Console.WriteLine(o); // 2,2\n\n            ((Point) o).Change(3, 3);\n            Console.WriteLine(o); // 2,2\n\n            // 将P转型接口,装箱\n            // 在已装箱的值上调用Change, 堆上已装箱的值就变为4,4\n            // 并没有引用指向这个已装箱值,即将被垃圾回收掉\n            // 未装箱的Point p仍然是2,2\n            ((IChangeBoxedPoint) p).Change(4,4);\n            Console.WriteLine(p);// 2,2\n\n            // 将引用类型o转成IChangeBoxedPoint,才能使用Change方法\n            // 不需要装箱,因为o本来就是已装箱的Point\n            // Change(5,5);正确修改了已装箱的值\n            ((IChangeBoxedPoint) o).Change(5,5);\n            Console.WriteLine(o); //  5,5\n        }\n    }\n}\n```\n**演示接口方法如何修改已装箱值类型中的字段,在C#中,不用接口方法便无法做到.**\n\n**值类型应该是\"不可变\"(immutable). 也就是说我们不应该定义任何会修改实例字段的成员.建议将值类型字段都标记为readonly.** 否则容易写出一个试图更改字段的方法,就会产生非预期的行为. 标记readonly后,编译时就会报错.前面的例子清楚的揭示了为什么这样做.\n\n**FCL的核心值类型(Byte,Int32,UInt32,Int64,UInt64,Single,Double,Decimal,BigInteger,Complex以及所有枚举)都是`不可变`的.**\n\n> 不可变(immutable)： 即对象一旦被创建初始化后，它们的值就不能被改变，之后的每次改变都会产生一个新对象。\n\n所以，对于不变对象来说，调用对象自身的任意方法，也`不会改变该对象自身的内容`。相反，这些方法会创建`新的对象`并返回，这样，就保证了不可变对象本身永远是不可变的。\n\n\n# dynamic(动态)基元类型\n\nC#是类型安全的编程语言. 意味着所有表达式都解析成类型的实例,编译器生成的代码只执行对该类型有效的操作.\n\n类型安全的优势:\n1. 许多错误能在编译时检测到\n2. 能编译出更小,更快的代码. 是因为能在编译时进行更多预设,并在生成的IL和元数据中落实预设.\n\n\n为了方便开发人员使用`反射`或者与其他组件通信.C#编译器允许将`表达式/变量的类型`标记为`dynamic`.\n> 编译器生成特殊IL代码来描述所需操作,这种特殊的代码称为payload有效载荷.\n\n## dynamic 变量/表达式\n\n在运行时,`payload有效载荷`代码根据dynamic表达式/变量引用的对象的实际类型来决定具体执行的操作.\n\n```csharp\nstatic void Main(string[] args)\n{\n    dynamic val;\n    for (Int32 demo = 0;  demo<2 ;demo ++)\n    {\n        val = (demo == 0) ? (dynamic) 5 : (dynamic) \"A\";\n        // 两个操作数的类型是dynamic\n        val = val + val;\n        // 传入dynamic类型参数, C#编译器会生成payload代码\n        // 在运行时检查val的实际类型.\n        // 调用对应的重载版本.\n        M(val);\n    }\n}\nprivate static void M(Int32 n)\n{\n    Console.WriteLine($\"M(Int32):{n}\");\n}\n\nprivate static void M(String s)\n{\n    Console.WriteLine($\"M(String):{s}\");\n}\n```\n输出:\nM(Int32):10\nM(String):AA\n\n由于val是dynamic类型,C#编译器生成payload代码在`运行时`检查value的实际类型,然后决定`+`操作符实际要做什么.\n1. 第一个循环中: val = 5(Int32值),结果是10 .\n2. `M(val);`传入dynamic类型参数, C#编译器会生成`payload有效载荷代码`,在`运行时`检查val的实际类型,调用对应的重载版本.\n\n## dynamic 字段/方法参数/方法返回值\n\nC#编译器会将该类型转换为`System.Object`,并在元数据中向`字段/参数/返回类型`应用`System.Runtime.CompilerServices.DynamicAttribute`的实例.\n\n如果指定局部变量被指定为dynamic, 则变量类型也会成为Object\n","tags":["CLR读书笔记"]},{"title":"二基元类型引用类型和值类型2","url":"/2019/07/16/二基元类型引用类型和值类型2/","content":"# 引用类型和值类型\n\nCLR支持两种类型: 引用类型和值类型.\n\n引用类型总是从`托管堆`分配. C#的`new`操作符返回对象内存地址----指向对象数据的内存地址.\n\n**使用引用类型必须留意性能问题.**\n\n1. 内存必须从托管堆分配.\n2. 堆上分配的每个对象都有一些额外成员,这些额外成员必须初始化.\n3. 对象中的其他字节(为字段设置的字节)总是设为0.\n4. 从对管堆分配对象时,可能强制执行一次垃圾回收.\n\n为了提高性能,CLR提供了名为\"值类型\"的轻量级类型.\n\n**值类型** 的实例一般在线程栈上分配.\n\n1. 可以作为字段嵌入引用类型的对象中\n2. 在代表值类型实例的变量中**不包含指向实例的指针**.\n3. 实例中包含了实例本身的字段(值). 所以操作实例中的字段(值)不需要提领指针.\n4. 值类型不受垃圾回收器的控制.\n5. 所有值类型都是隐式密封,防止用作其他应用类型或值类型的基类.\n\n\n**值类型缓解了使用托管堆的压力,并减少了应用程序生存期内的垃圾回收次数.**\n\n> 在非托管环境(C/C++)中声明类型后, 使用该类型的代码会决定是在线程栈上还是应用程序的堆中分配该类型的实例.\n> 托管代码中,要由定义类型的开发人员决定在什么地方分配类型实例,使用此类型的人对此没有控制权.\n\n# 查看文档区分引用类型和值类型\n\n1. 在文档中查看类型时, 任何称为**类**的类型都是引用类型. 例如System.Exception类...\n2. 所有值类型都称为**结构**或**枚举**. 例如:System.Int32结构...\n\n\n## 结构&枚举\n\n所有`结构`都是抽象类型`System.ValueType`的直接派生类.`System.ValueType`本身又直接从`System.Object`派生.\n\n1. 根据定义, 所有值类型都必须从`System.ValueType`派生.\n2. 所有枚举都从`System.Enum`抽象类型派生,`System.Enum`从`System.ValueType`派生.\n\n> CLR和所有编程语言都会给予枚举特殊待遇(直接支持各种强大的操作,非托管环境中就不这样了.)\n\n# 引用类型和值类型的区别\n\n```csharp\n// 引用类型,因为class\nclass SomeRef { public Int32 x; }\n// 值类型\nstruct SomeVal{ public Int32 x; }\n\nstatic void ValueTypeDemo()\n{\n    // 图示左边部分\n    SomeRef r1 = new SomeRef();    // 在堆上分配\n    // 使用new看似是要在托管堆上分配实例,实际是C#编译器知道SomeVal是值类型\n    // 所以会正确的生成IL代码,在线程栈上分配,\n    // C#还会确保值类型中的所有字段都初始化为零.\n    // SomeVal v1; 还可以这么写. 但是C#认为此处v1没有初始化.\n    // 如果直接使用Int32 a = v1.x;将不能通过编译\n    SomeVal v1 = new SomeVal();    // 在栈上分配. 使用new操作符,C#会认为已经初始化.\n    r1.x = 5;                      // 提领指针\n    v1.x = 5;                      // 在栈上修改\n\n    // 图示右边部分\n    SomeRef r2 = r1;               // 只复制引用(指针)\n    SomeVal v2 = v1;               // 在栈上分配并复制成员\n    r1.x = 8;                      // r1.x和r2.x都会更改\n    v1.x = 9;                      // v1.x会更改,v2.x不变,为5\n}\n\n```\n\n![](二基元类型引用类型和值类型2/5-2.png)\n\n在代码中使用类型时, 必须注意是引用类型还是值类型,这会极大的影响在代码中表达自己意图的方式.\n\n# 设计类型时,满足什么条件才声明为值类型?\n\n1. 类型具有基元类型的行为. 是十分简单的类型,没有成员会修改类型的任何实例字段.\n  - 如果类型没有提供会更改字段的成员,就说该类型不可变(immutable).\n2. 类型不需要从其他任何类继承.\n3. 类型也不派生出其他任何类型\n\n类型实例大小也应该在考虑范围内,因为`实参`默认以`值方式传递`,造成对值类型实例中的字段进行复制,影响性能.\n1. 类型的实例较小(16字节或更小)\n2. 类型的实例较大(大于16字节),但不作为方法实参传递,也不从方法返回\n\n# 值类型的主要优势以及自身的局限\n\n1. `值类型`主要的优势是**不作为对象在托管堆上分配**.\n2. `值类型`对象有两种表示形式: `未装箱`和`已装箱`.  引用类型总是处于`已装箱`形式.\n3. `值类型`从`System.ValueType`派生. 该类型提供了与`System.Object`相同的方法,但重写了`Equals`方法,能在两个对象的字段值完全匹配的前提下返回true.还重写了GetHashCode方法.会将字段中的值都考虑在内.但是这个实现存在性能问题.所以定义自己的值类型时应该重写Equals和GetHashCode方法,并提供显式实现.\n4. 由于不能将`值类型`作为基类或新的引用类型,所以不应当在值类型中引入任何新的虚方法,所有方法不能是抽象的,并且隐式密封不可重写.\n5. `引用类型`的变量包含堆中对象的地址.引用类型的变量创建时默认初始化为`null`(表示当前不指向任何有效对象). 试图使用null引用时会报`NullReferenceException`异常.`值类型`的变量总是包含其基础类型的一个值.而`值类型`的初始化都为0. 值类型变量不是指针,不会报`NullReferenceException`异常.CLR允许为值类型添加`可空`标识.\n6. 将`值类型`变量赋给另一个`值类型`变量,会执行`逐字段复制`. `引用类型`的变量赋给另一个`引用类型`的变量值`只复制内存地址`.\n7. 两个或多个`引用类型`变量能引用堆中的同一对象,所以对一个变量操作可能会影响到另一个变量引用的对象.`值类型`则不会影响另一个值类型变量.\n8. 由于`未装箱的值类型`不在堆上分配, 定义了该类型的实例的方法不再活动(变量的生命周期结束),为它们分配的栈存储就会被释放.\n\n# CLR如何控制类型中的字段布局?\n\n为了提高性能,CLR能按照它所选择的任何方式排列`类型的字段`. 例如:CLR可以在内存中重新安排`字段的顺序`,将对象引用分为一组,同时正确排列和填充数据字段.\n\n定义类型时,针对类型的各个字段,你可以告诉CLR按照指定的顺序排列,还是按照CLR自己认为合适的方式重新排列.\n\n## 如何告诉CLR怎么排列?\n\n1. 要为自己定义的类或结构应用`System.Runtime.InteropServices.StructLayoutAttribute`特性.\n  - 向该特性的构造器传递`LayoutKind.Auto`          : 让CLR自动排列字段.  \n  - 顺序布局:传递`LayoutKind.Sequential`         : 让CLR保持你的字段布局.\n  - 精确布局:传递`LayoutKind.Explicit`           : 指定每个字段的偏移量,利用偏移量在内存中显示排列字段.\n2. 如果不指定`StructLayoutAttribute`,则CLR按照自己的方式.\n3. **注意:C#编译器有默认设定:**\n  - 默认`引用类型`选择`LayoutKind.Auto`\n  - 默认`值类型`选择`LayoutKind.Sequential`\n  - 这是因为C#编译器团队认为和`非托管代码`互操作时会经常用到`结构`.为此,字段必须保持程序员定义的顺序.\n  - 假如创建的值类型不与`非托管代码`互操作,就应该覆盖C#编译器的默认设定.\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n\n// 让CLR自动排列字段以增强这个值类型的性能\n// 覆盖掉C#编译器默认的`LayoutKind.Sequential`设置\n[StructLayout(LayoutKind.Auto)]\ninternal struct SomeValType\n{\n    private readonly Byte m_b;\n    ....\n}\n```\n\n### LayoutKind.Explicit说明\n\n构造器传递了`LayoutKind.Explicit`之后, 要向值类型中的每个字段都应用`System.Runtime.InteropServices.FieldOffsetAttribute`特性的实例.并且向该特性传递Int32值来指出字段第一个字节距离实例起始处的偏移量(以字节为单位).  \n\n显示布局常用来模拟非托管C/C++中的`union`,因为多个字段可起始于内存的相同偏移位置.\n\n注意在类型中:一个引用类型和一个值类型互相重叠是不合法的.多个值类型相互重叠则是合法的.为了是这样的类型能够验证,所有重叠字节都必须能通过公共字段访问.\n\n\n> union是特殊类,union中的数据成员在内存中的存储是相互重叠.每个数据成员都从相同的内存地址开始.\n> 分配给union的存储区数量是包含它最大数据成员所需的内存数, 同一时刻只有一个成员可以被赋值.\n> （1）同一个内存段可以用来存放几种不同类型的成员，但在每一个时刻只能存在其中一种，而不能同时存放几种，即每一瞬间只有一个成员起作用，其它的成员不起作用，不能同时都存在和起作用；\n> （2）共用体变量中起作用的成员是最后一个存放的成员，在存入一个新的成员后，原有的成员就会失去作用，即所有的数据成员具有相同的起始地址。\n> （3）union和struct都是由多个不同的数据成员组成，但是union所有成员共享一段内存地址，只存放最后一次赋值的成员值，而struct可以存放所以有成员的值。\n> （4）union的大小是所有成员中所占内存最大的成员的大小，struct是所有成员的大小的“和”。\n\n```csharp\nusing System;\nusing System.Runtime.InteropServices;\n// 让开发人员显示排列这个值类型的字段\n[StructLayout(LayoutKind.Explicit)]\ninternal struct SomeValType\n{\n    [FieldOffset(0)]\n    private readonly Byte m_b;// m_b和m_x字段在该类型的实例中相互重叠\n\n    [FieldOffset(0)]\n    private readonly Int16 m_x; // m_b和m_x字段在该类型的实例中相互重叠\n}\n```\n\n\n# 值类型的装箱和拆箱\n\n值类型不作为对象在托管堆中分配,不被垃圾回收,也不通过指针进行引用.\n\n```csharp\nusing System;\nusing System.Collections;\n\nnamespace ConsoleApp1\n{\n    struct Point{public Int32 x, y;}\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            ArrayList a = new ArrayList();\n            Point p;                        // 分配一个Point,不在堆中分配\n            // 每次迭代都初始化一个`Point值类型字段`, 并将该Point存储到ArrayList中.\n            for (int i = 0; i < 10; i++)\n            {\n                p.x = p.y = i;     // 初始化值类型中的成员\n                a.Add(p);          // 对值类型进行装箱,将引用添加到ArrayList中\n            }\n        }\n    }\n}\n```\n\n## ArrayList中究竟存储了什么? 是Point结构还是Point结构的地址?\n\n想要知道答案需要研究ArrayList的Add方法.\n\nAdd方法原型:`public virtual Int32 Add(object value);`\n\n1. 参数是`object`,也就是说Add获取对托管堆上的一个对象的引用(指针)来作为参数.\n2. a.Add(p); 之前的代码传递的是Point,是值类型.\n3. 为了使代码正确工作,Point值类型必须转换成真正的,在堆中托管的对象,而且必须获取对该对象的引用\n4. 对`值类型`转成`引用类型`要使用`装箱机制`.\n\n## 装箱机制发生的事情\n\n1. 在托管`堆`中分配内存. 分配的内存是值类型各字段所需的内存量(还要加上托管堆所有对象都有的两个额外成员:类型对象指针和同步块索引所需的内存量).\n2. **值类型的字段复制到新分配的堆内存.**\n3. 返回对象地址, 现在该地址是对象引用:值类型成了引用类型.\n\n在托管堆中分配相应的内存.  \n\n**C#编译器自动生成对值类型实例进行装箱所需的IL代码.** 但是仍需要理解内部的工作机制才能体会到代码的大小和性能问题.\n\n在运行时,当前存在于`Point值类型实例p`中的字段复制到`新分配的Point对象`中. 已装箱`Point对象`(现在是引用类型)的地址传给Add方法. `Point对象`一直存在于堆中,直至被垃圾回收.\n\n> FCL现在包含一组新的泛型集合类, 非泛型集合类已经是过时的东西.\n> 例如:应该使用`System.Collections.Generic.List<T>`类而不是`System.Collections.ArrayList`类.\n> `泛型集合类`对`非泛型集合类`进行了大量改进.\n> 1. API得到简化和增强,性能也得到显著提升\n> 2. 允许开发人员在操作`值类型的集合`时不需要对`集合中的项`进行`装箱/拆箱`\n> 3. 开发人员还获得编译时的类型安全性, 减少强制类型转换次数.\n\n## 拆箱机制\n\n要从上面代码中的`ArrayList a`取第一个元素.\n\n```csharp\nPoint p = (Point)a[0];\n```\n\n1. 它获取ArrayList的元素0包含的引用(指针), 试图放到`Point值类型`的实例p中.\n2. 为此,`已装箱Point对象`中的所有字段都必须复制到`值类型变量`p中. 后者在`线程栈`上.\n3. CLR分两步完成复制\n  - 第一步: 获取`已装箱Point对象`的`各个Point字段`的地址.  **← 此过程称为拆箱.**\n  - 第二步: 将字段包含的值从`堆`复制到`栈`的值类型实例中.\n\n拆箱不是直接将装箱过程倒过来, **装箱的代价被拆箱高得多.**\n1. 拆箱就是获取指针的过程.\n2. **拆箱不要求在内存中复制任何字节. 指针指向的是已装箱实例中的未装箱部分.**\n3. 拆箱操作后紧接着一次字段复制.\n\n\n### 已装箱值类型在拆箱时的过程\n\n1. 如果包含\"对已装箱值类型实例的引用\"的变量为null,抛出NullReferenceException.\n  - `Point p = (Point)a[0];// a为null时`\n2. 如果引用的对象不是所需值类型的已装箱实例,抛出InvalidCastException.\n\n```csharp\npublic static void Main()\n{\n  Int32 x = 5;\n  object o = x;              // 对x装箱,o引用已装箱对象\n  // 在对对象进行拆箱时,只能转型为最初未装箱的值类型(本例是Int32)\n  // 所以以下写法会抛出异常\n  Int16 y = (Int16)o;        // 抛出InvalidCastException.\n\n  // 正确写法\n  Int16 y = (Int16)(Int32)o; // 先拆箱为正确类型,再转型\n}\n```\n\n#### 拆箱和复制例子\n```csharp\npublic static void Main()\n{\n  Point p;\n  p.x = p.y = 1;\n  Object o = p;   // 对p装箱;  o引用已装箱实例\n\n  // 将Point的x字段变成2\n  p = (Point)o;   // 对o拆箱, 将字段从已装箱的实例复制到[栈]变量中 (复制所有字段)\n  p.x = 2;        // 更新[栈]变量的状态\n  o = p;          // 对p装箱;o引用新的已装箱实例 (复制所有字段)\n}\n```\n\n首先进行一次拆箱,再执行一次字段复制(到栈变量中),最后再执行一次装箱(在托管堆上创建全新的已装箱实例).\n\n这个过程对应用程序性能影响较大.\n\n> 此段代码用C++/CLI来写,效率会高很多,因为它允许在不复制字段的前提下,对已装箱的值类型进行拆箱,拆箱返回的是已装箱对象中的未装箱部分的地址(忽略对象的类型对象指针和同步索引块这两个额外成员),接着可以用这个指针来操作未装箱实例的字段(这些字段恰好在堆上的已装箱对象中).\n> C++/CLI直接在已装箱Point实例中修改Point的x字段的值. 就这避免了在堆上分配新对象和复制字段两次.\n\n### 从IL代码查看编译器隐式生成的装箱代码\n\n\n如果关心特定算法的性能,可以用ILDasm.exe这样的工具查看方法的IL代码,观察IL指令box都在哪些地方出现.\n\n#### 例子一\n\n```csharp\n// 以下代码发生了3次装箱\npublic static void Main()\n{\n  Int32 v = 5; // 值类型变量\n  object o = v; // 一次装箱\n  v = 123; // 将未装箱的值修改为123\n\n  Console.WriteLine(v + \",\" + (Int32) o );// 显示123,5\n}\n```\n\n解析:\n1. 首先在栈上创建一个Int32未装箱值类型实例`v` , 将其初始化为5.\n2. 创建Object类型的变量`o`, 让它指向`v`.\n  - 因为`引用类型的变量`始终是指向`堆`中的对象,所以C#生成正确的IL代码对`v`进行装箱,(复制所有字段到堆中)\n  - 让`v`的已装箱拷贝的地址存储到`o`中.\n3. 接着,值123被放到`未装箱值类型`实例`v`中, 但这个操作不会影响已装箱的Int32,后者值依然是5.\n4. 接着调用WriteLine方法, 由于方法需要string对象作为参数,编辑器选择Concat的重载版本去实现3个参数的合并\n5. `Concat(object,object,object)`\n  - 第一个参数传递v(未装箱的值参数),需要进行装箱操作\n  - 第二个参数\",\",作为string对象,引用传递.\n  - 第三个参数,`(Int32) o`, 先进行拆箱(但不紧接着执行复制),获取到在已装箱Int32中的未装箱Int32的地址.这个未装箱的Int32实例必须再次装箱. 将实例的内存地址传给arg2参数\n6. Concat方法调用每个对象的ToString方法,将每个对象的字符串连接起来.返给给WriteLine方法以最终显示.\n\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       47 (0x2f)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop       // nop:没有什么意义；\n\n  // Int32 v = 5;\n  IL_0001:  ldc.i4.5  // Ldc.I4 将所提供的 int32 类型的值作为 int32 推送到计算堆栈上。\n  IL_0002:  stloc.0   //从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。\n\n  // object o = v;\n  // 局部变量object o,位置设定为索引0\n  IL_0003:  ldloc.0   //将索引 0 处的局部变量加载到计算堆栈上。\n  IL_0004:  box        [System.Runtime]System.Int32  // 将值类转换为对象引用（O 类型）。\n  IL_0009:  stloc.1   //从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。\n\n  // v = 123;\n  IL_000a:  ldc.i4.s   123  // 将提供的 int8 值作为 int32 推送到计算堆栈上（短格式）。\n  IL_000c:  stloc.0\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // 在WriteLine方法参数(object引用类型)中, 会对值类型的v产生装箱操作\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"    // 推送对元数据中存储的字符串的新对象引用。\n\n  // Console.WriteLine(v + \",\" + (Int32) o );\n  // (Int32) o 拆箱操作,拆成原始的Int32值类型.\n  IL_0018:  ldloc.1\n  IL_0019:  unbox.any  [System.Runtime]System.Int32\n  // 由于被作为WriteLine方法参数(object引用类型), 再进行装箱操作\n  IL_001e:  box        [System.Runtime]System.Int32\n  // 调用string的Concat方法连接字符串\n  IL_0023:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  // 将Concat返回的string 传给WriteLine方法\n  IL_0028:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_002d:  nop\n\n  // 从Main返回,终止应用程序\n  IL_002e:  ret\n} // end of method Program::Main\n\n```\n\n如果改进一下,如下:\n```csharp\n// 此处如果修改成如下代码,效率更高,避免了2次操作:一次装箱一次拆箱\nConsole.WriteLine(v + \",\" + o );// 显示123,5\n```\n对比一下IL代码\n1. 比之前版本小了10个字节. 第一个版本`额外的拆箱/装箱`显然会产生更多的代码. 额外的装箱操作步骤会从托管堆中分配一个额外的对象, 将来对其进行垃圾回收.\n\n```csharp\n.method private hidebysig static void  Main(string[] args) cil managed\n{\n  .entrypoint\n  // 代码大小       37 (0x25)\n  .maxstack  3\n  .locals init (int32 V_0,\n           object V_1)\n  IL_0000:  nop\n  IL_0001:  ldc.i4.5\n  IL_0002:  stloc.0\n  IL_0003:  ldloc.0\n  IL_0004:  box        [System.Runtime]System.Int32\n  IL_0009:  stloc.1\n  IL_000a:  ldc.i4.s   123\n  IL_000c:  stloc.0\n  IL_000d:  ldloc.0\n  IL_000e:  box        [System.Runtime]System.Int32\n  IL_0013:  ldstr      \",\"\n  IL_0018:  ldloc.1\n  IL_0019:  call       string [System.Runtime]System.String::Concat(object,object,object)\n  IL_001e:  call       void [System.Console]System.Console::WriteLine(string)\n  IL_0023:  nop\n  IL_0024:  ret\n} // end of method Program::Main\n```\n\n进一步提升代码的性能:\n\n**v.ToString(),返回是的String,是引用类型,不需要装箱,减少一个装箱操作.**\n\n`Console.WriteLine(v.ToString() + \",\" + (Int32) o );`\n\n对应的IL代码则是: `IL_000f:  call       instance string [System.Runtime]System.Int32::ToString()`\n\n#### 例子二\n\n```csharp\n// 以下代码只发生了一次装箱.\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // 装箱\n    Object o = v;\n    // 修改栈, 不影响已装箱的o\n    v = 123;\n    // public static void WriteLine(int value)\n    // 方法WriteLine是传值的方式,不需要装箱\n    Console.WriteLine(v); // 123\n    // 拆箱\n    v = (Int32) o;\n    Console.WriteLine(v); // 5\n}\n```\n\n### FCL重载了很多常用值类型的方法,减少常用值类型的装箱次数\n```csharp\npublic static void WriteLine(double value);\npublic static void WriteLine(float value);\npublic static void WriteLine(int value);\n...\n```\n\n**大多数方法进行重载唯一的目的就是减少常用值类型的装箱次数.**\n\n但是FCL不可能接受你自己定义的值类型. 也可能FCL没有提供对应的重载版本,那调用方法传递值类型参数时,就是调用Object参数的重载版本. 将值类型实例作为Object传递会造成装箱.\n\n定义自己的类时, 可将类中的方法定义为泛型(通过泛型约束将类型参数限制为值类型), 这样方法就可以获取任何值类型而不必装箱.\n\n#### 例子三(如果要反复对一个值类型装箱,请改为手动方式)\n\n```csharp\nstatic void Main(string[] args)\n{\n    Int32 v = 5;\n    // v会被装箱3次,浪费时间和内存\n    Console.WriteLine($\"{v}+{v}+{v}\"); // 123\n\n    // 对v手动装箱一次\n    Object o = v;\n    // 编译下一行不会发生装箱行为\n    // 内存利用还是执行速度都比上一段代码更胜一筹\n    Console.WriteLine($\"{o}+{o}+{o}\"); // 123\n}\n```\n","tags":["CLR读书笔记"]},{"title":"二基元类型引用类型和值类型","url":"/2019/07/15/二基元类型引用类型和值类型/","content":"\n# 编程语言的基元类型\n\n## 什么是基元类型\n\n编译器直接支持的数据类型称为`基元类型(primitive type)`.\n\n基元类型直接映射到Framework类库FCL中存在的类型.例如C#中的`int`直接映射到的`System.Int32`类型.\n\n> MSDN文档将primitive type翻译成\"基元类型\",而不是容易混淆的\"基本类型\".\n\n以下四行代码都能正确编译,并能生成完全相同的`IL代码`.\n```csharp\n// 最方便的语法\nint a = 0;\n// 方便的语法\nSystem.Int32 a = 0;\n// 不方便的语法\nint a = new int();\n// 最不方便的语法\nSystem.Int32 a = new System.Int32();\n\n// 从另外一个角度可以认为C#编译器自动假定所有源代码都添加了一下using指令(取别名作用)\nusing sbyte = System.SByte;\nusing byte = System.Byte;\nusing short = System.Int16;\nusing ushort = System.UInt16;\nusing int = System.Int32;\nusing uint = System.UInt32;\n...\n```\n\n## 基元类型对应的FCL类型\n\n是要是符合CLS公共语言规范的类型,其他语言都提供了类似的基元类型. 不符合的就不一定支持了.\n\n![](二基元类型引用类型和值类型/5-1.png)\n\n## 关于关键字和完整的系统类型名称\n\nC#语言规范:\"从风格上说,最好使用关键字,而不是使用完整的系统类型名称.\"\n作者认为: 更好的是使用FCL类型名称,完全不用基元类型名称.\n\n事实上,作者希望编译器根本不提供`基元类型名称`, 而是强迫开发人员使用`FCL类型名称`.理由如下:\n\n1. 有些程序员纠结用`string`还是`String` . 由于C#的`string`(这是关键字)直接映射到`System.String`类型(这是FCL库中的类型). 所以两者没有区别.\n\n> 误区: 有些开发人员说32位系统上int代表32位整数,64位系统上int代表64位整数,这个说法是错误的.\n> 因为c#的`int`始终映射到`System.Int32`类型. 所以不管在什么操作系统上运行,代表的都是32位整数.\n> 如果用Int32,这样的误解就没有了.\n\n2. C#的`long`类型映射到的是`System.Int64`,而其他编程语言中可能映射到Int16或Int32. 例如C++/CLI就将long视为Int32. 事实上大多数语言不将long当做关键字.根本不编译使用了它的代码.\n\n3. FCL的许多方法都将类型名作为方法名的一部分.例如BinaryReader类型的方法包括ReadBoolean,ReadInt32,ReadSingle等, 而System.Convert类型的方法包括ToBoolean,ToInt32,ToSingle等.\n\n```csharp\n// 虽然语法上没问题, 但float的那一行无法一下子判断该行的正确性.\nBinaryReader br = new BinaryReader(...);\n// 使用float C#关键字\nfloat val = br.ReadSingle(); // 正确,但感觉别扭\n// 使用Single FCL类型名称\nSingle val = br.ReadSingle();// 正确,感觉自然\n\n```\n\n4. 平时只用C#的许多程序员逐渐忘了还可以用其他语言写面向CLR的代码.`C#主义逐渐入侵类库代码`.例如:FCL几乎完全是用C#写的,FCL团队向库中引入了`Array`的`GetLongLength`这样的方法,该方法返回的是`Int64`值.这种值在C#中确实是long,但是在其他语言比如C++/CLI中不是. 另一个例子是:`System.Linq.Enumerable`的`LongCount`方法.\n\n** 考虑到以上原因,本书坚持使用FCL类型名称.**\n\n## System.Int32 为什么能转 System.Int64?\n\n在许多编程语言中,一下代码都能正确编译并运行:\n\n```csharp\nInt32 i = 5;//32位值\nInt64 i = i;//隐形转型为64位值\n```\n但是根据上一章内容,对类型转换的讨论,你或许认为上述代码无法编译. 毕竟`System.Int32`和`System.Int64`是不同的类型.互相不存在派生关系. 但是能正确编译上述代码,运行起来也没有问题.\n\n原因是: C#编译器非常熟悉基元类型,会在编译代码时应用自己的特殊规则.\n1. 具体的说,C#编译器支持`与类型转换`,`字面值(直接量或文字常量)`以及`操作符`有关的模式.\n\n### 转型\n\n编译器能执行`基元类型之间`的隐式或显示转型.\n```csharp\nInt32 i = 5; //从Int32隐式转型为Int32\nInt64 l = i; //从Int32隐式转型为Int64\nSingle s =i; //从Int32隐式转型为Single\nByte b = (Byte)i;// 从Int32显示转型为Byte\nInt16 v = (Int16)s;//从Single显示转型为Int16\n```\n\n只有在转换`安全`的时候,C#才允许隐式转型.\n- 什么是转换`安全`的时候?\n  - 是指不会发生数据丢失的情况. 比如从`Int32`转换为`Int64`.\n\n- 如果可能`不安全`,C#就要求显示转型.\n  - 对于数值类型,`不安全`意味着转换后丢失精度或数量级.\n  - 例如`Single(float IEEE32位浮点值)`,转换为`Int16(short 有符号16位)`也要求显示转型.因为Single能表示比Int16更大数量级的数字(会丢失精度).\n\n#### C#编译器总是对转型结果进行截断\n\n比如 6.8的`Single(float IEEE32位浮点值)`转型为`Int32`,\n**C#总是对结果进行截断(向下取整)**, 结果是将6放入`Int32`类型中.\n\n> 有些编译器可能会将结果向上取整为7.\n\n### 字面值\n\n`字面值`可被看成是类型本身的实例.\n\n```csharp\n// 实例 调用 实例方法\nConsole.WriteLine(123.ToString() + 456.ToString()); // 123456\n\n// 如果表达式由字面值构成, 编译器在编译时就能完成表达式求值.从而增强应用程序性能.\nBoolean found = false;// 生成的代码将found设为0\nInt32 x = 100 + 20 + 3;// 生成的代码将x设为123\nString s = \"a \" + \"bc\";// 生成的代码将s设为\"a bc\"\n```\n\n## checked 和 unchecked 基元类型操作\n\n对基元类型执行的许多算术运算符都可能造成溢出:\n\n```csharp\n// byte 2^8 = 256\nByte b = 100;\n// 100 +200 = 300\n// 执行此处算术运算符时, 要求所有的操作数扩大到32位(64位,如果有操作数需要超过32位来表示的话)\n// b 和 200 都不超过32位,则先转换成32位值,然后加到一起,结果是一个32位的十进制300.\n// 然后该值存回b变量前**必须转型为Byte, C#不隐式执行此操作.**\nb = (Byte)(b + 200); // b 现在为 44\n```\n\n## 溢出处理\n\n1. 溢出大多数时候是不希望出现的,会导致应用程序行为失常.但是极少数时候计算哈希值和校验和,这种溢出可以接受.\n2. 不同语言处理溢出的方式不同, C/C++不将溢出视为错误,允许值回滚.VB则视为错误,并抛出异常.\n\n> 回滚:一个值超出允许的最大值时,回滚到一个非常小的,负的或者未定义的值.\n\nCLR提供了一些特殊的IL指令. 允许程序员自己决定如何处理溢出. CLR有一个add指令,作用是将两个值相加,但不执行溢出检查,还有一个add.ovf指令,会在溢出时抛System.OverfolwException异常.\n\n1. `溢出检查`默认是关闭的. 编译器生成IL代码时,将自动使用加减乘和转换指令的无溢出检查版本.代码能更快的运行.\n2. `/checked+`编译器开关在生成代码时使用溢出检查版本.这样CLR会检查这些运算,判断是否发生溢出,并抛出异常.\n3. 除了全局性的打开和关闭溢出检查, 程序员可以在代码的特定区域控制.\n   - unchecked 操作符\n   - checked 操作符\n\n```csharp\nUInt32 invalid = unchecked( (UInt32) (-1)); // OK\n\nByte b = 100;\n// 会抛出OverflowException异常\n// 这个过程中,b和200会转成32位值,\n// 300 转成 Byte就会抛出异常\nb = checked((Byte)(b + 200));\n\n// b包含44, 不会抛出异常.\nb = (Byte)checked(b + 200);\n```\n\nC#还支持checked和unchecked语句. 可以是语句块中的代码都进行或不进行溢出检查.\n\n> checked和unchecked语句 唯一作用就是决定生成哪个版本的加减乘和数据转换的IL指令.\n> **所以在checked操作符或语句中 调用方法,不会对该方法造成任何影响.**\n\n```csharp\nchecked\n{\n  Byte b = 100;\n  //简化 b = (Byte)(b + 200)\n  b += 200;\n}\n\nchecked\n{\n  // 假定SomeMethod试图把400加载到一个Byte中\n  SomeMethod(400);\n  // SomeMethod 可能会,也可能不会抛出OverflowException异常\n  // 如果SomeMethod使用checked指令编译,就可能会抛出异常.\n  // 但这和当前的checked语句无关.\n}\n```\n\n## 应对无效输入的建议\n\n1. 尽量使用有`符号数值类型`比如:Int32和Int64,而不是`无符号数值类型`UInt32和UInt64.\n  - 这允许编译器检测更多的上溢/下溢的错误.\n  - 类库的多个部分,比如Array和String的Length属性 被硬编码为返回有符号的值.\n  - 减少强制类型转换,无符号数值类型不符合CLS.\n\n2. 写代码时,如果代码可能发生你想不到的溢出(可能是无效的输入,使用用户或客户机提供的数据), 就把这些代码放到`checked块`中. 同时捕捉`OverflowException`异常.\n\n3. 将允许发生溢出的代码显示放到`unchecked块`中,比如在计算校验和时.\n\n4. 对于没有使用`unchecked`和`checked`的语句,都假定发生溢出时抛出异常.\n\n![](二基元类型引用类型和值类型/5-1-1.png)\n\n勾选 `检查运算上溢/下溢` 相当于打开了编译器的`/checked+开关`进行调试性生成.应用程序运行起来会慢一点.可以进行比较完整的溢出检查.\n\n## System.Decimal是非常特殊的类型\n\n1. C#和VB视为基元类型. 但是CLR不这样. CLR没有知道如何处理Decimal值的IL指令.\n2. Decimal类型自己定义一系列方法,包括Add,Subtract,Multiply,Divide. 还为`+-*/`等提供了操作符重载方法.\n3. 编译使用了Decimal值的代码时,**编译器会生成代码来调用Decimal的成员方法**,并**通过这些成员方法来进行实际的运算**. 这也意味着Decimal值的处理速度慢于CLR基元类型的值.\n4. 由于没有相应的IL指令来处理Decimal值, 所以checked和unchecked操作符,编译器开关都失去作用.\n\n## System.Numerics.BigInteger类型\n\n1. 类似的,BigInteger类型也在内部使用了`UInt32`数组来表示任意大的整数,它的值没有上限和下限.\n2. 因此对于BigInteger类型执行运算永远不会造成OverflowException异常\n3. 如果值太大,没有足够的内存来改变数组大小,BigInteger的运算可能会抛出`OutOfMemoryException`异常.\n","tags":["CLR读书笔记"]},{"title":"二设计类型类型基础","url":"/2019/07/08/二设计类型类型基础/","content":"\n# 所有类型都从System.Object派生\n\n**`运行时`要求每个类型都从`System.Object`派生**.\n\n```csharp\n//隐式派生自Object\nclass Employee｛\n  ...\n｝\n//显式派生自Object\nclass Employee: System.Object{\n  ...\n}\n```\n\n## System.Object的公共方法Equals\n| 公共方法 | 说明 |\n| :------| ------ |\n| Equals  | 如果两个对象具有`相同的值`就返回true  |\n\n### 对象的相等性和同一性\n\n#### 同一性\n\n```csharp\n// 此虚方法实现的是同一性,而非相等性.\n// 因为obj引用的对象如果不是引用相同对象,那就无法比较值是否相等.\npublic virtual Boolean Equals(Object obj)\n{\n  // 如果两个引用指向同一个对象,它们肯定包含相同的值\n  if (this == obj) return true;\n  // 假定对象包含不同的值\n  return false;\n}\n```\n\n| 静态方法 | 说明 |\n| :------| ------ |\n| ReferenceEquals  | 检查两个引用是否指向同一对象  |\n\n> 检查同一性务必调用ReferenceEquals,不应该使用C#的== 操作符 (除非都转成Object), 因为某个操作数可能重载了==操作符.\n\n```csharp\n// 上述方法是不合理的,因此Microsft提供了检查同一性的方法\npublic static bool ReferenceEquals (Object objA, Object objB) {\n    return objA == objB;\n}\n```\n#### 重写Equals方法\n\n1. Equals 必须自反: x.Equals(x)肯定返回true\n2. Equals 必须对称:  x.Equals(y)和y.Equals(x)返回相同\n3. Equals 必须可传递:  x.Equals(y)返回true,  y.Equals(z)返回true,那么 x.Equals(z)肯定是true\n4. Equals 必须一致:比较的两个值不变,返回值也不能变.\n\n### 值类型的基类ValueType重写了Equals方法\n\n```csharp\npublic override bool Equals(object obj)\n{\n  // 1.判断实参obj是否为null\n  if (obj == null)\n    return false;\n  RuntimeType type = (RuntimeType) this.GetType();\n  // 2.this和obj实参引用不同类型的对象,返回false\n  if ((RuntimeType) obj.GetType() != type)\n    return false;\n  object a = (object) this;\n\n  // 3. 如果对象的成員中存在对于堆上的引用，那么返回false，\n  // 如果不存在，返回true。例如按照ValPoint的定义，它仅包含一个int类型的字段x，自然不存在对堆上其他对象的引用，所以返回了true\n  if (ValueType.CanCompareBits((object) this))\n    return ValueType.FastEqualsCheck(a, obj);\n\n  // 4.利用反射获取值的所有字段\n  FieldInfo[] fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);\n  for (int index = 0; index < fields.Length; ++index)\n  {\n    object obj1 = ((RtFieldInfo) fields[index]).UnsafeGetValue(a);\n    object obj2 = ((RtFieldInfo) fields[index]).UnsafeGetValue(obj);\n    // 5. 判断是否为null\n    if (obj1 == null)\n    {\n      if (obj2 != null)\n        return false;\n    }\n    // 6. 通过调用字段的Equals方法进行比较\n    else if (!obj1.Equals(obj2))\n      return false;\n  }\n  return true;\n}\n```\n由于CLR反射机制慢,定义自己的值类型时应重写`Equals`方法来提供自己的实现.从而提高用自己类型的实例进行值相等性比较的性能. **当然,自己的实现不调用 `base.Equals`**.\n\n### 重写Equals方法还需要做的事\n\n1. 让类型实现`System.IEquatable<T>`接口的`Equals`方法\n  - 泛型接口,定义类型安全的`Equals`方法` bool Equals(T other)`;\n2. 重载==和!=操作符方法( 这些方法内部调用了类型安全的`CompareTo`方法. )\n3. 如果需要排序,类型还应该实现`System.IComparable`的`CompareTo`方法和泛型接口`System.IComparable<T>`的类型安全的`CompareTo`方法.\n4. 重载比较操作符方法<,<=,>,>= ( 这些方法内部调用了类型安全的`CompareTo`方法.)\n\n\n\n## System.Object的公共方法GetHashCode\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetHashCode  | 返回对象值的哈希码.如果某个类型的对象要在哈希表集合(比如`Dictionary`)中作为键使用,类型应重写该方法.  |\n\n### 对象哈希码\n\nFCL的设计者认为,如果能将任何对象的任何实例放到`哈希集合`中,能带来很多好处。为此`System.Object`提供了虚方法`GetHashCode`,它能获取任意对象的Int32哈希码.\n\n如果你定义的类型重写了Equals方法,还应该重写GetHashCode方法. 这是因为`System.Collections.Hashtable`类型,`System.Collections.Generic.Dictionary`类型以及一些其他的集合中,要求两个对象必须具有**相同哈希码才能被视为相等**. 确保相等性算法和对象哈希码算法一致.\n\n- 添加\n  - 向集合添加`键/值对`,首先要获取`键`对象的哈希码, 该哈希码指出这个`键/值对`要存储到哪个`哈希桶bucket`中.\n- 查找\n  - 集合需要查找`键`时候, 会获取`键`对象的哈希码, 此哈希码标识了现在要以顺序的方式搜索的哈希桶. 在这个哈希桶中查找哈希码相同的`键`对象,以及对应的`值`对象.\n- 修改\n  - **错误的方式: 直接修改集合中的`键`对象,修改后的键对象的哈希码与原来不同,就会去搜索错误的哈希桶,找不到对应的值对象.**\n  - 正确做法: 从集合中移除原来的`键/值对`, 修改键对象, 重新将新的键值对添加回哈希表.\n\n### 自己实现哈希算法\n自定义GetHashCode方法,取决于数据类型和数据分布情况, 需要设计出能返回良好分布值的哈希算法.\n\n要遵循的规则:\n1. 算法要提供良好的随机分布,使哈希表获得最佳性能.\n2. 一般不要调用Object或ValueType的GetHashCode方法, 因为两者的实现与高性能哈希算法不沾边.\n3. 算法至少使用一个实例字段.\n4. 理想情况下, 算法使用的字段值应该不可变,也就是说,字段在对象构造时初始化,在对象的生存期永不言变.\n5. 算法执行速度尽量快.\n6. 包含相同值的不同对象应返回相同的哈希码.\n\n> System.Object实现的GetHashCode方法对派生类型和其中的字段一无所知,所以返回一个在对象生存期保证不变的编号.\n\n> 最好不要将哈希码持久化, 因为生成哈希码的算法可能会发生改变. 例如:CLR版本升级后,String的GetHashCode方法发生了改变. 之前如果存储的是string的哈希码,则导致全部不对应了.\n\n\n## System.Object的公共方法ToString\n| 公共方法 | 说明 |\n| :------| ------ |\n| ToString  | 默认返回类型的完整名称`this.GetType().FullName` . 经常用于调试的目的重写该方法,返回一些值的字符串表示. |\n\n## System.Object的公共方法GetType\n| 公共方法 | 说明 |\n| :------| ------ |\n| GetType  | 返回从Type派生的一个类型的实例,指出调用GetType的对象是什么类型. |\n\n### GetType是非虚方法.\n\n目的是`不允许重写`. 防止类重写该方法,隐瞒其类型,进而破坏类型安全性.(用new关键字告诉编译器定义一个新方法`new public void F()`)\n\n\n> 返回的Type对象可以和反射类配合,获取与对象的类型有关的元数据信息.\n\n\n## System.Object的受保护方法MemberwiseClone\n| 受保护方法 | 说明 |\n| :------| ------ |\n| MemberwiseClone  | 就是创建一个浅表副本的新对象，然后将当前对象的非静态字段复制到该新对象. |\n\n`MemberwiseClone` 方法创建一个`浅表副本`，。如果字段是值类型的，则对该字段执行逐位复制。如果字段是引用类型，则**复制引用但不复制引用的对象**；因此，原始对象及其复本引用同一对象。\n\n```csharp\npublic DemoClass Clone1() //浅CLONE\n{\n    return this.MemberwiseClone() as DemoClass;\n}\n\npublic DemoClass Clone2() //深clone\n{\n    MemoryStream stream = new MemoryStream();\n    BinaryFormatter formatter = new BinaryFormatter();\n    formatter.Serialize(stream, this);\n    stream.Position = 0;\n    return formatter.Deserialize(stream) as DemoClass;\n}\n```\n\n\n### 什么是浅表副本?\n- 浅度拷贝( **浅表副本** )\n  - 一个集合的浅度拷贝意味着只拷贝集合中的元素，不管他们是引用类型或者是值类型，但是它`不拷贝引用所指的对象`。这就是说新集合中的引用和原始集合中的`引用所指的对象是同一个对象`。\n- 深度拷贝( **深表副本** )\n  - 深度拷贝不仅拷贝集合中的元素，而且还拷贝了这些元素直接或者间接引用的所有内容。这也就意味着，新集合中的引用和原始集合中的`引用所指的对象是不同的`.\n\n### 深度复制原理\n为了实现`深度复制`，我们就必须遍历有相互引用的对象构成的图，并需要处理其中的循环引用结构。这无疑是十分复杂的。幸好借助.Net的`序列化和反序列化机制`，可以十分简单的深度Clone一个对象。原理很简单，首先将对象序列化到内存流中，此时对象和对象引用的所用对象的状态都被保存到内存中。.Net的序列化机制会自动处理循环引用的情况。然后将内存流中的状态信息反序列化到一个新的对象中。这样一个对象的深度复制就完成了。在原型设计模式中CLONE技术非常关键。\n\n### 深拷贝的帮助类\n```csharp\npublic static class ObjectCopier\n{\n    /// <summary>\n    /// Perform a deep Copy of the object.\n    /// </summary>\n    /// <typeparam name=\"T\">The type of object being copied.</typeparam>\n    /// <param name=\"source\">The object instance to copy.</param>\n    /// <returns>The copied object.</returns>\n    public static T Clone<T>(T source)\n    {\n        // 判断泛型T是否能序列化\n        if (!typeof(T).IsSerializable)\n        {\n            throw new ArgumentException(\"The type must be serializable.\", \"source\");\n        }\n\n        // Don't serialize a null object, simply return the default for that object\n        // 不能序列化一个null对象\n        if (Object.ReferenceEquals(source, null))\n        {\n            return default(T);\n        }\n\n        // 流操作\n        IFormatter formatter = new BinaryFormatter();\n        Stream stream = new MemoryStream();\n        using (stream)\n        {\n            formatter.Serialize(stream, source);\n            stream.Seek(0, SeekOrigin.Begin);\n            return (T)formatter.Deserialize(stream);\n        }\n    }\n}  \n```\n\n\n## System.Object的受保护方法Finalize\n| 受保护方法 | 说明 |\n| :------| ------ |\n| Finalize  | 在垃圾回收器判断此对象作为垃圾被回收之后,在对象的内存被实际回收之前,调用此虚方法. |\n\n需要在回收之前执行清理工作的类型应重写此方法.\n\n\n# 所有对象都要用new操作符\n\n> 实例字段(实例成员)是非静态字段  --- 属于类的对象\n> 静态成员----------------------- 属于类\n\n\n**new 操作符所做的事情**\n1. 计算类型及其所有基类(一直到System.Object)中定义的所有实例字段需要的字节数. (计算需要的字节数 )\n  - `堆`上的每个对象都需要有`开销成员overhead`,包括 `类型对象指针(type object pointer)`和`同步块索引sync block index`.\n  - CLR利用这些`开销成员`管理对象. `开销成员`的字节数要计入对象的大小.\n2. 从`托管堆`中分配类型要求的字节数, 从而分配对象的`内存`, 分配的所有字节都设置为`零(0)`.\n3. 初始化对象的`开销成员`:`类型对象指针(type object pointer)`和`同步块索引sync block index`.\n4. 调用类型的实例化`构造器`,传递在new调用中指定的`实参`.\n  - 每个类型的构造器都负责初始化该类型定义的实例字段. 最终调用System.Object的构造器,该构造器什么都不做,简单地返回.\n5. 返回新建对象的一个引用(或指针).\n\n\n> 没有delete操作符用来显示释放为对象分配的内存, CLR采用垃圾回收机制.\n\n# 类型转换及类型安全性\n\n> CLR最重要的特性就是类型安全. 在运行时,CLR总是知道对象的类型是什么.\n> 调用GetType方法即可知道对象的确切类型.\n> 由于它是非虚方法,所以不可能伪装成别的类型.\n\nCLR运行将对象转换为`它的(实际)类型`或者`它的任何基类型`.\n\n- `对象类型` --转换成--> `该对象的基类型`\n  - C#中, `向基类型的转换`是一种安全的**隐式转换** .\n- 而将`对象类型` --转换成--> `该对象的某个派生类型`\n  - C#要求开发人员只能进行 **显示转换(强制类型转换)** .\n\n\n```csharp\n// Employee的基类是Object\n// 不需要转换, 派生类对象转基类对象是类型安全的隐式转换\nObject o = new Employee();\n\n// Employee是Object的派生类,需要进行转型\n// 必须用强制类型转换\nEmployee e = (Employee)o;\n```\n\n> 为了方便记忆,打个比方\n>- `公交汽车(派生类)` 可以认为是 `汽车(基类)` , 因为包含`汽车(基类)`都存在的东西.\n>- 但是, `汽车(基类)` 并不只有`公交汽车(派生类)`,还有其他类型的汽车.\n\n这样才能让编译器顺利编译这些代码.\n\n运行时做的事:\n1. CLR检查转型操作, 确保总是转换为对象的实际类型或者它的任何基类.\n\n```csharp\n// 在运行时, CLR会检查转换,判断o的实际类型是否是Employee类型或者它的派生类.\nEmployee e = (Employee) o;\n```\n( `A` ) >= `A/A的派生类`.\n\n因此,类型安全是CLR及其重要的一个特点.\n```csharp\nclass A{..}\n\nclass B:A{..}\n\nMain()\n{\n  B b = new B();\n  test(b);\n\n  DateTime t = new DateTime(...);\n  // 编译期 t的基类也是object,能通过编译\n  test(t);\n}\n\nstatic test(Object o)\n{\n  // 运行期会CLR会进行类型检查,\n  // 传进来的参数t类型基类不是A,也不是A的派生类,\n  // 会报System.InvalidCastException异常\n  A a = (A)o;\n}\n```\n给方法合适的参数能在编译期就能发现错误,而非运行期报错.例如改为`test(A a){}`而不是`Object`参数类型.\n\n\n# 使用C#的is和as操作符来转型\n\n> 相较于is操作符,使用as操作符来简化写法和提升性能.\n\n相较于之前的`()`强转语法,C#还有另外一方式进行类型转换. 是使用`is`操作符,区别如下\n1. 返回Boolean值true或false;\n2. 并且永远不会抛出异常.\n3. 如果对象引用null,is操作符总是返回false.\n\n通常使用方法:\n```csharp\n// 这种用法有个缺点,\n// CLR实际检查两次对象类型.\n// 1. is操作符首先核实o是否兼容于A类型,\n// 2. 如果是,在if内部转型时,CLR再次核实o是否引用一个A类型.\n// 这样对性能造成了一定的影响\nif(o is A)\n{\n  A a = (A)o;\n  // 在if剩余语句使用a\n}\n```\n\n**这种写法对性能造成影响,是因为CLR必须遍历继承层次结构,用每个基类型去核对指定的类型(上述例子中的A类型).**\n\nC#专门提供了as操作符,目的就是简化这种写法,同时提升性能.\n1. `as`操作符返回对同一个对象的`非null引用`.\n2. 工作方式与强制转换一样,并且不会抛出异常.\n3. 如果对象不能转型,则返回`null`.\n4. `as`操作符造成CLR值校验一次对象类型\n\n```csharp\n// as操作符造成CLR值校验一次对象类型\n// 从而提高性能\nA a = o as A;\nif (a != null)\n{\n  // 在if语句中使用a\n}\n\n```\n\n> 编译时错误 Complier Time Error 运行时错误Run Time Error\n\n```csharp\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // 向基类型的转换是一种安全的隐式转换\n        Base b2 = new Dervied();\n\n        // CTE 编译时错误\n\n        // Base派生自object,不能由new基类创建子类. new子类可以创建基类\n        // Base b3 = new Object(); // CTE\n        Object o2 = new Base();\n\n        // Dervied d3 = new Object(); // CTE\n        Object o3 = new Dervied();\n\n        // new Dervied()隐式转为Base类. b2要转成原本的Dervied类型需要显示转换\n        // Dervied d3 = b2; // Base b2 = new Dervied();  // CTE\n        Dervied d3 = (Dervied)b2;\n\n        // RTE 运行时错误\n\n        // 不能由new基类转换子类,CLR会在运行期检查类型,判断 (Dervied) >= new Base()\n        Dervied d6 = (Dervied) new Base(); // RTE\n        Base b5 = (Base) new Object(); //RTE\n    }\n}\n\nclass Base{}\nclass Dervied : Base{}\n```\n\n**注意: C#允许类型定义`转换操作符`方法, 只有在使用转型表达式时才调用这些方法,使用C# `as/is操作符`永远不会调用它们.**\n\n\n\n# 命名空间和程序集\n\n1. 命名空间和程序集不一定相关, 同一个命名空间中的类型可能在不同程序集中实现.同一程序集也可能包含不同命名空间中的类型.\n2. 使用命名空间用`using`指令\n  - 引用类库,标记命名, 少写代码.\n  - 为类型和命名空间创建别名, 消除歧义.\n\n```csharp\nusing Microsoft; // 可以少写Microsoft.前缀\nusing Wintellect;// 可以少写Wintellect.前缀\n\nusing WintellectWidget = Wintellect.Widget; //\n\npublic class Program\n{\n  // 这样写会有歧义,不明确引用. 两个命名空间中都包含Widget类\n  // Widget w = new Widget();\n\n  // 消除了歧义, 需要多打一点字\n  Wintellect.Widget w = new Wintellect.Widget();\n\n  // 使用using别名方式\n  WintellectWidget w = new WintellectWidget();\n}\n```\n3. `外部别名extren alias` 用于更精细的消除歧义\n  - 公司Axxxx Bxxxx Cxxxxx和Ayyyy Byyyy Cyyyyy公司都发布一个`BuyProduct`类型\n  - 如果他们都用ABC作为命名空间, 那同时引用这2个公司的dll就会出现一个问题\n    - `ABC.BuyProduct`方法会报不明确引用.\n\n![](二设计类型类型基础/外部别名.png)\n\n\n> 为此,为了降低冲突发生的概率,应该使用全称来作为自己的顶级命名空间名称.\n\n# 运行时的相互关系\n\n- C#中`栈` 是**编译期间就分配好的内存空间**，因此你的代码中必须就`栈的大小`有明确的定义；\n- `堆` 是**程序运行期间动态分配的内存空间**，你可以根据程序的运行情况确定要分配的堆内存的大小.\n\n## 创建线程栈\n\n已加载CLR的一个Windows进程，进程中可能有多个线程。\n\n**线程创建时会分到1MB的栈。**\n- 栈空间用于向方法`传递实参`\n- 方法内部定义的`局部变量`也在栈上。\n- 栈从高位内存地址向地位地址构建。\n\n## 开始调用一个方法M1\n\n在开始调用之前,\n- `序幕(prologue)代码`对其进行初始化.\n\n在方法做完工作后\n- `尾声(epilogue)代码`对其进行清理,以便返回至调用者.\n\n![](二设计类型类型基础/4-2.png)\n\n1. 假定线程执行的代码要调用M1方法\n2. M1方法开始执行时,它的`序幕代码`在线程栈上分配`局部变量name`的内存,如4-3图示.\n\n![](二设计类型类型基础/4-3.png)\n\n3. 然后M1调用M2方法, 将`局部变量name`作为`实参`传递,将这个实参也`压入栈`,并且将`返回地址`压栈.\n  - `返回地址`:被调用的方法在结束之后应该回至该位置.如4-4图示.\n\n![](二设计类型类型基础/4-4.png)\n\n4. M2方法开始执行时, 它的`序幕代码`在线程栈上分配`局部变量length和tally`的内存. 如4-5所示.\n\n![](二设计类型类型基础/4-5.png)\n\n5. M2方法内部开始执行,最终达到`return`语句,CPU的指令指针被设置成`返回地址`. M2的`栈帧展开(unwind)`.恢复成4-3所示.\n\n> `栈帧展开(unwind)` : 这个翻译来源自生活,把线缠到线圈上称为wind,从线圈上搜开称为unwind.同样的调用方法时压入栈帧称为wind,方法执行完毕弹出栈帧称为unwind.\n\n6. 最终M1会返回到它的调用者. 这同样通过将CPU的指令指针设置成返回地址来实现.\n\n\n# 围绕CLR来观察,来演示CLR如何工作的\n\n```csharp\ninternal class Employee {\n    public               int32         GetYearsEmployed()       { ... }\n    public    virtual    String        GenProgressReport()      { ... }\n    public    static     Employee      Lookup(String name)      { ... }    \n}\ninternal sealed class Manager : Employee {\n    public    override   String         GenProgressReport()    { ... }\n}   \n```\n\n1. Window进程已经启动,CLR已经加载到其中,托管堆已经初始化,而且创建了一个线程(连同它的1MB栈空间).\n2. 准备要调用M3方法.\n\n![](二设计类型类型基础/4-6.png)\n\n3. **JIT编译器** 将M3的`IL代码`转换成`本机CPU指令`时, CLR需要确认定义了这些类的类型都已加载.\n  - `Employee`,`Int32`,`Manager`,以及`String`(因为存在一个\"Joe\"的字符串).\n4. 然后利用程序集的`元数据`,CLR提取与这些类型有关的信息. 并创`建一些数据结构`来表示类型本身.\n  - 图4-7展示了`Employee`和`Manager`类型对象使用的`数据结构`.\n  - 至于`Int32`,`String`的`数据结构`可以认为之前已经定义好了.因为它们都是很常用的类型.所以图中没显示它们.\n\n![](二设计类型类型基础/4-7.png)\n\n- 堆上所有对象都包含两个额外成员:\n  - `类型对象指针(type object pointer)`\n  - `同步索引块(sync block index)`\n- 静态数据字段.\n- 方法表: 定义的所有方法都有一个对应的记录项.\n\n5. 当CLR确认方法需要的所有类型对象都已创建,M3的代码编译之后,就允许线程执行M3的`本机代码`.\n  - M3的`序幕代码`执行时必须在线程栈中为局部变量分配内存.\n  - 在调用类型构造器之前,CLR会先初始化同步块索引,将对象的所有实例字段设为null或者0.\n  - CLR自动将所有局部变量初始化为`null`或者`0`.\n  - Manager只定义了1个方法(GetProgressReport的重写)\n\n![](二设计类型类型基础/4-8-9.png)\n\n6. 任何时候在堆上新建对象,CLR都自动初始化内部的`类型对象指针`成员来引用和对象对应的类型对象.\n7. new 操作符返回Manager对象的内存地址. 该地址保存到变量e中,(e在线程栈上).\n8. M3下一行代码调用Employee的`静态方法Lookup`.\n  - CLR定位类型对象\n  - JIT编译器查找类型对象的方法表中对应的记录项, 对方法进行JIT(如果需要的话).\n  - 再调用JIT编译好的代码.\n9. 假定`静态方法Lookup`会从数据库找出一名经理Joe.\n  - 在方法内会在堆上构造一个新的Manager对象, 用Joe的对象初始化它.返回该对象的地址.\n  - 该地址保存到变量e中\n  - 这里e不再引用第一个Manager对象, 第一个对象会被垃圾回收.\n10. M3的下一行代码调用Employee的非虚实例方法GetYearsEmployed\n  - JIT编译器会找到 **发出调用的那个变量(e)的类型 对应的类型对象(Employee)**.\n  - 此时e的类型定义为`Employee`类型\n    - 如果此类型中没有定义被调用的方法\n    - JIT编译器会**回溯类层次结构**(一直到Object),并沿途的每个类型中查找该方法.\n\n> 之所以能`回溯`,是因为每个类型对象都有一个字段引用了它的`基类型`.\n\n![](二设计类型类型基础/4-10.png)\n\n11. JIT编译器找到了被调用方法的记录项, 进行JIT编译,再调用JIT编译好的代码,将返回的数据放到临时变量中保存.\n\n12. M3的下一行代码调用了Employee的`虚实例方法(虚方法,重写过的)`GetProgressReport.\n  - `调用虚方法`时,JIT编译器要在方法中生成一些额外的代码.\n  - 方法每次调用都会执行这些代码, 这些代码首先\n    - 检查`发出调用的变量`, 并跟随地址来到`发出调用的对象`\n    - 变量e当前引用的是代表\"Joe\"的Manager对象.\n    - 代码检查对象内部的`类型对象指针`成员, 该成员指向对象的实际类型.\n    - 代码在类型对象的方法表中查找对应调用方法的`记录项`,对方法进行JIT编译\n    - 再调用编译好的代码.\n    - 由于目前e引用的是一个Manager对象,所以会调用Manager的GetProgressReport实现\n\n![](二设计类型类型基础/4-11-12.png)\n\n\n> 注意:  如果Employee对象的`Lookup方法`发现\"Joe\"是`Employee`而不是`Manager`,则Lookup会在内部构造一个Employee对象,它的类型对象指针将引用Employee类型, 最终执行的则是Employee的GetProgressReport实现,而不是Manager的.\n\n\n# CLR内部发生的事情\n\nEmployee和Manager类型对象都包含\"类型对象指针\"成员. 这是由于类型对象本质上也是对象.\n\nCLR创建类型对象时, 必须初始化这些成员.\n\n## 初始化什么呢?\n\n1. CLR开始在一个进程中运行时, 会立即为MSCorLib.dll中定义的`System.Type`类型创建一个特殊的类型对象.\n2. Employee和Manager类型对象都是该类型的\"`实例`\"``\n3. System.Object的`GetType方法`返回存储在指定对象的`类型对象指针`成员中的地址.\n  - 也就是说,GetType方法返回`指向对象的类型对象`的指针.\n  - 这样就可以判断系统中任何对象的真实类型.\n\n![](二设计类型类型基础/4-13.png)\n","tags":["CLR读书笔记"]},{"title":"一CLR基础4","url":"/2019/07/07/一CLR基础4/","content":"# 程序集种类和部署方式\n\n本章将解释 .Net Framework为了解决版本控制问题而建立的基础结构.\n\n## 为什么要有强命名程序集?\n\n因为只根据文件名来区分程序集明显不够, CLR必须支持对程序集进行唯一性标识的机制. 这就需要`强命名程序集`.\n\n## 私有部署 & 全局部署\n\n- 私有部署:程序集部署到应用程序`基目录`或者`某个子目录`.\n- 全局部署:部署到`公认位置`的程序集.\n\n## 强命名程序集 & 弱命名程序集\n\n- 强命名程序集\n  - 使用了发布者的公钥/私钥进行了`签名`.\n  - 这对秘钥允许对程序集进行唯一性的标识.\n  - 私有部署和全局部署都可以.\n- 弱命名程序集\n  - 只能以私有方式部署.\n\n### 在生成的程序集中引用强命名程序集\n\n1. CSC.exe编译器 /r 开关引用,如果不指定目录,按照以下顺序查找\n  - 工作目录\n  - CSC所在目录\n  - 使用/lib 编译器开关指定的目录\n  - 使用LIB环境变量指定的任何目录\n\n## 唯一性标识技术\n- GUID(Globally Unique Identifier) 全局唯一标识符\n- URL(Uniform Resource Locator) 统一资源定位符\n- URN(Uniform Resource Name)\n\n没有使用以上技术,使用了 `标准的公钥/私钥加密技术`\n\n![](一CLR基础4/公钥.png)\n\n`PublicKeyToken`:公钥标记, 如果没null,则是弱命名程序集.\n\n## 创建强命名程序集\n\n可以使用SN.exe(Strong Name)工具来生成公钥/私钥对。\n\n在VS中,新建`公钥/秘钥文件`,可显示项目属性,点击`签名`标签,勾选`为程序集签名`,然后从选择`强名称秘钥文件`中新建.\n\n\n# 全局程序集缓存\n\n1. 如果一个程序集要由多个应用程序访问，必须把它放到一个已知的目录中，而且clr在检测到对该程序集的一个引用时，必须知道自动检查该目录。这个已知的位置成为`全局程序集缓存(GAC,Global Assmbly Cache)`。\n2. GAC通常位于`%SystemRoot%\\Microsoft\\Assembly`\n3. GAC目录是结构化的：其中包含许多子目录，并用一个算法来生成这些子目录的名称。不要手动复制.要用工具完成.\n4. 可以使用GACUtil.exe在GAC中安装一个强命名程序集.\n5. 无法将弱命名程序集安装到GAC.\n\n\n# \"运行时\"如何解析类型引用\n\n1. 运行应用程序,CLR会加载并初始化自身\n2. 读取程序集的`CLR头`,查找标识了应用程序入口方法(Main)的`MethodDefToken`\n3. 检索`MethodDef元数据表`,找到方法的的IL代码在文件中的偏移量\n4. 将IL代码JIT编译成本机代码.\n5. 最后执行本机代码.\n\n\n解析引用的类型时候,CLR可以在三个地方找到类型：\n- 同一个文件（早期绑定）\n- 不同的文件但同一个程序集（当前程序集清单目录）\n- 不同的文件不同的程序集（其他程序集清单目录）。　　\n\n\n- `早期绑定early binding`: 编译时便能发现对相同文件中的类型的访问.\n- `晚期绑定late binding`: 在运行时通过反射机制绑定到类型并调用方法.\n\n1. 对于CLR来说，所有程序集都是根据名称、版本、语言文化和公钥来标识的。\n2. GAC根据名称、版本、语言文化和`cpu架构`来标识程序集。\n","tags":["CLR读书笔记"]},{"title":"一CLR基础3","url":"/2019/07/07/一CLR基础3/","content":"# .Net Framework部署目标\n\n## 什么是DLL Hell?\n\n> Windows早期并没有很严谨的DLL版本管理机制，以致经常发生安装了某软件后，因为其覆盖了系统上原有的同一个DLL文件，而导致原有可运行的程序无法运行。但还原回原有的DLL文件之后，所新安装的软件就无法运行。若影响到系统所使用的重要DLL时也可能让系统容易死机甚至无法正常启动。\n\n[別再掉進DLL地獄的陷阱裡(DLL Hell)~.NET解決之道 資策會數位教育研究所講師 王芳芳](https://web.archive.org/web/20080208173943/http://www.iiiedu.org.tw/knowledge/knowledge20021130_1.htm)\n\n总结:\n\n1. The .NET Framework NET Assembly 自描述与版本管理功能让 zero-impact(零影响) 的部署安装成为可能，同時也终结了DLL Hell 。\n\n2. Application-Private Assemblies (or 被隔离的assembly) 只能被一个应用程式所使用- 它不会被其他的应用程式所影响。 隔离的assembly 让程式开发者对应用程式有着绝对的控制权，开发好的Application-Private Assemblies只要部署在和应用程式同一目录即可。\n\n3. 透过Side by side execution(并行执行)的技术，应用程式只要安装成功之后，就不用担心DLL更新版本，或规格的改变， 它允许一个assembly 的多个版本在一个机器上同时被安装并执行， 而且每一个应用程式都可以要求和不同的Assembly 版本系结。\n\n4. The .NET Framework 纪录应用程式版本资讯，并在执行应用程式时使用此资讯载入应用程式所需依赖的正确版本的Assemblies。\n\n# 将类型生成到模块中\n\n```csharp\npublic sealed class Program{\n        public static void Main()\n        {\n          // 由于引用了Console类的WriteLine方法\n          // 要顺利通过编译，必须向C#编译器提供一组程序集\n          // 使他能解析对外部类型的引用\n          System.Console.WriteLine(\"Hi\");\n        }\n}\n```\n>System.Console是Microsoft实现好的类型，用于实现这个类型的各个方法的IL代码存储在MSCorLib.dll\n\n> 此处”r“意为`reference`\n\n因此需要添加`r:MSCorLib.dll` 开关命令，完整编译命令行应如下：\n`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs `\n\n但由于其他命令均为默认命令，本例中的编译命令行可以简化为\n`csc.exe Program.cs `\n\n如果不想C#编译器自动引用`MSCorLib.dll`程序集，可以使用`/nostdlib`开关。\n\n## 生成三种应用程序的编译器开关\n\n> 此处”t“意为`target`\n\n- 生成控制台用户界面(Console User Interface, CUI)应用程序使用`/t:exe`开关；\n- 生成图形用户界面(Graphical User Interface, GUI)应用程序使用`/t:winexe`开关；\n- 生成Windows Store应用程序使用`/t:appcontainerexe`开关；\n\n## 集合开关命令的文件:响应文件\n\n编译时可以指定包含编译器设置命令的响应文件，例如：假定响应文件`MyProject.rsp`包含以下文本\n\n```csharp\n// MyProject.rsp\n/out:MyProject.exe\n/target:winexe\n```\n为了让CSC.exe使用该响应文件，可以像下面这样调用它\n\n`csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs`\n\nC#支持多个响应文件，其先后顺序服从就近原则，优先级为`控制台命令>本地>全局`。\n\n.NET Framework具有一个默认的全局CSC.rsp文件，在运行CSC.exe进行编译时会自动调用，全局CSC.rsp文件中列出了所有的程序集，就不必使用C#的/reference开关显式引用这些程序集，这会对编译速度有一些影响，但不会影响最终的程序集文件，以及执行性能，开发者也可以自己为全局CSC.rsp添加命令开关，但这可能为在其他机器上重现编译过程带来麻烦。\n\n另外，指定/noconfig开关后，编译器将忽略本地和全局CSC.rsp文件。\n\n# 什么是元数据? 元数据概述\n\n> 元数据（英语：metadata），又称诠释数据、中介数据、中继数据、后设数据等，为描述其他数据信息的数据.\n\n>元数据概述：元数据是一种二进制信息，用以对存储在公共语言运行库可移植可执行文件 (PE) 文件或存储在内存中的程序进行描述。将您的代码编译为 PE 文件时，便会将元数据插入到该文件的一部分中，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中。在模块或程序集中定义和引用的每个类型和成员都将在元数据中进行说明。当执行代码时，运行库将元数据加载到内存中，并引用它来发现有关代码的类、成员、继承等信息。\n\n首先回顾一下`托管模块(Managed Module)`。`托管模块`是一个需要`CLR`才能执行的`标准WindowsPE(Portable executable，简称PE)文件`。\n\n- `PE32(+)头` :PE 文件主要部分的索引和入口点的地址。运行库使用该信息确定该文件为 PE 文件并确定当将程序加载到内存时执行从何处开始。\n- `CLR表头`:是一个小的信息块，是托管模块特有的，包含生成时所面向的版本号、一些标志、和一个MethodDef token用来指定模块的入口方法，最后，CLR头还包含模块内部的一些元数据表的大小的偏移量\n- `中间语言(IL)代码` : 编译器在编译源代码时产生的指令。CLR在运行时会将IL代码编译成本地CPU指令\n- `元数据`: 元数据表和堆,是由三种表构成的二进制数据块，这三种表分别为`定义表(definiton talbe)`、`引用表(reference table)`和`清单表(mainfest table)`。运行库使用该部分记录您的代码中每个类型和成员的信息。本部分还包括自定义属性和安全性信息。\n\n## 元数据描述的信息\n\n元数据以非特定语言的方式描述在代码中定义的每一类型和成员。元数据存储以下信息：\n\n- 程序集的说明\n  - 标识（名称、版本、区域性、公钥）。\n  - 导出的类型\n  - 该程序集所依赖的其他程序集。\n  - 运行所需的安全权限。\n- 类型的说明\n  - 名称、可见性、基类和实现的接口。\n  - 成员（方法、字段、属性、事件、嵌套的类型）。\n- 属性\n  - 修饰类型和成员的其他说明性元素。\n\n### 定义表(definiton talbe)\n\n**代码中定义的任何东西都将在上表中的某个表创建一个记录项。**\n\n| `定义表`名称 | 说明 |\n| :------| ------ |\n| ModuleDef\t| 包含`模块`文件名,扩展名(不含路径),编辑器创建的GUID 的 记录项.|\n| TypeDef\t| 每个`类型`都在这个表中有一个记录项,包含类型的名称,基类,标志(public/private等),一些索引.这些索引指向MethodDef中属于该类型的方法、FieldDef表中该类的字段、PropertyDef表中该类型的属性以及EventDef表中该类型的时间.|\n| MetodDef  | 每个`方法`(包括入口方法)都在这个表中有一个记录项, 包含方法的名称,标志,签名,以及方法的IL代码在模块中的偏移量(位置),每个记录项还引用了ParamDef表中的一个记录项，后者包括与方法参数有关的更多信息。 |\n|FieldDef   |\t模块定义的每一个`字段`在这个表中都有一个记录项。每个记录项都包括标志、类型和名称。   |\n| ParamDef  |  关于`参数`的记录项 |\n| PropertyDef\t  |  模块定义的每个`属性`在这个表中都有一个记录项。每个记录项都包含标志、类型和名称。 |\n|EventDef\t   | 模块定义的每个事件在这个表中都有一个记录项。每个记录项都包含标志和名称。  |\n\n### 引用表(reference table)\n| `引用表`名称 | 说明 |\n| :------| ------ |\n| AssemblyRef  | `引用的每个程序集`的记录项,每个记录项都包含绑定(bind)该程序集所需的信息：程序集名称(不包含路径和扩展名)、版本号、语言文化及公钥Token(根据发布者的公钥生成一个小的哈希值，标识了所引用程序集的发布者)。  |\n| ModuleRef  | 实现该模块所引用的类型的`每个PE模块`在这个表中都有一个记录项。每个记录项都包含模块的文件名和扩展名(不含路径),如果存在别的模块实现了你需要的类型，这个表的作用便是同哪些类型建立绑定关系  |\n| TypeRef  | 模块引用的每一个`引用类型`.....  |\n| MemberRef   | 模块引用的`每个成员`（字段和方法，以及属性方法和事件方法）在这个表中都有一个记录项。每个记录项都包含成员的名称和签名，并指向对成员进行定义的那个类型的TypeRef记录项  |\n\n### 清单表(mainfest table)\n\n| `引用表`名称 | 说明 |\n| :------| ------ |\n|AssemblyDef   | 如果模块标识的是程序集，这个元数据表就包含`单一记录项来列出程序集名称`(不包含路径和扩展名)、版本(major，minor，build和revision)、语言文化、标志、哈希算法以及发布者公钥(可为null)  |\n|FileDef   | 每个`PE文件和资源文件`在这个表中都有一个记录项(清单本身所在的文件除外，该文件在AssemblyDef表的单一记录项中列出) 在每个记录项中，都包含文件名和扩展名(不含路径)、哈希值和一些标志。如果程序集只包含他的主模块，不包含其他非主模块和资源文件。FileDef将无记录 |\n|ManifestResourceDef   | 每个`资源`在这个表中都有一个记录项 .记录项中包含资源名称、一些标志(如果程序集外部可见，就为public，否则为private)以及FileDef表的一个索引(指出资源或流包含在哪个文件中)。如果资源不是独立文件(比如.jpg或者.gif文件)，那么资源就是包含在PE文件中的流。对于嵌入资源，记录项还包含一个偏移量，指出资源流在PE文件中的起始位置|\n|ExportedTypesDef   | 从程序集的所有PE模块中`导出的每个public类型`在这个表中都有一个记录项。  |\n\n\n# 将模块合并成程序集\n\n## Microsoft为何考虑要引入程序集这一概念?\n\n这是因为使用程序集，`可重用类型`的`逻辑表示`和`物理表示`就可以分开。\n- 物理上，可以将常用的类型放在一个文件中，不常用的程序放在另一些文件中，只在使用时加载，\n- 在逻辑上，这些程序仍然被组织于同一程序集中，不需要编写额外的代码显式进行链接。\n\n## 程序集(Assembly)是什么组成的?\n\n程序集(Assembly)是一个或多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了`清单(Manifest)`，如上一节一开始所述，`清单`也是`元数据`的组成部分之一，表中主要包含作为程序集组成部分的那些文件的名称。此外还描述程序集的版本、语言文化、发布者、公开导出类型以及构成程序集的所有文件。\n\n`CLR`操作的是程序集，对于程序集，有以下几点重要特性：\n- 程序集定义了可重用的类型。\n- 程序集用一个版本号标记。\n- 程序集可以关联安全信息。\n\n**程序集是进行重用、版本控制和应用安全性设置的基本单元。**\n\n对于一个程序集来说，除了包含清单元数据表的文件，程序集中的其他文件独立时不具备以上特点.\n\n## 编译生成含有清单元数据表的PE文件\n\nC#编译器都会生成程序集： `/t: exe`, `/t: winexe`, `/t: appcontainerexe`, `/t: library` 或者`/t: winmdobj`。这些开关会指示编译器生成含有清单元数据表的PE文件。\n\nC#编译器还支持`/t: module`开关。这个开关指示编译器生成一个不包含清单元数据表的PE文件。这样生成的肯定是一个DLL PE文件。CLR要想访问其中的任何类型，必须先将该文件添加到一个程序集中。使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\n\n例如:\n将不常用类型编译到一个单独模块，这样一来如果程序集的用户永远不使用不常用类型，就不需要部署这个模块。\n```csharp\n// 使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\ncsc /t:module 不常用类型.cs\n```\n\n`不常用类型.netmodule`这是一个标准的DLL PE文件，但是CLR不能但单独加载它。\n\n将输出的文件名改为MultiFileLibrary.dll, 目标是生成库文件,添加`不常用类型`的模块, 编译`FUI.cs`\n```csharp\n// 指定了/t: library开关，所以生成的是含有清单元数据表的DLL PE文件\n// /addmodule:不常用类型.netmodule 开关告诉编译器不`常用类型.netmodule`文件是程序集的一部分，从而将其添加到FileDef清单元数据表，并将`不常用类型.netmodule`的公开导出类型添加到ExportedTypesDef清单源数据表。\ncsc /out:NultiFileLibray.dll /t:library /addmodule:不常用类型.netmodule FUT.cs\n```\n\n## 使用程序集链接器(AL.exe)生成程序集\n\n除了使用C#编译器，还可以使用”程序集链接器“实用程序AL.exe来创建程序集。如果程序集要求包含由不同编译器生成的模块(而这些编译器不支持与C#编译器的/addmodule开关等家的几种机制)，程序集连接器就显得相当有用。\n\n**AL.exe能生成EXE文件，或者生成只包含清单的DLL PE文件。程序集链接器不能将多个文件合并成一个文件。**\n\n```csharp\ncsc /t:module RUT.cs\ncsc /t:module FUT.cs\nal /out:MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule\n```\n## 为程序集添加资源文件\n\n- 用AL.exe创建程序集时，可用`/enbed [resource]`开关将文件作为资源添加到程序集。该开关获取任意文件，并将文件内容嵌入最终的PE文件。也可用`/Link [resource]`开关获取资源文件，但只指出资源包含在程序集的哪个文件，并不嵌入到PE文件中；该资源文件独立，并必须与程序集文件一同被打包部署\n- C#编译器用`/resource`开关将资源嵌入PE文件，用`/linkresource`开关添加记录项引用资源文件。以上开关均会修改ManifestResourceDef清单表添加记录项，外部引用的开关还会修改FileDef表以指出资源包文件。\n\n\n\n# 程序集版本资源信息\n\n> Visual Studio新建C#项目时会在一个Properties文件夹中自动创建AssemblyInfo.cs文件。可直接打开该文件并修改自己的程序集特有信息。\n\n在应用程序代码中调用`System.Diagnostics.FileVersionInfo的`静态方法`GetVersionInfo`并传递程序集路径作为参数可以获取并检查这些信息。\n\n![](一CLR基础3/版本资源字段和对应的特性.png)\n\n```csharp\n// 有关程序集的一般信息由以下\n// 控制。更改这些特性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle(\"LentilToolbox\")]\n[assembly: AssemblyDescription(\"Licensed under the MIT license\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"LentilToolbox\")]\n[assembly: AssemblyCopyright(\"Copyright ©  2016 Lentil Sun\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n//将 ComVisible 设置为 false 将使此程序集中的类型\n//对 COM 组件不可见。  如果需要从 COM 访问此程序集中的类型，\n//请将此类型的 ComVisible 特性设置为 true。\n[assembly: ComVisible(false)]\n\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid(\"ac315d57-80ca-4e7a-b55c-064b94547552\")]\n\n// 程序集的版本信息由下列四个值组成:\n//\n//      主版本\n//      次版本\n//      生成号\n//      修订号\n//\n//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值，\n// 方法是按如下所示使用“*”: :\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.1.0.2\")]\n[assembly: AssemblyFileVersion(\"1.1.0.2\")]\n\n```\n\n| - | \tmajor（主版本号）|\tminor（次版本号）|\tbuild（内部版本号）|\trevision（修订号）|\n| :-----:| :-----: | :-----: | :-----: | :-----: |\n|示例  | 2  | 5  | 719  | 2  |\n\n\n注意：程序集有三个版本号，每个版本号都有不同的用途：\n- `AssemblyFileVersion`：这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号的作用是说明**该程序集的版本**。\n- `AssemblyInformationalVersion`：同上，这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号作用是说明**使用该程序集的产品的版本**。\n- `AssemblyVersion`：存储在AssemblyDef清单元数据表中，CLR在绑定到强命名程序集时会用到它。这个版本号很重要，它**唯一性地标识了程序集。**\n\n\n\n\n# 语言文化\n\n![](一CLR基础3/语言文化标记.png)\n\n未指定具体语言文化的程序集成为`语言文化中性(Culture neutral)`。\n\n```csharp\n// 将程序集的语言文化设为瑞士德语\n[assembly: AssemblyCulture(\"de-CH\")]\n```\n\n# CLR探测程序集文件会扫描的目录\n","tags":["CLR读书笔记"]},{"title":"一CLR基础2","url":"/2019/07/06/一CLR基础2/","content":"> 温故而知新\n\n# CLR功能\n\n## JIT(just-in-time 运行时编译技术)\n\n>通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。\n\n>`即时编译器`则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。\n\n>即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。\n\n为了执行方法，首先必须将方法的IL转换成本机(native)CPU指令。这是CLR的JIT编译器的职责。\n\n### 流程讲解\n\n![](一CLR基础2/方法的首次调用.png)\n\n1. 在Main方法执行之前,CLR会检测出Main的`代码引用`的所有类型.\n  - CLR分配一个`内部数据结构`来管理对引用类型的访问.\n  - 图中,Main方法引用了Console类型,CLR分配了一个`内部结构`.\n  - Console类型定义的每个方法都在`内部结构`中存在一个`记录项 entry`.\n  - 根据这个记录项可以找到方法的实现.\n  - 对这个`内部结构`进行初始化,每个方法都指向包含在CLR内部的一个`未编档函数`,称之为`JITCompiler`.\n2. 进入Main方法,首次调用`WriteLine方法`时, `JITCompiler函数`被调用.\n3. `JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的`IL代码`.\n4. 然后`JITCompiler`验证`IL代码`,将`WriteLine方法`的`IL代码`编译成`本机CPU指令`.\n5. `本机CPU指令`保存到动态分配的内存块中.`JITCompiler`将在CLR为类型创建的`内部数据结构`中,修改引用.\n6. 指向到刚才动态分配的内存块地址. 最后`JITCompiler`跳转到内存块中的代码(`WriteLine方法`的具体实现).\n7. 返回到Main中的代码.\n\n![](一CLR基础2/方法的第二次调用.png)\n8. 第二次调用`WriteLine方法`,由于已经进行了验证和编译,会直接跳转到已经编译好的`本机CPU指令`代码块中执行.\n\n方法仅在首次调用时才会有一些性能损失,之后调用全是以本机代码的形式全速运行.\n\n## JIT 编译技术特点\n\n1. JIT编译器将本机CPU指令存储到动态内存中.意味着一旦应用程序终止,编译好的代码也会被丢弃.\n2. JIT编译器会对`本机代码`进行优化.类似于C++编译器后端所做的事情. 可能花较多的时间生成优化代码.\n> 在Visual Studio中新建C#项目时，”调试“(Debug)配置指定的是/optimize-/debug:full，而”发布“(release)配置指定的是/optimize+/debug:pdbonly。\n\n3. JIT能够针对本机CPU为IL代码生成指令，以利用本机指定CPU的任何特殊指令进行编译。相反，非托管应用程序通常是针对具有最小功能集合的CPU编译的。\n\nJIT编译器能够判断一个特定的测试在它运行的机器上是否总是失败，例如，假定有一个方法包含以下代码\n```csharp\n// 如果主机只有一个CPU，JIT编译器不会为此代码生成任何CPU指令。\nif(numberofCPUs>1){\n    ...//Do something\n}\n```\n\n## 将IL代码编译成本机代码的验证过程\n\n将IL代码编译成本机代码的过程中,CLR会执行验证过程,根据元数据检查类型,返回值,返回语句,参数是否正确等等.\n\n\n## NGen.exe生成的本机代码与JIT生成的本机代码对比\n\n1. NGen生成的代码**不会**像JIT编译器生成的代码进行高度优化.较差的执行时性能.\n2. CLR加载程序集时,会检查是否存在一个对应的,由NGen生产的本机文件.\n3. NGen.exe生成的本机文件没有知识产权保护.\n4. NGen生成的文件可能失去同步.版本不匹配,系统升级过等,就无法使用.\n\n\n# 基类库支持功能\n\n> .Net Framework 包含 Framework类库(Framework Class Library,FCL).\n\n1. FCL是一组DLL程序集的统称.\n\n![](一CLR基础2/FLC部分常规命名空间.png)\n","tags":["CLR读书笔记"]},{"title":"一CLR基础","url":"/2019/07/05/一CLR基础/","content":"\n> 对真正的力量一无所知。\n\n# 程序执行基础概念\n- 代码\n- 翻译器\n  - 编译器\n  - 优化编译器\n- 中间语言\n- 执行\n  - 运行时系统\n    - 运行期\n  - 可执行文件\n  - 解释器\n  - 虚拟机\n\n---\n- 代码类型\n  - 源代码\n  - 目标代码\n  - 字节码\n  - 机器代码\n  - 微程序\n\n\n# CLR和 .Net Framework的关系\n\n>.NET框架 （.NET Framework） 是由微软开发，一个致力于敏捷软件开发（Agile software development）、快速应用开发（Rapid application development）、平台无关性和网络透明化的软件开发平台。.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、VB.NET、C++、Python等）的开发。\n\n由此可见，`.Net Framework`是一个支持多种开发语言的开发平台，而这种多语言支持的特性又要以CLR为基础。CLR是一个.Net产品的运行环境。`公共语言运行时(Common Language Runtime)`和 `.Net Framework Library(FCL)`是`.Net Framework`的两个主要组成部分。\n\n\n# 什么是CLR?\n\n> 通用语言运行平台（Common Language Runtime，简称CLR）是微软为他们的.NET的虚拟机所选用的名称。它是微软对通用语言架构（CLI）的实现版本，它定义了一个代码运行的环境。CLR运行一种称为通用中间语言的字节码，这个是微软的通用中间语言实现版本。\n\n1. `CLR`是一个类似`JVM`的虚拟机, 为.NET的程序提供运行的环境.\n2. `CLR`中运行的是一种字节码形态的` Microsoft Intermediate Language，简称MSIL \"微软中间语言\"`.\n3. 在.Net开发平台下，所有语言（C#、VB.NET、J#、C++/CLI）都会被编译为`MSIL`\n\n## CLR做了什么?\n\n1. 将`IL`代码在`运行时`编译成`本机代码Native Code`.(`JIT(just-in-time 运行时编译技术)`)\n> 本机代码Native Code,是面向特定CPU架构(x86,x64,ARM)的代码\n\n![](一CLR基础/1.png)\n\n## CLR有哪些功能?\n\n- 基类库支持 Base Class Library Support\n- 内存管理 Memory Management\n- 线程管理 Thread Management\n- 垃圾回收 Garbage Collection\n- 安全性 Security\n- 类型检查 Type Checker\n- 异常管理 Exception Manager\n- 调试管理 Debug Engine\n- 中间码(MSIL)到机器代码(Native)编译 (即时编译 (JIT just-in-time))\n- 类别装载 Class Loader\n\n\n# CIL是什么?如何生成?\n\n>字节码现在已经官方地成为了CIL (通用中间语言（Common Intermediate Language，简称CIL)\n\n1. 在编译.NET编程语言时，源代码被翻译成`CIL`,再由`CLR`负责运行\n2. `IL代码`有时又称为`托管代码(managed code)`.\n3. `IL代码`只是`面向CLR的编译器`生成的其中一部分.\n\n## IL代码\n\n1. `IL`是与CPU无关的面向对象的机器语言.\n\n## 非托管代码\n\n1. C++编译器默认生成包含`非托管代码`的EXE/DLL模块.\n2. 并且在运行时操纵非托管数据(`native 内存`).\n3. 不需要CLR就能运行.\n4. 只有C++编译器允许开发人员同时写`托管代码`和`非托管代码`,并生成到同一模块中.\n\n### 非托管代码和托管代码的互操作性\n\n- 托管代码能调用DLL中的非托管函数：托管代码通过`P/invoke机制`调用DLL中的函数\n- 托管代码可以使用现有的COM组件：详情可参考 .NET Framework SDK提供的TlbImp.exe\n- 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。详情可以参考 .NET Framework SDK提供的TlbExp.exe和RegAsm.exe工具。\n\n\n# 面向CLR的编译器生成了什么?\n\n> 微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。\n\n1. 不同语言的`编译器(Compiler)`就相当于一个这种语言的代码审查者(Checker),所做的工作就是检查源码语法是否正确，然后将源码编译成`CLR`所需要的`中间语言(IL)`.\n2. `C#语言编译器`编译C#源码文件之后生成`托管模块`.\n\n![](一CLR基础/将源代码编译成托管模块.png)\n\n## C#编译器做的工作\n\n1. C#编译器(CSC.exe)默认将生成的**托管模块转换成程序集**,也就是生成的是**含有清单的托管模块**.\n2. 生成的是PE32(+)文件.\n3. 这个PE32(+)文件包含一个名为`清单(manifest)`的数据块. `清单`也是`元数据表`的集合.\n\n![](一CLR基础/将托管模块合并成程序集.png)\n\n\n# 托管模块是什么?由哪些组成?\n\n1. 无论是什么编译器，最后都是生成`托管模块`。\n2. `托管模块`是标准的32位的可移植执行体（PE32）文件，或者是64位的（PE32+）\n3. 需要`CLR`才能运行。\n4. 其中托管模块中还包含完整的`元数据`.\n\n![](一CLR基础/托管模块的各个部分.png)\n- `CLR头`：包含使这个模块成为托管模块的信息。\n- `IL中间语言代码`：编译器编译源码的时候生成的代码。运行时，`CLR`将`IL`编译成`本机CPU指令`\n- `元数据`：面向CLR的每个编译器要在每个托管模块中生成完整的元数据。元数据是一个数据表的集合。一些数据描述了模块中定义了什么，另一些描述了模块中引用了什么。由于编译器同时生成元数据和代码，把他们绑在一起，并嵌入最终生成的托管模块。所以元数据和他描述的代码不会失去同步。\n-\n\n## 可移植执行体PE文件的结构\n\n![](一CLR基础/PE文件架构.png)\n\n# 元数据是什么?\n\n1. `元数据`简单的说是一个数据表的集合.\n2. 主要包含两种表:\n  - 描述源代码中定义的类型和成员\n  - 描述源代码`引用的`类型和成员\n3. 元数据有多种用途\n  - 避免了编译时对原生C/C++数据头和库文件的需求. 因为IL代码中已经包含了全部信息.编译器直接读取元数据.\n  - `智能感知IntelliSense`技术解析元数据,提示帮助写代码.\n  - CLR验证代码使用元数据确保只执行`类型安全`的操作.\n  - `元数据`允许将对象的字段序列化到内存块,发到另一台机器反序列化,重建对象状态.\n  - `元数据`允许垃圾回收器跟踪对象的生存期.\n\n\n\n# CTS通用类型系统是什么?\n\n> 通用类型系统 (Common Type System) 定义了运行期引擎如果使用程序中的数据类型，以及如何配置数据在存储器中的一种标准，依照此种标准所撰写的编程语言，都可以在同一个运行期引擎中使用，因此它是跨语言支持的重要部分，亦即匹配 CTS 规范的编程语言所撰写出的程序，都可以在 CLR 中使用。\n\n> CTS与CLI规格都是由微软所发展，当前已标准化为 ECMA 335 标准：“Common Language Infrastructure (CLI) Partitions I to VI.”，并且由 Microsoft 在 .NET Framework 中完全的实现。\n\n**由于类型是CLR的根本，微软专门为如何定义、使用和管理类型定义了一个正式的规范-- 通用类型系统(Common Type System)，即CTS。**\n\n事实上, 不根本不需要专门学习CTS规则本身,因为你选择的余元会采用你熟悉的方式公开它自己的`语言语法`与`类型规则`,通过编译来生成程序集时,会将语言特有的语法映射到IL---也就是CLR的`语言`.\n\n无论使用哪一种语言,类型的行为都完全一致,因为最终是由CLR的CTS来定义类型的行为.\n\n## 类型可见性和访问规则\n\n- `private`           : 成员只能由同一个类(class)类型中的其他成员访问.\n- `protected`         : 成员可以从派生类型访问,不管是不是在同一个程序集中.\n- `internal`          : 成员可以由同一个程序集中的任何代码访问.\n- `protected internal`: 可以由任何程序集中的派生类型访问.\n- `public`            : 成员可由任何程序集中的任何代码访问.\n\n\n\n# CLS通用语言规范是什么?\n\n > 定义了一个最小公共集，任何编译器只有支持这个功能集，生成的类型才能兼容其他符合CLS、面向CLR的语言生成的组件\n\n![](一CLR基础/CLS图示.png)\n\n在开发类型和方法的时候，如果希望它们对外“可见”，能够从符合 CLS 的任何一种编程语言中访问，就必须遵守由 CLS 定义的规则。注意， 假如代码只是从定义（这些代码的）程序集的内部访问，CLS 规则就不适用了。\n\n```csharp\nusing System\n\n//告诉编译器检查CLS相容性\n[assembly:CLSCompliant(true)]\n\nnamespace SomeLibrary\n{\n    //因为是public类，所以会显示警告\n    public sealed class SomeLibrarytype\n    {\n        //警告：SomeLibrary.SomeLibraryType.Abc()的返回类型不符合CLS\n        public UInt32 Abc(){return 0;}\n\n        //警告：仅大小写不同的标识符SomeLibrary.SomeLibraryType.abc()不符合CLS\n        public void abc(){ }\n\n        //不显示警告：该方法是私有的\n        private UInt32 ABC(){return 0;}\n    }\n}\n```\n- 第一个警告是因为Abc方法返回了无符号整数，一些语言是不能操作无符号整数值的\n- 第二个警告是因为该类型公开了两个public方法，这两个方法只是大小写和返回类型有别，VB和其他一些语言无法区分这两个方法。\n\n# 关于window32位和64位版本\n1. 如果程序集文件只包含`类型安全`的`托管代码`在32位和64位上都能运行.\n> 类型安全代码指访问被授权可以访问的内存位置.有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。(直接访问内存的其他位置)\n\n2. 如果要使用`不安全的代码`, 需要用到`/playform`命令行开关.如果指定了,则只能在对应平台上使用.默认`anycpu`.\n3. 可执行文件执行时,Windows会检查文件头,64位系统会通过`WoW64(Windows on Windows64)`技术运行32位应用程序.\n\n![](一CLR基础/platform对生成的模块的影响.png)\n\n4. Windows启动托管应用程序的流程.\n\n![](一CLR基础/Windows运行EXE流程.png)\n\n5. 可在代码中查询\n  - `Environment.Is64BitOperatingSystem`属性,判断是否在64位系统上运行.\n  - `Environment.Is64BitProcess`属性,判断是否在64位地址空间中运行\n\n# 不安全的代码\n\nC#编译器默认生成的是安全代码.\n\nC#允许开发人员通过`unsafe`关键字标记包含不安全代码的方法.\n\n# 保护IL代码\n\n1. 混淆器\n2. 在非托管模块中实现想保密的算法, 利用CLR的互操作功能实现应用程序的托管和非托管部分之间的通讯.\n\n# 一些微软提供的实用工具\n- CSC.exe C#编译器:将多个托管模块和资源文件合并成程序集的工具.\n- AL.exe 程序集链接器:将一组文件合并到程序集中.\n- CLRVer.exe 列出机器上安装的所有CLR版本\n  - `-all` 或者指定 `目标进程ID` 列出正在允许的进程使用的CLR版本号.\n- DumpBin.exe 和 CorFlags.exe:可以用来检查编译器生成的托管模块所嵌入的信息.\n- ILAsm.exe IL汇编器\n- ILDasm.exe IL反汇编器\n>用IL反编译工具查看生成的IL代码。这里使用的是ILDasm.exe，当然，你也可以使用一些其他的工具，例如.Net Reflector、ILSpy等。\n\n- NGen.exe 本机代码生成器: 将程序集的所有IL代码编译成本机代码.并将本机代码保存到一个磁盘文件中.\n- PEVerify.exe 检查一个程序集的所有方法,并报告其中含有不安全代码的方法.\n- MPGO.exe 分析客户端应用程序启动需要哪些东西,会写入一个profile并嵌入程序集中.NGen能根据这个更好的优化生成本机映像.\n- TlbImp.exe 托管代码可以使用现有的COM组件.\n- TlbExp.exe和RegAsm.exe 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。\n- FusLogVw.exe 帮助你了解CLR在运行时与程序集的绑定.\n- SN.exe 获取秘钥(生成公钥/私钥对),未提供显示私钥的功能.\n- GACUtil.exe在GAC中安装一个强命名程序集\n","tags":["CLR读书笔记"]},{"title":"HelloWorld","url":"/2019/07/05/HelloWorld/","content":"\n\n![](https://portablehexo.bitmoe.cn/hexopp/hexop.png)\n\n>**本版本仅适用于Win环境**\n>本文关键字： **Hexo绿色版**，**Hexo便携版**，**Hexo配置**，**Hexo**，**U盘**\n\n[Hexo](https://hexo.io/)是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。\n\n但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。\n\n所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。\n\n#### **版本介绍**\n那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。\n\n本便携版（Release 1.0.0）所包含的软件如下：\n>- Git: 2.7.4\n>- Nodejs: 6.10.1\n>- Npm: 4.4.1\n>- Hexo: 3.2.2\n\n# 用到的主题和插件\n\n1. 兼容Markdown图片语法和Hexo图片语法插件:https://github.com/7ym0n/hexo-asset-image\n2. 主题:https://github.com/aircloud/hexo-theme-aircloud\n3. Tag-Cloud插件 https://github.com/MikeCoder/hexo-tag-cloud\n4. 代码高亮插件:https://github.com/ele828/hexo-prism-plugin\n","tags":["HEXO"]},{"title":"ET入门小指南 v19.7.4","url":"/2019/07/04/ET入门小指南/","content":"\n![](ET入门小指南/1.jpg)\n\n# 了解ET\n\n[[Github]](https://github.com/egametang/ET)\n[[ET论坛]](https://bbs.honorworkroom.com/forum.php)\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端.\n\n[[具体介绍]](https://github.com/egametang/ET/blob/master/README.md)\n\n- [为什么使用C# .net core做服务端？](https://github.com/egametang/ET/blob/master/Book/1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.md)\n  - ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。\n- **为什么选择Unity作为客户端?**\n  - 当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。 客户端可以不使用Unity3d,需要自己对接协议.\n- [为什么后端选MongoBson序列化库?](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n- [为什么选MongoDB数据库?](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=183&extra=page%3D1)\n- [为什么选择ProtoBuf?](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 基于google官方3.4.1版本的protobuf c#-runtime以及3.4.0版本的protoc修改而来，还增加了0gc功能。仍然是标准的pb协议\n  - [ET使用精简过的PB库](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n- **为什么选择ILRuntime热更?**\n  - 因为ios的限制，之前unity热更新一般使用lua，导致unity3d开发人员要写两种代码，麻烦的要死。之后幸好出了ILRuntime库，利用ILRuntime库，unity3d可以利用C#语言加载热更新dll进行热更新。ILRuntime一个缺陷就是开发时候不支持VS debug，这有点不爽。ET框架使用了一个预编译指令ILRuntime，可以无缝切换。平常开发的时候不使用ILRuntime，而是使用Assembly.Load加载热更新动态库，这样可以方便用VS单步调试。在发布的时候，定义预编译指令ILRuntime就可以无缝切换成使用ILRuntime加载热更新动态库。这样开发起来及其方便，再也不用使用狗屎lua了\n- [什么是组件式设计?](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n\n\n# 运行Demo前的准备事项\n\n1. IDE选择\n  - **VS**\n    - ET 5.0(master)\n      - 建议使用VS2019 ( 用2017就自己去官网下 .net core 2.2)\n    - ET 4.0分支使用vs2017（更新到最新版）,并且要勾选\n      - a. .net 桌面开发\n      - visual studio tools for unity\n      -  .net core 2.1\n  - **Rider**\n    - 安装 .net core 2.2\n  - other.....\n\n2. Unity版本选择\n  - ET4.0请使用unity2017.4版\n  - ET5.0(master)需要unity2018.4版\n  - [为什么是.4版本](https://www.bilibili.com/video/av49789692)\n  - 别问怎么破解.问就是个人免费版.\n\n\n3. 安装MongoDB数据库(Demo中注释了数据库组件,只为了运行demo,就随意)\n\n\n# 准备运行Demo\n\n- [运行指南](https://github.com/egametang/ET/blob/master/Book/1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.md)\n\n- [常见的错误解决方法](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=203&extra=page%3D1)\n\n\n\n\n## 测试状态同步Demo\n\n打包一个客户端,unity开一个客户端.就会出现2个小人.点击鼠标右键即可移动人物.看到效果.\n\n## 帧同步Demo\n\n在4.0分支.\n\n# 学习ET\n\n\n\n\n你可能需要如下知识储备:\n- C# 语言基础 ([你渴望力量吗?](https://pan.baidu.com/s/1mqaaVIxOVo02pg8aXaQKXg)s1fz )\n- 设计模式    ([你渴望知识吗?](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 数据结构    ([那就看完吧](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 反射\n- 特性\n- 异步/协程\n- 了解ECS\n- 了解actor模型\n- 网络层TCP/UDP/KCP/ENET\n- MongoDB数据库\n- MongoBson\n- Protobuf\n- 服务器分布式相关\n- [网络同步模型的认识](https://www.gameres.com/849046.html?tdsourcetag=s_pcqq_aiomsg)\n\n客户端\n- Unity基础\n- UGUI\n- AssetBundle流程\n- 热更ILRuntime\n\n其余\n- AstarPathfinding\n- Behavior Designer\n- FGUI\n- NLog\n\n\n>猫大语录:\n应该先去提高下c#基础跟编程基础，再来看ET，碰到问题自己想办法解决，谷歌，打log。你现在好比初中基础却来做大学题目一样，到处碰壁，碰到问题自己不研究指望别人给你找问题，这样编程技术是无法提高的.\n群里能力有高有低，问问题也没什么。但是我是希望群里提问题前能够经过自己一番摸索，经过自己思考，经过谷歌，经过调试log等等再问。很多问题经过自己摸索查找资料能够增长很多知识。其实程序开发就是在不断找bug，在找bug中提升自己。\n\n# ET框架设计大纲\n\n- 公共部分\n  - ET的特色\n  - 什么是ECS\n- async await 协程\n\t- 什么是异步? 单线程？多线程？\n      - [ET/Book/2.1CSharp的协程](https://github.com/egametang/ET/blob/master/Book/2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n      - [ET/Book/2.2更好的协程](https://github.com/egametang/ET/blob/master/Book/2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n\t- 为什么需要async await，await是多线程吗？\n    \t- [ET/Book/2.3单线程异步](https://github.com/egametang/ET/blob/master/Book/2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md)\n\t- 更好的Task：ETTask\n    \t- [群内讨论/ETTask](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=204&extra=page%3D1)\n- [一切皆组件（Entity&Component）](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n  - [事件机制EventSystem](https://github.com/egametang/ET/blob/master/Book/3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.md)\n  - [强大的mongo bson](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n  - 设计一个双端网络库\n  - 协议格式的设计\n  - [protobuf](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 使用Kcp协议\n      - [kcp-bulild](https://github.com/egametang/kcp-bulild)\n  - 应用层循环缓冲区\n  - 消息打包解包\n  - 消息的分发处理\n  - 远程过程调用RPC\n  - 客户端无GC处理\n- 服务端\n\t- 服务端架构简介\n    \t- [服务器命名以及消息类的X2X代表意思](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=161&extra=page%3D1)\n\t- 组件式的服务器\n\t- [Actor模型](https://github.com/egametang/ET/blob/master/Book/5.4Actor%E6%A8%A1%E5%9E%8B.md)\n\t- [ActorLocation](https://github.com/egametang/ET/blob/master/Book/5.5Actor%20Location.md)\n\t- 设计一个计时器( TimerCompoent组件 )\n\t- 服务端热更\n    \t- [群内讨论/热更层和Model层/逻辑与数据相关](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=146&extra=page%3D1)\n\t- Config\n\t- [数值组件](https://github.com/egametang/ET/blob/master/Book/5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.md)\n    \t- [群内讨论/数值组件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=139&extra=page%3D1)\n\t- Repl\n    \t- [Nlog配置和Repl](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=151&extra=page%3D1)\n- 客户端\n\t- 客户端架构简介\n\t- 客户端资源管理\n\t- UI框架\n\t- 客户端热更 (ILRuntime)\n\t- 抛弃unity的协程，使用await\n\t- 组件可视化\n- Demo\n\t- demo的架构, 消息路径\n    \t- [Demo消息流转时序图](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=145&extra=page%3D2)\n\t- recast 3d寻路\n\n\n# ET的一些教学视频\n- [肉饼老师主讲](https://www.taikr.com/my/course/972) : ET3.0时期教程,可以学习如何分离客户端和服务器端,和一些开发思路\n- [初见主讲(B站)](https://www.bilibili.com/video/av33280463/?redirectFrom=h5) - [优酷](https://i.youku.com/i/UNTQ3MjU4MDEy?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DT~A):ET4.0教程,工具使用及demo运行,ET入门教程\n- [ET在Mac上运行指南-L主讲](http://www.liuocean.com/index.php/2018/07/25/et-kuang-jiamac-duan-gong-ju-zhi-chi/)百度云视频链接失效，参考文章吧\n-  [ET框架学习日记 by SwickSu](https://www.bilibili.com/video/av50871743?from=search&seid=9593939068874626189)\n\n# 群内大佬的Github\n- [C# 实现的十字链表的AOI算法](https://github.com/qq362946/AOI) by 初见\n  - [群内讨论/十字链表+快慢针方式的AOI算法可用于双端](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=174&extra=page%3D1)\n- [在初见的AOI（2D）的基础改成3D AOI](https://github.com/yhr28/3D_AOI) by yhr28\n- [ET-RPG-DEMO(基于ET框架的RPG游戏DEMO)](https://github.com/AnotherEnd15/ET-RPG-DEMO)   by AE\n  - [一种完全组合式的技能系统的设计思路](https://blog.csdn.net/qq_32270109/article/details/88551196?tdsourcetag=s_pcqq_aiomsg)\n- [RVO2](https://github.com/AnotherEnd15/RVO2) by AE\n- [Box2DSharp(BOX2D物理引擎C#版)](https://github.com/Zonciu/Box2DSharp)  by 白纸无字Zonciu\n- [Bullet版本(.netCore封装)](https://gitee.com/fengssy/ET-Platform-Bullet?tdsourcetag=s_pcqq_aiomsg) by 风恒\n- [FGUI/双端行为树](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n  - [群内讨论/Behavior Designer全热更行为树插件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=170&extra=page%3D1)\n- [NKGNMobaBasedOnET(基于ET框架的Moba游戏DEMO)](https://gitee.com/NKG_admin/MKGMobaBasedOnET) by 烟雨迷离半世殇\n- [ET斗地主Demo](https://github.com/Viagi/LandlordsCore)\n  - [斗地主架构图](https://pan.baidu.com/s/1wyv6ihefBjQmVynIUBumKA) o05k\n- [ET-MultiplyDemos小游戏集合](https://github.com/Acgmart/ET-MultiplyDemos) by 咲夜詩\n\n#群内大佬分享的一些工具/组件\n\n- [[Debug组件]DebuggerComponent.cs](https://pan.baidu.com/s/1bGJxNGu5P9KB8czCK1NRtw)  mcyz\n- [[AspNet组件]AspNetCoreComponent](https://pan.baidu.com/s/1q6KEgLY08pdht6IioVekVQ) z84o\n- [[Http请求帮助类]HttpRequestHelper](https://pan.baidu.com/s/15sf7KuMvN0NU_Dsx0frtiQ) 7mvr\n- [ET心跳组件2.0](https://pan.baidu.com/s/1oR8f9fSE91bsfmyPCjCTZg) 8p0b\n  - [这篇是初见早期写的心跳文章](http://www.tinkingli.com/?p=111) 不会心跳的可以看下原理\n\n\n\n# ET学习笔记/博客/公众号\n\n- [ET Mac环境运行和iOS打包指南.pdf](https://pan.baidu.com/s/1LyDaeA3l3skySb3ECu3VvA ) 9bzj\n- [Tinkingli博客教程](http://www.tinkingli.com/?cat=8)\n- [ECS概要--ET游戏框架详解](https://mp.weixin.qq.com/s/tDgqE_Ah8PWfnAGfi_R-aQ)  by 122304518\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n- [咲夜詩的博客](https://acgmart.com/unity/)\n- [群内分享的一些ET笔记](https://pan.baidu.com/s/1KqtGWVbFBRtQ_RJZTMYFww) ho3e\n- [ET5.0学习思维导图](https://pan.baidu.com/s/1I1jBThJ0uOC-9f4LHHebBA) 159n  by 小豆子\n- [Atheos的笔记](https://www.processon.com/view/link/5cb935fae4b0bab9095ebbd0#map)\n\n# 相关技术的教学文章\n\n## MongoDB\n- [官方Driver教程](https://mongodb.github.io/mongo-csharp-driver/2.7/getting_started/)\n- [官方API文档](http://api.mongodb.com/csharp/current/html/R_Project_CSharpDriverDocs.htm)\n- [菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [Working with MongoDB in .NET (Part 1): Driver Basics & Inserting Documents](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz)\n- [Working with MongoDB in .NET (Part 2): Retrieving Documents with Filter Clause](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-2-retrieving-mrlbeanm5)\n- [Working with MongoDB in .NET (Part 3): Skip, Sort, Limit, & Projections](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka)\n\n\n## ILRuntime\n\n- [官方主页](https://ourpalm.github.io/ILRuntime/public/v1/guide/index.html)\n- [Github-Demo](https://github.com/Ourpalm/ILRuntimeU3D/)\n- QQ群:512079820\n- [ILRuntime技术相关的总结](https://pan.baidu.com/s/1Re-mM-9KEoO3D7VXePdyIg) vz3q\n- [群内讨论/ILRuntime剪裁相关问题](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=195&extra=page%3D1)\n\n\n## FGUI\n\n- [官方主页](http://www.fairygui.com/guide/index.html)\n- [官方教程](http://www.sikiedu.com/course/139)\n- QQ群:614444599\n- [ET+FGUI+BD](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n","tags":["ET"]},{"title":"test","url":"/2019/07/04/test/","content":"# Test!!!!!!!!!!\n\n\n```csharp\nusing System;\nusing MongoDB.Driver;\n\nnamespace ETModel\n{\n\t[ObjectSystem]\n\tpublic class DBQueryTaskSystem : AwakeSystem<DBQueryTask, string, ETTaskCompletionSource<ComponentWithId>>\n\t{\n\t\tpublic override void Awake(DBQueryTask self, string collectionName, ETTaskCompletionSource<ComponentWithId> tcs)\n\t\t{\n\t\t\tself.CollectionName = collectionName;\n\t\t\tself.Tcs = tcs;\n\t\t}\n\t}\n\n\tpublic sealed class DBQueryTask : DBTask\n\t{\n\t\tpublic string CollectionName { get; set; }\n\n\t\tpublic ETTaskCompletionSource<ComponentWithId> Tcs { get; set; }\n\n\t\tpublic override async ETTask Run()\n\t\t{\n\t\t\tDBComponent dbComponent = Game.Scene.GetComponent<DBComponent>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// 执行查询数据库任务\n\t\t\t\tIAsyncCursor<ComponentWithId> cursor = await dbComponent.GetCollection(this.CollectionName).FindAsync((s) => s.Id == this.Id);\n\t\t\t\tComponentWithId component = await cursor.FirstOrDefaultAsync();\n\t\t\t\tthis.Tcs.SetResult(component);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthis.Tcs.SetException(new Exception($\"查询数据库异常! {CollectionName} {Id}\", e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","tags":["Test"]}]