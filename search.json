[{"title":"一CLR基础3","url":"/2019/07/07/一CLR基础3/","content":"# .Net Framework部署目标\n\n## 什么是DLL Hell?\n\n> Windows早期并没有很严谨的DLL版本管理机制，以致经常发生安装了某软件后，因为其覆盖了系统上原有的同一个DLL文件，而导致原有可运行的程序无法运行。但还原回原有的DLL文件之后，所新安装的软件就无法运行。若影响到系统所使用的重要DLL时也可能让系统容易死机甚至无法正常启动。\n\n[別再掉進DLL地獄的陷阱裡(DLL Hell)~.NET解決之道 資策會數位教育研究所講師 王芳芳](https://web.archive.org/web/20080208173943/http://www.iiiedu.org.tw/knowledge/knowledge20021130_1.htm)\n\n总结:\n\n1. The .NET Framework NET Assembly 自描述与版本管理功能让 zero-impact(零影响) 的部署安装成为可能，同時也终结了DLL Hell 。\n\n2. Application-Private Assemblies (or 被隔离的assembly) 只能被一个应用程式所使用- 它不会被其他的应用程式所影响。 隔离的assembly 让程式开发者对应用程式有着绝对的控制权，开发好的Application-Private Assemblies只要部署在和应用程式同一目录即可。\n\n3. 透过Side by side execution(并行执行)的技术，应用程式只要安装成功之后，就不用担心DLL更新版本，或规格的改变， 它允许一个assembly 的多个版本在一个机器上同时被安装并执行， 而且每一个应用程式都可以要求和不同的Assembly 版本系结。\n\n4. The .NET Framework 纪录应用程式版本资讯，并在执行应用程式时使用此资讯载入应用程式所需依赖的正确版本的Assemblies。\n\n# 将类型生成到模块中\n\n```csharp\npublic sealed class Program{\n        public static void Main()\n        {\n          // 由于引用了Console类的WriteLine方法\n          // 要顺利通过编译，必须向C#编译器提供一组程序集\n          // 使他能解析对外部类型的引用\n          System.Console.WriteLine(\"Hi\");\n        }\n}\n```\n>System.Console是Microsoft实现好的类型，用于实现这个类型的各个方法的IL代码存储在MSCorLib.dll\n\n> 此处”r“意为`reference`\n\n因此需要添加`r:MSCorLib.dll` 开关命令，完整编译命令行应如下：\n`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs `\n\n但由于其他命令均为默认命令，本例中的编译命令行可以简化为\n`csc.exe Program.cs `\n\n如果不想C#编译器自动引用`MSCorLib.dll`程序集，可以使用`/nostdlib`开关。\n\n## 生成三种应用程序的编译器开关\n\n> 此处”t“意为`target`\n\n- 生成控制台用户界面(Console User Interface, CUI)应用程序使用`/t:exe`开关；\n- 生成图形用户界面(Graphical User Interface, GUI)应用程序使用`/t:winexe`开关；\n- 生成Windows Store应用程序使用`/t:appcontainerexe`开关；\n\n## 集合开关命令的文件:响应文件\n\n编译时可以指定包含编译器设置命令的响应文件，例如：假定响应文件`MyProject.rsp`包含以下文本\n\n```csharp\n// MyProject.rsp\n/out:MyProject.exe\n/target:winexe\n```\n为了让CSC.exe使用该响应文件，可以像下面这样调用它\n\n`csc.exe @MyProject.rsp CodeFile1.cs CodeFile2.cs`\n\nC#支持多个响应文件，其先后顺序服从就近原则，优先级为`控制台命令>本地>全局`。\n\n.NET Framework具有一个默认的全局CSC.rsp文件，在运行CSC.exe进行编译时会自动调用，全局CSC.rsp文件中列出了所有的程序集，就不必使用C#的/reference开关显式引用这些程序集，这会对编译速度有一些影响，但不会影响最终的程序集文件，以及执行性能，开发者也可以自己为全局CSC.rsp添加命令开关，但这可能为在其他机器上重现编译过程带来麻烦。\n\n另外，指定/noconfig开关后，编译器将忽略本地和全局CSC.rsp文件。\n\n# 什么是元数据? 元数据概述\n\n> 元数据（英语：metadata），又称诠释数据、中介数据、中继数据、后设数据等，为描述其他数据信息的数据.\n\n>元数据概述：元数据是一种二进制信息，用以对存储在公共语言运行库可移植可执行文件 (PE) 文件或存储在内存中的程序进行描述。将您的代码编译为 PE 文件时，便会将元数据插入到该文件的一部分中，而将代码转换为 Microsoft 中间语言 (MSIL) 并将其插入到该文件的另一部分中。在模块或程序集中定义和引用的每个类型和成员都将在元数据中进行说明。当执行代码时，运行库将元数据加载到内存中，并引用它来发现有关代码的类、成员、继承等信息。\n\n首先回顾一下`托管模块(Managed Module)`。`托管模块`是一个需要`CLR`才能执行的`标准WindowsPE(Portable executable，简称PE)文件`。\n\n- `PE32(+)头` :PE 文件主要部分的索引和入口点的地址。运行库使用该信息确定该文件为 PE 文件并确定当将程序加载到内存时执行从何处开始。\n- `CLR表头`:是一个小的信息块，是托管模块特有的，包含生成时所面向的版本号、一些标志、和一个MethodDef token用来指定模块的入口方法，最后，CLR头还包含模块内部的一些元数据表的大小的偏移量\n- `中间语言(IL)代码` : 编译器在编译源代码时产生的指令。CLR在运行时会将IL代码编译成本地CPU指令\n- `元数据`: 元数据表和堆,是由三种表构成的二进制数据块，这三种表分别为`定义表(definiton talbe)`、`引用表(reference table)`和`清单表(mainfest table)`。运行库使用该部分记录您的代码中每个类型和成员的信息。本部分还包括自定义属性和安全性信息。\n\n## 元数据描述的信息\n\n元数据以非特定语言的方式描述在代码中定义的每一类型和成员。元数据存储以下信息：\n\n- 程序集的说明\n  - 标识（名称、版本、区域性、公钥）。\n  - 导出的类型\n  - 该程序集所依赖的其他程序集。\n  - 运行所需的安全权限。\n- 类型的说明\n  - 名称、可见性、基类和实现的接口。\n  - 成员（方法、字段、属性、事件、嵌套的类型）。\n- 属性\n  - 修饰类型和成员的其他说明性元素。\n\n### 定义表(definiton talbe)\n\n**代码中定义的任何东西都将在上表中的某个表创建一个记录项。**\n\n| `定义表`名称 | 说明 |\n| :------| ------ |\n| ModuleDef\t| 包含`模块`文件名,扩展名(不含路径),编辑器创建的GUID 的 记录项.|\n| TypeDef\t| 每个`类型`都在这个表中有一个记录项,包含类型的名称,基类,标志(public/private等),一些索引.这些索引指向MethodDef中属于该类型的方法、FieldDef表中该类的字段、PropertyDef表中该类型的属性以及EventDef表中该类型的时间.|\n| MetodDef  | 每个`方法`(包括入口方法)都在这个表中有一个记录项, 包含方法的名称,标志,签名,以及方法的IL代码在模块中的偏移量(位置),每个记录项还引用了ParamDef表中的一个记录项，后者包括与方法参数有关的更多信息。 |\n|FieldDef   |\t模块定义的每一个`字段`在这个表中都有一个记录项。每个记录项都包括标志、类型和名称。   |\n| ParamDef  |  关于`参数`的记录项 |\n| PropertyDef\t  |  模块定义的每个`属性`在这个表中都有一个记录项。每个记录项都包含标志、类型和名称。 |\n|EventDef\t   | 模块定义的每个事件在这个表中都有一个记录项。每个记录项都包含标志和名称。  |\n\n### 引用表(reference table)\n| `引用表`名称 | 说明 |\n| :------| ------ |\n| AssemblyRef  | `引用的每个程序集`的记录项,每个记录项都包含绑定(bind)该程序集所需的信息：程序集名称(不包含路径和扩展名)、版本号、语言文化及公钥Token(根据发布者的公钥生成一个小的哈希值，标识了所引用程序集的发布者)。  |\n| ModuleRef  | 实现该模块所引用的类型的`每个PE模块`在这个表中都有一个记录项。每个记录项都包含模块的文件名和扩展名(不含路径),如果存在别的模块实现了你需要的类型，这个表的作用便是同哪些类型建立绑定关系  |\n| TypeRef  | 模块引用的每一个`引用类型`.....  |\n| MemberRef   | 模块引用的`每个成员`（字段和方法，以及属性方法和事件方法）在这个表中都有一个记录项。每个记录项都包含成员的名称和签名，并指向对成员进行定义的那个类型的TypeRef记录项  |\n\n### 清单表(mainfest table)\n\n| `引用表`名称 | 说明 |\n| :------| ------ |\n|AssemblyDef   | 如果模块标识的是程序集，这个元数据表就包含`单一记录项来列出程序集名称`(不包含路径和扩展名)、版本(major，minor，build和revision)、语言文化、标志、哈希算法以及发布者公钥(可为null)  |\n|FileDef   | 每个`PE文件和资源文件`在这个表中都有一个记录项(清单本身所在的文件除外，该文件在AssemblyDef表的单一记录项中列出) 在每个记录项中，都包含文件名和扩展名(不含路径)、哈希值和一些标志。如果程序集只包含他的主模块，不包含其他非主模块和资源文件。FileDef将无记录 |\n|ManifestResourceDef   | 每个`资源`在这个表中都有一个记录项 .记录项中包含资源名称、一些标志(如果程序集外部可见，就为public，否则为private)以及FileDef表的一个索引(指出资源或流包含在哪个文件中)。如果资源不是独立文件(比如.jpg或者.gif文件)，那么资源就是包含在PE文件中的流。对于嵌入资源，记录项还包含一个偏移量，指出资源流在PE文件中的起始位置|\n|ExportedTypesDef   | 从程序集的所有PE模块中`导出的每个public类型`在这个表中都有一个记录项。  |\n\n\n# 将模块合并成程序集\n\n## Microsoft为何考虑要引入程序集这一概念?\n\n这是因为使用程序集，`可重用类型`的`逻辑表示`和`物理表示`就可以分开。\n- 物理上，可以将常用的类型放在一个文件中，不常用的程序放在另一些文件中，只在使用时加载，\n- 在逻辑上，这些程序仍然被组织于同一程序集中，不需要编写额外的代码显式进行链接。\n\n## 程序集(Assembly)是什么组成的?\n\n程序集(Assembly)是一个或多个类型定义文件及资源文件的集合。在程序集的所有文件中，有一个文件容纳了`清单(Manifest)`，如上一节一开始所述，`清单`也是`元数据`的组成部分之一，表中主要包含作为程序集组成部分的那些文件的名称。此外还描述程序集的版本、语言文化、发布者、公开导出类型以及构成程序集的所有文件。\n\n`CLR`操作的是程序集，对于程序集，有以下几点重要特性：\n- 程序集定义了可重用的类型。\n- 程序集用一个版本号标记。\n- 程序集可以关联安全信息。\n\n**程序集是进行重用、版本控制和应用安全性设置的基本单元。**\n\n对于一个程序集来说，除了包含清单元数据表的文件，程序集中的其他文件独立时不具备以上特点.\n\n## 编译生成含有清单元数据表的PE文件\n\nC#编译器都会生成程序集： `/t: exe`, `/t: winexe`, `/t: appcontainerexe`, `/t: library` 或者`/t: winmdobj`。这些开关会指示编译器生成含有清单元数据表的PE文件。\n\nC#编译器还支持`/t: module`开关。这个开关指示编译器生成一个不包含清单元数据表的PE文件。这样生成的肯定是一个DLL PE文件。CLR要想访问其中的任何类型，必须先将该文件添加到一个程序集中。使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\n\n例如:\n将不常用类型编译到一个单独模块，这样一来如果程序集的用户永远不使用不常用类型，就不需要部署这个模块。\n```csharp\n// 使用`/t: module`开关时，C#编译器默认为输出文件使用`.netmodule`扩展名。\ncsc /t:module 不常用类型.cs\n```\n\n`不常用类型.netmodule`这是一个标准的DLL PE文件，但是CLR不能但单独加载它。\n\n将输出的文件名改为MultiFileLibrary.dll, 目标是生成库文件,添加`不常用类型`的模块, 编译`FUI.cs`\n```csharp\n// 指定了/t: library开关，所以生成的是含有清单元数据表的DLL PE文件\n// /addmodule:不常用类型.netmodule 开关告诉编译器不`常用类型.netmodule`文件是程序集的一部分，从而将其添加到FileDef清单元数据表，并将`不常用类型.netmodule`的公开导出类型添加到ExportedTypesDef清单源数据表。\ncsc /out:NultiFileLibray.dll /t:library /addmodule:不常用类型.netmodule FUT.cs\n```\n\n## 使用程序集链接器(AL.exe)生成程序集\n\n除了使用C#编译器，还可以使用”程序集链接器“实用程序AL.exe来创建程序集。如果程序集要求包含由不同编译器生成的模块(而这些编译器不支持与C#编译器的/addmodule开关等家的几种机制)，程序集连接器就显得相当有用。\n\n**AL.exe能生成EXE文件，或者生成只包含清单的DLL PE文件。程序集链接器不能将多个文件合并成一个文件。**\n\n```csharp\ncsc /t:module RUT.cs\ncsc /t:module FUT.cs\nal /out:MultiFileLibrary.dll /t:library FUT.netmodule RUT.netmodule\n```\n## 为程序集添加资源文件\n\n- 用AL.exe创建程序集时，可用`/enbed [resource]`开关将文件作为资源添加到程序集。该开关获取任意文件，并将文件内容嵌入最终的PE文件。也可用`/Link [resource]`开关获取资源文件，但只指出资源包含在程序集的哪个文件，并不嵌入到PE文件中；该资源文件独立，并必须与程序集文件一同被打包部署\n- C#编译器用`/resource`开关将资源嵌入PE文件，用`/linkresource`开关添加记录项引用资源文件。以上开关均会修改ManifestResourceDef清单表添加记录项，外部引用的开关还会修改FileDef表以指出资源包文件。\n\n\n\n# 程序集版本资源信息\n\n> Visual Studio新建C#项目时会在一个Properties文件夹中自动创建AssemblyInfo.cs文件。可直接打开该文件并修改自己的程序集特有信息。\n\n在应用程序代码中调用`System.Diagnostics.FileVersionInfo的`静态方法`GetVersionInfo`并传递程序集路径作为参数可以获取并检查这些信息。\n\n![](一CLR基础3/版本资源字段和对应的特性.png)\n\n```csharp\n// 有关程序集的一般信息由以下\n// 控制。更改这些特性值可修改\n// 与程序集关联的信息。\n[assembly: AssemblyTitle(\"LentilToolbox\")]\n[assembly: AssemblyDescription(\"Licensed under the MIT license\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"\")]\n[assembly: AssemblyProduct(\"LentilToolbox\")]\n[assembly: AssemblyCopyright(\"Copyright ©  2016 Lentil Sun\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n//将 ComVisible 设置为 false 将使此程序集中的类型\n//对 COM 组件不可见。  如果需要从 COM 访问此程序集中的类型，\n//请将此类型的 ComVisible 特性设置为 true。\n[assembly: ComVisible(false)]\n\n// 如果此项目向 COM 公开，则下列 GUID 用于类型库的 ID\n[assembly: Guid(\"ac315d57-80ca-4e7a-b55c-064b94547552\")]\n\n// 程序集的版本信息由下列四个值组成:\n//\n//      主版本\n//      次版本\n//      生成号\n//      修订号\n//\n//可以指定所有这些值，也可以使用“生成号”和“修订号”的默认值，\n// 方法是按如下所示使用“*”: :\n// [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"1.1.0.2\")]\n[assembly: AssemblyFileVersion(\"1.1.0.2\")]\n\n```\n\n| - | \tmajor（主版本号）|\tminor（次版本号）|\tbuild（内部版本号）|\trevision（修订号）|\n| :-----:| :-----: | :-----: | :-----: | :-----: |\n|示例  | 2  | 5  | 719  | 2  |\n\n\n注意：程序集有三个版本号，每个版本号都有不同的用途：\n- `AssemblyFileVersion`：这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号的作用是说明**该程序集的版本**。\n- `AssemblyInformationalVersion`：同上，这个版本号存储在Win32版本资源中供使用者参考，CLR既不检查，也不关心，这个版本号作用是说明**使用该程序集的产品的版本**。\n- `AssemblyVersion`：存储在AssemblyDef清单元数据表中，CLR在绑定到强命名程序集时会用到它。这个版本号很重要，它**唯一性地标识了程序集。**\n\n\n\n\n# 语言文化\n\n![](一CLR基础3/语言文化标记.png)\n\n未指定具体语言文化的程序集成为`语言文化中性(Culture neutral)`。\n\n```csharp\n// 将程序集的语言文化设为瑞士德语\n[assembly: AssemblyCulture(\"de-CH\")]\n```\n\n# CLR探测程序集文件会扫描的目录\n","tags":["CLR读书笔记"]},{"title":"一CLR基础2","url":"/2019/07/06/一CLR基础2/","content":"> 温故而知新\n\n# CLR功能\n\n## JIT(just-in-time 运行时编译技术)\n\n>通常，程序有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，而解释执行的则是一句一句边运行边翻译。\n\n>`即时编译器`则混合了这二者，一句一句编译源代码，但是会将翻译过的代码缓存起来以降低性能损耗。相对于静态编译代码，即时编译的代码可以处理延迟绑定并增强安全性。\n\n>即时编译器有两种类型，一是字节码翻译，二是动态编译翻译。\n\n为了执行方法，首先必须将方法的IL转换成本机(native)CPU指令。这是CLR的JIT编译器的职责。\n\n### 流程讲解\n\n![](一CLR基础2/方法的首次调用.png)\n\n1. 在Main方法执行之前,CLR会检测出Main的`代码引用`的所有类型.\n  - CLR分配一个`内部数据结构`来管理对引用类型的访问.\n  - 图中,Main方法引用了Console类型,CLR分配了一个`内部结构`.\n  - Console类型定义的每个方法都在`内部结构`中存在一个`记录项 entry`.\n  - 根据这个记录项可以找到方法的实现.\n  - 对这个`内部结构`进行初始化,每个方法都指向包含在CLR内部的一个`未编档函数`,称之为`JITCompiler`.\n2. 进入Main方法,首次调用`WriteLine方法`时, `JITCompiler函数`被调用.\n3. `JITCompiler`会在定义该类型的程序集的元数据中查找被调用方法的`IL代码`.\n4. 然后`JITCompiler`验证`IL代码`,将`WriteLine方法`的`IL代码`编译成`本机CPU指令`.\n5. `本机CPU指令`保存到动态分配的内存块中.`JITCompiler`将在CLR为类型创建的`内部数据结构`中,修改引用.\n6. 指向到刚才动态分配的内存块地址. 最后`JITCompiler`跳转到内存块中的代码(`WriteLine方法`的具体实现).\n7. 返回到Main中的代码.\n\n![](一CLR基础2/方法的第二次调用.png)\n8. 第二次调用`WriteLine方法`,由于已经进行了验证和编译,会直接跳转到已经编译好的`本机CPU指令`代码块中执行.\n\n方法仅在首次调用时才会有一些性能损失,之后调用全是以本机代码的形式全速运行.\n\n## JIT 编译技术特点\n\n1. JIT编译器将本机CPU指令存储到动态内存中.意味着一旦应用程序终止,编译好的代码也会被丢弃.\n2. JIT编译器会对`本机代码`进行优化.类似于C++编译器后端所做的事情. 可能花较多的时间生成优化代码.\n> 在Visual Studio中新建C#项目时，”调试“(Debug)配置指定的是/optimize-/debug:full，而”发布“(release)配置指定的是/optimize+/debug:pdbonly。\n\n3. JIT能够针对本机CPU为IL代码生成指令，以利用本机指定CPU的任何特殊指令进行编译。相反，非托管应用程序通常是针对具有最小功能集合的CPU编译的。\n\nJIT编译器能够判断一个特定的测试在它运行的机器上是否总是失败，例如，假定有一个方法包含以下代码\n```csharp\n// 如果主机只有一个CPU，JIT编译器不会为此代码生成任何CPU指令。\nif(numberofCPUs>1){\n    ...//Do something\n}\n```\n\n## 将IL代码编译成本机代码的验证过程\n\n将IL代码编译成本机代码的过程中,CLR会执行验证过程,根据元数据检查类型,返回值,返回语句,参数是否正确等等.\n\n\n## NGen.exe生成的本机代码与JIT生成的本机代码对比\n\n1. NGen生成的代码**不会**像JIT编译器生成的代码进行高度优化.较差的执行时性能.\n2. CLR加载程序集时,会检查是否存在一个对应的,由NGen生产的本机文件.\n3. NGen.exe生成的本机文件没有知识产权保护.\n4. NGen生成的文件可能失去同步.版本不匹配,系统升级过等,就无法使用.\n\n\n# 基类库支持功能\n\n> .Net Framework 包含 Framework类库(Framework Class Library,FCL).\n\n1. FCL是一组DLL程序集的统称.\n\n![](一CLR基础2/FLC部分常规命名空间.png)\n","tags":["CLR读书笔记"]},{"title":"一CLR基础","url":"/2019/07/05/一CLR基础/","content":"\n> 对真正的力量一无所知。\n\n# 程序执行基础概念\n- 代码\n- 翻译器\n  - 编译器\n  - 优化编译器\n- 中间语言\n- 执行\n  - 运行时系统\n    - 运行期\n  - 可执行文件\n  - 解释器\n  - 虚拟机\n\n---\n- 代码类型\n  - 源代码\n  - 目标代码\n  - 字节码\n  - 机器代码\n  - 微程序\n\n\n# CLR和 .Net Framework的关系\n\n>.NET框架 （.NET Framework） 是由微软开发，一个致力于敏捷软件开发（Agile software development）、快速应用开发（Rapid application development）、平台无关性和网络透明化的软件开发平台。.NET框架是以一种采用系统虚拟机运行的编程平台，以通用语言运行库（Common Language Runtime）为基础，支持多种语言（C#、VB.NET、C++、Python等）的开发。\n\n由此可见，`.Net Framework`是一个支持多种开发语言的开发平台，而这种多语言支持的特性又要以CLR为基础。CLR是一个.Net产品的运行环境。`公共语言运行时(Common Language Runtime)`和 `.Net Framework Library(FCL)`是`.Net Framework`的两个主要组成部分。\n\n\n# 什么是CLR?\n\n> 通用语言运行平台（Common Language Runtime，简称CLR）是微软为他们的.NET的虚拟机所选用的名称。它是微软对通用语言架构（CLI）的实现版本，它定义了一个代码运行的环境。CLR运行一种称为通用中间语言的字节码，这个是微软的通用中间语言实现版本。\n\n1. `CLR`是一个类似`JVM`的虚拟机, 为.NET的程序提供运行的环境.\n2. `CLR`中运行的是一种字节码形态的` Microsoft Intermediate Language，简称MSIL \"微软中间语言\"`.\n3. 在.Net开发平台下，所有语言（C#、VB.NET、J#、C++/CLI）都会被编译为`MSIL`\n\n## CLR做了什么?\n\n1. 将`IL`代码在`运行时`编译成`本机代码Native Code`.(`JIT(just-in-time 运行时编译技术)`)\n> 本机代码Native Code,是面向特定CPU架构(x86,x64,ARM)的代码\n\n![](一CLR基础/1.png)\n\n## CLR有哪些功能?\n\n- 基类库支持 Base Class Library Support\n- 内存管理 Memory Management\n- 线程管理 Thread Management\n- 垃圾回收 Garbage Collection\n- 安全性 Security\n- 类型检查 Type Checker\n- 异常管理 Exception Manager\n- 调试管理 Debug Engine\n- 中间码(MSIL)到机器代码(Native)编译 (即时编译 (JIT just-in-time))\n- 类别装载 Class Loader\n\n\n# CIL是什么?如何生成?\n\n>字节码现在已经官方地成为了CIL (通用中间语言（Common Intermediate Language，简称CIL)\n\n1. 在编译.NET编程语言时，源代码被翻译成`CIL`,再由`CLR`负责运行\n2. `IL代码`有时又称为`托管代码(managed code)`.\n3. `IL代码`只是`面向CLR的编译器`生成的其中一部分.\n\n## IL代码\n\n1. `IL`是与CPU无关的面向对象的机器语言.\n\n## 非托管代码\n\n1. C++编译器默认生成包含`非托管代码`的EXE/DLL模块.\n2. 并且在运行时操纵非托管数据(`native 内存`).\n3. 不需要CLR就能运行.\n4. 只有C++编译器允许开发人员同时写`托管代码`和`非托管代码`,并生成到同一模块中.\n\n### 非托管代码和托管代码的互操作性\n\n- 托管代码能调用DLL中的非托管函数：托管代码通过`P/invoke机制`调用DLL中的函数\n- 托管代码可以使用现有的COM组件：详情可参考 .NET Framework SDK提供的TlbImp.exe\n- 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。详情可以参考 .NET Framework SDK提供的TlbExp.exe和RegAsm.exe工具。\n\n\n# 面向CLR的编译器生成了什么?\n\n> 微软已经为多种语言开发了基于CLR的编译器，这些语言包括：C++/CLI、C#、Visual Basic、F#、Iron Python、 Iron Ruby和IL。\n\n1. 不同语言的`编译器(Compiler)`就相当于一个这种语言的代码审查者(Checker),所做的工作就是检查源码语法是否正确，然后将源码编译成`CLR`所需要的`中间语言(IL)`.\n2. `C#语言编译器`编译C#源码文件之后生成`托管模块`.\n\n![](一CLR基础/将源代码编译成托管模块.png)\n\n## C#编译器做的工作\n\n1. C#编译器(CSC.exe)默认将生成的**托管模块转换成程序集**,也就是生成的是**含有清单的托管模块**.\n2. 生成的是PE32(+)文件.\n3. 这个PE32(+)文件包含一个名为`清单(manifest)`的数据块. `清单`也是`元数据表`的集合.\n\n![](一CLR基础/将托管模块合并成程序集.png)\n\n\n# 托管模块是什么?由哪些组成?\n\n1. 无论是什么编译器，最后都是生成`托管模块`。\n2. `托管模块`是标准的32位的可移植执行体（PE32）文件，或者是64位的（PE32+）\n3. 需要`CLR`才能运行。\n4. 其中托管模块中还包含完整的`元数据`.\n\n![](一CLR基础/托管模块的各个部分.png)\n- `CLR头`：包含使这个模块成为托管模块的信息。\n- `IL中间语言代码`：编译器编译源码的时候生成的代码。运行时，`CLR`将`IL`编译成`本机CPU指令`\n- `元数据`：面向CLR的每个编译器要在每个托管模块中生成完整的元数据。元数据是一个数据表的集合。一些数据描述了模块中定义了什么，另一些描述了模块中引用了什么。由于编译器同时生成元数据和代码，把他们绑在一起，并嵌入最终生成的托管模块。所以元数据和他描述的代码不会失去同步。\n-\n\n## 可移植执行体PE文件的结构\n\n![](一CLR基础/PE文件架构.png)\n\n# 元数据是什么?\n\n1. `元数据`简单的说是一个数据表的集合.\n2. 主要包含两种表:\n  - 描述源代码中定义的类型和成员\n  - 描述源代码`引用的`类型和成员\n3. 元数据有多种用途\n  - 避免了编译时对原生C/C++数据头和库文件的需求. 因为IL代码中已经包含了全部信息.编译器直接读取元数据.\n  - `智能感知IntelliSense`技术解析元数据,提示帮助写代码.\n  - CLR验证代码使用元数据确保只执行`类型安全`的操作.\n  - `元数据`允许将对象的字段序列化到内存块,发到另一台机器反序列化,重建对象状态.\n  - `元数据`允许垃圾回收器跟踪对象的生存期.\n\n\n\n# CTS通用类型系统是什么?\n\n> 通用类型系统 (Common Type System) 定义了运行期引擎如果使用程序中的数据类型，以及如何配置数据在存储器中的一种标准，依照此种标准所撰写的编程语言，都可以在同一个运行期引擎中使用，因此它是跨语言支持的重要部分，亦即匹配 CTS 规范的编程语言所撰写出的程序，都可以在 CLR 中使用。\n\n> CTS与CLI规格都是由微软所发展，当前已标准化为 ECMA 335 标准：“Common Language Infrastructure (CLI) Partitions I to VI.”，并且由 Microsoft 在 .NET Framework 中完全的实现。\n\n**由于类型是CLR的根本，微软专门为如何定义、使用和管理类型定义了一个正式的规范-- 通用类型系统(Common Type System)，即CTS。**\n\n事实上, 不根本不需要专门学习CTS规则本身,因为你选择的余元会采用你熟悉的方式公开它自己的`语言语法`与`类型规则`,通过编译来生成程序集时,会将语言特有的语法映射到IL---也就是CLR的`语言`.\n\n无论使用哪一种语言,类型的行为都完全一致,因为最终是由CLR的CTS来定义类型的行为.\n\n## 类型可见性和访问规则\n\n- `private`           : 成员只能由同一个类(class)类型中的其他成员访问.\n- `protected`         : 成员可以从派生类型访问,不管是不是在同一个程序集中.\n- `internal`          : 成员可以由同一个程序集中的任何代码访问.\n- `protected internal`: 可以由任何程序集中的派生类型访问.\n- `public`            : 成员可由任何程序集中的任何代码访问.\n\n\n\n# CLS通用语言规范是什么?\n\n > 定义了一个最小公共集，任何编译器只有支持这个功能集，生成的类型才能兼容其他符合CLS、面向CLR的语言生成的组件\n\n![](一CLR基础/CLS图示.png)\n\n在开发类型和方法的时候，如果希望它们对外“可见”，能够从符合 CLS 的任何一种编程语言中访问，就必须遵守由 CLS 定义的规则。注意， 假如代码只是从定义（这些代码的）程序集的内部访问，CLS 规则就不适用了。\n\n```csharp\nusing System\n\n//告诉编译器检查CLS相容性\n[assembly:CLSCompliant(true)]\n\nnamespace SomeLibrary\n{\n    //因为是public类，所以会显示警告\n    public sealed class SomeLibrarytype\n    {\n        //警告：SomeLibrary.SomeLibraryType.Abc()的返回类型不符合CLS\n        public UInt32 Abc(){return 0;}\n\n        //警告：仅大小写不同的标识符SomeLibrary.SomeLibraryType.abc()不符合CLS\n        public void abc(){ }\n\n        //不显示警告：该方法是私有的\n        private UInt32 ABC(){return 0;}\n    }\n}\n```\n- 第一个警告是因为Abc方法返回了无符号整数，一些语言是不能操作无符号整数值的\n- 第二个警告是因为该类型公开了两个public方法，这两个方法只是大小写和返回类型有别，VB和其他一些语言无法区分这两个方法。\n\n# 关于window32位和64位版本\n1. 如果程序集文件只包含`类型安全`的`托管代码`在32位和64位上都能运行.\n> 类型安全代码指访问被授权可以访问的内存位置.有的语言（尤其是C和C++）允许做一些非常“不正当”的事情。(直接访问内存的其他位置)\n\n2. 如果要使用`不安全的代码`, 需要用到`/playform`命令行开关.如果指定了,则只能在对应平台上使用.默认`anycpu`.\n3. 可执行文件执行时,Windows会检查文件头,64位系统会通过`WoW64(Windows on Windows64)`技术运行32位应用程序.\n\n![](一CLR基础/platform对生成的模块的影响.png)\n\n4. Windows启动托管应用程序的流程.\n\n![](一CLR基础/Windows运行EXE流程.png)\n\n5. 可在代码中查询\n  - `Environment.Is64BitOperatingSystem`属性,判断是否在64位系统上运行.\n  - `Environment.Is64BitProcess`属性,判断是否在64位地址空间中运行\n\n# 不安全的代码\n\nC#编译器默认生成的是安全代码.\n\nC#允许开发人员通过`unsafe`关键字标记包含不安全代码的方法.\n\n# 保护IL代码\n\n1. 混淆器\n2. 在非托管模块中实现想保密的算法, 利用CLR的互操作功能实现应用程序的托管和非托管部分之间的通讯.\n\n# 一些微软提供的实用工具\n- CSC.exe C#编译器:将多个托管模块和资源文件合并成程序集的工具.\n- AL.exe 程序集链接器:将一组文件合并到程序集中.\n- CLRVer.exe 列出机器上安装的所有CLR版本\n  - `-all` 或者指定 `目标进程ID` 列出正在允许的进程使用的CLR版本号.\n- DumpBin.exe 和 CorFlags.exe:可以用来检查编译器生成的托管模块所嵌入的信息.\n- ILAsm.exe IL汇编器\n- ILDasm.exe IL反汇编器\n>用IL反编译工具查看生成的IL代码。这里使用的是ILDasm.exe，当然，你也可以使用一些其他的工具，例如.Net Reflector、ILSpy等。\n\n- NGen.exe 本机代码生成器: 将程序集的所有IL代码编译成本机代码.并将本机代码保存到一个磁盘文件中.\n- PEVerify.exe 检查一个程序集的所有方法,并报告其中含有不安全代码的方法.\n- MPGO.exe 分析客户端应用程序启动需要哪些东西,会写入一个profile并嵌入程序集中.NGen能根据这个更好的优化生成本机映像.\n- TlbImp.exe 托管代码可以使用现有的COM组件.\n- TlbExp.exe和RegAsm.exe 非托管代码可以使用托管类型：可用C#创建ActiveX控件或Shell扩展。\n- FusLogVw.exe 帮助你了解CLR在运行时与程序集的绑定.\n","tags":["CLR读书笔记"]},{"title":"HelloWorld","url":"/2019/07/05/HelloWorld/","content":"\n\n![](https://portablehexo.bitmoe.cn/hexopp/hexop.png)\n\n>**本版本仅适用于Win环境**\n>本文关键字： **Hexo绿色版**，**Hexo便携版**，**Hexo配置**，**Hexo**，**U盘**\n\n[Hexo](https://hexo.io/)是一个快速、简洁且高效的博客框架，支持 GitHub Flavored Markdown 的所有功能；具有超快生成速度，让上百个页面在几秒内瞬间完成渲染；还拥有各式各样的插件等等。\n\n但是就像很多教程里面写的那样，搭建 Hexo 本地环境，需要安装 Node.js、Git 以及使用 npm 进行安装和配置。这对于毫无经验的新手来说，是一个很大的挑战。同时，由于这些环境的存在，导致如果需要更换计算机的时候，重新安装配置一个新的Hexo环境，又得花费一些功夫。\n\n所以呢，锵锵，我们整合了一个 Hexo 便携版，来简化本地环境的部署。\n\n#### **版本介绍**\n那么所谓的便携版到底是什么？便携版就是将 Hexo 本地环境所需要的各种依赖环境的整合到一起，做成的不需要安装的版本。\n\n本便携版（Release 1.0.0）所包含的软件如下：\n>- Git: 2.7.4\n>- Nodejs: 6.10.1\n>- Npm: 4.4.1\n>- Hexo: 3.2.2\n\n# 用到的主题和插件\n\n1. 兼容Markdown图片语法和Hexo图片语法插件:https://github.com/7ym0n/hexo-asset-image\n2. 主题:https://github.com/aircloud/hexo-theme-aircloud\n3. Tag-Cloud插件 https://github.com/MikeCoder/hexo-tag-cloud\n4. 代码高亮插件:https://github.com/ele828/hexo-prism-plugin\n","tags":["HEXO"]},{"title":"ET入门小指南 v19.7.4","url":"/2019/07/04/ET入门小指南/","content":"\n![](ET入门小指南/1.jpg)\n\n# 了解ET\n\n[[Github]](https://github.com/egametang/ET)\n[[ET论坛]](https://bbs.honorworkroom.com/forum.php)\n\nET是一个开源的游戏客户端（基于unity3d）服务端双端框架，服务端是使用C# .net core开发的分布式游戏服务端.\n\n[[具体介绍]](https://github.com/egametang/ET/blob/master/README.md)\n\n- [为什么使用C# .net core做服务端？](https://github.com/egametang/ET/blob/master/Book/1.2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8.net%20core.md)\n  - ET框架使用C#做服务端，现在C#是完全可以跨平台的，在linux上安装.netcore，即可，不需要修改任何代码，就能跑起来。性能方面，现在.netcore的性能非常强，比lua，python，js什么快的多了。做游戏服务端完全不在话下。\n- **为什么选择Unity作为客户端?**\n  - 当前Unity是最火的游戏引擎，C#服务端搭配Unity完全是天作之合，基本上找不到缺陷。 客户端可以不使用Unity3d,需要自己对接协议.\n- [为什么后端选MongoBson序列化库?](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n- [为什么选MongoDB数据库?](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=183&extra=page%3D1)\n- [为什么选择ProtoBuf?](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 基于google官方3.4.1版本的protobuf c#-runtime以及3.4.0版本的protoc修改而来，还增加了0gc功能。仍然是标准的pb协议\n  - [ET使用精简过的PB库](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n- **为什么选择ILRuntime热更?**\n  - 因为ios的限制，之前unity热更新一般使用lua，导致unity3d开发人员要写两种代码，麻烦的要死。之后幸好出了ILRuntime库，利用ILRuntime库，unity3d可以利用C#语言加载热更新dll进行热更新。ILRuntime一个缺陷就是开发时候不支持VS debug，这有点不爽。ET框架使用了一个预编译指令ILRuntime，可以无缝切换。平常开发的时候不使用ILRuntime，而是使用Assembly.Load加载热更新动态库，这样可以方便用VS单步调试。在发布的时候，定义预编译指令ILRuntime就可以无缝切换成使用ILRuntime加载热更新动态库。这样开发起来及其方便，再也不用使用狗屎lua了\n- [什么是组件式设计?](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n\n\n# 运行Demo前的准备事项\n\n1. IDE选择\n  - **VS**\n    - ET 5.0(master)\n      - 建议使用VS2019 ( 用2017就自己去官网下 .net core 2.2)\n    - ET 4.0分支使用vs2017（更新到最新版）,并且要勾选\n      - a. .net 桌面开发\n      - visual studio tools for unity\n      -  .net core 2.1\n  - **Rider**\n    - 安装 .net core 2.2\n  - other.....\n\n2. Unity版本选择\n  - ET4.0请使用unity2017.4版\n  - ET5.0(master)需要unity2018.4版\n  - [为什么是.4版本](https://www.bilibili.com/video/av49789692)\n  - 别问怎么破解.问就是个人免费版.\n\n\n3. 安装MongoDB数据库(Demo中注释了数据库组件,只为了运行demo,就随意)\n\n\n# 准备运行Demo\n\n- [运行指南](https://github.com/egametang/ET/blob/master/Book/1.1%E8%BF%90%E8%A1%8C%E6%8C%87%E5%8D%97.md)\n\n- [常见的错误解决方法](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=203&extra=page%3D1)\n\n\n\n\n## 测试状态同步Demo\n\n打包一个客户端,unity开一个客户端.就会出现2个小人.点击鼠标右键即可移动人物.看到效果.\n\n## 帧同步Demo\n\n在4.0分支.\n\n# 学习ET\n\n\n\n\n你可能需要如下知识储备:\n- C# 语言基础 ([你渴望力量吗?](https://pan.baidu.com/s/1mqaaVIxOVo02pg8aXaQKXg)s1fz )\n- 设计模式    ([你渴望知识吗?](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 数据结构    ([那就看完吧](https://pan.baidu.com/s/1P7O7KMNIDGTRTwBh1pz8Gg) wkur )\n- 反射\n- 特性\n- 异步/协程\n- 了解ECS\n- 了解actor模型\n- 网络层TCP/UDP/KCP/ENET\n- MongoDB数据库\n- MongoBson\n- Protobuf\n- 服务器分布式相关\n\n客户端\n- Unity基础\n- UGUI\n- AssetBundle流程\n- 热更ILRuntime\n\n其余\n- AstarPathfinding\n- Behavior Designer\n- FGUI\n- NLog\n\n>猫大语录:\n应该先去提高下c#基础跟编程基础，再来看ET，碰到问题自己想办法解决，谷歌，打log。你现在好比初中基础却来做大学题目一样，到处碰壁，碰到问题自己不研究指望别人给你找问题，这样编程技术是无法提高的.\n群里能力有高有低，问问题也没什么。但是我是希望群里提问题前能够经过自己一番摸索，经过自己思考，经过谷歌，经过调试log等等再问。很多问题经过自己摸索查找资料能够增长很多知识。其实程序开发就是在不断找bug，在找bug中提升自己。\n\n# ET框架设计大纲\n\n- 公共部分\n  - ET的特色\n  - 什么是ECS\n- async await 协程\n\t- 什么是异步? 单线程？多线程？\n      - [ET/Book/2.1CSharp的协程](https://github.com/egametang/ET/blob/master/Book/2.1CSharp%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n      - [ET/Book/2.2更好的协程](https://github.com/egametang/ET/blob/master/Book/2.2%E6%9B%B4%E5%A5%BD%E7%9A%84%E5%8D%8F%E7%A8%8B.md)\n\t- 为什么需要async await，await是多线程吗？\n    \t- [ET/Book/2.3单线程异步](https://github.com/egametang/ET/blob/master/Book/2.3%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5.md)\n\t- 更好的Task：ETTask\n    \t- [群内讨论/ETTask](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=204&extra=page%3D1)\n- [一切皆组件（Entity&Component）](https://github.com/egametang/ET/blob/master/Book/3.3%E4%B8%80%E5%88%87%E7%9A%86%E7%BB%84%E4%BB%B6.md)\n  - [事件机制EventSystem](https://github.com/egametang/ET/blob/master/Book/3.4%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6EventSystem.md)\n  - [强大的mongo bson](https://github.com/egametang/ET/blob/master/Book/3.2%E5%BC%BA%E5%A4%A7%E7%9A%84MongoBson%E5%BA%93.md)\n  - 设计一个双端网络库\n  - 协议格式的设计\n  - [protobuf](https://github.com/egametang/protobuf3-for-Unity-and-ILRuntime)\n  - 使用Kcp协议\n      - [kcp-bulild](https://github.com/egametang/kcp-bulild)\n  - 应用层循环缓冲区\n  - 消息打包解包\n  - 消息的分发处理\n  - 远程过程调用RPC\n  - 客户端无GC处理\n- 服务端\n\t- 服务端架构简介\n    \t- [服务器命名以及消息类的X2X代表意思](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=161&extra=page%3D1)\n\t- 组件式的服务器\n\t- [Actor模型](https://github.com/egametang/ET/blob/master/Book/5.4Actor%E6%A8%A1%E5%9E%8B.md)\n\t- [ActorLocation](https://github.com/egametang/ET/blob/master/Book/5.5Actor%20Location.md)\n\t- 设计一个计时器( TimerCompoent组件 )\n\t- 服务端热更\n    \t- [群内讨论/热更层和Model层/逻辑与数据相关](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=146&extra=page%3D1)\n\t- Config\n\t- [数值组件](https://github.com/egametang/ET/blob/master/Book/5.6%E6%95%B0%E5%80%BC%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1.md)\n    \t- [群内讨论/数值组件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=139&extra=page%3D1)\n\t- Repl\n    \t- [Nlog配置和Repl](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=151&extra=page%3D1)\n- 客户端\n\t- 客户端架构简介\n\t- 客户端资源管理\n\t- UI框架\n\t- 客户端热更 (ILRuntime)\n\t- 抛弃unity的协程，使用await\n\t- 组件可视化\n- Demo\n\t- demo的架构, 消息路径\n    \t- [Demo消息流转时序图](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=145&extra=page%3D2)\n\t- recast 3d寻路\n\n\n# ET的一些教学视频\n- [肉饼老师主讲](https://www.taikr.com/my/course/972) : ET3.0时期教程,可以学习如何分离客户端和服务器端,和一些开发思路\n- [初见主讲(B站)](https://www.bilibili.com/video/av33280463/?redirectFrom=h5) - [优酷](https://i.youku.com/i/UNTQ3MjU4MDEy?spm=a2h0j.11185381.module_basic_dayu_sub.DL~DT~A):ET4.0教程,工具使用及demo运行,ET入门教程\n- [ET在Mac上运行指南-L主讲](http://www.liuocean.com/index.php/2018/07/25/et-kuang-jiamac-duan-gong-ju-zhi-chi/)百度云视频链接失效，参考文章吧\n-  [ET框架学习日记 by SwickSu](https://www.bilibili.com/video/av50871743?from=search&seid=9593939068874626189)\n\n# 群内大佬的Github\n- [C# 实现的十字链表的AOI算法](https://github.com/qq362946/AOI) by 初见\n  - [群内讨论/十字链表+快慢针方式的AOI算法可用于双端](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=174&extra=page%3D1)\n- [在初见的AOI（2D）的基础改成3D AOI](https://github.com/yhr28/3D_AOI) by yhr28\n- [ET-RPG-DEMO(基于ET框架的RPG游戏DEMO)](https://github.com/AnotherEnd15/ET-RPG-DEMO)   by AE\n  - [一种完全组合式的技能系统的设计思路](https://blog.csdn.net/qq_32270109/article/details/88551196?tdsourcetag=s_pcqq_aiomsg)\n- [RVO2](https://github.com/AnotherEnd15/RVO2) by AE\n- [Box2DSharp(BOX2D物理引擎C#版)](https://github.com/Zonciu/Box2DSharp)  by 白纸无字Zonciu\n- [Bullet版本(.netCore封装)](https://gitee.com/fengssy/BulletSharpPInvoke?tdsourcetag=s_pcqq_aiomsg) by 风恒\n- [FGUI/双端行为树](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n  - [群内讨论/Behavior Designer全热更行为树插件](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=170&extra=page%3D1)\n- [NKGNMobaBasedOnET(基于ET框架的Moba游戏DEMO)](https://gitee.com/NKG_admin/MKGMobaBasedOnET) by 烟雨迷离半世殇\n- [ET斗地主Demo](https://github.com/Viagi/LandlordsCore)\n  - [斗地主架构图](https://pan.baidu.com/s/1wyv6ihefBjQmVynIUBumKA) o05k\n- [ET-MultiplyDemos小游戏集合](https://github.com/Acgmart/ET-MultiplyDemos) by 咲夜詩\n\n#群内大佬分享的一些工具/组件\n\n- [[Debug组件]DebuggerComponent.cs](https://pan.baidu.com/s/1bGJxNGu5P9KB8czCK1NRtw)  mcyz\n- [[AspNet组件]AspNetCoreComponent](https://pan.baidu.com/s/1q6KEgLY08pdht6IioVekVQ) z84o\n- [[Http请求帮助类]HttpRequestHelper](https://pan.baidu.com/s/15sf7KuMvN0NU_Dsx0frtiQ) 7mvr\n- [ET心跳组件2.0](https://pan.baidu.com/s/1oR8f9fSE91bsfmyPCjCTZg) 8p0b\n  - [这篇是初见早期写的心跳文章](http://www.tinkingli.com/?p=111) 不会心跳的可以看下原理\n\n\n\n# ET学习笔记/博客/公众号\n\n- [ET Mac环境运行和iOS打包指南.pdf](https://pan.baidu.com/s/1LyDaeA3l3skySb3ECu3VvA ) 9bzj\n- [Tinkingli博客教程](http://www.tinkingli.com/?cat=8)\n- [ECS概要--ET游戏框架详解](https://mp.weixin.qq.com/s/tDgqE_Ah8PWfnAGfi_R-aQ)  by 122304518\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n- [咲夜詩的博客](https://acgmart.com/unity/)\n- [群内分享的一些ET笔记](https://pan.baidu.com/s/1KqtGWVbFBRtQ_RJZTMYFww) ho3e\n\n\n\n# 相关技术的教学文章\n\n## MongoDB\n- [官方Driver教程](https://mongodb.github.io/mongo-csharp-driver/2.7/getting_started/)\n- [官方API文档](http://api.mongodb.com/csharp/current/html/R_Project_CSharpDriverDocs.htm)\n- [菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n- [Working with MongoDB in .NET (Part 1): Driver Basics & Inserting Documents](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-1-basics-g4frivcvz)\n- [Working with MongoDB in .NET (Part 2): Retrieving Documents with Filter Clause](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-2-retrieving-mrlbeanm5)\n- [Working with MongoDB in .NET (Part 3): Skip, Sort, Limit, & Projections](https://www.codementor.io/pmbanugo/working-with-mongodb-in-net-part-3-skip-sort-limit-and-projections-oqfwncyka)\n\n\n## ILRuntime\n\n- [官方主页](https://ourpalm.github.io/ILRuntime/public/v1/guide/index.html)\n- [Github-Demo](https://github.com/Ourpalm/ILRuntimeU3D/)\n- QQ群:512079820\n- [ILRuntime技术相关的总结](https://pan.baidu.com/s/1Re-mM-9KEoO3D7VXePdyIg) vz3q\n- [群内讨论/ILRuntime剪裁相关问题](https://bbs.honorworkroom.com/forum.php?mod=viewthread&tid=195&extra=page%3D1)\n\n\n## FGUI\n\n- [官方主页](http://www.fairygui.com/guide/index.html)\n- [官方教程](http://www.sikiedu.com/course/139)\n- QQ群:614444599\n- [ET+FGUI+BD](https://github.com/DukeChiang/DCET/tree/dukechiang_master) by DukeChiang\n- [烟雨迷离半世殇的博客](https://www.lfzxb.top/unity/et/)\n","tags":["ET"]},{"title":"test","url":"/2019/07/04/test/","content":"# Test!!!!!!!!!!\n\n\n```csharp\nusing System;\nusing MongoDB.Driver;\n\nnamespace ETModel\n{\n\t[ObjectSystem]\n\tpublic class DBQueryTaskSystem : AwakeSystem<DBQueryTask, string, ETTaskCompletionSource<ComponentWithId>>\n\t{\n\t\tpublic override void Awake(DBQueryTask self, string collectionName, ETTaskCompletionSource<ComponentWithId> tcs)\n\t\t{\n\t\t\tself.CollectionName = collectionName;\n\t\t\tself.Tcs = tcs;\n\t\t}\n\t}\n\n\tpublic sealed class DBQueryTask : DBTask\n\t{\n\t\tpublic string CollectionName { get; set; }\n\n\t\tpublic ETTaskCompletionSource<ComponentWithId> Tcs { get; set; }\n\n\t\tpublic override async ETTask Run()\n\t\t{\n\t\t\tDBComponent dbComponent = Game.Scene.GetComponent<DBComponent>();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// 执行查询数据库任务\n\t\t\t\tIAsyncCursor<ComponentWithId> cursor = await dbComponent.GetCollection(this.CollectionName).FindAsync((s) => s.Id == this.Id);\n\t\t\t\tComponentWithId component = await cursor.FirstOrDefaultAsync();\n\t\t\t\tthis.Tcs.SetResult(component);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tthis.Tcs.SetException(new Exception($\"查询数据库异常! {CollectionName} {Id}\", e));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n","tags":["Test"]}]