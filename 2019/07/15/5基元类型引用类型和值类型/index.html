<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        5基元类型引用类型和值类型 - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#编程语言的基元类型"><span class="toc-text">编程语言的基元类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是基元类型"><span class="toc-text">什么是基元类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基元类型对应的FCL类型"><span class="toc-text">基元类型对应的FCL类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于关键字和完整的系统类型名称"><span class="toc-text">关于关键字和完整的系统类型名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Int32-为什么能转-System-Int64"><span class="toc-text">System.Int32 为什么能转 System.Int64?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#转型"><span class="toc-text">转型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-编译器总是对转型结果进行截断"><span class="toc-text">C#编译器总是对转型结果进行截断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字面值"><span class="toc-text">字面值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checked-和-unchecked-基元类型操作"><span class="toc-text">checked 和 unchecked 基元类型操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#溢出处理"><span class="toc-text">溢出处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应对无效输入的建议"><span class="toc-text">应对无效输入的建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Decimal是非常特殊的类型"><span class="toc-text">System.Decimal是非常特殊的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Numerics-BigInteger类型"><span class="toc-text">System.Numerics.BigInteger类型</span></a></li></ol></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        5基元类型引用类型和值类型
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-07-15 17:05:52</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#CLR读书笔记" title="CLR读书笔记">CLR读书笔记</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="编程语言的基元类型"><a href="#编程语言的基元类型" class="headerlink" title="编程语言的基元类型"></a>编程语言的基元类型</h1><h2 id="什么是基元类型"><a href="#什么是基元类型" class="headerlink" title="什么是基元类型"></a>什么是基元类型</h2><p>编译器直接支持的数据类型称为<code>基元类型(primitive type)</code>.</p>
<p>基元类型直接映射到Framework类库FCL中存在的类型.例如C#中的<code>int</code>直接映射到的<code>System.Int32</code>类型.</p>
<blockquote>
<p>MSDN文档将primitive type翻译成”基元类型”,而不是容易混淆的”基本类型”.</p>
</blockquote>
<p>以下四行代码都能正确编译,并能生成完全相同的<code>IL代码</code>.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 最方便的语法</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 方便的语法</span>
System<span class="token punctuation">.</span>Int32 a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 不方便的语法</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 最不方便的语法</span>
System<span class="token punctuation">.</span>Int32 a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">System<span class="token punctuation">.</span>Int32</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 从另外一个角度可以认为C#编译器自动假定所有源代码都添加了一下using指令(取别名作用)</span>
<span class="token keyword">using</span> <span class="token keyword">sbyte</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>SByte<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">byte</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>Byte<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">short</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>Int16<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">ushort</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>UInt16<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">int</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>Int32<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">uint</span> <span class="token operator">=</span> System<span class="token punctuation">.</span>UInt32<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="基元类型对应的FCL类型"><a href="#基元类型对应的FCL类型" class="headerlink" title="基元类型对应的FCL类型"></a>基元类型对应的FCL类型</h2><p>是要是符合CLS公共语言规范的类型,其他语言都提供了类似的基元类型. 不符合的就不一定支持了.</p>
<p><img src="/2019/07/15/5基元类型引用类型和值类型/5-1.png" alt=""></p>
<h2 id="关于关键字和完整的系统类型名称"><a href="#关于关键字和完整的系统类型名称" class="headerlink" title="关于关键字和完整的系统类型名称"></a>关于关键字和完整的系统类型名称</h2><p>C#语言规范:”从风格上说,最好使用关键字,而不是使用完整的系统类型名称.”<br>作者认为: 更好的是使用FCL类型名称,完全不用基元类型名称.</p>
<p>事实上,作者希望编译器根本不提供<code>基元类型名称</code>, 而是强迫开发人员使用<code>FCL类型名称</code>.理由如下:</p>
<ol>
<li>有些程序员纠结用<code>string</code>还是<code>String</code> . 由于C#的<code>string</code>(这是关键字)直接映射到<code>System.String</code>类型(这是FCL库中的类型). 所以两者没有区别.</li>
</ol>
<blockquote>
<p>误区: 有些开发人员说32位系统上int代表32位整数,64位系统上int代表64位整数,这个说法是错误的.<br>因为c#的<code>int</code>始终映射到<code>System.Int32</code>类型. 所以不管在什么操作系统上运行,代表的都是32位整数.<br>如果用Int32,这样的误解就没有了.</p>
</blockquote>
<ol>
<li><p>C#的<code>long</code>类型映射到的是<code>System.Int64</code>,而其他编程语言中可能映射到Int16或Int32. 例如C++/CLI就将long视为Int32. 事实上大多数语言不将long当做关键字.根本不编译使用了它的代码.</p>
</li>
<li><p>FCL的许多方法都将类型名作为方法名的一部分.例如BinaryReader类型的方法包括ReadBoolean,ReadInt32,ReadSingle等, 而System.Convert类型的方法包括ToBoolean,ToInt32,ToSingle等.</p>
</li>
</ol>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 虽然语法上没问题, 但float的那一行无法一下子判断该行的正确性.</span>
BinaryReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BinaryReader</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 使用float C#关键字</span>
<span class="token keyword">float</span> val <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">ReadSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 正确,但感觉别扭</span>
<span class="token comment" spellcheck="true">// 使用Single FCL类型名称</span>
Single val <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">ReadSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 正确,感觉自然</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol>
<li>平时只用C#的许多程序员逐渐忘了还可以用其他语言写面向CLR的代码.<code>C#主义逐渐入侵类库代码</code>.例如:FCL几乎完全是用C#写的,FCL团队向库中引入了<code>Array</code>的<code>GetLongLength</code>这样的方法,该方法返回的是<code>Int64</code>值.这种值在C#中确实是long,但是在其他语言比如C++/CLI中不是. 另一个例子是:<code>System.Linq.Enumerable</code>的<code>LongCount</code>方法.</li>
</ol>
<p><strong> 考虑到以上原因,本书坚持使用FCL类型名称.</strong></p>
<h2 id="System-Int32-为什么能转-System-Int64"><a href="#System-Int32-为什么能转-System-Int64" class="headerlink" title="System.Int32 为什么能转 System.Int64?"></a>System.Int32 为什么能转 System.Int64?</h2><p>在许多编程语言中,一下代码都能正确编译并运行:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">Int32 i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//32位值</span>
Int64 i <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//隐形转型为64位值</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但是根据上一章内容,对类型转换的讨论,你或许认为上述代码无法编译. 毕竟<code>System.Int32</code>和<code>System.Int64</code>是不同的类型.互相不存在派生关系. 但是能正确编译上述代码,运行起来也没有问题.</p>
<p>原因是: C#编译器非常熟悉基元类型,会在编译代码时应用自己的特殊规则.</p>
<ol>
<li>具体的说,C#编译器支持<code>与类型转换</code>,<code>字面值(直接量或文字常量)</code>以及<code>操作符</code>有关的模式.</li>
</ol>
<h3 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h3><p>编译器能执行<code>基元类型之间</code>的隐式或显示转型.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">Int32 i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从Int32隐式转型为Int32</span>
Int64 l <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从Int32隐式转型为Int64</span>
Single s <span class="token operator">=</span>i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从Int32隐式转型为Single</span>
Byte b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span>i<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从Int32显示转型为Byte</span>
Int16 v <span class="token operator">=</span> <span class="token punctuation">(</span>Int16<span class="token punctuation">)</span>s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从Single显示转型为Int16</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有在转换<code>安全</code>的时候,C#才允许隐式转型.</p>
<ul>
<li><p>什么是转换<code>安全</code>的时候?</p>
<ul>
<li>是指不会发生数据丢失的情况. 比如从<code>Int32</code>转换为<code>Int64</code>.</li>
</ul>
</li>
<li><p>如果可能<code>不安全</code>,C#就要求显示转型.</p>
<ul>
<li>对于数值类型,<code>不安全</code>意味着转换后丢失精度或数量级.</li>
<li>例如<code>Single(float IEEE32位浮点值)</code>,转换为<code>Int16(short 有符号16位)</code>也要求显示转型.因为Single能表示比Int16更大数量级的数字(会丢失精度).</li>
</ul>
</li>
</ul>
<h4 id="C-编译器总是对转型结果进行截断"><a href="#C-编译器总是对转型结果进行截断" class="headerlink" title="C#编译器总是对转型结果进行截断"></a>C#编译器总是对转型结果进行截断</h4><p>比如 6.8的<code>Single(float IEEE32位浮点值)</code>转型为<code>Int32</code>,<br><strong>C#总是对结果进行截断(向下取整)</strong>, 结果是将6放入<code>Int32</code>类型中.</p>
<blockquote>
<p>有些编译器可能会将结果向上取整为7.</p>
</blockquote>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><p><code>字面值</code>可被看成是类型本身的实例.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 实例 调用 实例方法</span>
Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">456</span><span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 123456</span>

<span class="token comment" spellcheck="true">// 如果表达式由字面值构成, 编译器在编译时就能完成表达式求值.从而增强应用程序性能.</span>
Boolean found <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 生成的代码将found设为0</span>
Int32 x <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token number">20</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 生成的代码将x设为123</span>
String s <span class="token operator">=</span> <span class="token string">"a "</span> <span class="token operator">+</span> <span class="token string">"bc"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 生成的代码将s设为"a bc"</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="checked-和-unchecked-基元类型操作"><a href="#checked-和-unchecked-基元类型操作" class="headerlink" title="checked 和 unchecked 基元类型操作"></a>checked 和 unchecked 基元类型操作</h2><p>对基元类型执行的许多算术运算符都可能造成溢出:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// byte 2^8 = 256</span>
Byte b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 100 +200 = 300</span>
<span class="token comment" spellcheck="true">// 执行此处算术运算符时, 要求所有的操作数扩大到32位(64位,如果有操作数需要超过32位来表示的话)</span>
<span class="token comment" spellcheck="true">// b 和 200 都不超过32位,则先转换成32位值,然后加到一起,结果是一个32位的十进制300.</span>
<span class="token comment" spellcheck="true">// 然后该值存回b变量前**必须转型为Byte, C#不隐式执行此操作.**</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// b 现在为 44</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="溢出处理"><a href="#溢出处理" class="headerlink" title="溢出处理"></a>溢出处理</h2><ol>
<li>溢出大多数时候是不希望出现的,会导致应用程序行为失常.但是极少数时候计算哈希值和校验和,这种溢出可以接受.</li>
<li>不同语言处理溢出的方式不同, C/C++不将溢出视为错误,允许值回滚.VB则视为错误,并抛出异常.</li>
</ol>
<blockquote>
<p>回滚:一个值超出允许的最大值时,回滚到一个非常小的,负的或者未定义的值.</p>
</blockquote>
<p>CLR提供了一些特殊的IL指令. 允许程序员自己决定如何处理溢出. CLR有一个add指令,作用是将两个值相加,但不执行溢出检查,还有一个add.ovf指令,会在溢出时抛System.OverfolwException异常.</p>
<ol>
<li><code>溢出检查</code>默认是关闭的. 编译器生成IL代码时,将自动使用加减乘和转换指令的无溢出检查版本.代码能更快的运行.</li>
<li><code>/checked+</code>编译器开关在生成代码时使用溢出检查版本.这样CLR会检查这些运算,判断是否发生溢出,并抛出异常.</li>
<li>除了全局性的打开和关闭溢出检查, 程序员可以在代码的特定区域控制.<ul>
<li>unchecked 操作符</li>
<li>checked 操作符</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-csharp"><code class="language-csharp">UInt32 invalid <span class="token operator">=</span> <span class="token keyword">unchecked</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>UInt32<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// OK</span>

Byte b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 会抛出OverflowException异常</span>
<span class="token comment" spellcheck="true">// 这个过程中,b和200会转成32位值,</span>
<span class="token comment" spellcheck="true">// 300 转成 Byte就会抛出异常</span>
b <span class="token operator">=</span> <span class="token keyword">checked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Byte<span class="token punctuation">)</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// b包含44, 不会抛出异常.</span>
b <span class="token operator">=</span> <span class="token punctuation">(</span>Byte<span class="token punctuation">)</span><span class="token keyword">checked</span><span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>C#还支持checked和unchecked语句. 可以是语句块中的代码都进行或不进行溢出检查.</p>
<blockquote>
<p>checked和unchecked语句 唯一作用就是决定生成哪个版本的加减乘和数据转换的IL指令.<br><strong>所以在checked操作符或语句中 调用方法,不会对该方法造成任何影响.</strong></p>
</blockquote>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">checked</span>
<span class="token punctuation">{</span>
  Byte b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//简化 b = (Byte)(b + 200)</span>
  b <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">checked</span>
<span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 假定SomeMethod试图把400加载到一个Byte中</span>
  <span class="token function">SomeMethod</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// SomeMethod 可能会,也可能不会抛出OverflowException异常</span>
  <span class="token comment" spellcheck="true">// 如果SomeMethod使用checked指令编译,就可能会抛出异常.</span>
  <span class="token comment" spellcheck="true">// 但这和当前的checked语句无关.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="应对无效输入的建议"><a href="#应对无效输入的建议" class="headerlink" title="应对无效输入的建议"></a>应对无效输入的建议</h2><ol>
<li><p>尽量使用有<code>符号数值类型</code>比如:Int32和Int64,而不是<code>无符号数值类型</code>UInt32和UInt64.</p>
<ul>
<li>这允许编译器检测更多的上溢/下溢的错误.</li>
<li>类库的多个部分,比如Array和String的Length属性 被硬编码为返回有符号的值.</li>
<li>减少强制类型转换,无符号数值类型不符合CLS.</li>
</ul>
</li>
<li><p>写代码时,如果代码可能发生你想不到的溢出(可能是无效的输入,使用用户或客户机提供的数据), 就把这些代码放到<code>checked块</code>中. 同时捕捉<code>OverflowException</code>异常.</p>
</li>
<li><p>将允许发生溢出的代码显示放到<code>unchecked块</code>中,比如在计算校验和时.</p>
</li>
<li><p>对于没有使用<code>unchecked</code>和<code>checked</code>的语句,都假定发生溢出时抛出异常.</p>
</li>
</ol>
<p><img src="/2019/07/15/5基元类型引用类型和值类型/5-1-1.png" alt=""></p>
<p>勾选 <code>检查运算上溢/下溢</code> 相当于打开了编译器的<code>/checked+开关</code>进行调试性生成.应用程序运行起来会慢一点.可以进行比较完整的溢出检查.</p>
<h2 id="System-Decimal是非常特殊的类型"><a href="#System-Decimal是非常特殊的类型" class="headerlink" title="System.Decimal是非常特殊的类型"></a>System.Decimal是非常特殊的类型</h2><ol>
<li>C#和VB视为基元类型. 但是CLR不这样. CLR没有知道如何处理Decimal值的IL指令.</li>
<li>Decimal类型自己定义一系列方法,包括Add,Subtract,Multiply,Divide. 还为<code>+-*/</code>等提供了操作符重载方法.</li>
<li>编译使用了Decimal值的代码时,<strong>编译器会生成代码来调用Decimal的成员方法</strong>,并<strong>通过这些成员方法来进行实际的运算</strong>. 这也意味着Decimal值的处理速度慢于CLR基元类型的值.</li>
<li>由于没有相应的IL指令来处理Decimal值, 所以checked和unchecked操作符,编译器开关都失去作用.</li>
</ol>
<h2 id="System-Numerics-BigInteger类型"><a href="#System-Numerics-BigInteger类型" class="headerlink" title="System.Numerics.BigInteger类型"></a>System.Numerics.BigInteger类型</h2><ol>
<li>类似的,BigInteger类型也在内部使用了<code>UInt32</code>数组来表示任意大的整数,它的值没有上限和下限.</li>
<li>因此对于BigInteger类型执行运算永远不会造成OverflowException异常</li>
<li>如果值太大,没有足够的内存来改变数组大小,BigInteger的运算可能会抛出<code>OutOfMemoryException</code>异常.</li>
</ol>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
