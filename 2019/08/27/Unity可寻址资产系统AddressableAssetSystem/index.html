<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Unity可寻址资产系统AddressableAssetSystem - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是asset"><span class="toc-text">什么是asset?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是Addressable-Asset"><span class="toc-text">什么是Addressable Asset?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么要使用可寻址资产"><span class="toc-text">为什么要使用可寻址资产?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#入门"><span class="toc-text">入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使Asset成为AddressableAssets"><span class="toc-text">使Asset成为AddressableAssets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指定地址"><span class="toc-text">指定地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建可寻址内容"><span class="toc-text">构建可寻址内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用可寻址资产"><span class="toc-text">使用可寻址资产</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按地址加载或实例化"><span class="toc-text">按地址加载或实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子资产和组件"><span class="toc-text">子资产和组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用AssetReference类"><span class="toc-text">使用AssetReference类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建立考虑因素"><span class="toc-text">建立考虑因素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StreamingAssets中的本地数据"><span class="toc-text">StreamingAssets中的本地数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#提前下载"><span class="toc-text">提前下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建多个平台"><span class="toc-text">构建多个平台</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#开发周期"><span class="toc-text">开发周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#传统的资产管理"><span class="toc-text">传统的资产管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可寻址资产管理"><span class="toc-text">可寻址资产管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#资产组架构"><span class="toc-text">资产组架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建脚本"><span class="toc-text">构建脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Play-mode-scripts"><span class="toc-text">Play mode scripts</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析和调试"><span class="toc-text">分析和调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化对象"><span class="toc-text">初始化对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内容更新工作流程"><span class="toc-text">内容更新工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运作流程"><span class="toc-text">运作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#准备内容更新"><span class="toc-text">准备内容更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构建内容更新"><span class="toc-text">构建内容更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内容更新例子"><span class="toc-text">内容更新例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#资产托管服务"><span class="toc-text">资产托管服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概观"><span class="toc-text">概观</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打包模式测试和迭代"><span class="toc-text">打包模式测试和迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#管理key的内容服务器"><span class="toc-text">管理key的内容服务器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建立"><span class="toc-text">建立</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#配置新的主机服务"><span class="toc-text">配置新的主机服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Profile配置文件设定"><span class="toc-text">Profile配置文件设定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从批处理模式中开启服务"><span class="toc-text">从批处理模式中开启服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现自定义服务"><span class="toc-text">实现自定义服务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理"><span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#镜像加载和卸载"><span class="toc-text">镜像加载和卸载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资产加载"><span class="toc-text">资产加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#场景加载"><span class="toc-text">场景加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GameObject实例化"><span class="toc-text">GameObject实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可寻址的分析器Profiler"><span class="toc-text">可寻址的分析器Profiler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#何时清除内存"><span class="toc-text">何时清除内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步操作处理"><span class="toc-text">异步操作处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Type-vs-typeless-handles-类型与无类型句柄"><span class="toc-text">Type vs typeless handles(类型与无类型句柄)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncOperationHandle用例示例"><span class="toc-text">AsyncOperationHandle用例示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自定义操作"><span class="toc-text">自定义操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建自定义操作"><span class="toc-text">创建自定义操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Analyze分析"><span class="toc-text">Analyze分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Analyze"><span class="toc-text">使用Analyze</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提供分析规则"><span class="toc-text">提供分析规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#无法修复的规则"><span class="toc-text">无法修复的规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将自定义规则添加到GUI"><span class="toc-text">将自定义规则添加到GUI</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#升级到Addressables系统"><span class="toc-text">升级到Addressables系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#直接引用"><span class="toc-text">直接引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Resource文件夹"><span class="toc-text">Resource文件夹</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AB包方法"><span class="toc-text">AB包方法</span></a></li></ol></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Unity可寻址资产系统AddressableAssetSystem
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-08-27 20:35:11</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Unity资源管理系统" title="Unity资源管理系统">Unity资源管理系统</a>
        <span>/</span>
        
        <a class="tag" href="/tags/#Addressable Asset System" title="Addressable Asset System">Addressable Asset System</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p><a href="https://docs.unity3d.com/Packages/com.unity.addressables@1.1/manual/index.html" target="_blank" rel="external">Addressable Asset System 官方文档</a></p>
<p>Unity全新的资源管理流程Addressable Asset System(寻址式资源管理)可以让你在Unity编辑或运行时来管理各种资源加载分配。它是一个基于Asset Bundle架构延伸出来的高级管理系统。非常适合非程序人员来使用，意味着未来打包与管理资源的工作也可以让非程式人员来分担，对管理大型项目或结构复杂的资源特别有帮助。</p>
<h1 id="什么是asset"><a href="#什么是asset" class="headerlink" title="什么是asset?"></a>什么是asset?</h1><p>资产是您用于创建游戏或应用程序的内容。资产的常见示例包括预制件(Prefabs)，纹理(textures)，材料(materials)，音频剪辑(audio clips)和动画(animations)。</p>
<h1 id="什么是Addressable-Asset"><a href="#什么是Addressable-Asset" class="headerlink" title="什么是Addressable Asset?"></a>什么是Addressable Asset?</h1><p>使资产“可寻址”允许您使用该资产的唯一地址从任何地方调用它。无论该资产是在 <strong>本地应用程序中</strong> 还是在 <strong>内容交付网络(资源服务器)</strong> 上，可寻址资产系统都会找到并返回该资产。您可以通过其地址加载单个可寻址资产，或使用您定义的 <strong>自定义组标签</strong> 加载许多可寻址资产。</p>
<h1 id="为什么要使用可寻址资产"><a href="#为什么要使用可寻址资产" class="headerlink" title="为什么要使用可寻址资产?"></a>为什么要使用可寻址资产?</h1><p>Addressable 缩短了迭代周期:</p>
<ul>
<li><code>迭代时间</code>: 通过其地址引用类型非常有效.对内容的优化不需要更改代码.</li>
<li><code>依赖关系管理</code>: 系统返回所请求内容的所有依赖关系, 方便在内容返回之前加载所有依赖的网格,着色器,动画等.</li>
<li><code>内存管理</code>: 系统的卸载资产并加载它们,自动计算引用并提供强大的分析器以帮助您发现潜在的内存问题。</li>
<li><code>内容打包</code>: 由于系统映射并理解复杂的依赖关系链, 因此即使在移动或重命名资产时，也可以有效地打包捆绑包。您可以轻松地为本地和远程部署准备资产，以支持可下载内容和减少应用程序大小。</li>
</ul>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>可寻址资产系统包括两个包：</p>
<ul>
<li>Addressable Assets package (主要包)</li>
<li>Scriptable Build Pipeline package (依赖)</li>
</ul>
<blockquote>
<p>安装Addressable Assets包时，Scriptable Build Pipeline包将同时安装。</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><code>Address(地址)</code>: 资产的位置标识符，便于运行时检索.</li>
<li><code>AddressableAssetData directory(可寻址资产元数据目录)</code>: 将您的可寻址资产元数据存储在Project的Assets目录.</li>
<li><code>Asset group(资产组)</code>: 一组可用于 <strong>构建时处理的</strong> 可寻址资产.</li>
<li><code>Asset group schema(资产组架构)</code>: 定义一组数据，您可以将这些数据分配给组并在构建期间使用。</li>
<li><code>AssetReference(资产引用)</code>: 一个对象，其操作类似于直接引用，但具有 <strong>延迟初始化</strong>。该AssetReference对象将GUID存储为可按需加载的Addressable。</li>
<li><code>Asynchronous loading(异步加载)</code>: 允许在整个开发过程中更改资产及其依赖项的位置，而无需更改游戏代码。异步加载是可寻址资产系统的基础。</li>
<li><code>Build script(构建脚本)</code>: 运行 <strong>资产组处理器</strong> 以打包资产，并提供资源管理器的地址和资源位置之间的映射。</li>
<li><code>Label(标签)</code>: 为类似项的运行时加载提供附加的 <strong>可寻址资产标识符</strong> (例如, <code>Addressables.DownloadDependenciesAsync(&quot;spaceHazards&quot;);</code>).</li>
</ul>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p><strong>重要提示：可寻址资产系统需要Unity版本2018.3或更高版本</strong></p>
<h2 id="使Asset成为AddressableAssets"><a href="#使Asset成为AddressableAssets" class="headerlink" title="使Asset成为AddressableAssets"></a>使Asset成为AddressableAssets</h2><p>两种标记方式:</p>
<ol>
<li>在对象的<code>Inspector</code>面板中 -&gt; 单击<code>Address</code>复选框 -&gt; 输入用于标识资产的名称。</li>
</ol>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/inspectorcheckbox.png" alt=""></p>
<ol>
<li>选择 Window &gt; <code>Asset Management</code> &gt; <code>Addressables</code> 去打开 <code>Addressables window</code>. 然后, 将所需的资产从项目窗口拖进<code>Addressables window</code>的资产组。</li>
</ol>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/addressableswindow.png" alt=""></p>
<h2 id="指定地址"><a href="#指定地址" class="headerlink" title="指定地址"></a>指定地址</h2><p>资产的 <strong>默认地址</strong> 是项目中资产的路径（例如，<code>Assets/images/myImage.png</code>）。<strong>要从<code>Addressables window</code>更改资产的地址，请右键单击该资源，然后选择<code>Rename</code>。</strong></p>
<p>当您第一次开始使用可寻址资产时，系统会在<code>Assets/AddressableAssetsData</code>文件中为您的项目保存一些编辑时和运行时数据资产，这些资产应添加到您的版本控制签入中。</p>
<h2 id="构建可寻址内容"><a href="#构建可寻址内容" class="headerlink" title="构建可寻址内容"></a>构建可寻址内容</h2><p>在构建应用程序之前，<strong>Addressables资产系统需要将您的内容构建为正在运行的游戏可以使用的文件。</strong> 此步骤不是自动的。您可以通过编辑器或API构建此内容：</p>
<ul>
<li>要在Editor中构建内容，请打开<code>Addressables window</code>，然后选择<code>Build</code> -&gt; <code>Build Player Content</code>。</li>
<li>要使用API​​构建内容，请使用<code>AddressableAssetSettings.BuildPlayerContent()。</code></li>
</ul>
<h2 id="使用可寻址资产"><a href="#使用可寻址资产" class="headerlink" title="使用可寻址资产"></a>使用可寻址资产</h2><h3 id="按地址加载或实例化"><a href="#按地址加载或实例化" class="headerlink" title="按地址加载或实例化"></a>按地址加载或实例化</h3><p>您可以在运行时加载或实例化可寻址资产。<strong>加载资产会将所有依赖项加载到内存中（包括资产的捆绑数据，如果适用）</strong>，允许您在需要时使用该资产。<strong>这实际上并没有将所需资产放入场景中。要将资源添加到场景中，您必须实例化。</strong> 使用Addressables实例化接口将加载资源，然后立即将其添加到场景中。</p>
<p>要使用字符串地址从游戏脚本访问资产，请声明UnityEngine.AddressableAssets命名空间，然后调用以下方法：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 这会使用指定的地址加载资产。</span>
Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>GameObject<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"AssetAddress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 这会将具有指定地址的资产实例化到场景中。</span>
Addressables<span class="token punctuation">.</span><span class="token function">InstantiateAsync</span><span class="token punctuation">(</span><span class="token string">"AssetAddress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意：<code>LoadAssetAsync</code>和<code>InstantiateAsync</code>是异步操作。您可以在完成加载时提供回调以使用资产。</p>
</blockquote>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">using</span> UnityEngine<span class="token punctuation">.</span>AddressableAssets<span class="token punctuation">;</span>
<span class="token keyword">using</span> UnityEngine<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddressablesExample</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>

    GameObject myGameObject<span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// ...</span>

        <span class="token comment" spellcheck="true">// 使用指定的地址加载资产,完成时回调OnLoadDone方法</span>
        Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>GameObject<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"AssetAddress"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Completed <span class="token operator">+</span><span class="token operator">=</span> OnLoadDone<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span>    <span class="token function">OnLoadDone</span><span class="token punctuation">(</span>UnityEngine<span class="token punctuation">.</span>ResourceManagement<span class="token punctuation">.</span>AsyncOperations<span class="token punctuation">.</span>AsyncOperationHandle<span class="token operator">&lt;</span>GameObject<span class="token operator">></span> obj<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在生产环境中，您应该添加异常处理来捕获诸如null结果之类的场景。</span>
        myGameObject <span class="token operator">=</span> obj<span class="token punctuation">.</span>Result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="子资产和组件"><a href="#子资产和组件" class="headerlink" title="子资产和组件"></a>子资产和组件</h3><p><code>子资产</code>和<code>组件</code>是资产加载的特殊情况。</p>
<ul>
<li><code>组件</code>：您 <strong>无法</strong> 直接将GameObject的组件作为资源加载。您必须加载或实例化GameObject，然后从中检索组件引用。</li>
<li><code>子资产</code>：系统支持加载子资产，但需要特殊语法。潜在子资产的示例包括<code>sprite sheet</code>中的<code>sprites</code>或FBX文件中的动画片段。要加载它们，请使用以下示例语法：</li>
</ul>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 系统支持加载子资产，但需要特殊语法</span>
<span class="token comment" spellcheck="true">// 例如`sprite sheet`中的`sprites`</span>
<span class="token comment" spellcheck="true">// FBX文件中的动画片段</span>
Addressables<span class="token punctuation">.</span>LoadAssetAsync<span class="token operator">&lt;</span>IList<span class="token operator">&lt;</span>Sprite<span class="token operator">></span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"MySpriteSheetAddress"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="使用AssetReference类"><a href="#使用AssetReference类" class="headerlink" title="使用AssetReference类"></a>使用AssetReference类</h2><p>本<code>AssetReference类</code>提供一种方法来访问寻址的资产，而无需知道他们的地址。要使用<code>AssetReference类</code>访问可寻址资产：</p>
<ol>
<li>从<code>Scene hierarchy</code>结构或<code>Project window</code>中选择一个GameObject 。</li>
<li>在Inspector中，单击<code>Add Component</code>按钮，然后选择组件类型。任何可序列化组件都可以支持<code>AssetReference变量</code>（例如，<code>a game script</code>，<code>ScriptableObject</code>或<code>其他可序列化类</code>）。</li>
<li><code>AssetReference</code>在组件中添加公共变量（例如，<code>public AssetReference explosion;</code>）。</li>
<li>在Inspector中，选择要链接到对象的可寻址资产，方法是将资源从<code>Project window</code>拖动到公开AssetReference字段中，或者从项目中先前定义的可寻址资产的下拉列表中进行选择（如下所示）。</li>
</ol>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/Inspectorreferenceselection2.png" alt=""></p>
<ol>
<li>要加载或实例化AssetReference资产，请调用其相应的方法。<ol>
<li><code>AssetRefMember.LoadAssetAsync&lt;GameObject&gt;();</code></li>
<li>或者 <code>AssetRefMember.InstantiateAsync(pos, rot);</code></li>
</ol>
</li>
</ol>
<h2 id="建立考虑因素"><a href="#建立考虑因素" class="headerlink" title="建立考虑因素"></a>建立考虑因素</h2><h3 id="StreamingAssets中的本地数据"><a href="#StreamingAssets中的本地数据" class="headerlink" title="StreamingAssets中的本地数据"></a>StreamingAssets中的本地数据</h3><p>可寻址资产系统在运行时需要 <strong>一些文件来知道要加载什么以及如何加载它</strong>。这些文件是在构建Addressables数据时生成的，<strong>并在StreamingAssets文件夹中生成</strong>，该文件夹是Unity中包含构建中所有文件的特殊文件夹。构建Addressables内容时，系统会在库中对这些文件进行分级。然后，在构建应用程序时，<strong>系统会将所需文件复制到StreamingAssets</strong>，构建并从文件夹中 <strong>删除它们</strong>。这样，您可以为多个平台构建数据，同时只在每个构建中包含相关数据。</p>
<p>除了特定于Addressables的数据之外，构建其本地数据的任何组也将使用特定于库平台的分段位置。</p>
<p>要验证这是否有效，请将构建路径和加载路径设置为分别以<br><code>[UnityEngine.AddressableAssets.Addressables.BuildPath]</code>和开头的配置文件变量<code>{UnityEngine.AddressableAssets.Addressables.RuntimePath}</code>。您可以在<code>AddressableAssetSettings</code>的<code>Inspector</code>中指定这些设置（默认情况下，此对象位于Project的<code>Assets/AddressableAssetsData</code>目录中）。</p>
<h3 id="提前下载"><a href="#提前下载" class="headerlink" title="提前下载"></a>提前下载</h3><p>调用该<code>Addressables.DownloadDependenciesAsync()</code>方法会加载您传入的地址或标签的依赖关系。通常，这是资产包。</p>
<p><code>AsyncOperationHandle</code>此调用返回的结构包含一个<code>PercentComplete</code>可用于监视和显示下载进度的属性。您还可以让应用程序等到内容加载完毕。</p>
<p>如果您希望在下载之前询问用户是否同意，请使用<code>Addressables.GetDownloadSize()</code>返回从给定地址或标签下载内容所需的空间。请注意，这会考虑任何以前下载的仍在Unity资产包缓存中的捆绑包。</p>
<p>虽然提前为您的应用程序下载资产可能是有利的，<strong>但有些情况下您可能选择不这样做</strong>。例如：</p>
<ul>
<li>如果您的应用拥有大量在线内容，并且您通常希望用户只与其中的一部分进行互动。</li>
<li>您有一个必须在线连接才能运行的应用程序。如果您的所有应用内容都是小型捆绑包，您可以选择根据需要下载内容。</li>
</ul>
<p>您可以使用预加载功能显示下载已开始，然后继续，而不是使用百分比完成值等待内容加载。此实现需要加载或等待屏幕来处理资产在需要时尚未完成加载的实例。</p>
<h3 id="构建多个平台"><a href="#构建多个平台" class="headerlink" title="构建多个平台"></a>构建多个平台</h3><p>在构建应用程序内容时，可寻址资产系统会生成包含可寻址资产的资产包。<strong>资产包依赖于平台，因此必须为您打算支持的每个独特平台重建。</strong></p>
<p>默认情况下，在构建Addressables应用程序数据时，给定平台的数据存储在Addressables构建路径的特定于平台的子目录中。运行时路径考虑了这些平台文件夹，并指向适用的应用程序数据。</p>
<p>注意：如果<code>BuildScriptPackedPlayMode</code>在编辑器播放模式下使用Addressables 脚本，则Addressables将尝试加载<code>当前活动构建目标(your current active build target)</code>的数据。因此，<strong>如果您当前的构建目标数据与当前的编辑器平台不兼容，则可能会出现问题。</strong> 有关更多信息，请参阅有关Play mode scripts.的文档。</p>
<h1 id="开发周期"><a href="#开发周期" class="headerlink" title="开发周期"></a>开发周期</h1><h2 id="传统的资产管理"><a href="#传统的资产管理" class="headerlink" title="传统的资产管理"></a>传统的资产管理</h2><p>如果在Resources目录中安排内容，它将内置到基本应用程序中，您必须使用该<code>Resources.Load</code>方法加载内容，并提供资源的路径。</p>
<p>要访问存储在其他位置的内容，您可以使用直接引用或资产包(AB包)。如果您使用资产包(AB包)，则会再次按路径加载，将您的负载和组织策略捆绑在一起。如果您的资产包是远程的，或者依赖于其他捆绑包，则必须编写代码来管理下载，加载和卸载所有捆绑包。</p>
<h2 id="可寻址资产管理"><a href="#可寻址资产管理" class="headerlink" title="可寻址资产管理"></a>可寻址资产管理</h2><p>为资产提供<code>地址</code>允许您使用该地址加载它，无论您在项目中的位置或您如何构建资产。您可以毫无问题地更改可寻址资产的路径或文件名。您还可以 <strong>将<code>可寻址资产</code>从Resources文件夹或本地构建目标移动到其他构建位置（包括远程构建位置）</strong>，而无需更改加载代码。</p>
<h3 id="资产组架构"><a href="#资产组架构" class="headerlink" title="资产组架构"></a>资产组架构</h3><p>架构定义了一组数据。您可以在<code>Inspector</code>中将模式附加到资产组。附加到组的<code>模式集</code>定义了构建如何处理其内容。例如，在打包模式下构建时，<code>BundledAssetGroupSchema</code>附加了架构的组充当资产包的源。您可以将模式集合组合到用于定义新组的模板中。您可以通过<code>AddressableAssetsSettings</code>的<code>Inspector</code> 添加架构模板。</p>
<h2 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h2><p>构建脚本<code>ScriptableObject</code>在项目中表示为实现<code>IDataBuilder接口</code>的资产。用户可以创建自己的构建脚本，并<code>AddressableAssetSettings</code>通过其<code>Inspector</code> 将它们添加到对象中。要在“ 可寻址”窗口 <code>Addressables window (Window &gt; Asset Management &gt; Addressables)</code>,中应用构建脚本，请选择<code>构建脚本</code>，然后选择下拉选项。目前，有三个脚本用于支持完整的应用程序构建，三个Play模式脚本用于在编辑器中进行迭代。</p>
<h3 id="Play-mode-scripts"><a href="#Play-mode-scripts" class="headerlink" title="Play mode scripts"></a>Play mode scripts</h3><p>有三个构建脚本，用于创建Play模式数据以帮助您加速应用程序开发。</p>
<ul>
<li><p>Fast mode <strong>快速模式</strong><br>快速模式（<code>BuildScriptFastMode</code>）允许您在完成游戏流程时快速运行游戏。快速模式直接通过资产数据库加载资产，以便快速迭代，<strong>无需创建分析或资产包(AB包)</strong>。</p>
</li>
<li><p>Virtual mode <strong>虚拟模式</strong><br>虚拟模式（<code>BuildScriptVirtualMode</code>）<strong>分析布局和依赖关系的内容</strong>，而无需创建资产包(AB包)。资产从资产数据库<code>ResourceManager</code>加载，就像它们是通过捆绑加载一样。要查看在游戏过程中何时加载或卸载软件包，请在<code>Addressable Profiler window (Window &gt; Asset Management &gt; Addressable Profiler).</code>中查看资产使用情况。</p>
</li>
</ul>
<p>虚拟模式可帮助您模拟加载策略并调整内容组，以便为​​生产版本找到正确的平衡点。</p>
<ul>
<li>Packed Play mode <strong>打包模式</strong></li>
</ul>
<p>打包播放模式（<code>BuildScriptPackedPlayMode</code>）使用已构建的资产包(AB包)。此模式与已部署的应用程序构建最匹配，但它要求您将数据构建为单独的步骤。如果您不修改资源，此模式是最快的，因为它在进入播放模式时不会处理任何数据。您必须通过选择<code>Build &gt; Build Player Content</code>，在Addressables窗口（Window &gt; Asset Management &gt; Addressables）中为此模式 <strong>构建内容</strong> 或 <strong>使用游戏脚本中的方法</strong> <code>AddressableAssetSettings.BuildPlayerContent()</code>。</p>
<ul>
<li>Choosing the right script 选择正确的脚本</li>
</ul>
<p>要应用播放模式脚本，请从<code>Addressables window menu (Window &gt; Asset Management &gt; Addressables)</code>, 选择<code>Play Mode Script</code>, 下拉选项中进行选择.每种模式在开发和部署期间都有自己的时间和地点。下表说明了开发周期的各个阶段，其中特定模式很有用</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/choosingtherightscript.png" alt=""></p>
<h2 id="分析和调试"><a href="#分析和调试" class="headerlink" title="分析和调试"></a>分析和调试</h2><p>默认情况下，可寻址资产 <strong>仅记录警告和错误</strong>。您可以通过打开<code>Player settings window</code>，然后将<code>ADDRESSABLES_LOG_ALL</code> 添加到<code>Scripting Define Symbols</code>字段来启用详细日志记录。</p>
<p>您还可以通过在<code>AddressableAssetSettings</code>取消选中对象Inspector中的<code>Log Runtime Exceptions</code>选项来禁用异常。可以使用自己的异常处理程序实现该属性<code>ResourceManager.ExceptionHandler</code>，但这应该在Addressables完成运行时初始化之后完成（见下文）。</p>
<h2 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h2><p>您可以将对象附加到可寻址资源设置，并在运行时将它们传递给初始化过程。该<code>CacheInitializationSettings对象</code>在运行时控制Unity的缓存API. 要创建自己的初始化对象，请创建一个<code>ScriptableObject</code>并实现<code>该IObjectInitializationDataProvider接口</code>。这是系统的Editor组件，负责创建<code>ObjectInitializationData</code>使用运行时数据序列化的组件。</p>
<h2 id="内容更新工作流程"><a href="#内容更新工作流程" class="headerlink" title="内容更新工作流程"></a>内容更新工作流程</h2><p>Unity建议将游戏内容分为两类：</p>
<ul>
<li>您永远不会期望更新的静态内容。</li>
<li>您希望更新的动态内容。</li>
</ul>
<p>在此结构中，静态内容随应用程序一起提供（或在安装后很快下载），并且驻留在极少数大型捆绑包中。动态内容在线下载，理想情况下是较小的捆绑包，以最大限度地减少每次更新所需的数据量。可寻址资产系统的目标之一是使这个结构易于使用和修改，而无需更改脚本。</p>
<p>但是，当您不想发布全新的应用程序构建时，可寻址资产系统还可以适应需要更改“静态”内容的情况。</p>
<h3 id="运作流程"><a href="#运作流程" class="headerlink" title="运作流程"></a>运作流程</h3><p>Addressables使用内容目录将地址 <strong>映射到每个资产</strong>，<strong>指定加载它的位置和方式</strong>。为了使您的应用程序能够修改该映射，您的原始应用程序必须知道此目录的在线副本。要进行此设置，请在<code>AddressableAssetSettings</code>的<code>Inspector</code>上启用 <code>Build Remote Catalog(构建远程目录)</code> 设置。这可确保将目录的副本构建到指定路径并从指定路径加载。<strong>应用程序发布后，此加载路径无法更改。</strong> <strong>内容更新过程创建新版本的目录（具有相同的文件名）以 覆盖先前指定的加载路径上的文件</strong>。</p>
<p>构建应用程序会生成 <strong>唯一的应用程序内容版本字符串</strong>，用于 <strong>标识每个应用程序应加载的内容目录</strong>. 给定服务器可以包含应用程序的多个版本的目录而不会发生冲突。我们将所需的数据存储在<code>addressables_content_state.bin</code>文件中。这包括<code>版本字符串</code>，以及<code>标记为的组中包含的任何资产的哈希信息StaticContent</code>。默认情况下，此文件与<code>AddressableAssetSettings.asset</code>文件位于同一文件夹中。</p>
<p>该<code>addressables_content_state.bin</code>文件包含<code>每个哈希</code>和<code>依赖信息StaticContent</code>的 <strong>Addressables系统资产组</strong>。<strong>构建到StreamingAssets文件夹的所有组都应标记为<code>StaticContent</code></strong>，但大型远程组也可能受益于此指定。在下一节（准备内容更新，如下所述）期间，此哈希信息确定是否有任何StaticContent组包含已更改的资产，因此需要将这些资产移动到其他位置。</p>
<h3 id="准备内容更新"><a href="#准备内容更新" class="headerlink" title="准备内容更新"></a>准备内容更新</h3><p>如果您已在任何<code>StaticContent</code>组中修改了资产，则需要运行<code>Prepare For Content Update</code>命令。这将从静态组中取出任何已修改的资产，并将它们移动到新组。要生成新资产组：</p>
<ul>
<li>在Unity编辑器中打开Addressables窗口（窗口 &gt; 资产管理 &gt; 可寻址资产）。</li>
<li>在“ 可寻址”窗口中，选择顶部菜单栏上的 <code>Build</code>，然后选择<code>Prepare For Content Update</code>。</li>
<li>在打开的<code>Build Data File</code>对话框中，选择<code>addressables_content_state.bin</code>文件（默认情况下，该文件位于<code>Assets/AddressableAssetsData</code>项目目录中。</li>
</ul>
<p>此数据用于确定 <strong>自上次构建应用程序以来已修改的资产或依赖项</strong>。系统将这些资产移动到新组以准备内容更新构建。</p>
<p><strong>注意：如果所有更改都限制在非静态组中，则此命令将不执行任何操作。</strong></p>
<p>重要：在运行准备操作之前，Unity建议 <strong>分支您的版本控制</strong> 系统。准备操作以适合更新内容的方式重新排列资产组。分支确保您下次发布新播放器时，可以返回首选内容安排。</p>
<h3 id="构建内容更新"><a href="#构建内容更新" class="headerlink" title="构建内容更新"></a>构建内容更新</h3><p>要构建内容更新：</p>
<ul>
<li>在Unity编辑器中打开Addressables窗口（窗口 &gt; 资产管理 &gt; 可寻址资产）。</li>
<li>在Addressables窗口中，选择<code>Build</code>在顶部菜单上，然后<code>Build For Content Update</code>。</li>
<li>在打开的<code>Build Data File</code>对话框中，选择现有应用程序构建的构建文件夹。build文件夹必须包含<code>addressables_content_state.bin</code>文件。</li>
</ul>
<p>构建生成<code>content catalog内容目录</code>，<code>hash file哈希文件</code>和<code>asset bundles</code>资产包。</p>
<p>生成的内容目录与所选应用程序构建中的目录具有相同的名称，将 <strong>覆盖</strong> 旧目录和哈希文件。应用程序加载哈希文件以确定新目录是否可用。系统从应用程序附带或已下载的现有捆绑包中加载未修改的资产。</p>
<p>系统使用<code>addressables_content_state.bin</code>文件中的<code>内容版本字符串</code>和<code>位置信息</code>来创建<code>资产包(AB包)</code>。不包含更新内容的资产包使用与为更新选择的构建中的文件名相同的文件名编写。如果资产包中包含更新的内容，则会生成一个<code>包含更新内容的新资产包</code>，并使用<code>新文件名</code>，以便它可以与原始内容共存。只有具有新文件名的资产包必须复制到托管您内容的位置。</p>
<p>系统还为静态内容构建资产包，但您无需将其上载到内容托管位置，因为没有Addressables资产条目引用它们。</p>
<h3 id="内容更新例子"><a href="#内容更新例子" class="headerlink" title="内容更新例子"></a>内容更新例子</h3><p>一个已发布的应用程序知道以下资源组:</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新.png" alt=""></p>
<p>玩家的设备上有<code>Local_Static</code>，并且可能有一个或两个远程包缓存在本地。</p>
<p>如果您修改每个组中的一个资产(AssetA, AssetL, AssetX)，然后运行<code>Prepare For Content Update</code>，那么本地可寻址设置的结果如下:</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新1.png" alt=""></p>
<p><code>Prepare For Content Update</code>操作实际上编辑静态组, 系统构建了上面的布局.</p>
<p>从玩家的角度来看，你最终会得到以下内容:</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新3.png" alt=""></p>
<p><code>Local_Static包</code>已经在设备上，您不能更改它。这个旧版本的<code>AssetA</code>不再被引用。相反，它作为死数据被卡在设备上.</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新4.png" alt=""></p>
<p><code>Remote_Static包</code>没有改变。如果它还没有缓存在播放器的设备上，它将在请求<code>AssetM</code>或<code>AssetN</code>时下载。像<code>AssetA</code>一样，如果请求<code>AssetL</code>,这个旧版本的<code>AssetL</code>不再被引用。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新5.png" alt=""><br><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新6.png" alt=""></p>
<p>旧的<code>Remote_NonStatic包</code>被替换为一个新版本，由它的散列文件来区分。修改后的<code>AssetX</code>版本将使用这个新包进行更新。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/内容更新7.png" alt=""></p>
<p><code>content_update_group包</code>包含修改后的资产组成。</p>
<ol>
<li>任何已更改的本地资产将永久保留在用户设备上.</li>
<li>如果用户已经缓存了<code>Remote_NonStatic</code>,则需要重新下载包，包括未更改的资产（例如，在本例中，AssetY和AssetZ）。理想情况下，用户没有缓存捆绑包，在这种情况下，他们只需要下载<code>新Remote_NonStatic</code>捆绑包。</li>
<li>如果用户已经缓存了<code>Static_Remote</code>捆绑包，则他们只需要下载<code>更新的资产</code>（在本例中为<code>AssetL</code>通过<code>content_update_group</code>）。在这种情况下，这是理想的。如果用户没有缓存包，则必须通过<code>content_update_group</code>下载新的<code>AssetL</code>，并通过未触及的<code>Remote_Static</code>包下载现已失效的资产集。无论初始缓存状态如何，在某种程度上，用户的设备上都将拥有已失效的资产集，尽管从未被访问，但该资产集将被无限期缓存。</li>
</ol>
<p>远程内容的最佳设置将取决于您的特定用例。</p>
<h1 id="资产托管服务"><a href="#资产托管服务" class="headerlink" title="资产托管服务"></a>资产托管服务</h1><h2 id="概观"><a href="#概观" class="headerlink" title="概观"></a>概观</h2><p>托管服务提供了一个集成工具，用于使用<code>可寻址资产</code>配置数据从Unity Editor中将打包内容提供给本地或网络连接的应用程序版本。托管服务旨在提高测试打包内容时的迭代速度，还可用于向本地和远程网络上的连接客户端提供内容。</p>
<h3 id="打包模式测试和迭代"><a href="#打包模式测试和迭代" class="headerlink" title="打包模式测试和迭代"></a>打包模式测试和迭代</h3><p>从编辑器播放模式测试转向平台应用程序构建测试会为开发过程带来复杂性和时间成本。托管服务提供可扩展的编辑器嵌入式内容交付服务，可直接映射到您的Addressables组配置。使用自定义Addressables配置文件，您可以快速配置应用程序以从Unity Editor本身加载所有内容。这包括部署到移动设备或任何其他平台的构建，这些构建可以对您的开发系统进行网络访问。</p>
<h3 id="管理key的内容服务器"><a href="#管理key的内容服务器" class="headerlink" title="管理key的内容服务器"></a>管理key的内容服务器</h3><p>您可以将资产托管服务部署到服务器环境中，方法是以批处理模式(headless)运行，为内部网和面向internet的Unity应用程序客户机托管内容。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>本文详细介绍了项目的资产托管服务的初始设置。虽然设置指南侧重于编辑器工作流，但您可以使用API​​通过设置类的<code>HostingServicesManager属性</code>来配置托管服务<code>AddressableAssetSettings。</code></p>
<h3 id="配置新的主机服务"><a href="#配置新的主机服务" class="headerlink" title="配置新的主机服务"></a>配置新的主机服务</h3><p>使用<code>Hosting window</code>添加，配置和启用新的主机服务。在编辑器中，<code>Window &gt; Asset Management &gt; Hosting Services</code>，或单击<code>Addressables window</code>菜单中的<code>Hosting</code>按钮以访问<code>Hosting window</code>。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesWindow_1.png" alt=""></p>
<p>要添加新的主机服务，请单击“ 添加服务”按钮。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesAddService_1.png" alt=""></p>
<p>在出现的“ 添加服务”对话框中，您可以选择预定义的服务类型或定义自定义服务类型。要使用预定义的服务类型，请从“ 服务类型”下拉选项中进行选择。使用“ 描述性名称”字段输入服务的名称。</p>
<p>新添加的服务显示在“ 主机 ” 窗口的“ 主机服务”部分中，默认为禁用状态。要启动该服务，请单击 <strong>启用服务</strong> 按钮。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesWindow_2.png" alt=""></p>
<p><code>HTTP Hosting Service</code>在启动时<code>自动分配端口号</code>。端口号在Unity会话之间保存并重用。要选择其他端口，请在“ 端口”字段中指定特定端口号，或使用“ 重置”按钮随机分配不同的端口。</p>
<p>注意：如果重置端口号，则必须执行完整的应用程序构建以生成并嵌入正确的URL。</p>
<p>现在，HTTP Hosting Service已启用，可以从<code>BuildPath</code>每个资产组中指定的目录中提供内容。</p>
<h2 id="Profile配置文件设定"><a href="#Profile配置文件设定" class="headerlink" title="Profile配置文件设定"></a>Profile配置文件设定</h2><p>在开发期间使用托管服务时，Unity建议创建一个配置文件，该配置文件使用专门为此目的创建的一个或多个目录来配置所有资产组以从托管服务加载内容。</p>
<p>在“ 可寻址”窗口菜单（“ 窗口” &gt;“ 资产管理” &gt;“ 可寻址资源”）中，选择“ 配置文件” &gt;“ 检查配置文件设置”。您也可以通过<code>AddressableAssetSettings</code>的<code>Inspector</code> 访问这些设置。</p>
<p>接下来，创建一个新的配置文件 在以下示例中，新配置文件称为<code>Editor Hosted</code>。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesProfiles_1.png" alt=""></p>
<p>修改加载路径字段，改为从托管服务加载。<code>HttpHostingService</code>是使用本地IP地址和分配给服务的端口的URL。在“ 主机”窗口中，您可以使用命名的配置文件变量<code>PrivateIpAddress</code>并<code>HostingServicePort</code>构造URL（例如，<code>http://[PrivateIpAddress]:[HostingServicePort]</code>）。</p>
<p>此外，您应该修改所有构建路径变量以指向Project的Assets文件夹之外的公共目录</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesProfiles_2.png" alt=""></p>
<p>验证是否正确配置了每个组。确保将路径<code>BuildPath</code>和<code>LoadPath</code>路径设置为各自的配置文件密钥，这些密钥已修改为与托管服务一起使用。在此示例中，您可以看到如何LoadPath扩展配置文件变量以构建从托管服务加载的正确基本URL。</p>
<p><img src="/2019/08/27/Unity可寻址资产系统AddressableAssetSystem/HostingServicesGroups_1.png" alt=""></p>
<p>最后，从<code>Addressables窗口</code>中选择<code>新配置文件(new profile)</code>，创建构建并部署到目标设备。Unity Editor现在通过<code>HttpHostingService</code>服务提供来自应用程序的所有加载请求。您现在可以在不重新部署的情况下对内容进行添加和更改。重建可寻址内容，然后重新启动已部署的应用程序以刷新内容。</p>
<h2 id="从批处理模式中开启服务"><a href="#从批处理模式中开启服务" class="headerlink" title="从批处理模式中开启服务"></a>从批处理模式中开启服务</h2><p>您还可以使用托管服务从以批处理模式运行的Unity编辑器中提供内容。为此，请使用以下选项从命令行启动Unity：</p>
<p><code>-batchMode -executeMethod UnityEditor.AddressableAssets.HostingServicesManager.BatchMode</code></p>
<p>这将从默认<code>AddressableAssetSettings对象</code>加载<code>Hosting Services</code>配置，并启动所有已配置的服务。</p>
<p>要使用备用<code>AddressableAssetSettings</code>配置，请创建自己的静态方法入口点，以调用<code>UnityEditor.AddressableAssets.HostingServicesManager.BatchMode(AddressableAssetSettings settings)</code>重载。</p>
<h2 id="实现自定义服务"><a href="#实现自定义服务" class="headerlink" title="实现自定义服务"></a>实现自定义服务</h2><p>实现<code>IHostingService</code>接口的脚本,您的自定义服务将显示在“ 服务类型”下拉选项中。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="镜像加载和卸载"><a href="#镜像加载和卸载" class="headerlink" title="镜像加载和卸载"></a>镜像加载和卸载</h2><p>使用可寻址资产时，确保正确内存管理的主要方法是正确镜像加载和卸载调用。如何执行此操作取决于您的资产类型和加载方法。然而，在所有情况下，release方法要么接受加载的资产，要么接受加载返回的操作句柄。</p>
<p>例如: 加载 <code>a</code>由<code>AsyncOperationHandle&lt;SceneInstance&gt;</code>,您可以通过这个返回的句柄释放它，或者通过<code>handle.Result</code>释放它。Result(在本例中是SceneInstance)。</p>
<h2 id="资产加载"><a href="#资产加载" class="headerlink" title="资产加载"></a>资产加载</h2><p>要加载资产，请使用:</p>
<ul>
<li><code>Addressables.LoadAssetAsync</code></li>
<li><code>Addressables.LoadAssetsAsync</code>。</li>
</ul>
<p><strong>这会将资产加载到内存中而不进行实例化</strong></p>
<p> Every time the load call executes, it adds one to the ref-count for each asset loaded. <strong>每次加载调用执行时，它会为每个加载的资产的ref-count添加一个。</strong></p>
<p> 如果用相同的地址调用LoadAssetAsync三次，你会得到<code>AsyncOperationHandle结构体</code>的三个 <strong>不同实例</strong>，都引用相同的底层操作。对于相应的资产，该操作的<code>ref-count</code>为3。如果加载成功，则生成的<code>AsyncOperationHandle结构</code>包含<code>.Result属性</code>中的资产.您可以使用已加载的资产使用Unity的内置实例化方法进行实例化，该方法不会增加Addressables引用计数。</p>
<p> 要卸载资产，请使用<code>Addressables.Release</code>减少<code>ref-count</code>的方法。<strong>当给定资产的引用计数为零时，该资产已准备好卸载，并减少任何依赖项的引用计数。</strong></p>
<p><strong>注意：资产可能会立即卸载，也可能不会立即卸载，具体取决于现有的依赖项。</strong></p>
<h2 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h2><p>要加载场景，请使用:</p>
<ul>
<li><code>Addressables.LoadSceneAsync</code></li>
</ul>
<p>您可以使用此方法加载场景<code>Single模式</code>，关闭所有打开的场景或<code>Additive模式</code>.</p>
<p>要卸载场景，请使用:</p>
<ul>
<li><code>Addressables.UnloadSceneAsync</code>或在Single模式下打开新场景。</li>
</ul>
<p>您可以使用Addressables界面或使用<code>SceneManager.LoadScene</code>或<code>SceneManager.LoadSceneAsync</code>方法打开新场景。打开一个新场景将关闭当前场景，正确地减少<code>ref-count</code>.</p>
<h2 id="GameObject实例化"><a href="#GameObject实例化" class="headerlink" title="GameObject实例化"></a>GameObject实例化</h2><p>要加载和实例化GameObject资产，请使用:</p>
<ul>
<li><code>Addressables.InstantiateAsync</code>。</li>
</ul>
<p>这将实例化由指定<code>location参数</code>定位的预制件。<strong>Addressables系统将加载Prefab及其依赖项，增加所有相关资产的引用计数。</strong></p>
<p><code>InstantiateAsync</code>在同一地址上调用三次会导致所有依赖资产的<code>ref-count</code>为3。<br>不像调用<code>LoadAssetAsync</code>三次,每次<code>InstantiateAsync</code>调用都会返回一个AsyncOperationHandle指向唯一操作的调用。这是因为每个实例化<code>InstantiateAsync</code>的结果都是唯一的实例。<code>InstantiateAsync</code>和其他加载调用之间的另一个区别是可选<code>trackHandle</code>参数。设置为<code>false</code>，必须<code>AsyncOperationHandle</code>在释放实例时保持使用。这更有效，但需要更多的开发工作。</p>
<p>要销毁实例化的gameObject，请使用:</p>
<ul>
<li><code>Addressables.ReleaseInstance</code>或关闭包含实例化对象的Scene。</li>
</ul>
<p>此场景可以在Additive或Single模式下加载（并因此关闭）,也可以使用<code>Addressables</code>或<code>SceneManagement</code>的API 加载此场景。如果设置trackHandle为false，则只能<code>Addressables.ReleaseInstance</code>使用句柄调用，而不能使用实际的GameObject 调用。</p>
<p><strong>注意：如果您调用<code>Addressables.ReleaseInstance</code>的是未使用<code>Addressables</code>的API 创建的实例，或者是使用该API创建的trackHandle==false，则系统会检测到该false实例并返回以指示该方法无法释放指定的实例。在这种情况下，实例不会被销毁。</strong></p>
<p><code>Addressables.InstantiateAsync</code>有一些相关的开销，所以如果你需要每帧数百次实例化相同的对象，考虑通过<code>Addressables</code>的API 加载，然后通过其他方法实例化。在这种情况下，您将调用<code>Addressables.LoadAssetAsync</code>，然后保存结果并调用<code>GameObject.Instantiate()</code>该结果。这允许以 <strong>Instantiate同步方式调用</strong>。缺点是 <strong>Addressables系统不知道您创建了多少个实例</strong>，如果管理不当，可能会导致内存问题。例如，引用纹理的预制件将不再具有要引用的有效加载纹理，从而导致渲染问题（或更糟）。这些问题可能很难追踪，因为您可能无法立即触发内存卸载.</p>
<h2 id="可寻址的分析器Profiler"><a href="#可寻址的分析器Profiler" class="headerlink" title="可寻址的分析器Profiler"></a>可寻址的分析器Profiler</h2><p>使用 <strong>Addressable Profiler窗口</strong> 监视所有Addressables系统操作的<code>引用计数</code>。要在编辑器中访问该窗口，请选择 <code>Window &gt; Asset Management &gt; Addressable Profiler</code>。</p>
<p>要点：要在分析器中查看数据，<strong>必须在对象的检查器中启用<code>Send Profiler Events</code>设置</strong> 在<code>AddressableAssetSettings</code>。</p>
<p>分析器中提供了以下信息：</p>
<ul>
<li>白色垂直线表示发生加载请求的帧。</li>
<li>蓝色背景表示当前正在加载资产。</li>
<li>图表的绿色部分表示资产的当前引用计数。</li>
</ul>
<h2 id="何时清除内存"><a href="#何时清除内存" class="headerlink" title="何时清除内存"></a>何时清除内存</h2><p>不再引用的资产（由分析器中蓝色部分的末尾表示）并不一定意味着资产已被卸载。常见的适用方案涉及资产包中的多个资产。</p>
<ul>
<li>在一个资产包(stuff材料)中有三个资产(<code>树</code>、<code>坦克</code>和<code>牛</code>)</li>
<li>当<code>树</code>加载时，分析器会显示一个<code>树</code>的<code>ref-count</code>和一个<code>stuff</code>的<code>ref-count</code>。</li>
<li>当坦克加载时，分析器将显示<code>树</code>和<code>坦克</code>的一个<code>ref-count</code>，以及<code>stuff</code>包的两个<code>ref-count</code>。</li>
<li>如果你释放<code>树</code>，它的ref-count变为零，蓝色的条就消失了。</li>
</ul>
<p>在此示例中，此时tree资产实际上未卸载。您可以加载资产包或其部分内容，但 <strong>不能部分卸载资产包。</strong> <code>stuff</code>在<code>bundle</code>本身完全卸载之前，不会卸载任何资产。<strong>此规则的例外是引擎接口<code>Resources.UnloadUnusedAssets</code>.</strong> 在上面的场景中 <strong>执行此方法将导致tree卸载</strong>。由于Addressables系统无法识别这些事件，因此探查器图仅反映了Addressables引用计数（不完全是内存的内容）。请注意，如果您选择使用<code>Resources.UnloadUnusedAssets</code>，则操作非常慢，并且只应在不显示任何故障的屏幕上调用（例如加载屏幕）。</p>
<h1 id="异步操作处理"><a href="#异步操作处理" class="headerlink" title="异步操作处理"></a>异步操作处理</h1><p><code>Addressables</code>API中的几个方法返回一个<code>AsyncOperationHandle结构</code>。此句柄的主要目的是允许访问操作的状态和结果。在您调用<code>Addressables.Release</code>或<code>Addressables.ReleaseInstance</code>执行操作之前，操作的结果是有效的.</p>
<p><strong>操作完成后，<code>AsyncOperationHandle.Status</code>属性为<code>AsyncOperationStatus.Succeeded</code>或<code>AsyncOperationStatus.Failed</code>。如果成功，您可以通过该<code>AsyncOperationHandle.Result</code>属性访问结果。</strong></p>
<p>您可以定期检查操作状态，也可以使用该<code>AsyncOperationHandle.Complete</code>事件注册完成的回调。当您不再需要返回的<code>AsyncOperationHandle结构</code>提供的资产时，您应该使用该方法释放它<code>Addressables.Release</code>。</p>
<h2 id="Type-vs-typeless-handles-类型与无类型句柄"><a href="#Type-vs-typeless-handles-类型与无类型句柄" class="headerlink" title="Type vs typeless handles(类型与无类型句柄)"></a>Type vs typeless handles(类型与无类型句柄)</h2><p>大多数<code>Addressables</code>API方法返回一个通用<code>AsyncOperationHandle&lt;T&gt;结构</code>，允许<code>AsyncOperationHandle.Completed</code>事件和<code>AsyncOperationHandle.Result</code>对象的类型安全。还有一个非泛型<code>AsyncOperationHandle</code>结构，您可以根据需要在两个句柄之间进行转换。</p>
<p>请注意，如果您尝试将<code>非泛型句柄</code>强制转换为<code>不正确类型的泛型句柄</code>，则会发生运行时异常</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> textureHandle <span class="token operator">=</span> Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"mytexture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 转换AsyncOperationHandle&lt;Texture2D> 成一个 AsyncOperationHandle:</span>
<span class="token comment" spellcheck="true">// 泛型Handle转换成非泛型Handle</span>
AsyncOperationHandle nonGenericHandle <span class="token operator">=</span> textureHandle<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 转换AsyncOperationHandle成一个 AsyncOperationHandle&lt;Texture2D>:</span>
<span class="token comment" spellcheck="true">// 非泛型Handle转换成泛型Handle</span>
AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> textureHandle2 <span class="token operator">=</span> nonGenericHandle<span class="token punctuation">.</span><span class="token generic-method function">Convert<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 会抛出异常,必须是Texture2D类型</span>
AsyncOperationHandle<span class="token operator">&lt;</span>Texture<span class="token operator">></span> textureHandle3 <span class="token operator">=</span> nonGenericHandle<span class="token punctuation">.</span><span class="token generic-method function">Convert<span class="token punctuation">&lt;</span>Texture<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="AsyncOperationHandle用例示例"><a href="#AsyncOperationHandle用例示例" class="headerlink" title="AsyncOperationHandle用例示例"></a>AsyncOperationHandle用例示例</h2><p>使用<code>AsyncOperationHandle.Completed</code>回调注册完成事件的侦听器：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 注册回调, 加载完成后调用TextureHandle_Completed</span>
    AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> textureHandle <span class="token operator">=</span> Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAsset<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"mytexture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    textureHandle<span class="token punctuation">.</span>Completed <span class="token operator">+</span><span class="token operator">=</span> TextureHandle_Completed<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">TextureHandle_Completed</span><span class="token punctuation">(</span>AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> handle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">.</span>Status <span class="token operator">==</span> AsyncOperationStatus<span class="token punctuation">.</span>Succeeded<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Texture2D result <span class="token operator">=</span> handle<span class="token punctuation">.</span>Result<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 纹理可以使用了。</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>AsyncOperationHandle</code>实现<code>IEnumerator</code>所以它可以在协同程序中产生：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> IEnumerator <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> handle <span class="token operator">=</span> Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"mytexture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token keyword">return</span> handle<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">.</span>Status <span class="token operator">==</span> AsyncOperationStatus<span class="token punctuation">.</span>Succeeded<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Texture2D texture <span class="token operator">=</span> handle<span class="token punctuation">.</span>Result<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// The texture is ready for use.</span>
        <span class="token comment" spellcheck="true">// ...</span>
        <span class="token comment" spellcheck="true">// Release the asset after its use:</span>
        Addressables<span class="token punctuation">.</span><span class="token function">Release</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Addressables</code>还通过<code>AsyncOperationHandle.Task</code>属性支持异步<code>await</code>。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> handle <span class="token operator">=</span> Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"mytexture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> handle<span class="token punctuation">.</span>Task<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 任务完成了。在存储结果之前，请确保检查状态是否成功。</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意:使用<code>SceneManager.LoadSceneAsync</code>加载场景并将<code>allowSceneActivation</code>设置为<code>false</code>或使用<code>Addressables.LoadSceneAsync</code>并为<code>activateOnLoad</code>参数传入<code>false</code>会导致随后的异步操作被阻塞，无法完成。</p>
<h1 id="自定义操作"><a href="#自定义操作" class="headerlink" title="自定义操作"></a>自定义操作</h1><p><code>IResourceProvider</code>接口 API允许您通过以数据驱动的方式定义位置和依赖项来扩展加载过程。<br>在某些情况下，您可能希望创建自定义操作。<code>IResourceProvider</code> API内部构建在这些自定义操作之上。</p>
<h2 id="创建自定义操作"><a href="#创建自定义操作" class="headerlink" title="创建自定义操作"></a>创建自定义操作</h2><p>通过从<code>AsyncOperationBase</code>类派生并覆盖所需的虚拟方法来创建自定义操作。您可以将派生操作传递给<code>ResourceManager.StartOperation</code>方法以启动操作并接收<code>AsyncOperationHandle结构</code>。以这种方式启动的操作注册到ResourceManager并出现在Addressables分析器中。</p>
<ul>
<li>执行操作</li>
</ul>
<p>ResourceManager调用<code>AsyncOperationBase.Execute</code>方法。以便在可选的依赖项操作完成后进行自定义操作。</p>
<ul>
<li>完成处理</li>
</ul>
<p>当您的自定义操作完成时，调用<code>AsyncOperationBase.Complete</code>。在自定义操作对象上。您可以在<code>Execute</code>方法中调用它，也可以将其推迟到调用的外部。调用<code>AsyncOperationBase.Complete</code>通知ResourceManager操作已经完成，并将调用关联的AsyncOperationHandle。完成事件。</p>
<ul>
<li>终止操作</li>
</ul>
<p>ResourceManager调用<code>AsyncOperationBase.Destroy</code>。释放引用<code>AsyncOperationHandle</code>时的自定义操作。这里应该释放与自定义操作关联的任何内存或资源。</p>
<h1 id="Analyze分析"><a href="#Analyze分析" class="headerlink" title="Analyze分析"></a>Analyze分析</h1><p>Analyze是一个收集有关Projects的Addressables布局信息的工具。在某些情况下，Analyze可能会采取适当的措施来清理项目的状态。在其他情况下，Analyze纯粹是一个信息工具，可让您就Addressables布局做出更明智的决策。</p>
<h2 id="使用Analyze"><a href="#使用Analyze" class="headerlink" title="使用Analyze"></a>使用Analyze</h2><p>在编辑器中，打开“ 可寻址”窗口（“ 窗口” &gt;“ 资产管理” &gt;“ 可寻址资源”），然后单击菜单中的<code>Analyze</code>按钮以打开 <code>Analyze window</code>.。</p>
<p>“分析”窗口显示“分析”规则列表以及以下操作：</p>
<ul>
<li>分析所选规则<ul>
<li>分析操作是规则的信息收集步骤。</li>
</ul>
</li>
<li>修复所选规则<ul>
<li>这使用在分析步骤期间收集的数据来执行任何必要的修改并解决问题。</li>
</ul>
</li>
<li>清除所选规则<ul>
<li>此操作将删除分析收集的所有数据并相应地更新TreeView。</li>
</ul>
</li>
</ul>
<h2 id="提供分析规则"><a href="#提供分析规则" class="headerlink" title="提供分析规则"></a>提供分析规则</h2><p>可修复的规则</p>
<ul>
<li>检查重复的组依赖关系</li>
</ul>
<p>此规则通过扫描所有组<code>BundledAssetGroupSchemas</code>并投影资产组布局来检查可能重复的资产。这基本上需要触发完整的构建，因此这种检查既耗时又耗费性能。</p>
<p><strong>问题</strong>：重复的资产是由共享依赖关系的不同组中的资产导致的，例如共享存在于不同可寻址组中的材质的两个预制体。该材质(及其任何依赖项)将被拉入包含预制块的两组中。为了防止这种情况的发生，必须将材质标记为可寻址的，或者使用预制体之一，或者在它自己的空间中，从而将材料及其依赖关系放在一个单独的可寻址组中。</p>
<p><strong>解决方案</strong>：如果此检查发现任何问题，则对此规则运行修复操作会创建一个新的可寻址组，可在其中移动所有相关资产。</p>
<p><strong>例外</strong>：如果您有一个包含多个对象的资产，则不同的组可能只会拉入部分资产，而不会实际复制。具有许多网格的FBX就是一个例子。如果一个网格在“GroupA”中而另一个在“GroupB”中，则此规则将认为FBX是共享的，如果运行修复操作，则将其提取到自己的组中。在这种边缘情况下，运行修复操作实际上是有害的，因为两个组都没有完整的FBX资产。</p>
<p>另请注意，重复的资产可能并不总是一个问题。如果资产永远不会被同一组用户请求（例如，特定于区域的资产），则可能需要重复的依赖性，或者至少是无关紧要的。每个项目都是唯一的，因此应根据具体情况评估修复重复的资产依赖性。</p>
<h2 id="无法修复的规则"><a href="#无法修复的规则" class="headerlink" title="无法修复的规则"></a>无法修复的规则</h2><ul>
<li>检查Resources找到可寻址的重复依赖项</li>
</ul>
<p>此规则检测构建的可寻址数据与驻留在Resources文件夹中的资产之间是否存在任何资产或资产依赖关系。</p>
<p><strong>问题</strong>：这些重复意味着数据将包含在应用程序构建和Addressables构建中。</p>
<p><strong>解决方案</strong>：此规则不可修复，因为不存在适当的操作。它纯粹是信息性的，提醒您冗余。您必须决定如何进行以及采取何种措施（如果有的话）。可能的手动修复的一个示例是将有问题的资产移出Resources文件夹，并使它们成为可寻址的。</p>
<ul>
<li>检查场景是否有可寻址的重复依赖项</li>
</ul>
<p>此规则检测“编辑器场景”列表和“可寻址”中场景之间共享的任何资产或资产依赖项。</p>
<p><strong>问题</strong>：这些重复意味着数据将包含在应用程序构建和Addressables构建中。</p>
<p><strong>解决方案</strong>：它纯粹是信息性的，提醒您冗余。您必须决定如何进行以及采取何种措施（如果有的话）。可能的手动修复的一个示例是从构建设置中拉出带有重复引用的内置场景，并使其成为可寻址场景。</p>
<h2 id="将自定义规则添加到GUI"><a href="#将自定义规则添加到GUI" class="headerlink" title="将自定义规则添加到GUI"></a>将自定义规则添加到GUI</h2><p>自定义规则必须使用GUI类自身注册AnalyzeWindow.RegisterNewRule<ruletype>()，才能显示在“ 分析”窗口中。例如：</ruletype></p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">MyRule</span> <span class="token punctuation">:</span> AnalyzeRule <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">[</span>InitializeOnLoad<span class="token punctuation">]</span>
<span class="token keyword">class</span> <span class="token class-name">RegisterMyRule</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">RegisterMyRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        AnalyzeWindow<span class="token punctuation">.</span><span class="token generic-method function">RegisterNewRule<span class="token punctuation">&lt;</span>MyRule<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="升级到Addressables系统"><a href="#升级到Addressables系统" class="headerlink" title="升级到Addressables系统"></a>升级到Addressables系统</h1><p>本文详细介绍了如何修改现有项目以利用可寻址资产。引用资产有三种传统方法：</p>
<ul>
<li><strong>直接引用</strong>：将资源直接添加到应用程序自动加载的组件或场景中。</li>
<li><strong>资源文件夹</strong>：将资源添加到 Resource文件夹并按文件名加载它们。</li>
<li><strong>Asset Bundles</strong>：将资产添加到资产包，然后按文件路径加载它们的依赖项。</li>
</ul>
<h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><ol>
<li>替换对具有资产引用的对象的直接引用（例如，<code>public GameObject directRefMember;</code>变为<code>public AssetReference AssetRefMember;</code>）。</li>
<li>将资源拖动到相应组件的Inspector上，就像直接引用一样。</li>
<li>如果希望基于对象而不是字符串名称加载资产，请直接从您在设置中创建的AssetReference对象实例化它（例如，<code>AssetRefMember.LoadAssetAsync&lt;GameObject&gt;();</code>或<code>AssetRefMember.InstantiateAsync(pos, rot);</code>）。</li>
</ol>
<p>注意：可寻址资产系统<code>异步</code>加载资产。更新对资产引用的直接引用时，还必须更新代码以<code>异步操作</code>。</p>
<h2 id="Resource文件夹"><a href="#Resource文件夹" class="headerlink" title="Resource文件夹"></a>Resource文件夹</h2><p>将Resources文件夹中的资产标记为Addressable时，<strong>系统会自动将资源从Resources文件夹移动到名为Resources_moved的Project中的新文件夹</strong>。移动资产的默认地址是旧路径，省略文件夹名称。例如，您的加载代码可能会更改<code>Resources.LoadAsync&lt;GameObject&gt;(&quot;desert/tank.prefab&quot;);</code>为<code>Addressables.LoadAssetAsync&lt;GameObject&gt;(&quot;desert/tank.prefab&quot;);</code>。</p>
<h2 id="AB包方法"><a href="#AB包方法" class="headerlink" title="AB包方法"></a>AB包方法</h2><p>当您打开Addressables窗口时，<strong>Unity提供将所有资产包转换为可寻址资产组</strong>。这是迁移代码的最简单方法。</p>
<p><strong>如果选择手动转换资产</strong>，请单击 <strong>忽略</strong> 按钮。然后，<strong>使用先前描述的直接引用或资源文件夹方法。</strong></p>
<p>资产地址的默认路径是其文件路径。如果您使用路径作为资产的地址，则您将以与从捆绑中加载的方式相同的方式加载资产。可寻址资产系统处理捆绑包及其所有依赖项的加载。</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
