<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        27计算限制的异步处理2 - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Parallel的静态For，ForEach和Invoke方法"><span class="toc-text">Parallel的静态For，ForEach和Invoke方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并行语言集成查询-PLINQ"><span class="toc-text">并行语言集成查询 PLINQ</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#执行定时计算限制操作"><span class="toc-text">执行定时计算限制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一些计时器类的说明"><span class="toc-text">一些计时器类的说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程池如何管理线程"><span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#设置线程池限制"><span class="toc-text">设置线程池限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何管理工作者线程"><span class="toc-text">如何管理工作者线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#缓存线和伪共享-第四版没这节"><span class="toc-text">缓存线和伪共享(第四版没这节)</span></a></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        27计算限制的异步处理2
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-09-25 00:29:55</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#CLR读书笔记" title="CLR读书笔记">CLR读书笔记</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="Parallel的静态For，ForEach和Invoke方法"><a href="#Parallel的静态For，ForEach和Invoke方法" class="headerlink" title="Parallel的静态For，ForEach和Invoke方法"></a>Parallel的静态For，ForEach和Invoke方法</h1><p>在一些常见的编程情形中，使用任务也许会提升性能。为了简化编程，静态类<code>System.Threading.Tasks.Paraller</code>封装了这些常见的情形，<strong>它内部使用Task对象</strong>。</p>
<p>例如，不要像下面一样处理一个集合中的所有项：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 不建议写法</span>
<span class="token comment" spellcheck="true">// 一个线程顺序执行这个工作(每次迭代调用一次DoWork)</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>Int32 i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">DoWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>相反，可以使用<code>Parallel</code>类型的<code>For方法</code>，让多个线程池线程辅助完成这个工作：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 建议写法</span>
<span class="token comment" spellcheck="true">// 线程池的线程并行处理工作</span>
Parallel<span class="token punctuation">.</span><span class="token function">For</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> i <span class="token operator">=</span><span class="token operator">></span> <span class="token function">DoWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>类似的，如果有一个集合，那么不要像下面这样写：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 不建议写法</span>
<span class="token comment" spellcheck="true">// 一个线程顺序执行这个工作(每次迭代调用一次DoWork)</span>
<span class="token keyword">foreach</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> item <span class="token keyword">in</span> conllection<span class="token punctuation">)</span> <span class="token function">DoWork</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 建议写法</span>
<span class="token comment" spellcheck="true">// 线程池的线程并行处理工作</span>
Parallel<span class="token punctuation">.</span><span class="token function">ForEach</span><span class="token punctuation">(</span>conllection<span class="token punctuation">,</span>item<span class="token operator">=</span><span class="token operator">></span><span class="token function">DoWork</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>如果代码中既可以用<code>For</code>，也可以用<code>ForEach</code>，那么建议使用<code>For</code></strong>，因为它执行的快一点。最后，如果要执行几个方法，那么可以顺序执行它们，如下所示：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">//  一个线程顺序执行所有方法    </span>
<span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 线程池的线程并行执行</span>
parallel<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>
            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">Method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Parallel</code>的所有方法都让调用线程参与处理。从资源利用的角度说，这是一件好事，因为我们不希望调用线程停下来(阻塞)，等待线程池做完所有工作后才继续。然而，如果调用线程在线程池完成自己的那一部分工作之前完成工作，调用程序就会将自己挂起，直到所有工作完成。这也是一件好事，因为这个提供了和普通for和foreach循环时相同的语义：线程要在所有工作后才继续运行。还要注意，如果任何操作抛出一个未处理的异常，你调用的<code>paraller方法</code>最后会抛出一个<code>AggregateException</code>。</p>
<p>当然，这并不是说需要检查自己的所有源代码，将for循环替换成Parallel.For的调用。<strong>调用Parallel的方法时，有一个前提条件务必记住：工作项要能并行执行</strong>。因此，<strong>如果工作项必须顺序执行，就不要调用Parallel的方法</strong>。另外，<strong>要避免会修改任何共享数据的工作项，因为多个线程同时处理的数据可能损坏</strong>。为了解决这个问题，一般的方法就是围绕数据访问添加<strong>线程同步锁</strong>。但是这样一来，一次就只能有一个线程访问数据，无法享受并行处理多个想带来的好处。</p>
<p>除此之外，<code>Parallel的方法</code>本身也有开销：委托对象必须分配，而针对每一个工作项，都要调用一次这些委托。如果有大量可由多个线程处理的工作项，那么也许会获得性能的提升。但是，如果只为区区几个工作项使用<code>Parallel</code>的方法，或者为处理得非常快的工作项使用<code>Parallel</code>就会得不偿失, 反而降低性能。</p>
<p><code>Parallel</code>的<code>For</code>，<code>ForEach</code>和<code>Invoke方法</code>都能接受一个<code>ParallelOptions对象</code>的重载版本。这个对象的定义如下:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">     <span class="token comment" spellcheck="true">// 存储用于配置 Parallel 类的方法的操作的选项。</span>
     <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelOptions</span>
     <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 初始化 ParallelOptions 类的新实例</span>
        <span class="token keyword">public</span> <span class="token function">ParallelOptions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 允许取消操作, 默认None</span>
        <span class="token keyword">public</span> CancellationToken CancellationToken <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 允许指定可以并发操作的最大工作项数目，默认为-1(可用CPU数)</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> MaxDegreeOfParallelism <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 指定调度器, 默认为TaskScheduler.Default</span>
        <span class="token keyword">public</span> TaskScheduler TaskScheduler <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除此之外，<code>For</code>和<code>ForEach</code>方法有一些重载版本允许传递3个委托：</p>
<ul>
<li>任务局部初始化委托(localInit)，为参与工作的每一个任务都调用一次委托。这个委托是在任务被要求处理一个工作项之前调用。</li>
<li>主体委托(body)，为参与工作的各个线程所处理的每一项都调用一次委托。</li>
<li>任务局部终结委托(localFinally)，为参与工作的每一个任务都调用一次委托。这个委托是在任务处理好派遣给它的所有工作之后调用。即使主体委托引发一个未处理的异常，也会调用它。</li>
</ul>
<p>以下示例代码演示了如何利用3个委托，计算一个目录中的所有文件的字节长度总计值：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">        <span class="token keyword">private</span> <span class="token keyword">static</span> Int64 <span class="token function">DirectoryBytes</span><span class="token punctuation">(</span>String path<span class="token punctuation">,</span> String searchPattern<span class="token punctuation">,</span> SearchOption searchOption<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 当前目录中文件的可枚举集合。</span>
            <span class="token keyword">var</span> files <span class="token operator">=</span> Directory<span class="token punctuation">.</span><span class="token function">EnumerateFiles</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> searchPattern<span class="token punctuation">,</span> searchOption<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Int64 masterTotal <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

            ParallelLoopResult result <span class="token operator">=</span> Parallel<span class="token punctuation">.</span><span class="token generic-method function">ForEach<span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Int64<span class="token punctuation">></span></span><span class="token punctuation">(</span>files<span class="token punctuation">,</span>
               <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>
               <span class="token punctuation">{</span>
                   <span class="token comment" spellcheck="true">// localInit: 每个任务开始之前调用一次</span>
                   <span class="token comment" spellcheck="true">// 每个任务开始之前，总计值都初始化为0</span>
                   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span><span class="token punctuation">,</span>

               <span class="token punctuation">(</span>file<span class="token punctuation">,</span> parallelLoopState<span class="token punctuation">,</span> index<span class="token punctuation">,</span> taskLocalTotal<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span>
               <span class="token punctuation">{</span>
                   <span class="token comment" spellcheck="true">// body: 每个任务调用一次</span>
                   <span class="token comment" spellcheck="true">// 获得这个文件的大小，把它添加到这个任务的累加值上</span>
                   Int64 fileLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                   FileStream fs <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                   <span class="token keyword">try</span>
                   <span class="token punctuation">{</span>
                       fs <span class="token operator">=</span> File<span class="token punctuation">.</span><span class="token function">OpenRead</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
                       fileLength <span class="token operator">=</span> fs<span class="token punctuation">.</span>Length<span class="token punctuation">;</span>
                   <span class="token punctuation">}</span>
                   <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 忽略拒绝访问的文件 */</span> <span class="token punctuation">}</span>
                   <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fs <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> fs<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
                   <span class="token keyword">return</span> taskLocalTotal <span class="token operator">+</span> fileLength<span class="token punctuation">;</span>
               <span class="token punctuation">}</span><span class="token punctuation">,</span>

               taskLocalTotal <span class="token operator">=</span><span class="token operator">></span>
               <span class="token punctuation">{</span>
                   <span class="token comment" spellcheck="true">// localFinally: 每个任务完成后调用一次</span>
                   <span class="token comment" spellcheck="true">// 将这个任务的总计值(taskLocalTotal)加到中的总计值(masterTotal)上去</span>
                   Interlocked<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> masterTotal<span class="token punctuation">,</span> taskLocalTotal<span class="token punctuation">)</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> masterTotal<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个任务都通过<code>taskLocalTotal</code>变量为分配给它的文件维护自己的总计值。每个任务完成工作之后，都调用<code>Interlocked.Add方法</code><strong>[对两个 32 位整数进行求和并用和替换第一个整数]，以一种线程安全的方式更新总的总计值</strong>。由于每个任务都有自己的总计值，可以在一个工作项处理期间，无需进行线程同步。由于线程同步会造成性能的损失，所以不需要线程同步是一件好事。<strong>只有在每个任务返回之后，masterTotal才需要以一种线程安全的方式更新materTotal变量</strong>。所以，因为调用<code>Interlocked.Add</code>方法而造成的性能损失每个任务只发生一次，而不会每个工作项都发生。</p>
<p>注意，我们向主体委托传递一个<code>ParallelLoopState</code>对象，它的定义如下：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">// 可用来使 Parallel 循环的迭代与其他迭代交互</span>
    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelLoopState</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获取循环的任何迭代是否已引发相应迭代未处理的异常</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> IsExceptional <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 获取循环的任何迭代是否已调用 Stop</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> IsStopped <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 获取从中调用 Break 的最低循环迭代。</span>
        <span class="token keyword">public</span> <span class="token keyword">long</span><span class="token operator">?</span> LowestBreakIteration <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 获取循环的当前迭代是否应基于此迭代或其他迭代发出的请求退出。</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> ShouldExitCurrentIteration <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 告知 Parallel 循环应在系统方便的时候尽早停止执行当前迭代之外的迭代。</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Break</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 告知 Parallel 循环应在系统方便的时候尽早停止执行。</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参与工作的每一个任务都会获得它自己的<code>ParallelState</code>对象，并可通过这个对象和参与工作的其他任务进行交互。<code>Stop方法</code>告诉循环停止处理任何更多的工作，未来对IsStopped属性的查询会返回true。<code>Break方法</code>告诉循环不再继续处理当前项之后的项。例如，假如<code>ForEach</code>被告知要处理100项，并在第5项时调用了Break，那么循环会确保前5项处理好之后，ForEach才返回。但注意，这并不是说在这100项中，只有前5项被处理，也许第5项之后可能在以前已经处理过了。<code>LowestBreakIteration</code>属性返回在处理过程中调用过Break方法的最低的项。从来没有调用过Break，LowestBreakIteration会返回null.</p>
<p>处理任何一项时，如果造成一个未处理的异常，<code>IsExceptional</code>属性会返回true。如果处理一项时会花费大量的时间，代码可查询<code>ShouldExitCurrentIteration属性</code>看它是否应该提前退出。如果调用过Stop，调用过Break，取消过CancellationTokenSource，或者处理一项时造成了未处理的异常，这个属性就会返回true。</p>
<p>Parallel的For和ForEach方法都返回一个<code>ParallelLoopResult</code>实例，他看起来像下面这样：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">// 可以根据以下两属性判断某个线程调用Break方法还是Stop方法</span>
    <span class="token keyword">public</span> <span class="token keyword">struct</span> ParallelLoopResult
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果操作提前终止, 以下方法返回false</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> IsCompleted <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 获取从中调用 System.Threading.Tasks.ParallelLoopState.Break() 的最低迭代的索引。</span>
        <span class="token keyword">public</span> <span class="token keyword">long</span><span class="token operator">?</span> LowestBreakIteration <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可通过检查属性来了解循环的结果，如果<code>IsCompleted</code>返回true。表明循环运行完成，所有项都得到了处理。如果<code>IsCompleted</code>为false，而且<code>LowestBreakIteration</code>为null，表明参与工作的某个线程调用了Stop方法。如果<code>LowestBreakIteration</code>返回false，而且<code>LowestBreakIteration</code>不为null，表名参与工作的某个线程调用的Break方法，<code>LowestBreakIteration</code>返回的Int64值指明了保证已得到处理的最低一项的索引。 如果抛出异常, 应捕捉AggregateException来得体地恢复.</p>
<h1 id="并行语言集成查询-PLINQ"><a href="#并行语言集成查询-PLINQ" class="headerlink" title="并行语言集成查询 PLINQ"></a>并行语言集成查询 PLINQ</h1><p>Microsoft的<code>语言集成查询(LINQ)功能</code>提供了一个简捷的语法来<strong>查询数据集合</strong>。使用LINQ，可轻松对数据线进行筛选、排序、投射等。<strong>使用<code>LINQ to Object</code>时，只有一个线程顺序处理数据集合中的所有项；我们称为顺序查询</strong>。为了提高处理性能，可以使用<code>并行LINQ(Parallel LINQ)</code>，<strong>它将顺序查询转换成为一个并行查询</strong>，在内部使用任务(这些任务的排列由默认TaskScheduler来调度)，将集合中的数据项的处理工作分散到多个CPU上，一边并发处理多个数据。和Prarllel的方法相似，如果同时要处理大量项，或者每一项的处理过程都是一个耗时的计算限制的操作，那么就可以使用<code>PLINQ</code>获得最大的收益。</p>
<p>静态<code>System.Linq.ParallelEnumerable</code>类(<code>在System.Core.dll</code>中定义)实现了<code>PLINQ</code>的所有功能，所以必须通过C#的using指令将System.Linq命名空间导入到你的源码中。尤其是，<strong>这个类公开了所有标准LINQ操作符的并行版本</strong>，比如<code>Where</code>，<code>Select</code>，<code>SelectMany</code>，<code>GroupBy</code>，<code>Join</code>，<code>Skip</code>，<code>Task</code>等。所有这些方法都是扩展了<code>System.Linq.ParallelQuery&lt;T&gt;类型</code>的扩展方法。</p>
<p>为了让自己的<code>LINQ to Object</code>查询调用这些方法的并行版本，必须将自己的<strong>顺序查询</strong>(基于<code>IEnumberable</code>或者<code>IEnumerable&lt;T&gt;</code>)转换成<strong>并行查询</strong>(基于<code>ParallelQuery</code>或者<code>ParallelQuery&lt;T&gt;</code>)，这是用<code>ParallelEnumerable</code>的<code>AsParallel</code>扩展方法来实现的，如下所示：</p>
<p><code>public static ParallelQuery&lt;TSource&gt; AsParallel&lt;TSource&gt;(this IEnumerable&lt;TSource&gt; source)</code></p>
<p>下面是将一个顺序查询转换成并行查询的例子。查询返回的是一个程序集中定义的所有过时(obsolete)方法。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span>
 <span class="token punctuation">{</span>
     <span class="token punctuation">[</span><span class="token function">Obsolete</span><span class="token punctuation">(</span><span class="token string">"过时函数不应使用"</span><span class="token punctuation">,</span> <span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testobsolete</span><span class="token punctuation">(</span><span class="token keyword">bool</span> a<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>

     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>

 <span class="token keyword">class</span> <span class="token class-name">Program</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token function">ObsoleteMethods</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">)</span><span class="token punctuation">.</span>Assembly<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">ObsoleteMethods</span><span class="token punctuation">(</span>Assembly assembly<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">var</span> query <span class="token operator">=</span>
             <span class="token keyword">from</span> type <span class="token keyword">in</span> assembly<span class="token punctuation">.</span><span class="token function">GetExportedTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AsParallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 将顺序查询转换成并行查询</span>
             <span class="token keyword">from</span> method <span class="token keyword">in</span> type<span class="token punctuation">.</span><span class="token function">GetMethods</span><span class="token punctuation">(</span>BindingFlags<span class="token punctuation">.</span>Public <span class="token operator">|</span> BindingFlags<span class="token punctuation">.</span>Instance <span class="token operator">|</span> BindingFlags<span class="token punctuation">.</span>Static<span class="token punctuation">)</span>
             <span class="token keyword">let</span> obsoleteAttrType <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>ObsoleteAttribute<span class="token punctuation">)</span>
             <span class="token keyword">where</span> Attribute<span class="token punctuation">.</span><span class="token function">IsDefined</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obsoleteAttrType<span class="token punctuation">)</span>
             <span class="token keyword">orderby</span> type<span class="token punctuation">.</span>FullName
             <span class="token keyword">let</span> obsoleteAttrObj <span class="token operator">=</span> <span class="token punctuation">(</span>ObsoleteAttribute<span class="token punctuation">)</span> Attribute<span class="token punctuation">.</span><span class="token function">GetCustomAttribute</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> obsoleteAttrType<span class="token punctuation">)</span>
             <span class="token keyword">select</span> String<span class="token punctuation">.</span><span class="token function">Format</span><span class="token punctuation">(</span><span class="token string">"Type={0}\nMethod={1}\nMessage={2}\n"</span><span class="token punctuation">,</span> type<span class="token punctuation">.</span>FullName<span class="token punctuation">,</span> method<span class="token punctuation">.</span><span class="token function">ToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> obsoleteAttrObj<span class="token punctuation">.</span>Message<span class="token punctuation">)</span><span class="token punctuation">;</span>

         <span class="token comment" spellcheck="true">// 显示结果</span>
         <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> result <span class="token keyword">in</span> query<span class="token punctuation">)</span>
             Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 控制台输出:         </span>
<span class="token comment" spellcheck="true">// Type    = ConsoleApplication.MyClass</span>
<span class="token comment" spellcheck="true">// Method  = Void testobsolete(Boolean)</span>
<span class="token comment" spellcheck="true">// Message = 过时函数不应使用</span>

     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在一个查询中，可以从执行<code>并行操作</code>切换回执行<code>顺序操作</code>，这是通过调用<code>ParallelEnumerable</code>的<code>AsSequential方法</code>做到的.</p>
<p><code>public static IEnumerable &lt;TSource&gt; AsSequential&lt;TSource&gt;(this ParallelQuery&lt;TSource&gt; source)</code></p>
<p>这个方法将一个<code>ParallQuery&lt;T&gt;</code>转换回一个<code>IEnumerable&lt;T&gt;</code>。这样一来，在调用了<code>AsDequential</code>之后执行的操作将只由一个线程执行。</p>
<p>通常，一个<code>LINQ查询</code>的结果数是让某个线程执行一个<code>foreach语句</code>计算获得的。这意味着只有一个线程遍历查询的所有结果。如果希望以并行的方式处理查询的结果，就应该使用<code>ParallelEnumerable</code>的<code>ForAll</code>方法处理查询：</p>
<p><code>static void ForAll&lt;TSource&gt;(this ParallelQuery&lt;TSource&gt; source,Action&lt;TSource&gt; action)</code></p>
<p>这个方法允许多个线程同时处理结果，可以修改前面的代码来使用该方法：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// (单线程对结果进行操作)显示结果</span>
<span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token keyword">var</span> result <span class="token keyword">in</span> query<span class="token punctuation">)</span>
    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//(多线程同时处理结果)显示结果</span>
query<span class="token punctuation">.</span><span class="token function">ForAll</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span>WriteLine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而，<strong>让多个线程同时调用<code>Console.WriteLine</code>反而会损害性能</strong>，因为<code>Console类</code>内部会对线程进行同步，<strong>确保每次只有一个线程</strong> 能访问控制台程序窗口，避免来自多个线程的文本最后显示成一团乱麻。<strong>希望为每个结果都执行计算时，才使用ForAll方法</strong>。</p>
<p>由于<code>PLINQ</code>可用多个线程处理数据项，所以数据项被并发处理，<strong>结果被无序返回</strong>。如果需要让<code>PLINQ</code>保存数据项的顺序，可调用<code>ParallelEnumerable</code>的<code>AsOrderd</code>方法。调用这个方法时，线程会成组处理数据项。然后，这些数据项被合并回去，以保持顺序。这样会损害到性能。</p>
<p>以下操作符<strong>生成不排序</strong>的操作：<code>Distinct</code>，<code>Except</code>，<code>Intersect</code>，<code>Union</code>，<code>Join</code>，<code>GroupBy</code>，<code>GroupJoin</code>和<code>ToLookup</code>。在这些操作符之后，如果想再次强制排序，只需调用<code>AsOrdered</code>方法。</p>
<p>以下操作符<strong>生成排序</strong>的操作：<code>OrderBy</code>，<code>OrderByDescending</code>，<code>Thenby</code>和<code>ThenByDescending</code>。在这些出操作符之后，如果想再次恢复不排序的处理，只需调用<code>AsUnordered</code>方法。</p>
<p>PLINQ提供了一些额外的<code>ParallelEnumerable</code>方法，可调用它们来控制查询的处理方式：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// 设置要与查询关联的 CancellationToken</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> <span class="token generic-method function">WithCancellation<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source<span class="token punctuation">,</span> CancellationToken cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 设置要在查询中使用的并行度。 并行度是将用于处理查询的同时执行的任务的最大数目。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> <span class="token generic-method function">WithDegreeOfParallelism<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source<span class="token punctuation">,</span> <span class="token keyword">int</span> degreeOfParallelism<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 设置查询的执行模式。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> <span class="token generic-method function">WithExecutionMode<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source<span class="token punctuation">,</span> ParallelExecutionMode executionMode<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//设置此查询的合并选项，它指定查询对输出进行缓冲处理的方式。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> <span class="token generic-method function">WithMergeOptions<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> ParallelQuery<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source<span class="token punctuation">,</span> ParallelMergeOptions mergeOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>显然，<code>WithCancellation</code>方法允许传递一个<code>CancellationToken</code>，使查询处理能提前停止。<code>WithDegreeOfParallelism</code>方法指定最多允许多少个线程处理查询；他不会强迫创建满全部线程，如果并不是全部都需要的话。你一般不会调用这个方法。另外，默认情况下，会为每个内核用一个线程来执行查询。但如果想空出一些内核做其他工作, 可调用<code>WithDegreeOfParallelism</code>并传递小于可用内核数的一个数字. 另外, 如果查询要执行同步I/O操作,还可传递比内核数大的数字, 因为线程会在这些操作期间阻塞, 这虽然会浪费更多线程, 但我强烈建议不要在服务器应用程序中执行同步I/O操作.</p>
<p>PLINQ分析一个查询，然后决定如何最好地处理它。有的时候，顺序处理一个查询可以获得更好的性能，尤其在使用以下任何操作时：<code>Concat</code>，<code>ElementAt(OrDefault)</code>，<code>First(OrDefault)</code>，<code>Last(OrDefault)</code>，<code>Skip(While)</code>，<code>Task(While)</code>或<code>Zip</code>。使用<code>Select(Many)</code>或<code>Where</code>的重载版本，并向你的<code>selector</code>或<code>predicate</code>委托传递一个位置索引时也是如此。然而，可以调用<code>WithExecutionMode</code>，向它传递某个<code>ParallelExecuteMode</code>标志，从而强迫查询以并行方式处理：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">enum</span> ParallelExecutionMode
<span class="token punctuation">{</span>
    Default <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>           <span class="token comment" spellcheck="true">// 让并行LINQ决定处理查询的最佳方式</span>
    ForceParallelism <span class="token operator">=</span> <span class="token number">1</span>   <span class="token comment" spellcheck="true">// 强迫查询以其并行方式处理</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如前所述，并行LINQ让多个线程处理数据项，结果必须再合并回去。可调用<code>WithMergeOptions</code>向它传递以下某个<code>ParallelMargeOptions</code>标志，从而控制这些结果的缓冲和合并方式：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">    <span class="token comment" spellcheck="true">// 指定查询中要使用的输出合并的首选类型。 换言之，它指示 PLINQ 如何将多个分区的结果合并回单个结果序列。 这仅是一个提示，系统在并行处理所有查询时可能不会考虑这一点。</span>
    <span class="token keyword">public</span> <span class="token keyword">enum</span> ParallelMergeOptions
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//   使用默认合并类型，即 AutoBuffered。</span>
        Default <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">//  不利用输出缓冲区进行合并。 一旦计算出结果元素，就向查询使用者提供这些元素。</span>
        NotBuffered <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">//  利用系统选定大小的输出缓冲区进行合并。 在向查询使用者提供结果之前，会先将结果累计到输出缓冲区中。</span>
        AutoBuffered <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>

        <span class="token comment" spellcheck="true">//   利用整个输出缓冲区进行合并。 在向查询使用者提供任何结果之前，系统会先累计所有结果。</span>
        FullyBuffered <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这些选项使你能在某种程度上控制速度和内存消耗的对应关系。<code>NotBuffered</code> 最省内存，但处理速度慢一些。<code>FullyBuffered</code> 消耗较多内存，但运行得最快。<code>AutoBuffered</code> 介于<code>NotBuffered</code>和<code>FullyBuffered</code> 之间，最好亲自试验所有选项，并对比其性能，来选择那种方式。</p>
<h1 id="执行定时计算限制操作"><a href="#执行定时计算限制操作" class="headerlink" title="执行定时计算限制操作"></a>执行定时计算限制操作</h1><p><code>System.Threading</code>命名空间定义了一个<code>Timer类</code>，可用它让一个线程池线程定时调用一个方法。构造<code>Timer</code>类的一个实例相当于告诉线程池：在将来的某个时间会回调你的一个方法。Timer类提供了几个构造函数，相互都非常相似：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> MarshalByRefObject<span class="token punctuation">,</span> IDisposable
<span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>TimerCallback callback<span class="token punctuation">,</span> <span class="token keyword">object</span> state<span class="token punctuation">,</span> <span class="token keyword">int</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">int</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>TimerCallback callback<span class="token punctuation">,</span> <span class="token keyword">object</span> state<span class="token punctuation">,</span> <span class="token keyword">long</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">long</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>TimerCallback callback<span class="token punctuation">,</span> <span class="token keyword">object</span> state<span class="token punctuation">,</span> TimeSpan dueTime<span class="token punctuation">,</span> TimeSpan period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Timer</span><span class="token punctuation">(</span>TimerCallback callback<span class="token punctuation">,</span> <span class="token keyword">object</span> state<span class="token punctuation">,</span> <span class="token keyword">uint</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">uint</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>4个构造器以完全一样的方式构造<code>Timer</code>对象。</p>
<p><code>callback参数</code>标识希望由一个线程池线程回调的方法。当然，你写的对调方法必须和<code>System.Threading.TimerCallback委托</code>类型匹配，如下所示：</p>
<p><code>delegate void TimerCallback(Object state);</code></p>
<p><code>state参数</code>允许在每次调用回调方法时都像它传递状态数据；如果没有需要传递的状态数据，可以传递null。</p>
<p><code>dueTime参数</code>告诉CLR在<strong>首次调用回调方法之前要等待多少毫秒</strong>。可以使用一个有符号或无符号的32位值，一个有符号的64位值或者一个<code>TimeSpan值</code>指定毫秒数。如果希望回调方法立即调用，为<code>dueTime参数</code>指定0即可。</p>
<p>最后一个<code>period周期</code>参数指定了以后每次调用回调方法需要等待的时间(毫秒)。<strong>如果为这个参数传递<code>Timeout.Infinite(-1)</code>，线程池线程值调用回调方法一次</strong>。</p>
<p>在内部，线程池为所有<code>Timer对象</code>只使用了一个线程。这个线程知道下一个<code>Timer对象</code>在什么时候到期。下一个<code>Timer对象</code>到期时，线程就会唤醒，在内部调用<code>TreadPool</code>的<code>QueueUserWorkItem</code>，将一个工作项添加到线程池队列中，使你的回调方法得到调用。如果回调方法的执行时间很长，计时器可能(在上个回调还没有完成时)再次触发。这个能造成多个线程同时执行你的回调方法。为解决这个问题，<strong>我的建议是：构造<code>Timer</code>时，为<code>period</code>参数指定<code>Timeout.Infinite</code>。这样，计时器就只触发一次</strong>。然后，在你的回调方法中，调用<code>Change</code>方法指定一个新的<code>dueTime</code>，并再次为<code>period参数</code>指定<code>Timeout.Infinite</code>。</p>
<p>以下是<code>Change</code>方法的各个重载版本.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> MarshalByRefObject<span class="token punctuation">,</span> IDisposable
<span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token keyword">int</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">int</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token keyword">long</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">long</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Change</span><span class="token punctuation">(</span>TimeSpan dueTime<span class="token punctuation">,</span> TimeSpan period<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Change</span><span class="token punctuation">(</span><span class="token keyword">uint</span> dueTime<span class="token punctuation">,</span> <span class="token keyword">uint</span> period<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>Timer</code>类还提供了<code>Dispose</code>方法，允许完全取消计时器，并可在当时处于pending状态的所有回调完成之后，向<code>notifyObject参数</code>标识的内核对象发送信号。以下是Dispose方法的各个重载版本：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Timer</span> <span class="token punctuation">:</span> MarshalByRefObject<span class="token punctuation">,</span> IDisposable
<span class="token punctuation">{</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Dispose</span><span class="token punctuation">(</span>WaitHandle notifyObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>提示：一个<code>Timer</code>对象被<strong>垃圾回收</strong>时，它的<strong>终结代码</strong>告诉线程池取消计时器，使它不再触发。所以，使用一个<code>Timer</code>对象时，<strong>要确定有一个变量在保持Timer对象的存活</strong>，否则对你的回调方法调用就会停止。</p>
<p>以下代码演示了如何让一个线程池线程立即开始调用一个回调方法，以后每2秒钟调用一次：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Timer s_timer<span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>

        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"每2秒检查一次状态"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 创建但不启动计时器</span>
        <span class="token comment" spellcheck="true">// 确保s_timer在线程池线程调用 Status 之前引用该计时器</span>
        s_timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>Status<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 现在s_timer已被赋值, 可以启动计时器</span>
        <span class="token comment" spellcheck="true">// 现在在Status中调用Change, 保证不会抛出NullReferenceException</span>
        <span class="token comment" spellcheck="true">// (防止被垃圾回收, 确定有一个变量在保持Timer对象的存活)</span>
        s_timer<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 防止进程终止</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 这个方法签名必须匹配 TimerCallback 委托匹配</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Status</span><span class="token punctuation">(</span>Object state<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这个方法由一个线程池线程执行</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"In Status at {0}"</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Thread<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 模拟其他工作1秒钟</span>

        <span class="token comment" spellcheck="true">// 返回前放Timer在2秒后再次触发</span>
        s_timer<span class="token punctuation">.</span><span class="token function">Change</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> Timeout<span class="token punctuation">.</span>Infinite<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 这个方法返回后, 线程回归池中, 等待下一个工作项</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// In Status at 2019/9/26 12:58:50</span>
<span class="token comment" spellcheck="true">// In Status at 2019/9/26 12:58:53</span>
<span class="token comment" spellcheck="true">// In Status at 2019/9/26 12:58:56</span>
<span class="token comment" spellcheck="true">// In Status at 2019/9/26 12:58:59</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要定时执行的操作, 可以利用<code>Task</code>的<code>静态Delay</code>方法和C#的<code>async</code>和<code>await</code>关键字.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
     <span class="token keyword">private</span> <span class="token keyword">static</span> Timer s_timer<span class="token punctuation">;</span>

     <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"每2秒检查一次状态"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

         Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 防止进程终止</span>
     <span class="token punctuation">}</span>

     <span class="token comment" spellcheck="true">// 这个方法可获取你想要的任何参数</span>
     <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">async</span> <span class="token keyword">void</span> <span class="token function">Status</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token keyword">true</span><span class="token punctuation">)</span>
         <span class="token punctuation">{</span>
             Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"检查Status在 {0}"</span><span class="token punctuation">,</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment" spellcheck="true">// 要检查的代码放到这里.</span>

             <span class="token comment" spellcheck="true">// 在循环末尾, 在不阻塞线程的前提下延迟2秒</span>
             <span class="token keyword">await</span> Task<span class="token punctuation">.</span><span class="token function">Delay</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// await 允许线程返回</span>
             <span class="token comment" spellcheck="true">// 2秒之后, 某个线程会在await之后介入并继续循环</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 检查Status在 2019/9/26 13:09:14</span>
<span class="token comment" spellcheck="true">// 检查Status在 2019/9/26 13:09:16</span>
<span class="token comment" spellcheck="true">// 检查Status在 2019/9/26 13:09:18</span>
<span class="token comment" spellcheck="true">// 检查Status在 2019/9/26 13:09:20</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在不阻塞线程的前提下延迟2秒<code>await Task.Delay(2000);</code> <strong>await 允许线程返回,2秒之后, 某个线程会在await之后介入并继续循环</strong>.</p>
<h2 id="一些计时器类的说明"><a href="#一些计时器类的说明" class="headerlink" title="一些计时器类的说明"></a>一些计时器类的说明</h2><p>FCL事实上提供了几个计时器，大多是开发人员都不清楚每个计时器到底有什么独到之处，在这里试着解释一下：</p>
<ul>
<li><code>System.Threading</code>的<code>Timer类</code>    <ul>
<li>这是刚刚讨论过的计时器。要在一个<strong>线程池线程上</strong>执行定时的(周期性发生的)后台任务，<strong>它是最好的计时器</strong>。</li>
</ul>
</li>
<li><p><code>System.Windows.Forms</code>的<code>Timer类</code>    </p>
<ul>
<li>构造这个类的一个实例，相当于告诉Windows将一个计时器和调用线程关联。当这个计时器触发时，WIndows将一条计时器消息(WM_TIMER)注入线程的消息队列。线程必须执行一个消息泵来提取这些消息，并把它们派遣给想要的回调方法。注意，<strong>所有这些工作都只有一个线程完成——设置计时器的线程保证就是执行回调方法的线程。这还意味着你的计时器方法不会由多个线程并发执行</strong>。</li>
</ul>
</li>
<li><p><code>System.Windows.Threading</code>的<code>DispatcherTimer类</code></p>
<ul>
<li>这个类是 <code>System.Windows.Forms</code>的<code>Timer类</code>在Siverlight和WPF应用程序中的等价物。</li>
</ul>
</li>
<li><p><code>System.Timers</code>的<code>Timer类</code></p>
<ul>
<li>这个计时器基本是<code>System.Threading</code>的<code>Timer类</code>的一个<strong>包装类</strong>。<strong>当计时器到触发时，会导致CLR将事件放到线程池的队列中</strong>。尽量不要使用这个类而是使用System.Threading的Timer类。</li>
</ul>
</li>
</ul>
<h1 id="线程池如何管理线程"><a href="#线程池如何管理线程" class="headerlink" title="线程池如何管理线程"></a>线程池如何管理线程</h1><p>讨论线程池如何管理工作者线程和I/O线程. 最好是将线程池看做一个黑盒.</p>
<h2 id="设置线程池限制"><a href="#设置线程池限制" class="headerlink" title="设置线程池限制"></a>设置线程池限制</h2><p>CLR允许开发人员设置线程池要创建最大线程数。但实践证明，<strong>线程池永远都不该为池中的线程数设置上限，因为可能发生饥饿或死锁</strong>。假如队列中有1000个工作项，但这些工作项全都因为一个事件而阻塞，等1001个工作项发出信号才能解除阻塞。如果设置最大1000个线程，第1001个工作项就不会执行，所有1000个线程都会一直阻塞，最终用户被迫终止应用程序，并丢失他们都做的为保存的工作。</p>
<p>由于存在饥饿和死锁问题，CLR团队一直都在稳步地增加线程默认能够拥有的最大线程数。目前默认值是最大1000个线程。这基本可以看成是不限数量的，因为一个32位进程最大有2G的可用选址空间。加载一组Win32和CLR DLLs，并分配了本地堆和托管堆之后，剩余约1.5G的地址控制。由于每个线程都要为其用户模式栈和线程环境块(TEB)准备超过1MB的内存，所以一个32位进程中，最多能够有1360个线程。试图创建更多的线程，会抛出一个OutOfMemotyExcption。当然，64位进程提供了8TB的地址空间,所以理论上可以创建千百万个线程.</p>
<p><code>System.Threading.ThreadPool类</code>提供了几个静态方法，可调用它们设置和查询线程池的线程数：<code>GetMaxThreads</code>，<code>SetMaxThreads</code>，<code>GetMinThreads</code>，<code>SetMinThreads</code>和<code>GetAvailableThreads</code>[获得可用的线程数量]。强烈建议你不要调用上述任何方法。限制线程池的线程数，一般只会造成应用程序性能变得更差。</p>
<h2 id="如何管理工作者线程"><a href="#如何管理工作者线程" class="headerlink" title="如何管理工作者线程"></a>如何管理工作者线程</h2><p>下图展示了构成线程池的一部分的工作者线程的各种数据结构。<code>ThreadPool.QueueUserWorkItem</code>方法和<code>Timer类</code>总是将<strong>工作项放到全局队列中</strong>。工作者线程采用一个<strong>先入先出</strong>算法将工作项从这个队列中取出来，并处理它们。由于多个工作者线程可能同时从全局队列中拿走工作项，所以所有工作者线程都竞争一个<strong>线程同步锁</strong>，<strong>以保证两个或多个线程不会获取同一个工作项</strong>。这个线程同步锁在某些应用程序中可能成为瓶颈，对伸缩性和性能造成某种程序的限制</p>
<p><img src="/2019/09/25/000000目录-CLR读书笔记/27计算限制的异步处理2/QQ截图20190926133331.png" alt=""></p>
<p>现在，让我们谈谈使用默认<code>TaskScheduler</code>(通过查询<code>TaskScheduler</code>的静态<code>Default</code>属性来获得)来调度的<code>Task</code>对象。当一个非工作者线程调度一个<code>Task</code>时，<code>Task</code>会添加到<strong>全局队列</strong>中。</p>
<p>但是，每个工作者线程都有它自己的本地队列。当一个<strong>工作者线程</strong>调度一个<code>Task</code>时，<code>Task</code>会添加到调用线程的本地队列中。</p>
<p>一个<strong>工作者线程</strong>准备好处理一个工作项时，它总是先检查它的<strong>本地队列</strong>来查找一个<code>Task</code>。存在一个Task，工作者线程就从它的本地队列中移出<code>Task</code>,并对工作项进行处理。要注意的是，工作者线程采用<strong>后入先出</strong>的算法将任务从它的本地队列中取出。由于工作者线程是唯一允许访问它自己的本地队列列头的线程，所以<strong>无需同步锁</strong>，而且在队列中添加和删除Task的速度非常快。这个行为的副作用在于，<strong>Task是按照和进入队列时相反的顺序执行的</strong>。</p>
<p>重要提示：<strong>线程池从来不保证排队中的工作项的处理顺序</strong>，这是合理的，尤其考虑到多线程可能同时处理工作项。然而，<strong>上述副作用使得这个问题变得更加恶化。你必须保证自己的应用程序对工作项或Task的执行顺序不做任何预设</strong>。</p>
<p>如果一个<strong>工作者线程</strong>发现它的本地队列变空了，<strong>工作者线程就会尝试从另一个工作者线程的本例队列中”偷”一个Task</strong>。这个Task是从一个本地队列的<strong>尾部</strong>“偷”走的，并要求获得一个线程同步锁，这对性能可能有少许影响。当然，这种”偷窃”行为很少发生，所以很少需要获取这个锁。</p>
<p>如果所有本地队列都变空，那么<strong>工作者线程</strong>会使用FIFO(先进先出)算法，从全局队列中提取一个工作项。</p>
<p>如果全局队列也为空，那么线程就会进入睡眠状态，等待事情的发生。如果睡眠的时间太长，它会自己醒来，并销毁自己，允许系统回收线程使用的资源(包括内核对象、栈、TEB等)。</p>
<p>线程池会快速创建工作者线程，使工作者线程的数量等于传给<code>ThreadPool</code>的<code>SetMinThreads</code>方法的值。如果从不调用这个方法(也不建议你调用)，那么默认值等于你的进程允许使用的CPU数，这是由线程的affinity mask(关联掩码)决定的。通常，你的进程允许使用机器上的所有CPU数，所以线程池创建的工作者线程数量很快就会达到机器上的CPU数。创建了这么多的的线程后，线程池会监视工作项的完成速度。如果工作项完成的时间太长，线程池会创建更多的工作者线程。如果工作项的完成速度开始变快，工作者线程会被销毁。</p>
<h1 id="缓存线和伪共享-第四版没这节"><a href="#缓存线和伪共享-第四版没这节" class="headerlink" title="缓存线和伪共享(第四版没这节)"></a>缓存线和伪共享(第四版没这节)</h1><p>为了提升反复访问内存的性能，如今的CPU在芯片上都集成了<code>高速缓存</code>。线程首次从RAM去取一些值时，CPU从RAM获取所需的值，并把它存储到CPU的<code>高速缓存</code>中。事实上，为了进一步提升性能，CPU会在逻辑上将所有内存都划分为所谓的<code>缓冲行(cache line)</code>。一个缓冲行有64个字节构成，所以CPU从RAM中获取并存储64字节的块。如果应用程序需要读取一个Int32值，那么会获取包含了那个Intt32的64个字节，这样会获取到比需要的更多字节，这样通常会造成性能增强，因为大多数应用程序在访问了一些数据之后，通常会继续访问存储在那些数据周围的数据。由于相邻的数据已经提取到CPU的缓存中，就避免了慢速的RAM访问。</p>
<p>然而，如果两个或多个内核访问同一个<code>缓冲行</code>中的字节，内核必须相互通信，并在内核之间传递缓冲行，造成多个内核不能同时处理相邻的字节，这对性能会造成严重影响。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FalseSharing</span>
<span class="token punctuation">{</span>
<span class="token preprocessor property">#<span class="token directive keyword">if</span> true</span>
    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Data</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这两个字段是相邻的，并(极有可能)在相同的缓冲行中</span>
        <span class="token keyword">public</span> Int32 field1<span class="token punctuation">;</span>
        <span class="token keyword">public</span> Int32 field2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token preprocessor property">#<span class="token directive keyword">else</span></span>
<span class="token comment" spellcheck="true">// 现在，让我们修改Data类,使它看起来项下面这样</span>
<span class="token comment" spellcheck="true">// 这两个字段分开了，不再相同的缓冲行中</span>
<span class="token comment" spellcheck="true">// 比上述写法运行速度上快一些</span>
<span class="token punctuation">[</span><span class="token function">StructLayout</span><span class="token punctuation">(</span>LayoutKind<span class="token punctuation">.</span>Explicit<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token function">FieldOffset</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">public</span> Int32 field1<span class="token punctuation">;</span>
  <span class="token punctuation">[</span><span class="token function">FieldOffset</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">public</span> Int32 field2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token preprocessor property">#<span class="token directive keyword">endif</span></span>

    <span class="token keyword">private</span> <span class="token keyword">const</span>  Int32     iterations   <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Int32     s_operations <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> Stopwatch s_stopwatch<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Go</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 分配一个对象，并记录开始时间</span>
        Data data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        s_stopwatch <span class="token operator">=</span> Stopwatch<span class="token punctuation">.</span><span class="token function">StartNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// // 让零个线程访问在对象中它们自己的字段</span>
        ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> <span class="token function">AccessData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span> <span class="token function">AccessData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AccessData</span><span class="token punctuation">(</span>Data data<span class="token punctuation">,</span> Int32 field<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这里的线程各自访问它们在Data对象中自己的字段</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Int32 x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> iterations<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>field <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> data<span class="token punctuation">.</span>field1<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> data<span class="token punctuation">.</span>field2<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 不管哪个线程最后结束，都显示它花的时间</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> s_operations<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Access time: {0}"</span><span class="token punctuation">,</span> s_stopwatch<span class="token punctuation">.</span>Elapsed<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Elapsed经过的时间</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上述代码中，Data对象在构造时包含了两个字段。这两个字段极有可能在同一个缓冲行中。然后，两个线程池线程启动并执行<code>AccessData</code>方法。一个将1加到Data的filed1上的100 000 000 次，另一个线程对filed2字段做同样的事情。每个线程完成后，都递减s_operations字段中的值；最后一个将字段递减为0的线程就是最后一个结束的线程，它显示两个线程完成它们的工作总共发了多少时间。</p>
<p>在上述代码中，现在用一个缓存线(64字节)分隔两个字段。再次运行，比第一个版本快了一些。从程序角度看，两个线程处理的是不同的数据。但从CPU缓存线来看，CPU处理的是相同的数据。这称为<strong>伪共享(false sharing)</strong> 。在第二个版本中，字段在不同的缓存线上，所以CPU可以真正做到独立，不必共享什么。</p>
<p>通过上述讨论，应该知道在多个线程同时访问相邻的数据时，<code>缓存线</code>和<code>伪共享</code>可能对应用程序产生严重影响。在性能非常紧要的情形下，这是你应该注意的一点。如果检查到这个问题，通常都可以设计出一种方式来避免它(这里用的就是<code>FiledOffset attribute</code>)。</p>
<p>要注意的是，数组在数组内存起始处维护着它的长度，具体位置是在前几个数据元素之后，访问一个数组元素时，CLR验证你使用的索引在数组的长度之内。这意味着访问一个数组总是牵涉到访问数组的长度。因此，为了避免产生额外的伪共享，应该避免让一个线程向数组的前几个元素写入，同时让其他线程访问数组中的其他元素。</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
