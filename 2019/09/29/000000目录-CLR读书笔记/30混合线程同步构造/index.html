<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        30混合线程同步构造 - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#混合线程同步构造"><span class="toc-text">混合线程同步构造</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#一个简单的混合锁"><span class="toc-text">一个简单的混合锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#自旋-线程所有权和递归"><span class="toc-text">自旋,线程所有权和递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FCL中的混合构造"><span class="toc-text">FCL中的混合构造</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ManualResetEventSlim类和SemaphoreSlim类"><span class="toc-text">ManualResetEventSlim类和SemaphoreSlim类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor类和同步块"><span class="toc-text">Monitor类和同步块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ReaderWriterLockSlim类"><span class="toc-text">ReaderWriterLockSlim类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OneManyLock类"><span class="toc-text">OneManyLock类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountdownEvent类"><span class="toc-text">CountdownEvent类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Barrier类"><span class="toc-text">Barrier类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程同步构造小结"><span class="toc-text">线程同步构造小结</span></a></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        30混合线程同步构造
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-09-29 15:27:58</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#CLR读书笔记" title="CLR读书笔记">CLR读书笔记</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="混合线程同步构造"><a href="#混合线程同步构造" class="headerlink" title="混合线程同步构造"></a>混合线程同步构造</h1><p>上一章讨论了基元用户模式和内核模式线程同步构造. 其他所有线程同步构造都基于它们而构建. 讨论了FCL自带的许多混合构造.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Interlocked</span>
<span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// return (++location)</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Int32 <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token keyword">ref</span> Int32 location<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// return (--location)</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Int32 <span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> Int32 location<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// return (location1 += value)</span>
  <span class="token comment" spellcheck="true">// 注意value可能是一个负数, 从而实现减法运算</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Int32 <span class="token function">Add</span><span class="token punctuation">(</span><span class="token keyword">ref</span> Int32 location1<span class="token punctuation">,</span> Int32 <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// Int32 old = location1; location1 = value; return old;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Int32 <span class="token function">Exchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> Int32 location1<span class="token punctuation">,</span> Int32 <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// Int32 old = location1</span>
  <span class="token comment" spellcheck="true">// if(location1 == comparand) location1 = value;</span>
  <span class="token comment" spellcheck="true">// return old;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> Int32 <span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> Int32 location1<span class="token punctuation">,</span> Int32 <span class="token keyword">value</span><span class="token punctuation">,</span> Int32 comparand<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EventWaitHandle</span> <span class="token punctuation">:</span> WaitHandle
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> Boolean <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将Boolean设为true, 总是返回true</span>
   <span class="token keyword">public</span> Boolean <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将Boolean设为false, 总是返回true</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore</span> <span class="token punctuation">:</span> WaitHandle
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token function">Semaphore</span><span class="token punctuation">(</span>Int32 initialCount<span class="token punctuation">,</span> Int32 maximumCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> Int32 <span class="token function">Release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 Release(1); 返回上一个计数</span>
   <span class="token keyword">public</span> Int32 <span class="token function">Release</span><span class="token punctuation">(</span>Int32 releaseCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 返回上一个计数</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Mutex</span> <span class="token punctuation">:</span> WaitHandle
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token function">Mutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ReleaseMutex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="一个简单的混合锁"><a href="#一个简单的混合锁" class="headerlink" title="一个简单的混合锁"></a>一个简单的混合锁</h1><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// Hybrid 混合</span>
<span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">SimpleHybridLock</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Int32 由基元用户模式构造(Interlocked的方法)使用</span>
    <span class="token keyword">private</span> Int32 m_waiters <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// AutoResetEvent 时基元内核模式构造</span>
    <span class="token comment" spellcheck="true">// 自动重置事件构造(内核模式构造)</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> AutoResetEvent m_waiterLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoResetEvent</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这个线程想要获得锁</span>
        <span class="token comment" spellcheck="true">// 用户模式构造</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_waiters<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁可以自由使用,无竞争, 直接返回</span>

        <span class="token comment" spellcheck="true">// 另一个线程拥有锁(发送竞争), 使这个线程等待</span>
        m_waiterLock<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里产生较大的性能影响</span>
        <span class="token comment" spellcheck="true">// WaitOne返回后,这个线程拿到锁了</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这个线程准备释放锁</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_waiters<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 没有其他线程正在等待,直接返回</span>

        <span class="token comment" spellcheck="true">// 有其他线程正在阻塞, 唤醒其中一个</span>
        m_waiterLock<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这里产生较大的性能影响</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_waiterLock<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//较大的性能影响</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了获得出色的性能, 锁要尽量操作<code>Int32</code>, 少操作<code>AutoResetEvent</code>. 每次构造<code>SimpleHybridLock</code>对象就会创建<code>AutoResetEvent</code>比<code>Int32</code>对性能影响大的多. 多个线程同时访问锁时, 只有在第一次检测到竞争时才会创建<code>AutoResetEvent</code>, 这样就避免了性能损失.</p>
<p>调用<code>Enter</code>的第一个线程造成<code>Interlocked.Increment</code>在<code>m_waiters</code>字段上加1, 使它的值变成1. 这个线程发现以前有零个线程正在等待这个锁, 所以线程从它的<code>Enter</code>调用中返回. 如果另一个线程介入并调用Enter, 这个线程将<code>m_waiters</code>递增到2, 发现锁在另一个线程里, 所以这个线程会使用<code>AutoResetEvent</code>的<code>WaitOne</code>方法, 从而阻塞自身. 调用<code>WaitOne</code>造成线程的代码转变成内核模式的代码, 反正线程都要停止, 花费点时间来停止也不算太坏. 这样的好处就是不会因为在CPU上自旋而浪费CPU时间.</p>
<p><code>Leave</code>方法. 一个线程调用Leave时, 会调用<code>Interlocked.Decrement</code>在<code>m_waiters</code>字段上减1, 如果它的值现在是0, 表明没有其他线程在调用<code>Enter</code>时发生阻塞, 调用<code>Leave</code>的线程可以直接返回. 这个速度很快. 如果不为0, 就意味着存在竞争, 这个线程必须唤醒一个(只能一个)阻塞的线程. 唤醒线程是通过<code>m_waiterLock.Set()</code>实现, 线程必须转换成内核模式代码, 再转换回来. <code>AutoResetEvent</code>确保只有一个阻塞的线程被唤醒. <code>AutoResetEvent</code>上阻塞的其他所有线程会继续阻塞,直到新的,解除了阻塞的线程最终调用Leave.</p>
<p><img src="/2019/09/29/000000目录-CLR读书笔记/30混合线程同步构造/QQ截图20190930160208.png" alt=""></p>
<h1 id="自旋-线程所有权和递归"><a href="#自旋-线程所有权和递归" class="headerlink" title="自旋,线程所有权和递归"></a>自旋,线程所有权和递归</h1><p>由于转换为内核模式会造成巨大的性能损失, 而且线程占有锁的时间通常都很短, 所以为了提升应用程序的总体性能, <strong>可以让一个线程在用户模式中自旋一小段时间,再让线程转换为内核模式. 如果在线程正在等待的锁在线程自旋期间变得可用, 就能避免向内核模式的转换.</strong></p>
<p>此外, 有的锁限制只能由获得锁的线程释放锁, 有的锁允许当前拥有它的线程递归地拥有锁(多次拥有). <code>Mutex</code>锁就是这样的一个例子. 可通过一些别致的逻辑构建支持自旋,线程所有权和递归的一个<strong>混合锁</strong>:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">AnotherHybridLock</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// Int32 由基元用户模式构造Interlocked方法使用</span>
    <span class="token keyword">private</span> Int32 m_waiters <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// AutoResetEvent 是基元内核模式构造</span>
    <span class="token keyword">private</span> AutoResetEvent m_waiterLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoResetEvent</span><span class="token punctuation">(</span><span class="token keyword">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 这个字段控制自旋, 希望能提升性能</span>
    <span class="token keyword">private</span> Int32 m_spincount <span class="token operator">=</span> <span class="token number">4000</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用来计数</span>

    <span class="token comment" spellcheck="true">// 这些字段指出哪个线程拥有锁,以及拥有了多少次</span>
    <span class="token keyword">private</span> Int32 m_owningThreadId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> m_recursion <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果调用线程已经拥有锁, 递增递归计数并返回</span>
        Int32 threadId <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">==</span> m_owningThreadId<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            m_recursion<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 调用线程不拥有锁, 尝试获取它</span>
        SpinWait spinwait <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpinWait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Int32 spinCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> spinCount <span class="token operator">&lt;</span> m_spincount<span class="token punctuation">;</span> spinCount<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果可以自由使用, 这个线程就获得它,设置一些状态并返回</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">CompareExchange</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_waiters<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> GotLock<span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">// 黑科技: 给其他线程运行的机会,希望锁会被释放</span>
            spinwait<span class="token punctuation">.</span><span class="token function">SpinOnce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 自旋结束, 锁仍未获得,再试一次</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_waiters<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 仍然是竞态条件,这个线程必须阻塞</span>
            m_waiterLock<span class="token punctuation">.</span><span class="token function">WaitOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等待锁, 性能有损失</span>
            <span class="token comment" spellcheck="true">// 等这个线程醒来,它拥有锁, 设置一些状态并返回</span>
        <span class="token punctuation">}</span>

        GotLock<span class="token punctuation">:</span>
        <span class="token comment" spellcheck="true">// 一个线程获得锁时, 我们记录它的ID,并指出线程拥有锁1次</span>
        m_owningThreadId <span class="token operator">=</span> threadId<span class="token punctuation">;</span>
        m_recursion      <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Leave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果调用线程不拥有锁, 表明存在bug</span>
        Int32 threadId <span class="token operator">=</span> Thread<span class="token punctuation">.</span>CurrentThread<span class="token punctuation">.</span>ManagedThreadId<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>threadId <span class="token operator">!=</span> m_owningThreadId<span class="token punctuation">)</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SynchronizationLockException</span><span class="token punctuation">(</span><span class="token string">"Lock not owned by calling thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 递减递归计数,</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>m_recursion <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        m_owningThreadId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 现在没有线程拥有锁</span>

        <span class="token comment" spellcheck="true">// 如果没有其他线程, 直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Interlocked<span class="token punctuation">.</span><span class="token function">Decrement</span><span class="token punctuation">(</span><span class="token keyword">ref</span> m_waiters<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 其他线程正在等待, 唤醒一个</span>
        m_waiterLock<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 有性能损失</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_waiterLock<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出, 为锁添加额外的行为只会, 会增大它拥有的字段数量, 进而增大内存消耗. 而且这些代码必须执行,造成锁的性能下降. 这里与之前几个版本锁进行再次比较:</p>
<p><img src="/2019/09/29/000000目录-CLR读书笔记/30混合线程同步构造/QQ截图20190930163720.png" alt=""></p>
<p><code>AnotherHybridLock</code>性能不如<code>SimpleHybridLock</code>. 这是因为需要额外的逻辑和错误检查来管理线程所有权和递归行为.</p>
<h1 id="FCL中的混合构造"><a href="#FCL中的混合构造" class="headerlink" title="FCL中的混合构造"></a>FCL中的混合构造</h1><p>FCL自带了许多混合构造, 他们通过一些别致的逻辑将你的线程保持在用户模式, 从而增强应用程序的性能. 有的混合构造直到首次有线程在一个构造上发生竞争时, 才会创建内核模式的构造. 许多构造还支持使用一个<code>CancellationToken</code>参数, 使一个线程强迫解除正在构造上等待的其他线程的阻塞.</p>
<h2 id="ManualResetEventSlim类和SemaphoreSlim类"><a href="#ManualResetEventSlim类和SemaphoreSlim类" class="headerlink" title="ManualResetEventSlim类和SemaphoreSlim类"></a>ManualResetEventSlim类和SemaphoreSlim类</h2><p><code>System.Threading.ManualResetEventSlim</code>和<code>System.Threading.SemaphoreSlim</code>这两个类。这两个类的构造方式和对应的内核模式构造完全一致，只是他们都在用户模式中“自旋”，而且都推迟到第一次竞争时，才创建内核模式的构造。它们的Wait方法运行传递一个CancellationToken和一个超时值。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ManualResetEventSlim</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">ManualResetEventSlim</span><span class="token punctuation">(</span><span class="token keyword">bool</span> initialState<span class="token punctuation">,</span> <span class="token keyword">int</span> spinCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">,</span> CancellationToken cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">bool</span> IsSet <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> SpinCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> WaitHandle WaitHandle <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SemaphoreSlim</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">SemaphoreSlim</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCount<span class="token punctuation">,</span> <span class="token keyword">int</span> maxCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Release</span><span class="token punctuation">(</span><span class="token keyword">int</span> releaseCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">,</span> CancellationToken cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> Task<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">WaitAsync</span><span class="token punctuation">(</span><span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">,</span> CancellationToken cancellationToken<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> CurrentCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> WaitHandle AvailableWaitHandle <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Monitor类和同步块"><a href="#Monitor类和同步块" class="headerlink" title="Monitor类和同步块"></a>Monitor类和同步块</h2><p>最常用的混合型线程构造就是<code>Monitor类</code>了，它提供了<strong>支持自旋，线程所有权和递归的互斥锁</strong>。 C#有内建的关键词支持它, JIT编译器对它知之甚详, 而且CLR自己也在代表你的应用程序使用它. 但是<code>Monitor</code>实际上是存在许多问题的。</p>
<p>堆中的每个对象都可关联一个名为<strong>同步块</strong>的数据结构，同步块包含字段，它为内核对象、拥有线程的ID、递归计数以及线程等待计数提供了相应的字段。<code>Monitor</code>是静态类，它的方法接受对任何堆对象的引用。这些方法对指定对象的同步块的字段进行操作。以下是<code>Monitor</code>最常用的方法：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Monitor</span>
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Exit</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 还可知道你个尝试进入锁时的超时值(不常用)</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">TryEnter</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token keyword">bool</span> lockTaken<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">TryEnter</span><span class="token punctuation">(</span><span class="token keyword">object</span> obj<span class="token punctuation">,</span> <span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">,</span> <span class="token keyword">ref</span> <span class="token keyword">bool</span> lockTaken<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果为每个堆中对象都关联一个同步数据结构显得很浪费, 尤其是大多数对象的同步块从不使用. 为了节省内存, CLR团队采用一种更经济的方式, 原理是:</p>
<p>CLR初始化时在堆中分配一个同步块数组. 一个对象在构造时, 它的同步块索引初始化为<code>-1</code>, 表明不使用任何同步块, 然后调用<code>Monitor.Enter</code>时, CLR在数组中找到一个空白同步块, 并设置对象的同步块索引,让它引用该同步块. <strong>也就是说, 对象和同步块是动态关联的</strong>. 调用<code>Exit</code>时, 会检查是否有其他任何线程正在等待使用对象的同步块. 如果没有线程等待,同步块就自由了, <code>Exit</code>将对象的同步块索引设为返回<code>-1</code>, 自由的同步块可以和另一个对象关联.</p>
<p>类型对象有两个开销成员: 同步块索引和类型对象指针.</p>
<p><img src="/2019/09/29/000000目录-CLR读书笔记/30混合线程同步构造/QQ截图20190930165935.png" alt=""></p>
<p>下面是<code>Monitor</code>原本的使用方法：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> DateTime m_timeOfLastTrans<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PerformTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//以下代码拥有对数据的独占访问权</span>
        m_timeOfLastTrans <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span>
        Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> DateTime LasTransaction
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span>
        <span class="token punctuation">{</span>
            Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//以下代码拥有对数据的独占访问权</span>
            DateTime temp <span class="token operator">=</span> m_timeOfLastTrans<span class="token punctuation">;</span>
            Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>表面上看起来很简单，但实际却存在许多问题。现在的问题是，每个对象的同步块索引隐式为公共的，下面的代码演示了可能造成的影响：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DoSomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">var</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 这个线程获取对象的公共锁</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//让线程池线程显示LastTransaction时间</span>
    <span class="token comment" spellcheck="true">//注意：线程池线程会阻塞，知道DoSomeMethod调用了Monitor.Exit</span>
    ThreadPool<span class="token punctuation">.</span><span class="token function">QueueUserWorkItem</span><span class="token punctuation">(</span>o <span class="token operator">=</span><span class="token operator">></span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这里会调用LasTransaction的get方法,并Monitor.Enter(this);</span>
        <span class="token comment" spellcheck="true">// 再次去获取这个公共锁, 因为这个锁已经被拿走了</span>
        <span class="token comment" spellcheck="true">// 这里只能等到主线程执行Monitor.Exit(t);之后才能拿.</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>LastTransaction<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//这里执行一些其他代码</span>
    Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>DoSomeMethod</code>的线程调用<code>Monitor.Enter</code>获取到了对象的公共锁，线程池线程查询<code>LastTransaction属性</code>时，这个属性也调用<code>Monitor.Enter</code>来获取同一个锁, 造成线程池阻塞, 直到<code>DoSomeMethod</code>执行了<code>Monitor.Exit(t);</code>, 用调试器可发现线程池线程在<code>LastTransaction属性</code>内部阻塞. 但很难判断是另外哪个线程拥有锁.</p>
<p><strong>因此, 我的建议是始终坚持使用私有锁.</strong></p>
<p>要解决这个问题的话，需要使用私有锁，把<code>Transaction</code>改成如下就可以解决上面的问题：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span>
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> DateTime m_timeOfLastTrans<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 现在每个Transaction对象都有私有锁</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> Object m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PerformTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//以下代码拥有对数据的独占访问权</span>
        m_timeOfLastTrans <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span>
        Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> DateTime LasTransaction
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 之前是this 公开的锁</span>
            Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//以下代码拥有对数据的独占访问权</span>
            DateTime temp <span class="token operator">=</span> m_timeOfLastTrans<span class="token punctuation">;</span>
            Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span>m_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果<code>Transaction</code>的成员时静态的, 只需要将<code>只读m_lock字段</code>也变成静态字段,即可确保静态成员的线程安全性.  </p>
<p>通过这个讨论, 一个明显的结论是: Monitor根本就不该实现成静态类, 它应该像其他所有同步构造那样实现. 也就是说是一个可以实例化并在上面调用实例方法的类.</p>
<ul>
<li>变量能引用一个代理对象——–前提是变量引用的那个对象的类型派生自<code>MarshalByObject</code>类. 调用<code>Monitor</code>的方法时, 传递对代理对象的引用, 锁定的是代理对象而不是代理引用的实际对象.</li>
<li>如果线程调用<code>Monitor.Enter</code>, 向它传递对类型对象的引用, 而且这个类型对象是以<code>AppDomain中立</code>的方式加载的, 线程就会跨越进程中的所有AppDomain在那个类型上获取锁, 这是CLR一个已知的BUG. 破坏了AppDomain本应提供的隔离能力.     <strong>建议: 永远都不要想Monitor的方法传递类型的对象引用.</strong></li>
<li>由于字符串可以<strong>留用</strong>, 所以两个完全独立的代码可能在不知情的情况下获取对内存中的一个String对象的引用. 如果将这个<code>String对象</code>传给<code>Monitor</code>的方法, 两个独立的代码段现在就回在不知情的情况下以同步方式执行.  </li>
<li>跨越AppDomain边界传递字符串时, CLR不创建字符串的副本; 相反, 它值是将对字符串的一个引用传给其他AppDomain. String对象也和其他对象一样关联了一个同步索引块, 这个索引时可变的. 使不同AppDomain中的线程在不知情的情况下开始同步, 这是CLR的AppDomain隔离存在的另一个bug.  <strong>建议: 永远都不要想Monitor的方法传递String.</strong></li>
<li>由于<code>Monitor</code>的方法要获取一个<code>Object</code>,所以传递<code>值类型</code>会导致<strong>值类型被装箱</strong>, 造成线程在已装箱对象上获取锁. 每次调用<code>Monitor.Enter</code>都会在一个完全不同的对象上获取锁, 造成完全无法实现线程同步.</li>
<li>向方法应用<code>[MethodImpl(MethodImplOptions.Synchronized)]</code>特性, 会造成JIT编译器用<code>Monitor.Enter</code>和<code>Monitor.Exit</code>调用包围方法的本机代码. 如果是实例方法, 会将this传给<code>Monitor</code>的这些方法. 锁定隐式公共的锁. 如果方法是静态的, 对类型的类型对象的引用会传给这些方法. 造成锁定<code>AppDomain中立</code>的类型.  <strong>我的建议永远不要使用这种特性.</strong></li>
<li>调用类型的类型构造器时, CLR要获取类型对象上的一个锁, 确保只有一个线程初始化类型对象及其静态字段. 同样的, 这个类型可能以<code>AppDomain中立</code>的方式加载,所以会出问题.<ul>
<li>加入类型构造器的代码进入死循环, 进程中的所有AppDomain都无法使用该类型.</li>
<li>建议尽量避免使用类型构造器</li>
</ul>
</li>
</ul>
<blockquote>
<p>有一种程序集可以被多个AppDomain使用,这种程序集叫做”AppDomain中立”的程序集</p>
</blockquote>
<p>再看下面这种情况，由于C#提供了<code>lock关键字</code>来提供一个简化的语法，如果像下面这样写：</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DoSomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">lock</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//...这里的代码拥有对数据的独占访问权</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>等价于以下写法:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">DomSomeMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Boolean lockTaken<span class="token operator">=</span><span class="token keyword">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//这里可能发生异常</span>
        Monitor<span class="token punctuation">.</span><span class="token function">Enter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span><span class="token keyword">ref</span> lockTaken<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//这里的代码拥有对数据的独占访问权</span>
    <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>lockTaken<span class="token punctuation">)</span> Monitor<span class="token punctuation">.</span><span class="token function">Exit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个问题是，C#团队认为他们在<code>finally块</code>中调用<code>Monitor.Exit</code>是帮了你一个大忙，因为这样一样，总是可以确保锁得以释放。然而这只是他们一厢情愿的想法，如果在<code>Try块</code>更改状态时候发生异常，那么另一个线程很可能继续操作损坏的数据，这样的结果难以预料，同时还有可能引发安全隐患。第二个问题是进入和离开<code>try</code>会发生性能影响。所以在代码中应该不要使用lock语句。<strong>建议杜绝使用C#的lock语句</strong>.</p>
<p>讨论以下<code>lockTaken</code>变量, 下面是这个变量试图解决的问题. 假定一个线程进入<code>try</code>块, 但在调用<code>Minitor.Enter</code>之前推出. 现在<code>finally块</code>会得以调用, 但它的代码不应退出锁. 所以就用到了<code>lockTaken</code>, 初始化为false, 调用了<code>Minitor.Enter</code>之后会设为true. 这样<code>finally块</code>就知道到底要不要调用<code>Monitor.Exit</code>.</p>
<h1 id="ReaderWriterLockSlim类"><a href="#ReaderWriterLockSlim类" class="headerlink" title="ReaderWriterLockSlim类"></a>ReaderWriterLockSlim类</h1><p>如果所有线程都希望以只读方式访问数据, 就没必要阻塞它们, 应该允许他们并发地访问数据. 另一方面, 如果一个线程希望修改数据,这个线程就需要对数据的独占式访问.<code>System.Threading.ReaderWriterLockSlim</code>封装了这种功能的逻辑。</p>
<ol>
<li>一个线程向数据写入时，访问请求的其它所有线程都被阻塞。</li>
<li>一个线程从数据读取时，请求读取的其它线程允许继续执行，但请求写入的线程仍被阻塞。</li>
<li>向数据写入的线程结束后，要么解除一个写入线程(<code>writer</code>)的阻塞，使它能向数据写入。要么解除所有读取线程(<code>reader</code>)的阻塞，使它们能够并发访问数据。如果没有线程被阻塞，锁就进入可自由使用的状态，可供下一个<code>reader</code>或<code>writer</code>线程获取。</li>
<li>从数据读取的所有线程结束后，一个writer线程被解除阻塞，使其能够向数据写入。如果没有线程被阻塞，锁就进入可自由使用的状态，可供下一个writer或reader线程使用。</li>
</ol>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReaderWriterLockSlim</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
  <span class="token keyword">public</span> <span class="token function">ReaderWriterLockSlim</span><span class="token punctuation">(</span>LockRecursionPolicy recursionPolicy<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">EnterReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">TryEnterReadLock</span><span class="token punctuation">(</span><span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ExitWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">EnterWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">TryEnterWriteLock</span><span class="token punctuation">(</span><span class="token keyword">int</span> millisecondsTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ExitWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 大多数应用程序从不查询以下任何属性</span>
  <span class="token keyword">public</span> <span class="token keyword">bool</span> IsReadLockHeld <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">bool</span> IsWriteLockHeld <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> CurrentReadCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> RecursiveReadCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> RecursiveWriteCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> WaitingReadCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">int</span> WaitingWriteCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">public</span> LockRecursionPolicy RecursionPolicy <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用法:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">internal</span> <span class="token keyword">sealed</span> <span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 构造ReaderWriterLockSlim实例，</span>
    <span class="token comment" spellcheck="true">// NoRecursion 不支持递归加锁</span>
    <span class="token comment" spellcheck="true">// SupportsRecursion 支持线程所有权和递归行为</span>
    <span class="token keyword">private</span> <span class="token keyword">readonly</span> ReaderWriterLockSlim m_lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReaderWriterLockSlim</span><span class="token punctuation">(</span>LockRecursionPolicy<span class="token punctuation">.</span>NoRecursion<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">private</span>          DateTime             m_timeOfLastTrans<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">PerformTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_lock<span class="token punctuation">.</span><span class="token function">EnterWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//以下代码拥有对数据的独占访问权</span>
        m_timeOfLastTrans <span class="token operator">=</span> DateTime<span class="token punctuation">.</span>Now<span class="token punctuation">;</span>
        m_lock<span class="token punctuation">.</span><span class="token function">ExitWriteLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> DateTime LastTransaction
    <span class="token punctuation">{</span>
        <span class="token keyword">get</span>
        <span class="token punctuation">{</span>
            m_lock<span class="token punctuation">.</span><span class="token function">EnterReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            DateTime temp <span class="token operator">=</span> m_timeOfLastTrans<span class="token punctuation">;</span>
            m_lock<span class="token punctuation">.</span><span class="token function">ExitReadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        m_lock<span class="token punctuation">.</span><span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ReaderWriterLockSlim</code>的构造器允许传递<code>LockRecursionPolicy</code>标志, 是否支持线程所有权和递归行为. <strong>建议总是想构造器传递<code>NoRecursion</code>, 那些行为对锁的性能有负面影响</strong>. reader-writer锁支持线程所有权和递归的代价非常高昂, 事实上, 为了线程安全的方式维护所有这些信息, 内部要使用一个互斥的自旋锁.</p>
<p><img src="/2019/09/29/000000目录-CLR读书笔记/30混合线程同步构造/QQ截图20190930181745.png" alt=""></p>
<h2 id="OneManyLock类"><a href="#OneManyLock类" class="headerlink" title="OneManyLock类"></a>OneManyLock类</h2><p>作者自己实现了一个<code>OneManyLock类</code>, 速度<code>比ReaderWriterLockSlim</code>快约1.7倍.</p>
<h2 id="CountdownEvent类"><a href="#CountdownEvent类" class="headerlink" title="CountdownEvent类"></a>CountdownEvent类</h2><p><code>System.Threading.CountdownEvent</code>构造使用<code>ManualResetEventSlim</code>对象。这个构造阻塞一个线程，直到它的内部计数器变成0。从某种角度来说，这个构造的行为和Semaphore的行为相反（Semaphore是在计数为0时阻塞线程）。下面列出这个类的一些成员</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountdownEvent</span> <span class="token punctuation">:</span> IDisposable
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">CountdownEvent</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">AddCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">TryAddCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> CurrentCount <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">bool</span> IsSet <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦一个<code>CountdownEvent</code>的<code>CurrentCount</code>为0时，它就不能再更改了，<code>CountdownEvent</code>为0时，<code>addCount</code>方法会抛出一个<code>InvalidOperationException</code>异常。如果<code>CurrentCount</code>为0，<code>TryAddCount</code>直接返回false.</p>
<h2 id="Barrier类"><a href="#Barrier类" class="headerlink" title="Barrier类"></a>Barrier类</h2><p>平时一般用不上. <code>System.Threading.Barrier</code>控制一些列线程需要并行工作，从而在一个算法的不同阶段推进。</p>
<h1 id="线程同步构造小结"><a href="#线程同步构造小结" class="headerlink" title="线程同步构造小结"></a>线程同步构造小结</h1><p>代码尽量不要阻塞任何线程, 执行异步计算或I/O操作时, 将数据从一个线程交给另一个线程时, 避免多个线程同时访问数据. 如果不能做到, 请尽量使用<code>Volatile</code>和<code>Interlocked</code>的方法. 因为它们速度很快,绝不阻塞线程. 只能操作简单类型, 可以像<code>Interlocked Anything模式</code>那样在这些类型上执行丰富的操作.</p>
<ul>
<li>线程模型很简单<ul>
<li>阻塞线程虽然会牺牲一些资源和性能, 但可顺序地写应用程序代码, 无需使用回调方法. <strong>不过C#的异步方法功能现在提供了不阻塞线程的简化编程模型</strong>.</li>
</ul>
</li>
<li>线程又专门用途</li>
</ul>
<p>为了同步在不同AppDomain或进程中运行的线程, 请使用内核对象构造.</p>
<p>要在一系列操作中原子性地操纵状态,请使用带有私有字段的<code>Monitor</code>类. 可以用<code>reader-writer锁</code>代替<code>Monitor</code>. 虽然前者慢, 但它们允许多个线程并发执行. 提升了总体性能.</p>
<p><strong>对于计算限制的工作, 可以使用任务避免使用大量线程同步构造. 每个任务都关联一个或多个延续任务, 某个操作完成后, 这些任务将通过某个线程池线程继续执行.</strong>  </p>
<p><strong>对于I/O限制的工作, 调用各种<code>XxxAsync方法</code>将造成你的代码在I/O操作完成后继续. 这其实类似于任务的延续任务.</strong></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
