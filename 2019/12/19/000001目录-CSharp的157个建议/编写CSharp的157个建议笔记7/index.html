<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        编写CSharp的157个建议笔记7 - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#成员设计"><span class="toc-text">成员设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#建议90-不要为抽象类提供公开的构造方法"><span class="toc-text">建议90 : 不要为抽象类提供公开的构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议91-可见字段应该重构为属性"><span class="toc-text">建议91 : 可见字段应该重构为属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议92-谨慎将数组或集合作为属性"><span class="toc-text">建议92 : 谨慎将数组或集合作为属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议93-构造方法应初始化主要属性和字段"><span class="toc-text">建议93 : 构造方法应初始化主要属性和字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议94-区别对待override和new"><span class="toc-text">建议94 : 区别对待override和new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议95-避免在构造方法中调用虚成员"><span class="toc-text">建议95 : 避免在构造方法中调用虚成员</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议96-成员应优先考虑公开基类型或接口"><span class="toc-text">建议96 : 成员应优先考虑公开基类型或接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议97-优先考虑将基类型或接口作为参数传递"><span class="toc-text">建议97 : 优先考虑将基类型或接口作为参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议98-用params减少重复参数"><span class="toc-text">建议98 : 用params减少重复参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议99-重写时不应使用子类参数"><span class="toc-text">建议99 : 重写时不应使用子类参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议100-静态方法和实例方法没有区别"><span class="toc-text">建议100 : 静态方法和实例方法没有区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#建议101-使用扩展方法，向现有类型“添加”方法"><span class="toc-text">建议101 : 使用扩展方法，向现有类型“添加”方法</span></a></li></ol></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        编写CSharp的157个建议笔记7
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-12-19 14:54:06</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#CSharp的157个建议" title="CSharp的157个建议">CSharp的157个建议</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="成员设计"><a href="#成员设计" class="headerlink" title="成员设计"></a>成员设计</h1><p>所谓成员，是指类型的字段和方法。在成员设计时掌握一定的原则，可以规避一些陷阱。本章将从最通用的角度阐述一些开发人员在进阶过程中会遇到的瓶颈。这些瓶颈有一部分是设计原则方面的问题，有一部分则需要大家仔细体会并练习，否则代码中就会出现Bug。部分案例可能不常用，但有助于大家加深对面向对象成员设计的理解。</p>
<h2 id="建议90-不要为抽象类提供公开的构造方法"><a href="#建议90-不要为抽象类提供公开的构造方法" class="headerlink" title="建议90 : 不要为抽象类提供公开的构造方法"></a>建议90 : 不要为抽象类提供公开的构造方法</h2><p>首先，抽象类可以有构造方法。即使没有为抽象类指定构造方法，编译器也会为我们生成一个默认的protected构造方法。</p>
<p>其次，抽象类的构造方法不应该是public或internal的。<strong>抽象类设计的本意只能让子类继承</strong>，而不是用于生成实例对象的。如果抽象类是public或internal的，它对于其他类型来说就是可见的，而这是不必要的，也是多余的。换句话说，抽象类只需对子类可见就行了。</p>
<h2 id="建议91-可见字段应该重构为属性"><a href="#建议91-可见字段应该重构为属性" class="headerlink" title="建议91 : 可见字段应该重构为属性"></a>建议91 : 可见字段应该重构为属性</h2><p>字段和属性有本质的区别。这个本质的区别就是:属性是方法。</p>
<p>查看下面这个类型Person:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>经过编译器的编译后，针对属性Name,实际会生成一个静态字段和两个方法(get,set).</p>
<p>从这里就可以知道，属性实际上是编译器抛给我们的语法糖。属性相比较于字段，具有如下优势:</p>
<ul>
<li>1)可以为属性添加代码。正因为属性是方法，所以可以在方法内对设置或获取属性的过程进行更多精细化的控制。常见的如:可以为属性添加NameChanged事件支持等。单凭字段本身是完成不了这样的功能的。</li>
<li>2)可以让属性支持线程安全。要让属性变成线程安全的，可以让类型自身去实现。而要让字段支持线程安全，就只能靠调用者本身来实现了。</li>
<li>3)属性得到了VS编辑器的支持，还得到了实现自动属性这种功能。自动属性的特点在LINQ中得到了广泛应用，尤其是匿名类型中，它只能实现只读的自动属性，而不支持字段。</li>
<li>4)从设计的角度，也就是面向对象的角度来看，<strong>公开的字段也应该使用属性</strong>。改变字段的状态，类型不会被通知到:而改变属性的值，类型支持则会被通知。</li>
</ul>
<p>综上所述，如果一个类型存在一个可见字段，那么它应该被重构为属性。当然，如果某个属性仅仅对内部可见，而且不涉及上面这4点内容，则建议使用字段。</p>
<h2 id="建议92-谨慎将数组或集合作为属性"><a href="#建议92-谨慎将数组或集合作为属性" class="headerlink" title="建议92 : 谨慎将数组或集合作为属性"></a>建议92 : 谨慎将数组或集合作为属性</h2><p>数组和集合作为属性存在会引起这样的一个分歧:如果属性是只读的，我们通常会认为它是不可改变的，但是如果将只读属性应用于数组和集合，而元素的内容和数量却仍旧可以随意更改。我们可以随意对Employees进行集合操作，它不变的只是自身的引用而已。</p>
<p>如果某个类型含有集合概念的属性，那么它的可见性应该为private或protected,并且，它更应该是一个字段。类型对外只公开必要的方法来操作这个集合。但是话又说回来，如果一定要将某个数组或集合设置为属性，那么应考虑将其置为只读，参见建议25。</p>
<h2 id="建议93-构造方法应初始化主要属性和字段"><a href="#建议93-构造方法应初始化主要属性和字段" class="headerlink" title="建议93 : 构造方法应初始化主要属性和字段"></a>建议93 : 构造方法应初始化主要属性和字段</h2><p>类型的属性应该在构造方法调用完毕之前完成初始化工作。如果字段没有在初始化器中设置初始值，那么它就应该在构造方法中初始化。类型一旦被实例化，那么它应该被视为具有完整的行为和属性。就好比，一旦一只健康的猫来到这个世界上，那它就应该具备猫爪和猫尾巴，而不是在查看这只猫的尾巴时得到一个null。</p>
<p><code>Employee specialA = new Employee() { Name = &quot;Mike&quot; };</code></p>
<p>上面所演示的是-一个字段初始化器。实际上，<strong>初始化器也属于编译器的语法糖，它在经编译后，在构造方法的最开始处执行</strong>。也就是说，可以将初始化器理解为构造方法的一部分。类型的其他引用类型字段也应该在构造器中初始化，比如specialB,因为需要保证类型的其他地方在用到该字段的时候不会因为它是null而产生混淆。</p>
<h2 id="建议94-区别对待override和new"><a href="#建议94-区别对待override和new" class="headerlink" title="建议94 : 区别对待override和new"></a>建议94 : 区别对待override和new</h2><p>override和new使类型体系因为继承而呈现出多态性。多态是判断一门语言是否是“面向对象语言”的三个重要特性之一。多态要求子类具有与基类方法同名的方法，而override和new的作用就是:</p>
<ul>
<li>如果子类中的方法前面带有new关键字，则该方法被定义为独立于基类的方法。</li>
<li>如果子类中的方法前面带有override关键字，则子类的对象将调用该方法，而不是调用基类方法。</li>
</ul>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Shape</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">MethodVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"base MethodVirtual call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"base Method call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Circle</span> <span class="token punctuation">:</span> Shape
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">MethodVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"circle override MethodVirtual"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">:</span> Shape
<span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Triangle</span> <span class="token punctuation">:</span> Shape
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token class-name">void</span> <span class="token function">MethodVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"triangle new MethodVirtual"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">new</span> <span class="token class-name">void</span> <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"triangle new Method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Diamond</span> <span class="token punctuation">:</span> Shape
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">MethodVirtual</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Diamond default MethodVirtual"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Diamond default Method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的继承体系中: 类型Shape是所有子类的基类.</p>
<p>Circle类override父类的MethodVirtual,所以即使子类转型为Shape,调用的还是子类的方法.</p>
<p>类型Rectangle没有对基类做任何处理，所以无论子类是否转型为Shape,调用的都是基类Shape的方法。</p>
<p>类型Triangle将基类Shape的virtual方法和非virtual方法都new了一遍.因为子类已经new了父类的方法，故子类方法和基类方法完全没有关系了，只要s被转型为Shape,则针对s调用的都是父类方法。</p>
<p>类型Diamond包含了两个和基类一模一样的方法，并且没有额外的修饰符。这在编辑器中会提出警示。但是如果选择忽略这些警示，程序一样还是可以运行。</p>
<h2 id="建议95-避免在构造方法中调用虚成员"><a href="#建议95-避免在构造方法中调用虚成员" class="headerlink" title="建议95 : 避免在构造方法中调用虚成员"></a>建议95 : 避免在构造方法中调用虚成员</h2><p>在构造方法中调用虚成员会带来一些意想不到的错误，虽然这种用法不常见，但还是需要注意这类陷阱。</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    American american <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">ReadKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">InitSkin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">InitSkin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//省略</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">American</span> <span class="token punctuation">:</span> Person
<span class="token punctuation">{</span>
    Race Race<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">American</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Race <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Race</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Name <span class="token operator">=</span> <span class="token string">"White"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">InitSkin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>Race<span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Race</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>运行该示例，会出现异常NullReferenceException:未将对象引用设置到对象的实例。</p>
<p>在调用者代码中，我们需要创建一个American的实例对象american。由于发现类型还存在一个基类Person,所以运行时会首先调用基类的构造方法。在该构造方法中，Person调用了虚方法InitSkin。从上一个建议的说明我们知道，由于是虚方法，<strong>所以会在运行时调用子类的InitSkin方法</strong>。在子类的InitSkin方法中，需要打印出来种族名。<strong>而这个时候，方法的调用堆栈还一直在基类的构造方法内，也就是在子类的构造方法中下面这行代码还完全没有执行</strong>:<code>Race = new Race() { Name = &quot;White&quot; };</code></p>
<p>现在我们应该已经理解了为什么这段看上去没有问题的代码在运行时会抛出异常。</p>
<p>基于以上的原因，建议不要在构造方法中调用虚成员。</p>
<h2 id="建议96-成员应优先考虑公开基类型或接口"><a href="#建议96-成员应优先考虑公开基类型或接口" class="headerlink" title="建议96 : 成员应优先考虑公开基类型或接口"></a>建议96 : 成员应优先考虑公开基类型或接口</h2><p>类型成员如果优先考虑公开基类型或接口，那么会让类型支持更多的应用场合。</p>
<p>FCL中最典型的相关例子是集合的功能操作。我们都知道在FCL中，集合根据功能划分有多种类型，比如<code>List&lt;T&gt;</code>、<code>Dictionary&lt;TKey, TValue&gt;</code>、<code>HashSet&lt;T&gt;</code> 等。以一个最简单的操作Empty (清空集合)为例。该功能要求我们删除集合中的所有元素，然后返回一个干净的集合。如果不返回基类型或接口的话，则要求我们为每一个集合类型都实现一个这样的方法。这是很恐怖的。</p>
<p>现在，微软在FCL中实现了这样一个静态类型Enumerable,我们可以找到对应的代码:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> IEnumerable<span class="token operator">&lt;</span>TResult<span class="token operator">></span> <span class="token generic-method function">Empty<span class="token punctuation">&lt;</span>TResult<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">return</span> EmptyEnumerable<span class="token operator">&lt;</span>TResult<span class="token operator">></span><span class="token punctuation">.</span>Instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>因为使用了泛型接口IEnumerable,所以现在所有的集合子类都可以不实现自己的Empty方法了。我们应体会这种编程模式带来的好处，并在自己的项目中灵活运用。</p>
<h2 id="建议97-优先考虑将基类型或接口作为参数传递"><a href="#建议97-优先考虑将基类型或接口作为参数传递" class="headerlink" title="建议97 : 优先考虑将基类型或接口作为参数传递"></a>建议97 : 优先考虑将基类型或接口作为参数传递</h2><p>除了公开基类型或接口外，基于同样的道理，方法的参数也应该考虑基类型或接口。还是以Enumerable类型为例，它的成员方法中只要涉及需要操作集合对象的地方，在参数.上都要使用IEnumerable泛型接口，比如:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> IEnumerable<span class="token operator">&lt;</span>TSource<span class="token operator">></span> <span class="token generic-method function">Take<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> IEnumerable<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source，<span class="token keyword">int</span> count<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>source <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> Error<span class="token punctuation">.</span><span class="token function">ArgumentNull</span> <span class="token punctuation">(</span><span class="token string">" source"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token generic-method function">TakeIterator<span class="token punctuation">&lt;</span>TSource<span class="token punctuation">></span> </span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> count<span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该方法用于获取集合指定数量的一个子集。正是因为存在这个扩展方法，我们才可以对所有的泛型集合类型进行Take操作。</p>
<h2 id="建议98-用params减少重复参数"><a href="#建议98-用params减少重复参数" class="headerlink" title="建议98 : 用params减少重复参数"></a>建议98 : 用params减少重复参数</h2><p>如果方法的参数数目不定，且参数类型一致，则可以使用params关键字减少重复的参数声明。代码如下所示:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">void</span> <span class="token function">Method1</span> <span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">,</span> <span class="token keyword">object</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Method2</span> <span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">,</span> <span class="token keyword">object</span> a，<span class="token keyword">object</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">Method3</span> <span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">,</span> <span class="token keyword">object</span> a<span class="token punctuation">,</span> <span class="token keyword">object</span> b，<span class="token keyword">object</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 此处的三个方法可以合并成-一个方法:</span>
<span class="token keyword">void</span> <span class="token function">Method</span><span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">,</span> <span class="token keyword">params</span> <span class="token keyword">object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arga<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="建议99-重写时不应使用子类参数"><a href="#建议99-重写时不应使用子类参数" class="headerlink" title="建议99 : 重写时不应使用子类参数"></a>建议99 : 重写时不应使用子类参数</h2><p>重写时，如果使用了子类参数，可能会偏离设计者的预期目标。比如，存在一个如下继承体系:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Employee</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token punctuation">:</span> Employee
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，类型ManagerSalary中的SetSalary方法重写了Salary 中的相同方法，重写的方式是采用一个子类参数，代码如下所示:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Salary</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SetSalary</span><span class="token punctuation">(</span>Employee e<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"职员被设置了薪水。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ManagerSalary</span> <span class="token punctuation">:</span> Salary
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//   public new void SetSalary(Employee m)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SetSalary</span><span class="token punctuation">(</span>Manager m<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"经理被设置了薪水。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用者的代码看起来如下:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp">ManagerSalary m <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ManagerSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m<span class="token punctuation">.</span><span class="token function">Setsalary</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 码输出如下:</span>
<span class="token comment" spellcheck="true">// 职员被设置了薪水。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>设计者的本意是要设置经理的薪水，可是实际调用的代码却设置了员工的薪水.</p>
<p>所以，在重写时使用子类参数有一定的风险，应当避免这种设计。正确的方法应当仍旧使用Employee类型参数，这起码能让编辑器提醒我们要使用new关键字。</p>
<h2 id="建议100-静态方法和实例方法没有区别"><a href="#建议100-静态方法和实例方法没有区别" class="headerlink" title="建议100 : 静态方法和实例方法没有区别"></a>建议100 : 静态方法和实例方法没有区别</h2><p>静态方法和实例方法有什么区别?首先我们应该坚决地、肯定地下一个结论:它们之间没有区别。</p>
<p>静态方法在加载时机和内存使用上与实例方法完全一致。在这里，我们先引出一个概念“类型对象”。比如类型Person，我们都知道new Person(会产生一个对象，这个对象叫做“实例对象”，它在运行时会加载到GC Heap上。而“类型对象”是指代表Person类型本身的那个对象，这个对象在第一次使用类型时被加载到LoaderHeap上。类型对象包括其自身的指针、自身的同步索引块、静态字段，以及一个方法表。在这个方法表中，无论是静态方法还是实例方法都会被存储起来，当然，存储的是方法的记录项，方法本身是在调用时由运行时编译的。类型对象和实例对象在内存中的分布情况如图7-1所示。</p>
<p><img src="/2019/12/19/000001目录-CSharp的157个建议/编写CSharp的157个建议笔记7/QQ截图20191221120506.png" alt=""></p>
<p>如果一定要说静态方法和实例方法有区别，那它们之间唯一的区别就是，当我们需要使用实例方法的时候，首先应该有实例对象。我们不能绕开实例对象，直接从类型本身去调用实例方法。所以，从设计的角度来说，如果一个方法只跟类型本身有关系，那么它就应该被设计成静态方法，如果跟类型的实例对象有关系，那它就应该被设计成实例方法。</p>
<p>静态方法被不少人误解的地方还有:静态方法天然就是同步方法。即便是那些有一定开发经验的程序员，有的时候也会犯这种常识性的错误。尽管微软声称FCL中大部分代码都被实现成线程安全的了，但并不意味着代码天然就是同步的，要让静态方法线程安全，必须由程序员编写同步代码，而不是让编译器或运行时为我们做这些事情。</p>
<p>要从设计的角度去理解静态方法和实例方法。离开了设计，它们没有区别。</p>
<h2 id="建议101-使用扩展方法，向现有类型“添加”方法"><a href="#建议101-使用扩展方法，向现有类型“添加”方法" class="headerlink" title="建议101 : 使用扩展方法，向现有类型“添加”方法"></a>建议101 : 使用扩展方法，向现有类型“添加”方法</h2><p>考虑如何让一个sealed类型具备新的行为。以往，我们会创建一个包装器类，然后为其添加方法，而这看上去一点儿也不优雅。我们也许会考虑修改设计，直接修改sealed类型，然后为其发布一个新版本，但这依赖于你拥有全部的源码。更多的时候，我们会采取针对第三方公司提供的API进行编码的方式。对于我们来说，FCL是一组第三方公司(微软)提供给我们的最好的API。</p>
<p>包装器类的编码形式如下:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>StudentConverter<span class="token punctuation">.</span><span class="token function">GetSexString</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StudentConverter</span>
<span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">string</span> <span class="token function">GetSexString</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token keyword">return</span> student<span class="token punctuation">.</span><span class="token function">GetSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">true</span> <span class="token operator">?</span> <span class="token string">"男"</span> <span class="token punctuation">:</span> <span class="token string">"女"</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span>
 <span class="token punctuation">{</span>
     <span class="token keyword">public</span> <span class="token keyword">bool</span> <span class="token function">GetSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token keyword">false</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，Student 类型只提供了一个GetSex方法，它返回了一个布尔值的结果。我们的需求是要将该布尔值转为一个字符串，StudentConverter 就是为了满足该需求而创建的一个包装器类。调用者的代码看起来就应该是这样的:</p>
<p><code>Console.WriteLine(StudentConverter.GetSexstring(student)) ;</code></p>
<p>但是我们现在知道，可以有更优美的形式让调用者像调用Student类型的实例方法一样来调用GetSexString了。这种更好的方式就是扩展方法，代码如下所示:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">Program</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">GetSexString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StudentExtension</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">string</span> <span class="token function">GetSexString</span><span class="token punctuation">(</span><span class="token keyword">this</span> Student student<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> student<span class="token punctuation">.</span><span class="token function">GetSex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">true</span> <span class="token operator">?</span> <span class="token string">"男D"</span> <span class="token punctuation">:</span> <span class="token string">"女?"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>扩展方法除了让调用者可以像调用类型自身的方法一样去调用扩展方法外(见Main方法中的调用代码)，它还有一些其他的主要优点，如下所示:</p>
<ul>
<li>可以扩展密封类型:</li>
<li>可以扩展第三方程序集中的类型;</li>
<li>展方法可以避免不必要的深度继承体系。</li>
</ul>
<p>当然，扩展方法还有一些必须遵循的要求:</p>
<ul>
<li>扩展方法必须在静态类中，且该类不能是一个嵌套类;</li>
<li>扩展方法必须是静态的</li>
<li>扩展方法的第一个参数必须是要扩展的类型，而且必须加上了this 关键字;</li>
<li>不支持扩展属性、事件。</li>
</ul>
<p>值得注意的一点是，扩展方法还能够扩展接口。这让接口看上去也是可以被扩展的(见建议102)。扩展方法的这个特性被广泛应用于提供LINQ查询功能的Enumerable类和Queryable类中。以Enumerable为例，针对<code>IEnumerable&lt;T&gt;</code>接口提供了非常丰富的一组方法，如方法Select:</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> IEnumerable<span class="token operator">&lt;</span>TResult<span class="token operator">></span> Select<span class="token operator">&lt;</span>TSource<span class="token punctuation">,</span> <span class="token function">TResulto</span> <span class="token punctuation">(</span><span class="token keyword">this</span> I Enumerable<span class="token operator">&lt;</span>TSource<span class="token operator">></span> source<span class="token punctuation">,</span> FunceTSource<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> TResult<span class="token operator">></span> selector<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>它相当于让继承自<code>IEnumerable&lt;T&gt;</code>接口的任何子类型都拥有了Select方法，而这些Selct方法在调用者看来，就好像是<code>IEnumerable&lt;T&gt;</code>接口所声明的一样。</p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
