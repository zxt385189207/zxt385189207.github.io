<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="闭关修仙の小弟的博客">
    <meta name="keyword"  content="闭关修仙">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Unity可寻址资产系统AddressableAsset使用 - 闭关修仙的小弟
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<link rel="stylesheet" href="/css/prism-darcula.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Hello World </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>闭关修仙的小弟</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#以前的加载资源步骤"><span class="toc-text">以前的加载资源步骤</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ET中使用需要修改的地方"><span class="toc-text">ET中使用需要修改的地方</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用Addressables"><span class="toc-text">使用Addressables</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Addressable-Importer"><span class="toc-text">Unity Addressable Importer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Addressables-1"><span class="toc-text">使用Addressables</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建包体内容方式"><span class="toc-text">构建包体内容方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时加载资源"><span class="toc-text">运行时加载资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化相关"><span class="toc-text">实例化相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#销毁实例化的对象"><span class="toc-text">销毁实例化的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据加载释放"><span class="toc-text">数据加载释放?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnityEngine-Object-Destroy和Addressables-ReleaseInstance"><span class="toc-text">UnityEngine.Object.Destroy和Addressables.ReleaseInstance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载场景"><span class="toc-text">加载场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载组件component"><span class="toc-text">加载组件component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加载子资产"><span class="toc-text">加载子资产</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资产引用计数"><span class="toc-text">资产引用计数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资产引用类型"><span class="toc-text">资产引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载或实例化AssetReference类型对象的方法"><span class="toc-text">加载或实例化AssetReference类型对象的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#build的注意事项"><span class="toc-text">build的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#提前下载"><span class="toc-text">提前下载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三种模式的构建脚本"><span class="toc-text">三种模式的构建脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用资产数据库-FastMode"><span class="toc-text">使用资产数据库(FastMode)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模拟组-VirtualMode"><span class="toc-text">模拟组(VirtualMode)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用现有的方式进行构建-Use-Existing-Build"><span class="toc-text">使用现有的方式进行构建(Use Existing Build)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Content更新流程"><span class="toc-text">Content更新流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态内容包"><span class="toc-text">静态内容包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态内容包"><span class="toc-text">动态内容包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更新原理"><span class="toc-text">更新原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#应用程序的版本文件"><span class="toc-text">应用程序的版本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Bundle-IDs"><span class="toc-text">Unique Bundle IDs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在运行时检查内容更新"><span class="toc-text">在运行时检查内容更新</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Building-for-content-updates-构建更新的内容"><span class="toc-text">Building for content updates 构建更新的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-for-content-updates-构建内容更新"><span class="toc-text">Building for content updates 构建内容更新</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#异步操作句柄"><span class="toc-text">异步操作句柄</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#关于Addressables-Hosting"><span class="toc-text">关于Addressables Hosting</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理的一个例子"><span class="toc-text">内存管理的一个例子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#更新日志"><span class="toc-text">更新日志</span></a></li></ol>
</div>

    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> Hello World </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Unity可寻址资产系统AddressableAsset使用
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-11-13 12:34:13</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#Unity资源管理系统" title="Unity资源管理系统">Unity资源管理系统</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="以前的加载资源步骤"><a href="#以前的加载资源步骤" class="headerlink" title="以前的加载资源步骤"></a>以前的加载资源步骤</h1><pre class="line-numbers language-csharp"><code class="language-csharp">  <span class="token comment" spellcheck="true">// 1. 加载此名称的AB包</span>
  ETModel<span class="token punctuation">.</span>Game<span class="token punctuation">.</span>Scene<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>ResourcesComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">LoadBundle</span><span class="token punctuation">(</span><span class="token string">"config.unity3d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 2. 因为是config包,所以添加Config组件</span>
  Game<span class="token punctuation">.</span>Scene<span class="token punctuation">.</span><span class="token generic-method function">AddComponent<span class="token punctuation">&lt;</span>ConfigComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 3. 找出需要Config配置的类型</span>
  <span class="token comment" spellcheck="true">// ConfigComponent获取注册到事件系统中的所有类型</span>
  List<span class="token operator">&lt;</span>Type<span class="token operator">></span> types <span class="token operator">=</span> Game<span class="token punctuation">.</span>EventSystem<span class="token punctuation">.</span><span class="token function">GetTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment" spellcheck="true">// 只加载对应的配置类型</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>configAttribute<span class="token punctuation">.</span>Type<span class="token punctuation">.</span><span class="token function">Is</span><span class="token punctuation">(</span>AppType<span class="token punctuation">.</span>ClientH<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment" spellcheck="true">// 实例化一个类型</span>
  <span class="token keyword">object</span> obj <span class="token operator">=</span> Activator<span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 转换成ACategory配置基类</span>
  ACategory iCategory <span class="token operator">=</span> obj <span class="token keyword">as</span> ACategory<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 调用初始化方法和结束初始化方法</span>
  iCategory<span class="token punctuation">.</span><span class="token function">BeginInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  iCategory<span class="token punctuation">.</span><span class="token function">EndInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 4. UnitConfig的定义</span>
  <span class="token punctuation">[</span><span class="token function">Config</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>AppType<span class="token punctuation">.</span>ClientH <span class="token operator">|</span>  AppType<span class="token punctuation">.</span>ClientM <span class="token operator">|</span> AppType<span class="token punctuation">.</span>Gate <span class="token operator">|</span> AppType<span class="token punctuation">.</span>Map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
  <span class="token keyword">public</span> <span class="token keyword">partial</span> <span class="token keyword">class</span> <span class="token class-name">UnitConfigCategory</span> <span class="token punctuation">:</span> ACategory<span class="token operator">&lt;</span>UnitConfig<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 5. ACategory定义了BeginInit方法,在其中调用ConfigHelper.GetText方法</span>
  <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">BeginInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ConfigHelper<span class="token punctuation">.</span><span class="token function">GetText</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Name:UnitConfig</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>


  <span class="token comment" spellcheck="true">// 6. 通过ResourcesComponent获取对应AB包中的对应名称资源的prefab</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">string</span> <span class="token function">GetText</span><span class="token punctuation">(</span><span class="token keyword">string</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    GameObject config <span class="token operator">=</span> <span class="token punctuation">(</span>GameObject<span class="token punctuation">)</span>ETModel<span class="token punctuation">.</span>Game<span class="token punctuation">.</span>Scene<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>ResourcesComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetAsset</span><span class="token punctuation">(</span><span class="token string">"config.unity3d"</span><span class="token punctuation">,</span> <span class="token string">"Config"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>


  <span class="token comment" spellcheck="true">// 7. 扩展一个GameObject的扩展方法</span>
  <span class="token comment" spellcheck="true">// 用于从ReferenceCollector脚本中获取对应key的prefab</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> T <span class="token generic-method function">Get<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">this</span> GameObject gameObject<span class="token punctuation">,</span> <span class="token keyword">string</span> key<span class="token punctuation">)</span> <span class="token keyword">where</span> T <span class="token punctuation">:</span> <span class="token keyword">class</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> gameObject<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>ReferenceCollector<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-method function">Get<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 8. 使用扩展方法, 获取挂载在prefab上的UnitConfig.txt的内容</span>
  <span class="token keyword">string</span> configStr <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token generic-method function">Get<span class="token punctuation">&lt;</span>TextAsset<span class="token punctuation">></span></span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span>text<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 9. 返回给之前ACategory定义的BeginInit方法继续处理</span>
  <span class="token comment" spellcheck="true">// 对字符串进行分割 ,逐行读取, 解析Json反序列化成Object</span>
  T t <span class="token operator">=</span> ConfigHelper<span class="token punctuation">.</span><span class="token generic-method function">ToObject<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> T <span class="token generic-method function">ToObject<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">string</span> str<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> JsonHelper<span class="token punctuation">.</span><span class="token generic-method function">FromJson<span class="token punctuation">&lt;</span>T<span class="token punctuation">></span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 10. 完成AB包的加载和反序列化成UnitConfig对象的过程, 卸载AB包</span>
  ETModel<span class="token punctuation">.</span>Game<span class="token punctuation">.</span>Scene<span class="token punctuation">.</span><span class="token generic-method function">GetComponent<span class="token punctuation">&lt;</span>ResourcesComponent<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">UnloadBundle</span><span class="token punctuation">(</span><span class="token string">"config.unity3d"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="ET中使用需要修改的地方"><a href="#ET中使用需要修改的地方" class="headerlink" title="ET中使用需要修改的地方"></a>ET中使用需要修改的地方</h1><ul>
<li>Entity:</li>
</ul>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token comment" spellcheck="true">// Unity\Assets\Model\Base\Object\Entity.cs</span>
<span class="token comment" spellcheck="true">// Unity\Assets\Hotfix\Base\Object\Entity.cs</span>
<span class="token preprocessor property">#<span class="token directive keyword">if</span> !SERVER</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>ViewGO <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 这里用Addressables.ReleaseInstance判断对象是否是AAS实例化的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Addressables<span class="token punctuation">.</span><span class="token function">ReleaseInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>ViewGO<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        UnityEngine<span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">Destroy</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>ViewGO<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// UnityEngine.Object.Destroy(this.ViewGO);</span>
<span class="token punctuation">}</span>
<span class="token preprocessor property">#<span class="token directive keyword">endif</span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>UI组件</li>
<li>AddressableAssetComponent组件</li>
<li>UnitFactory<ul>
<li>加载资源</li>
<li>实例化</li>
</ul>
</li>
</ul>
<h1 id="使用Addressables"><a href="#使用Addressables" class="headerlink" title="使用Addressables"></a>使用Addressables</h1><h2 id="Unity-Addressable-Importer"><a href="#Unity-Addressable-Importer" class="headerlink" title="Unity Addressable Importer"></a>Unity Addressable Importer</h2><blockquote>
<p>先导入这个库!!!!!!!, 不然可能导致这个工具不工作.</p>
</blockquote>
<p>资源自动导入AAS工具的使用方法:</p>
<ol>
<li>打开目录中的文件: <code>Packages/manifest.json</code></li>
<li>添加依赖 <code>&quot;com.littlebigfun.addressable-importer&quot;: &quot;https://github.com/favoyang/unity-addressable-importer.git&quot;</code></li>
</ol>
<p><a href="https://github.com/zxt385189207/unity-addressable-importer/blob/master/Documentation~/AddressableImporter.md" target="_blank" rel="external">翻译使用文档</a></p>
<p>AssetGroupTemplates组模板设置:</p>
<p><img src="/2019/11/13/Unity可寻址资产系统AddressableAsset使用/15741301280259-2.jpg" alt=""></p>
<blockquote>
<p>这个部分的设置都比较好理解，Bundle Naming可以选择其他的，我是为了测试Unity Cloud Build所以一直用的No Hash</p>
</blockquote>
<ul>
<li><code>Update Restriction</code>:<ul>
<li><code>Can Change Post Release</code> 作为非静态包, 发布后可以修改</li>
<li><code>Can Not Change Post Release</code> 作为静态包, 发布后不可修改<ul>
<li>如果更新了静态包内容, 那么您需要运行<code>Tools-&gt;Check for Content Update Restrictions</code>命令。这将从静态组中取出任何修改后的资产，并将它们移动到一个新组中。生成新的资产组.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="使用Addressables-1"><a href="#使用Addressables-1" class="headerlink" title="使用Addressables"></a>使用Addressables</h2><p>在package管理器中更新至最新版.</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>禁用可寻址项自动初始化。现在，它将在第一次调用时初始化自身(例如加载或实例化)。要在启动时初始化而不是第一次使用，请调用<code>Addressables.Initialize()</code>。</p>
<h2 id="构建包体内容方式"><a href="#构建包体内容方式" class="headerlink" title="构建包体内容方式"></a>构建包体内容方式</h2><ul>
<li>在编辑器中build content, 打开<code>Addressables Groups window</code>, 选择<code>Build</code>&gt; <code>New Build</code> &gt; <code>Default Build Script</code>.</li>
<li>用API则使用:  <code>AddressableAssetSettings.BuildPlayerContent()</code></li>
</ul>
<h2 id="运行时加载资源"><a href="#运行时加载资源" class="headerlink" title="运行时加载资源"></a>运行时加载资源</h2><p>加载Loading一个asset会加载它所有的依赖项(all dependencies)到内存中. 注意: 此时没有实例化.</p>
<p>实例化需要使用Addressables提供的接口</p>
<p>异步加载:</p>
<ul>
<li><code>Addressables.LoadAssetAsync&lt;GameObject&gt;(&quot;Asset Address Name&quot;);</code></li>
</ul>
<p>异步实例化:</p>
<ul>
<li><code>Addressables.InstantiateAsync(&quot;Asset Address Name&quot;);</code></li>
</ul>
<p>当资产完成加载/实例化时，您可以提供一个回调来处理它</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddressablesExample</span> <span class="token punctuation">:</span> MonoBehaviour
<span class="token punctuation">{</span>
    GameObject myGameObject<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>GameObject<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"AssetAddress"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Completed <span class="token operator">+</span><span class="token operator">=</span> OnLoadDone<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">OnLoadDone</span><span class="token punctuation">(</span>UnityEngine<span class="token punctuation">.</span>ResourceManagement<span class="token punctuation">.</span>AsyncOperations<span class="token punctuation">.</span>AsyncOperationHandle<span class="token operator">&lt;</span>GameObject<span class="token operator">></span> obj<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 在生产环境中，应该添加异常处理来捕获null结果等情况的异常。</span>
        myGameObject <span class="token operator">=</span> obj<span class="token punctuation">.</span>Result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实例化相关"><a href="#实例化相关" class="headerlink" title="实例化相关"></a>实例化相关</h3><p><code>Addressables.InstantiateAsync</code>有一些相关的<strong>开销</strong>，因此如果您需要每帧实例化相同的对象数百次，请考虑通过<code>Addressables</code> API去Load资源，然后通过其他方法实例化。</p>
<p>在本例中，您将调用<code>Addressables.LoadAssetAsync</code>，然后保存结果并为该结果调用<code>GameObject.Instantiate()</code>。</p>
<p><strong>这允许灵活地以同步方式调用实例化。缺点是可寻址系统不知道您创建了多少实例，如果管理不当，可能会导致内存问题</strong>。例如，引用纹理的预设将不再具有要引用的有效加载纹理，从而导致渲染问题（或更糟）。这类问题可能很难追踪，因为您可能不会立即触发内存卸载.</p>
<p>不再被引用的资产(由分析器中蓝色部分的末尾表示)并不一定意味着资产已被卸载。一个常见的应用场景涉及到一个资产包中的多个资产。</p>
<h2 id="销毁实例化的对象"><a href="#销毁实例化的对象" class="headerlink" title="销毁实例化的对象"></a>销毁实例化的对象</h2><p><code>Addressables.ReleaseInstance</code>,</p>
<blockquote>
<p> 或者关闭当前场景. 此场景可以在Additive模式或Single模式下加载（并因此关闭）</p>
</blockquote>
<p>InstantiateAsync和其他加载调用是可选的trackHandle参数。当设置为false时，<strong>必须保持AsyncOperationHandle句柄的引用,在释放实例时使用</strong>。这更有效，但是需要更多的开发工作。 相当于不追踪,不增加引用计数.</p>
<p><strong>如果将trackHandle设置为false，则只能使用句柄调用Addressables.ReleaseInstance，而不是使用实际的GameObject。</strong></p>
<p>如果你使用<code>Addressables.ReleaseInstance</code>释放一个不是由<code>Addressables</code>创建的对象, 或者是传入<code>trackHandle == false</code>,系统检测到这一点并返回false，表示该方法无法释放指定的实例。在这种情况下，实例不会被销毁。</p>
<h3 id="数据加载释放"><a href="#数据加载释放" class="headerlink" title="数据加载释放?"></a>数据加载释放?</h3><p>不需要释放<code>AsyncOperationHandle.Result</code>的接口,将仍然需要操作本身被释放。例如<code>Addressables.LoadResourceLocationsAsync</code>和<code>Addressables.GetDownloadSizeAsync</code>.它们加载您可以访问的数据，直到操作被释放。这个版本应该通过<code>Addressables.Release</code>来完成释放操作。</p>
<p>在<code>AsyncOperationHandle.Result</code>字段中不返回任何内容的操作有一个可选参数，用于在完成时自动释放操作句柄。</p>
<ul>
<li>如果完成后不再需要这些操作句柄之一，请将<code>autoReleaseHandle</code>参数设置为true，以确保操作句柄已清除.</li>
<li>如果需要在操作句柄完成后检查其状态，则希望<code>autoReleaseHandle</code>为false。</li>
</ul>
<p>这些接口的示例有<code>Addressables.DownloadDependenciesAsync</code>和<code>Addressables.UnloadScene。</code></p>
<h3 id="UnityEngine-Object-Destroy和Addressables-ReleaseInstance"><a href="#UnityEngine-Object-Destroy和Addressables-ReleaseInstance" class="headerlink" title="UnityEngine.Object.Destroy和Addressables.ReleaseInstance"></a>UnityEngine.Object.Destroy和Addressables.ReleaseInstance</h3><p>ReleaseInstance不能卸载不识别的对象, 失败则返回false.</p>
<h2 id="加载场景"><a href="#加载场景" class="headerlink" title="加载场景"></a>加载场景</h2><p><code>Addressables.LoadSceneAsync</code></p>
<p>您可以使用此方法以<code>Single mode</code>模式加载场景，该模式将关闭所有打开的场景. 或者以<code>Additive mode</code>附加模式加载场景.</p>
<p>关闭场景</p>
<p><code>Addressables.UnloadSceneAsync</code> 或以<code>Single mode</code>加载一个新场景,会自动关闭其他打开的场景.</p>
<h2 id="加载组件component"><a href="#加载组件component" class="headerlink" title="加载组件component"></a>加载组件component</h2><p>你<strong>不能</strong>直接通过Addressables加载GameObject的component。您必须加载或实例化GameObject，然后从中检索组件引用.</p>
<h2 id="加载子资产"><a href="#加载子资产" class="headerlink" title="加载子资产"></a>加载子资产</h2><p>例如: FBX文件中的<code>animation clips</code>动画片段.</p>
<p>要加载资产中的<strong>所有</strong>子对象</p>
<ul>
<li><code>Addressables.LoadAssetAsync&lt;IList&lt;Sprite&gt;&gt;(&quot;MySpriteSheetAddress&quot;);</code></li>
</ul>
<p>要加载资产中的<strong>单个</strong>子对象</p>
<ul>
<li><code>Addressables.LoadAssetAsync&lt;Sprite&gt;(&quot;MySpriteSheetAddress[MySpriteName]&quot;);</code></li>
</ul>
<h2 id="资产引用计数"><a href="#资产引用计数" class="headerlink" title="资产引用计数"></a>资产引用计数</h2><ul>
<li><strong>加载到内存<code>LoadAssetAsync</code>:</strong><ul>
<li>调用3次,将获得<code>AsyncOperationHandle</code>结构的三个不同实例，它们都引用相同的底层操作。 每次返回都是指向唯一的<code>AsyncOperationHandle</code>操作对象.</li>
</ul>
</li>
<li><strong>实例化<code>InstantiateAsync</code>:</strong><ul>
<li>对同一个地址调用三次InstantiateAsync会导致所有相关资产的ref-count为3。</li>
</ul>
</li>
</ul>
<p>这是因为每个InstantiateAsync的结果都是唯一的实例。另一个区别在于InstantiateAsync和其他加载调用是可选的trackHandle参数。<strong>当设置为false时，必须保持AsyncOperationHandle的句柄的引用,在释放实例时使用</strong>。这更有效，但是需要更多的开发工作。相当于不追踪,不增加引用计数.</p>
<p>卸载时需要使用<code>Addressables.Release</code>去减少引用计数.</p>
<h2 id="资产引用类型"><a href="#资产引用类型" class="headerlink" title="资产引用类型"></a>资产引用类型</h2><p>AssetReference类提供了一种访问Addressable Assets的方法，而不需要知道它们的地址。</p>
<p>任何可序列化的组件都可以支持一个AssetReference变量(例如，一个游戏脚本、ScriptableObject或其他可序列化的类)。</p>
<h3 id="加载或实例化AssetReference类型对象的方法"><a href="#加载或实例化AssetReference类型对象的方法" class="headerlink" title="加载或实例化AssetReference类型对象的方法"></a>加载或实例化AssetReference类型对象的方法</h3><p><code>public AssetReference assetRefMember;</code></p>
<p>加载资产</p>
<ul>
<li><code>assetRefMember.LoadAssetAsync&lt;GameObject&gt;();</code></li>
</ul>
<p>实例化资产</p>
<ul>
<li><code>assetRefMember.InstantiateAsync(pos, rot);</code></li>
</ul>
<p>以上方法也是异步方法. 可以提供一个回调来处理返回结果.</p>
<p>如果将包含子资产的资产(例如SpriteAtlas或FBX)添加到资产引用中，您就可以选择引用资产本身或子资产。你看到的下拉菜单变成了两个。第一个选择是资产本身，第二个选择是子资产。如果您在下拉菜单中选择第二个，它将被视为对主要资产的引用。</p>
<h2 id="build的注意事项"><a href="#build的注意事项" class="headerlink" title="build的注意事项"></a>build的注意事项</h2><p>可寻址资产系统在运行时需要一些文件来知道加载什么以及如何加载。这些文件是在您 build Addressables data并在StreamingAssets文件夹中结束时生成的，StreamingAssets是Unity中的一个特殊文件夹，其中包含了构建中的所有文件. 当您构建<code>Addressables content</code>,时，系统将这些文件置于库中。然后，当您构建应用程序时，系统将所需的文件复制到StreamingAssets，构建并从文件夹中删除它们。通过这种方式，您可以为多个平台构建数据，而在每个构建中只包含相关的数据。</p>
<h2 id="提前下载"><a href="#提前下载" class="headerlink" title="提前下载"></a>提前下载</h2><p><code>Addressables.DownloadDependenciesAsync()</code></p>
<p>这个调用返回的<code>AsyncOperationHandle结构</code>包含一个<code>PercentComplete</code>属性，您可以使用它来监视和显示下载进度。你也可以让应用程序等待，直到内容已经加载。</p>
<p>如果希望在下载之前征求用户的同意，可以使用<code>Addressables.GetDownloadSize()</code>返回从给定地址或标签下载内容所需的空间.</p>
<p>您可以使用预加载功能来显示下载已经开始，然后继续下载，而不是使用百分比完成值来等待内容加载。此实现将需要加载或等待画面来处理在需要时资产尚未完成加载的实例。</p>
<h1 id="三种模式的构建脚本"><a href="#三种模式的构建脚本" class="headerlink" title="三种模式的构建脚本"></a>三种模式的构建脚本</h1><h2 id="使用资产数据库-FastMode"><a href="#使用资产数据库-FastMode" class="headerlink" title="使用资产数据库(FastMode)"></a>使用资产数据库(FastMode)</h2><p>使用资产数据库模式(BuildScriptFastMode)允许您在运行游戏流时快速运行游戏。它直接通过资产数据库加载资产，以便快速迭代，而<strong>不需要进行分析或创建资产包</strong>。</p>
<h2 id="模拟组-VirtualMode"><a href="#模拟组-VirtualMode" class="headerlink" title="模拟组(VirtualMode)"></a>模拟组(VirtualMode)</h2><blockquote>
<p>可以用Event Viewer进行分析, 模拟使用bundle加载, 进行详细的性能评估和资产使用情况</p>
</blockquote>
<p>模拟组模式(BuildScriptVirtualMode)在<strong>不创建资产包</strong>的情况下<strong>分析布局和依赖项的内容</strong>。资产通过ResourceManager从资产数据库加载，就像通过bundle加载一样。要查看包在游戏过程中何时加载或卸载，请在Addressables事件查看器窗口(窗口&gt;资产管理&gt;可寻址&gt;事件查看器)中查看资产使用情况。</p>
<p>模拟组模式帮助您模拟加载策略，并调整内容组以找到生产版本的正确平衡。</p>
<h2 id="使用现有的方式进行构建-Use-Existing-Build"><a href="#使用现有的方式进行构建-Use-Existing-Build" class="headerlink" title="使用现有的方式进行构建(Use Existing Build)"></a>使用现有的方式进行构建(Use Existing Build)</h2><p>使用现有的构建模式与已部署的应用程序构建最接近，</p>
<p>使用此模式前, 需要先build出资产内容Content,称为打包,</p>
<ul>
<li><code>AddressableAssetSettings.BuildPlayerContent()</code>,</li>
<li><code>Build</code> &gt; <code>New Build</code> &gt; <code>Default Build Script</code></li>
</ul>
<h1 id="Content更新流程"><a href="#Content更新流程" class="headerlink" title="Content更新流程"></a>Content更新流程</h1><h2 id="静态内容包"><a href="#静态内容包" class="headerlink" title="静态内容包"></a>静态内容包</h2><p>不会去更新的包,在这种结构中，静态内容随应用程序一起发布.</p>
<p>然而，当您不想发布整个新的应用程序构建时，可寻址资产系统也可以适应需要更改静态内容包的情况。</p>
<h2 id="动态内容包"><a href="#动态内容包" class="headerlink" title="动态内容包"></a>动态内容包</h2><p>动态内容驻留在网上，最好是在较小的包中，以最小化每次更新所需的数据量。</p>
<h2 id="更新原理"><a href="#更新原理" class="headerlink" title="更新原理"></a>更新原理</h2><p>Addressables使用内容目录将地址映射到每个资产，并指定在何处以及如何加载它。为了向您的应用程序提供修改映射的能力，您的原始应用程序必须知道此目录的在线副本。要进行设置，请在AddressableAssetSettings检查器上启用<code>Build Remote Catalog</code>设置。这确保将目录的副本构建到指定路径并从指定路径加载。一旦你的应用程序发布，这个加载路径就不能改变。内容更新过程创建目录的新版本(具有相同的文件名)来覆盖文件.</p>
<h2 id="应用程序的版本文件"><a href="#应用程序的版本文件" class="headerlink" title="应用程序的版本文件"></a>应用程序的版本文件</h2><p>构建应用程序将生成一个惟一的应用程序内容版本字符串，该字符串标识每个应用程序应该加载的内容目录。一个给定的服务器可以包含应用程序的多个版本的目录，而不会产生冲突。我们将需要的数据存储在<code>addressables_content_state.bin</code>文件中。这包括版本字符串，以及标记为<code>StaticContent</code>的组中包含的任何资产的hash信息。默认情况下，<strong>此文件与您的AddressableAssetSettings.asset位于相同的文件夹中</strong>。</p>
<p><code>addressables_content_state.bin</code>文件包含Addressables系统中每个<code>静态内容资产组</code>的<strong>hash和依赖项信息</strong>。构建到StreamingAssets文件夹的所有组都应该标记为静态内容，尽管大型远程组也可以从这种指定中受益。这个hash信息确定是否有任何静态内容组包含更改的资产，因此需要将这些资产转移到其他地方。</p>
<h2 id="Unique-Bundle-IDs"><a href="#Unique-Bundle-IDs" class="headerlink" title="Unique Bundle IDs"></a>Unique Bundle IDs</h2><blockquote>
<p>用于运行时更新包 , 而不是启动时检测</p>
</blockquote>
<p>当将资产包加载到内存中时，Unity强制要求不能用相同的内部名称加载两个包。这可能对在运行时更新包造成一些限制。由于Addressables支持在初始化之外更新目录，那么就可以更新已加载的内容。</p>
<p>要实现这一目标，必须做到以下两点之一。</p>
<ul>
<li>第一个选项是选择是在更新目录之前卸载所有addressables内容。</li>
<li>第二个选项是确保更新后的资产包具有唯一的内部标识符。这将允许您在旧包仍在内存中时加载新包。</li>
</ul>
<p>我们有一个选项来启用第二个选项。在AddressableAssetSettings检查器中打开<code>Unique Bundle IDs</code>。此选项的缺点是需要重新构建依赖项链上的包。意思是如果你在一个组中改变了一个材质，默认情况下只有材质包会被重建。使用<code>Unique Bundle IDs</code>，引用该材质的任何资产都需要重新构建。</p>
<h2 id="在运行时检查内容更新"><a href="#在运行时检查内容更新" class="headerlink" title="在运行时检查内容更新"></a>在运行时检查内容更新</h2><p>您可以添加一个自定义脚本来定期检查是否有新的Addressables内容更新。使用以下函数调用来启动更新:</p>
<p><code>public static AsyncOperationHandle&lt;List&lt;string&gt;&gt; CheckForCatalogUpdates(bool autoReleaseHandle = true)</code></p>
<p>其中List<string>包含修改后的locator IDs列表。您可以过滤这个列表，只更新特定的IDs或者将其完全传递给UpdateCatalogs API。</string></p>
<p>如果有新的内容，您可以向用户显示一个按钮来执行更新，或者自动执行更新。请注意，开发人员需要确保陈旧的资产得到释放。目录列表可以是空的，如果是空的，下面的脚本将更新所有需要更新的目录:</p>
<p><code>public static AsyncOperationHandle&lt;List&lt;IResourceLocator&gt;&gt; UpdateCatalogs(IEnumerable&lt;string&gt; catalogs = null, bool autoReleaseHandle = true)</code></p>
<p>返回值是更新的定位器(IResourceLocator)列表。</p>
<h1 id="Building-for-content-updates-构建更新的内容"><a href="#Building-for-content-updates-构建更新的内容" class="headerlink" title="Building for content updates 构建更新的内容"></a>Building for content updates 构建更新的内容</h1><p>如果您在任何StaticContent groups中都有修改过的资产，那么您需要运行<code>Check for Content Update Restrictions</code>命令。这将从静态组中取出任何修改后的资产，并将它们移动到一个新组中。生成新的资产组.</p>
<ol>
<li>在Unity编辑器中打开Addressables组窗口(Window&gt; Asset Management &gt; Addressables &gt;Groups)。</li>
<li>在Addressables组窗口中，选择顶部菜单栏上的工具，然后<code>Check for Content Update Restrictions</code>.</li>
<li>在打开的构建数据文件对话框中，选择<code>addressables_content_state.bin</code>文件(默认情况下，该文件位于Assets/AddressableAssetsData项目目录中)。</li>
</ol>
<p>此数据用于确定自上次构建应用程序以来修改了哪些资产或依赖项。系统将这些资产移动到一个新的组，为内容更新构建做准备。</p>
<blockquote>
<p>注意:如果您的所有更改都局限于<strong>非静态组</strong>，则此命令<code>Check for Content Update Restrictions</code>将不起任何作用。</p>
</blockquote>
<p>重要提示:在运行准备操作之前，Unity建议对版本控制系统进行分支。<code>prepare operation</code>会以适合更新内容的方式重新排列资产组。分支确保了下次你发行一个新的播放器时，你可以回到你喜欢的内容安排。</p>
<h2 id="Building-for-content-updates-构建内容更新"><a href="#Building-for-content-updates-构建内容更新" class="headerlink" title="Building for content updates 构建内容更新"></a>Building for content updates 构建内容更新</h2><ol>
<li>打开Addressables Groups window在Unity Editor(Window &gt; Asset Management &gt; Addressables &gt; Groups).</li>
<li>在Addressables组窗口中，在顶部菜单中选择Build，然后选择<code>Update a Previous Build</code>.</li>
<li>在打开的“<code>Build Data File</code>”对话框中，选择现有应用程序生成的生成文件夹。构建文件夹必须包含一个<code>addressables_content_state.bin</code>文件。</li>
</ol>
<p>建生成内容目录( content catalog)、hash文件和资产包(AB包)。</p>
<p>生成的内容目录与所选应用程序构建中的目录具有相同的名称，覆盖了旧的目录和散列文件。应用程序加载散列文件以确定是否有新的目录可用。系统从应用程序附带的或已经下载的现有包加载未修改的资产。</p>
<p>系统使用来自addressables_content_state.bin文件的内容版本字符串和位置信息来创建资产包(AB包)。不包含更新内容的资产包是使用与为更新选择的构建中的文件名相同的文件名编写的。<strong>如果一个资产包包含更新的内容，就会生成一个新的资产包，其中包含更新的内容，并有一个新的文件名，以便它可以与原始文件共存</strong>。只有具有新文件名的资产包必须复制到你存放content的目录位置。</p>
<p>系统还为静态内容构建资产包，但是您不需要将它们上载到内容托管位置，因为没有Addressables资产条目引用它们。</p>
<blockquote>
<p>本地的静态AB包在有更新之后, 会作为死数据一直在用户机器上.Remote_Static包如果已经被缓存在用户机器上, 更新之后也会变成死数据.不再被引用.</p>
<p>旧的Remote_NonStatic包被替换为一个新版本，其区别在于它的散列文件。修改后的版本将使用这个新包进行更新。</p>
<p>content_update_group包由将要向前引用的修改资产组成</p>
</blockquote>
<h1 id="异步操作句柄"><a href="#异步操作句柄" class="headerlink" title="异步操作句柄"></a>异步操作句柄</h1><p><code>AsyncOperationHandle</code> 结构</p>
<p>这个句柄的主要目的是允许访问操作的状态和结果。操作的结果在调用<code>Addressables.Release</code>或<code>Addressables.ReleaseInstance</code>之前有效.</p>
<p>当操作完成时,<code>AsyncOperationHandle.Status</code>是<code>Succeeded</code>或者 <code>Failed</code>, 如果成功,可以通过<code>AsyncOperationHandle.Result</code>访问结果.</p>
<p>您可以定期检查操作状态，或者使用<code>AsyncOperationHandle.Complete</code>注册完成的回调。当您不再需要返回的AsyncOperationHandle结构提供的资产时，应该使用<code>Addressables.Release</code>方法来释放它。</p>
<p>可以支持异步<code>await</code>通过<code>AsyncOperationHandle.Task</code>属性.</p>
<pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">async</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    AsyncOperationHandle<span class="token operator">&lt;</span>Texture2D<span class="token operator">></span> handle <span class="token operator">=</span> Addressables<span class="token punctuation">.</span><span class="token generic-method function">LoadAssetAsync<span class="token punctuation">&lt;</span>Texture2D<span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token string">"mytexture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> handle<span class="token punctuation">.</span>Task<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// The task is complete. Be sure to check the Status is successful before storing the Result.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>AsyncOperationHandle.Task属性在WebGL上不可用，因为该平台不支持多线程操作。</p>
</blockquote>
<p>请注意，<code>allowSceneActivation</code>设置为false并使用<code>SceneManager.LoadSceneAsync</code>加载的场景 或使用<code>Addressables.LoadSceneAsync</code>的，并为<code>activateOnLoad</code>参数设置false的场景, 可能会导致后续异步操作被阻止并无法完成。</p>
<h1 id="关于Addressables-Hosting"><a href="#关于Addressables-Hosting" class="headerlink" title="关于Addressables Hosting"></a>关于Addressables Hosting</h1><p>如果您重置端口号，您必须执行完整的应用程序构建来生成和嵌入正确的URL.</p>
<blockquote>
<p>您应该修改所有构建路径变量以指向项目资产文件夹外的公共目录。</p>
</blockquote>
<h1 id="内存管理的一个例子"><a href="#内存管理的一个例子" class="headerlink" title="内存管理的一个例子"></a>内存管理的一个例子</h1><p>在一个资产包（stuff）中有三个资产（tree、tank和cow）。</p>
<ul>
<li>加载<code>tree</code>时，探查器显示<code>tree</code>的1个ref计数，以及1个<code>stuff</code>计数。</li>
<li>稍后，当<code>tank</code>加载时，profiler将显示<code>tree</code>和<code>tank</code>的各1个ref计数，以及<code>stuff bundle</code>的2个ref计数。</li>
<li>如果释放<code>tree</code>，ref count变为0，蓝色条消失。</li>
</ul>
<p>在本例中，<code>tree</code>资源在此时实际上没有卸载。可以加载资产包或其部分内容，但不能部分卸载资产包。在bundle本身完全卸载之前，任何资产都不会卸载。此规则的例外是引擎接口 <code>Resources.UnloadUnusedAssets</code>方法。在上述场景中执行此方法将导致<code>tree</code>卸载。由于可寻址系统无法意识到这些事件，探查器图只反映可寻址引用计数（而不是确切的内存容量）。请注意，如果选择使用<code>Resources.UnloadUnusedAssets</code>，则该操作非常缓慢，并且只应在不会显示出任何故障的界面（例如加载界面）上调用。</p>
<h1 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h1><ul>
<li>添加了PrimaryKey到IResourceLocation。默认情况下，这是地址。</li>
<li>ReleaseInstance不会销毁它无法识别的对象, 返回bool, 销毁成功返回true,失败返回false.</li>
<li>您可以使用LoadResourceLocationsAsync，然后将结果映射回一个地址。</li>
<li>添加ResourceType到IResourceLocation<ul>
<li>这允许您在加载位置之前了解它的类型。<br>-</li>
</ul>
</li>
</ul>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢支持 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        
        <li>
            <a target="_blank"  href="https://github.com/zxt385189207">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="https://www.baidu.com">baidu</a></span>
        <span>/</span>
        
        <span><a href="https://www.google.com">google</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script type="text/javascript">
       (function() {
           if (typeof LivereTower === 'function') { return; }

           var j, d = document.getElementById('lv-container');

           d.setAttribute('data-id','city');
           d.setAttribute('data-uid' , 'MTAyMC80NTEwMS8yMTYxOA==');

           j = document.createElement('script');
           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
           j.async = true;

           d.appendChild(j);
       })();
    </script>
    <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>

</html>
